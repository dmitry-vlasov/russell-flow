import ds/set;
import ru_fileinfo;
import ru_conf;

export {

	MmParseSource(includes : [string], toplevel : [MmElement], info : RuFileInfo,);

	MmElement ::= MmComment, MmDisj, MmEssential, MmProvable, MmBlock, MmAxiomatic, MmConst, MmVars, MmFloating, MmInclude;
		MmComment(text : string);
		MmInclude(file : string);
		MmDisj(vars : [string]);
		MmConst(symbs : [string]);
		MmVars(symbs : [string]);
		MmEssential(label : string, expr : MmExpr);
		MmFloating(label : string, type : string, var : string);
		MmAxiomatic(label : string, expr : MmExpr);
		MmProvable(label : string, expr : MmExpr, proof : MmProof);
		MmBlock(elements : [MmElement]);

	MmProof(labels : [string]);
	MmExpr(symbs : [MmSymb]);
	MmSymb(literal : string, isVar : bool);

	MmHyp ::= MmEssential, MmFloating;
	MmStat ::= MmAxiomatic, MmProvable;

	MmAssertion(
		disj  : [MmDisj],
		hyps  : [MmHyp],
		inner : [MmHyp],
		stat  : MmStat
	);

	MmLabeled ::= MmHyp, MmAssertion;

	MmDecl ::= MmAssertion, MmConst, MmComment;

	MmSource(
		includes : [MmInclude],
		decls : [MmDecl],
		info : RuFileInfo,
	);
	
	MmAny ::= MmParseSource, MmComment, MmDisj, MmEssential, MmProvable, MmBlock, MmAxiomatic, MmConst, MmVars, MmFloating, MmInclude,
		MmProof, MmExpr, MmSymb, MmAssertion, MmSource;

	mmApplySubst(expr : MmExpr, subst : Tree<string, MmExpr>) -> MmExpr;
	mmSubst2s(s : Tree<string, MmExpr>) -> string;
	mmStack2s(s : List<MmExpr>) -> string;
	mm2s(a : MmAny) -> string;
	
	MmMath(
		sources : Tree<string, MmSource>,
		labeled : Tree<string, MmLabeled>,
		consts  : Set<string>,
		conf : RuConf
	);

	mmMath2Source(math : MmMath, file : string) -> MmSource;
	mmFindLeafSources(math : MmMath) -> [MmSource];
	mmStripComments(src : MmSource) -> MmSource;
}

mmFindLeafSources(math : MmMath) -> [MmSource] {
	filter(getTreeValues(math.sources), \src -> src.includes == [])
}

mmApplySubst(expr : MmExpr, subst : Tree<string, MmExpr>) -> MmExpr {
	applied = ref [];
	iter(expr.symbs, \symb ->
		switch (lookupTree(subst, symb.literal)) {
			Some(e): iter(e.symbs, \s -> refArrayPush(applied, s));
			None(): refArrayPush(applied, symb);
		}
	);
	MmExpr(^applied)
}

mm2s(a : MmAny) -> string {
	vars2s = \hs -> {
		str = strGlue(filtermap(hs, \h -> 
			switch (h) {
				MmFloating(lab, type, var): Some(var);
				default: None();
			}
		), " ");
		if (str == "") "" else "$v " + str + " $.\n\t";
	};
	switch (a) {
		MmParseSource(__,toplevel,__): strGlue(map(toplevel, mm2s), "\n") + "\n";
		MmComment(text):  "$( " + text + " $)\n";
		MmInclude(file):  "$[ " + file + " $]\n";
		MmDisj(vars):     "$d " + strGlue(vars, " ") + " $.";
		MmConst(symbs):   "$c " + strGlue(symbs, " ") + " $.\n";
		MmVars(symbs):     "$v " + strGlue(symbs, " ") + " $.";
		MmEssential(label, expr):       label + " $e " + mm2s(expr) + " $.";
		MmFloating(label, type, var):   label + " $f " + type + " " + var + " $.";
		MmAxiomatic(label, expr):       label + " $a " + mm2s(expr) + " $.";
		MmProvable(label, expr, proof): label + " $p " + mm2s(expr) + mm2s(proof);
		MmBlock(es): "${\n" + "\t" + strGlue(map(es, mm2s), "\n\t") + "\n$}";
		MmProof(labels):  " $= " + strGlue(labels, " ") + " $.";
		MmExpr(symbs): strGlue(map(symbs, \s -> s.literal), " ");
		MmSymb(literal, __): literal;
		MmAssertion(disj, hyps, inner, stat): 
			"${\n\t" +
				vars2s(concat(hyps, inner)) + 
				(if (disj == []) "" else strGlue(map(disj, mm2s), "\n\t") + "\n\t") +
				(if (hyps == []) "" else strGlue(map(hyps, mm2s), "\n\t") + "\n\t" ) +
				(if (inner == []) "" else strGlue(map(inner, mm2s), "\n\t") + "\n\t" ) +
				mm2s(a.stat) +
			"\n$}\n";
		MmSource(includes, decls, info): 
			strGlue(map(includes, mm2s), "\n") + "\n" + strGlue(map(decls, mm2s), "\n") + "\n\n";
	}
}

mmSubst2s(s : Tree<string, MmExpr>) -> string {
	foldTree(s, "", \var, expr, str -> str + "\n" + var + " --> " + mm2s(expr))
}

mmStack2s(s : List<MmExpr>) -> string {
	foldList(s, "", \acc, e -> acc + "\n\t" + mm2s(e)) + "\n";
}

mmMath2Source(math : MmMath, file : string) -> MmSource {
	MmSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			mmMathCollectSource(src, math, acc)
		).first,
		RuFileInfo(file, file, 0.0, 0.0)
	)
}

mmMathCollectSource(src : MmSource, math : MmMath, acc : Pair<[MmDecl], Set<string>>) -> Pair<[MmDecl], Set<string>> {
	if (containsSet(acc.second, src.info.file)) acc else {
		acc1 = fold(src.includes, Pair(acc.first, insertSet(acc.second, src.info.file)), 
			\ac, inc -> {
				switch (lookupTree(math.sources, inc.file)) {
					Some(inc_src): mmMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

mmStripComments(src : MmSource) -> MmSource {
	MmSource(src with decls = filter(src.decls, \decl -> 
		switch (decl) {
			MmComment(__): false;
			default: true;
		}
	))
}
