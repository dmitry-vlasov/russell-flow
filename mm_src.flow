import ds/set;

export {

	MmSource(top : MmBlock);

	MmElement ::= MmComment, MmDisj, MmEssential, MmProvable, MmBlock, MmAxiomatic, MmConst, MmVar, MmFloating, MmInclude;
		MmComment(contents : string);
		MmInclude(file : string);
		MmDisj(vars : [string]);
		MmConst(symbs : [string]);
		MmVar(symbs : [string]);
		MmEssential(label : string, expr : MmExpr);
		MmFloating(label : string, type : string, var : string);
		MmAxiomatic(label : string, expr : MmExpr);
		MmProvable(label : string, expr : MmExpr, proof : MmProof);
		MmBlock(elements : [MmElement]);

	MmProof(labels : [string]);
	MmExpr(symbs : [MmSymb]);
	MmSymb(literal : string, isVar : bool);

	MmHyp ::= MmEssential, MmFloating;
	MmStat ::= MmAxiomatic, MmProvable;

	MmAssertion(
		disj : [MmDisj],
		hyps : [MmHyp],
		statement : MmStat
	);

	MmLabeled ::= MmHyp, MmAssertion;

	MmTheory(
		assertions : [MmAssertion],
		labeled : Tree<string, MmLabeled>
	);

	mmApplySubst(expr : MmExpr, subst : Tree<string, MmExpr>) -> MmExpr;

	mmExpr2s(e : MmExpr) -> string;
	mmSubst2s(s : Tree<string, MmExpr>) -> string;
	mmStack2s(s : List<MmExpr>) -> string;
	mmStat2s(s : MmStat) -> string;
	mmHyp2s(h : MmHyp) -> string;
	mmDisj2s(d : MmDisj) -> string;
	mmAssertion2s(a : MmAssertion) -> string;
}

mmApplySubst(expr : MmExpr, subst : Tree<string, MmExpr>) -> MmExpr {
	applied = ref [];
	iter(expr.symbs, \symb ->
		switch (lookupTree(subst, symb.literal)) {
			Some(e): iter(e.symbs, \s -> refArrayPush(applied, s));
			None(): refArrayPush(applied, symb);
		}
	);
	MmExpr(^applied)
}

mmExpr2s(e : MmExpr) -> string {
	strGlue(map(e.symbs, \symb -> symb.literal + if (symb.isVar) "*" else ""), " ")
}

mmSubst2s(s : Tree<string, MmExpr>) -> string {
	foldTree(s, "", \var, expr, str -> str + "\n" + var + " --> " + mmExpr2s(expr))
}

mmStack2s(s : List<MmExpr>) -> string {
	foldList(s, "", \acc, e -> acc + "\n\t" + mmExpr2s(e)) + "\n";
}

mmStat2s(s : MmStat) -> string {
	switch (s) {
		MmAxiomatic(label, expr): 
			label + " $a " + mmExpr2s(expr) + " $.";
		MmProvable(label, expr, proof): 
			label + " $a " + mmExpr2s(expr) + " $= " + 
			strGlue(proof.labels, " ") + " $.";
	}
}

mmHyp2s(h : MmHyp) -> string {
	switch (h) {
		MmFloating(label, type, var): 
			label + " $f " + type + " " + var + " $.";
		MmEssential(label, expr): 
			label + " $e " + mmExpr2s(expr) + " $.";
	}
}

mmDisj2s(d : MmDisj) -> string {
	"$d " + strGlue(d.vars, " ") + " $."
}

mmAssertion2s(a : MmAssertion) -> string {
	"${\n" +
		fold(a.disj, "", \acc, d -> acc + "\t" + mmDisj2s(d) + "\n") +
		fold(a.hyps, "", \acc, h -> acc + "\t" + mmHyp2s(h) + "\n") +
		"\t" + mmStat2s(a.statement) + "\n" +
	"$}"
}

