import ru_math;

export {
	ruSplitMath(math : RuMath) -> RuMath;
}

ruSplitMath(math : RuMath) -> RuMath {
	num1 = sizeTree(math.sources);
	ret = ruCollectNames(RuMath(math with 
		sources = foldTree(math.sources, makeTree(), \name, src, acc -> {
				if (math.conf.verbose > 1) {
					println("going to split file: " + src.info.file);
				}
				mergeTree(acc, ruSplitSources(src, math.conf))
			}
		)
	));
	src = RuSource(
		map(getTreeValues(ret.sources), \src -> RuImport(src.info.file, -1)),
		[],
		RuFileInfo(math.conf.file, math.conf.file + ".ru", 0.0, 0.0)
	);
	if (math.conf.verbose > 0) {
		println("ru split " + i2s(num1) + " files into " + i2s(sizeTree(ret.sources)));
	}
	RuMath(ret with sources = setTree(ret.sources, math.conf.file, src))
}

RuSplitSource(
	pattern : string,
	header : string,
	path : string,
	decls : ref [RuBlock],
	subs : ref [RuSplitSource]
);

strReplaceAll(str : string, chars : string, onto : string) -> string {
	char_codes = buildSet(s2a(chars));
	under_code = getCharCodeAt(onto, 0);
	fold(
		map(s2a(str), \i -> if (containsSet(char_codes, i)) under_code else i),
		"",
		\ac, i -> ac + fromCharCode(i)
	)
}

ruSplitLevel(src : RuSplitSource, pattern : string) -> RuSplitSource {
	makePath = \h -> strReplaceAll(h, " /:.?!;$\\\"'", "_");
	addBlock = \acc, block -> { refArrayPush(lastElement(^(acc.subs), acc).decls, block); acc }
	addSrc = \acc, h -> {
		path = src.path + "/" + makePath(h);
		refArrayPush(acc.subs, RuSplitSource(pattern, h, path, ref [], ref [])); 
		acc 
	}
	getHeader = \txt -> trim2(strSplit(txt, "\n")[2], " \t\n\r");
	fold(^(src.decls), RuSplitSource(src with decls = ref [], subs = ref []), \acc, block ->
		switch (block) {
			RuComment(text, __): {
				if (!strContains(text, pattern)) {
					addBlock(acc, block)
				} else {
					addBlock(addSrc(acc, getHeader(text)), block);
				}
			}
			default: addBlock(acc, block);
		}
	)
}

RuSplitPattern(
	pattern : string, 
	child : Maybe<RuSplitPattern>
);

ruSplitSourceRec(src : RuSplitSource, p : RuSplitPattern) -> RuSplitSource {
	parts = ruSplitLevel(src, p.pattern);
	switch (p.child) {
		None(): parts;
		Some(ch_p):
			RuSplitSource(parts with
				subs = ref map(^(parts.subs), \part -> ruSplitSourceRec(part, ch_p))
			);
	}
}

ruDoSplitSource(src : RuSource, conf : RuConf) -> RuSplitSource {
	ruSplitSourceRec(
		RuSplitSource("", "", src.info.file, ref src.decls, ref []), 
		RuSplitPattern("######", 
			Some(RuSplitPattern("#*#*#*#",
				Some(RuSplitPattern("=-=-=-=", 
					Some(RuSplitPattern("-.-.-.-.", 
						None()
					))
				))
			))
		)
	)
}

ruLinearizeSplitSources(src : RuSplitSource, acc : [RuSource], conf : RuConf) -> [RuSource] {
	file = if (src.path == conf.file) src.path + "_init" else src.path;
	header_pattern = lpad("", src.pattern, 40); 
	curr_src = RuSource(
		if (acc == []) [] else [RuImport(acc[length(acc) - 1].info.file, -1)],
		^(src.decls),
		RuFileInfo(file, file + ".ru", 0.0, 0.0)
	);
	if (conf.verbose > 1) {
		println("ru splitted file: " + curr_src.info.file);
	}
	fold(^(src.subs), concat(acc, [curr_src]), \ac, sub ->
		ruLinearizeSplitSources(sub, ac, conf)
	);
}

ruSplitSources(src : RuSource, conf : RuConf) -> Tree<string, RuSource> {
	values2tree(ruLinearizeSplitSources(ruDoSplitSource(src, conf), [], conf), \s ->s.info.file)
}
