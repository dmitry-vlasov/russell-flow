import math/stringmath;
import ru_exp;

export {
	ruVerifyTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem>;
	ruVerifyMath(math : RuMath) -> RuMath {
		ruDoVerifyMath(math.sources, math)
	}
	ruMatchStep(step : RuStep, th : RuTheorem, math : RuMath) -> Maybe<Pair<RuAssertion, Tree<RuVarRef, RuExp>>>;
}

ruDoVerifyMath(left : Tree<string, RuSource>, acc : RuMath) -> RuMath {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.path))
		);
		//println("modules to verify: " + strGlue(map(ready, \s -> s.info.file), ", "));
		verified = concurrent(true, map(ready, \s -> \-> ruVerifySource(s, acc)));
		new_acc = fold(verified, acc, \ac, v_src -> {
			new_assertions = fold(v_src.decls, ac.assertions, \a, decl ->
				switch (decl) {
					RuTheorem(name,__,__,__,__,__,__): setTree(a, name, decl);
					default: a;
				}
			);
			RuMath(ac with 
				assertions = new_assertions, 
				sources = setTree(ac.sources, v_src.info.file, v_src)
			);
		});
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		ruDoVerifyMath(new_left, new_acc);
	}
}

ruVerifySource(src : RuSource, acc : RuMath) -> RuSource {
	start = timestamp();
	decls_acc = fold(src.decls, Pair([], acc), \ac, decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__): {
				eitherMap(ruVerifyTheorem(decl, ac.second),
					\th -> Pair(
						concat(ac.first, [th]), 
						RuMath(ac.second with assertions = setTree(ac.second.assertions, th.name, th))
					),
					ac
				);
			}
			default: Pair(concat(ac.first, [decl]), ac.second);
		}
	);
	if (acc.conf.verbose > 0) {
		println("verified: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	RuSource(src with decls = decls_acc.first)
}

ruStepRefExp(ref : RuRef, th : RuTheorem) -> RuExp {
	switch (ref) {
		RuHypRef(i,__): th.hyps[i].expr;
		RuStepRef(i,__): th.proof.steps[i].expr;
	}
}

ruMatchStep(step : RuStep, th : RuTheorem, math : RuMath) -> Maybe<Pair<RuAssertion, Tree<RuVarRef, RuExp>>> {
	switch (lookupTree(math.assertions, step.assertion)) {
		Some(ass):
			maybeMap(
				maybeBind(
					foldi(ass.hyps, Some(makeTree()), \i, ac, h -> {
						switch (ac) {
							None(): None();
							Some(s): 
								maybeBind(
									ruMatch(ruStepRefExp(step.refs[i], th), h.expr, math),
									\x -> ruMergeSubst(s, x)
								);
						}
					}), 
					\s -> maybeBind(
						ruMatch(step.expr, ass.prop, math),
						\x -> ruMergeSubst(s, x)
					)
				),
				\subst -> Pair(ass, subst)
			);
		None(): {
			math.conf.onError(
				"unknown assertion " + step.assertion, 
				[RuPlace(lookupTreeDef(math.names, th.name, "<unknown>"), step.pos)]
			);
			None();
		}
	}
}

ruVerifyTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem> {
	//println("verifying: " + th.name);
	th_disjs = fold(th.proof.steps, Some(makeSet()), \acc, step ->
		switch (acc) {
			None(): acc;
			Some(disjs): {
				switch (ruMatchStep(step, th, math)) {
					Some(p):
						ruComputeTheoremDisjs(p.second, disjs, p.first.disjs, th, math);
					None(): {
						println("no match");
						quit(0);
						None();
					}
				}
			}
		}
	);
	eq_disjs = \ds1, ds2 -> {
		sizeSet(ds1) == sizeSet(ds2) &&
		all(zipWith(set2array(ds1), set2array(ds2), 
				\d1, d2 -> d1.v1 == d2.v1 && d1.v2 == d2.v2
			)
		);
	}
	maybeMap(th_disjs, 
		\ds -> {
			th_vars = ruAssertion2Vars(th);
			th_ds = filterSet(ds, \d -> containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2));
			pr_ds = filterSet(ds, \d -> !(containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2)));
			/*var2s = \v -> v.name + ":" + v.type;
			if (!isEmptySet(th.disjs) && !eq_disjs(th_ds, th.disjs)) {
				println("disjs differ:");
				println("th.disj: " + strGlue(map(set2array(th.disjs), \p -> "[" + var2s(p.v1) + ", " + var2s(p.v2) + "]"), ", "));
				println("th_ds:   " + strGlue(map(set2array(th_ds), \p -> "[" + var2s(p.v1) + ", " + var2s(p.v2) + "]"), ", "));
				quit(0);
			}*/
			RuTheorem(th with 
				disjs = th_ds,
				proof = RuProof(th.proof with disjs = pr_ds)
			)
		}
	)
}

ruComputeTheoremDisjs(s : Tree<RuVarRef, RuExp>, th_disjs : Set<RuDisj>, a_disjs : Set<RuDisj>, th : RuTheorem, math : RuMath) -> Maybe<Set<RuDisj>> {
	foldSet(a_disjs, Some(th_disjs), \acc, disj -> 
		maybeBind(acc, \th_dsj -> 
			switch (lookupTree(s, disj.v1)) {
				Some(e1): {
					switch (lookupTree(s, disj.v2)) {
						Some(e2): {
							e1_vars = ruExp2Vars(e1.nodes);
							e2_vars = ruExp2Vars(e2.nodes);
							common_vars = intersectSets(e1_vars, e2_vars);
							if (!isEmptySet(common_vars)) {
								math.conf.onError(
									"disjointed variables violation, variables: " + disj.v1.name + " and " + disj.v2.name +
									" are mappped onto expressions, with common vars: " + strGlue(map(set2array(common_vars), \v -> v.name), ", "), 
									[RuPlace(lookupTreeDef(math.names, th.name, "<unknown>"), disj.pos)]
								);
								None();
							} else {
								Some(foldSet(e1_vars, th_dsj, \ac, w1 ->
									foldSet(e2_vars, ac, \a, w2 ->
										if (w1.name < w2.name) insertSet(a, RuDisj(w1, w2, th.pos)) else a
									)
								));
							}
						}
						None(): acc;
					}
				}
				None(): acc;
			}
		)
	)
}
