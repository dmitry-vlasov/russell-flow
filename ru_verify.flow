import ru_exp;

export {
	ruVerifyTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem>;
	ruVerifyMath(math : RuMath) -> void;
}

ruVerifyMath(math : RuMath) -> void {
	traverseInOrder(math.assertions,
		\name, ass -> {
			switch (ass) {
				RuTheorem(__,__,__,__,__,__,__): {
					if (isNone(ruVerifyTheorem(ass, math))) {
						math.conf.onError("verification of " + name + " failed", [ruMakePlace(name, ass.pos, math)])
					}
				}
				default: {}
			}
		}
	)
}

ruStepRefExp(ref : RuRef, th : RuTheorem) -> RuExp {
	switch (ref) {
		RuHypRef(i,__): th.hyps[i].expr;
		RuStepRef(i,__): th.proof.steps[i].expr;
	}
}

ruVerifyTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem> {
	//println("verifying: " + th.name);
	disjs = fold(th.proof.steps, Some([]), \acc, step ->
		switch (acc) {
			None(): acc;
			Some(disjs): {
				switch (lookupTree(math.assertions, step.assertion)) {
					Some(a): {
						ms = maybeBind(
							foldi(a.hyps, Some(makeTree()), \i, ac, h -> {
								
								switch (ac) {
									None(): None();
									Some(s): 
										maybeBind(
											ruMatch(ruStepRefExp(step.refs[i], th), h.expr, math),
											\x -> ruMergeSubst(s, x)
										);
								}
							}), 
							\s -> maybeBind(
								ruMatch(step.expr, a.prop, math),
								\x -> ruMergeSubst(s, x)
							)
						);
						switch (ms) {
							Some(s): {
								acc;
							}
							None(): {
								println("no match");
								quit(0);
								None();
							}
						}
					}
					None(): {
						math.conf.onError(
							"unknown assertion " + step.assertion, 
							[RuPlace(lookupTreeDef(math.names, th.name, "<unknown>"), step.pos)]
						);
						None();
					}
				}
			}
		}
	);
	maybeMap(disjs, \ds -> RuTheorem(th with disjs = ds))
}
