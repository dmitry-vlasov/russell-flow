import ds/tree;
import string;

export {
	RuTrie(
		data : Maybe<??>,
		map : Tree<?, RuTrie<?, ??>>,
	);
	ruTrieEmpty = RuTrie(None(), makeTree());

	ruAdd2Trie(key : [?], data : Maybe<??>, trie : RuTrie<?, ??>) -> RuTrie<?, ??> {
		if (length(key) == 0) trie else doRuAdd2Trie(0, key, data, trie)
	}

	ruTrie2s(t : RuTrie<?, ??>, show_key : (?) -> string, show_val : (??) -> string) -> string {
		foldTree(doRuTrie2tree(t, [], makeTree(), show_key, show_val), "",
			\path, val, acc ->
				acc + strGlue(path, " ") + " --> " + val + "\n"
		)
	}

	ruMergeRuTrie(t1 : RuTrie<?, ??>, t2 : RuTrie<?, ??>) -> RuTrie<?, ??>;
}

doRuAdd2Trie(i : int, key : [?], data : Maybe<??>, trie : RuTrie<?, ??>) -> RuTrie<?, ??> {
	n = lookupTreeDef(trie.map, key[i], ruTrieEmpty);
	if (i + 1 == length(key)) {
		RuTrie(n.data, setTree(trie.map, key[i], RuTrie(n with data = data)));
	} else {
		RuTrie(n.data, setTree(trie.map, key[i], doRuAdd2Trie(i + 1, key, data, n)));
	}
}

doRuTrie2tree(trie : RuTrie<?, ??>, path : [string], acc : Tree<[string], string>, show_key : (?) -> string, show_val : (??) -> string) -> Tree<[string], string> {
	foldTree(trie.map, acc, 
		\k, v, ac -> {
			path1 = concat(path, [show_key(k)]);
			ac1 = doRuTrie2tree(v, path1, ac, show_key, show_val);
			switch (v.data) {
				None(): ac1;
				Some(d): setTree(ac1, path1, show_val(d));
			}
		}
	)
}

ruMergeRuTrie(t1 : RuTrie<?, ??>, t2 : RuTrie<?, ??>) -> RuTrie<?, ??> {
	RuTrie(
		if (isNone(t2.data)) t1.data else t2.data,
		mergeTreeCustom(t1.map, t2.map, \__, s1, s2 -> ruMergeRuTrie(s1, s2))
	)
}
