import fs/filesystem;
import sys/concurrent;
import lingo/compiler/syntaxtree_util;
import ru_conf;
import ru_fileinfo;
import parse/ru_load_file;
import parse/ru_load_ast;

export {
	RuLoadSource(imps : [string], src : string, info : RuFileInfo);
	ruLoad(conf : RuConf) -> [RuLoadSource];
}

ruLoad(conf : RuConf) -> [RuLoadSource] {
	if (fileExists(conf.file)) {
		getTreeValues(ruLoadImports([conf.file], conf, makeTree()));
	} else {
		conf.onError("file " + conf.file + " is not found", []);
		[]
	}
}

ruLoadImports(imports : [string], conf : RuConf, acc : Tree<string, RuLoadSource>) -> Tree<string, RuLoadSource> {
	if (imports == []) acc else {
		loaded = filtermap(
			concurrent(true, map(imports, \imp -> \ -> ruLoadSource(imp, conf.onError))), 
			idfn
		);
		new_imports = fold(loaded, [], \ac, l ->
			concat(ac, filter(l.imps, \i -> !containsKeyTree(acc, i)))
		);
		ruLoadImports(new_imports, conf, fold(loaded, acc, \ac, l -> setTree(ac, l.info.file, l)))
	}
}

ruLoadSource(file : string, onError : (string, [RuPlace]) -> void) -> Maybe<RuLoadSource> {
	if (fileExists(file)) {
		src_str = getFileContent(file);
		pr1 = parse_load(src_str);
		st = pr1.first;
		err = pr1.second;
		if (st.end != strlen(src_str)) {
			onError("Syntax error: expected one of " + strGlue(err.expected, ", ") + " while met: " + err.met, []);
			None()
		} else {
			Some(RuLoadSource(
				map(filter(get_load_lblock_s(st), \s -> s.rule == st_limport), \i -> grabSTText(get_load_lpath(i), src_str)), 
				src_str, 
				makeRuFileInfo(file)
			));
		}
	} else {
		onError("file " + file + " is not found", []);
		None()
	}
}
