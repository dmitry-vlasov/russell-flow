import fs/filesystem;
import sys/concurrent;
import parse/mm_parse;

export {
	mmCollectMath(parsed : Tree<string, MmParseSource>, conf : RuConf) -> Maybe<MmMath>;
}

mmCollectMath(parsed : Tree<string, MmParseSource>, conf0 : RuConf) -> Maybe<MmMath> {
	err_count = ref 0;
	conf = ruAddErrCounter(conf0, err_count);
	start = timestamp();
	collected = mmDoCollectMath(parsed, conf, MmMath(makeTree(), makeTree(), makeSet(), conf));
	println("collected: " +i2s(sizeTree(collected.sources)) + " files in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	if (^err_count == 0) {
		Some(collected);
	} else {
		None();
	}
}

mmDoCollectMath(left : Tree<string, MmParseSource>, conf : RuConf, acc : MmMath) -> MmMath {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.includes, \inc -> !containsKeyTree(left, inc))
		);
		//println("modules to process: " + strGlue(map(ready, \s -> s.info.file), ", "));
		srcs = concurrent(true, map(ready, \s -> \-> mmCollectSource(s, conf)));
		add_hyps = \ac, hs -> fold(hs, ac, \a, h : MmHyp -> setTree(a, h.label, h));
		new_acc = fold(srcs, acc, \ac, src -> 
			MmMath(
				setTree(ac.sources, src.info.file, src),
				fold(src.decls, ac.labeled, \a, decl ->
					switch (decl) {
						MmAssertion(__, hyps, inner, stat):
							add_hyps(add_hyps(setTree(a, stat.label, decl), hyps), inner);
						default: a;
					}
				),
				fold(src.decls, ac.consts, \a, decl ->
					switch (decl) {
						MmConst(symbs):
							fold(symbs, a, \x, s -> insertSet(x, s));
						default: a;
					}
				),
				conf
			)
		);
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		mmDoCollectMath(new_left, conf, new_acc);
	}
}

MmCollectAcc(
	vars  : Set<string>,
	disjs : List<MmDisj>,
	hyps  : List<MmHyp>,
	src   : MmSource,
);

mmCollectSource(src : MmParseSource, conf : RuConf) -> MmSource {
	start = timestamp();
	acc = mmCollectElements(src.toplevel, 
		MmCollectAcc(makeSet(), makeList(), makeList(), MmSource([], [], src.info))
	);
	if (conf.verbose > 0) {
		println("collected: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	acc.src
}

mmCollectElements(els : [MmElement], acc : MmCollectAcc) -> MmCollectAcc {
	fold(els, acc,
		\ac, el -> {
			switch (el) {
				MmComment(__): 
					MmCollectAcc(ac with src = MmSource(ac.src with decls = concat(ac.src.decls, [el])));
				MmInclude(__):
					MmCollectAcc(ac with src = MmSource(ac.src with includes = concat(ac.src.includes, [el])));
				MmVars(vs):
					MmCollectAcc(ac with vars = fold(vs, ac.vars, \a, v-> insertSet(a, v)));
				MmDisj(__): 
					MmCollectAcc(ac with disjs = Cons(el, ac.disjs));
				MmConst(cs): 
					MmCollectAcc(ac with src = MmSource(ac.src with decls = concat(ac.src.decls, [el])));
				MmEssential(l, __):
					MmCollectAcc(ac with hyps = Cons(el, ac.hyps));
				MmFloating(l, __, __):
					MmCollectAcc(ac with hyps = Cons(el, ac.hyps));
				MmAxiomatic(l, __):
					MmCollectAcc(ac with src = MmSource(ac.src with decls = concat(ac.src.decls, [mmMakeAssertion(el, ac)])));
				MmProvable(l, __, __):
					MmCollectAcc(ac with src = MmSource(ac.src with decls = concat(ac.src.decls, [mmMakeAssertion(el, ac)])));
				MmBlock(es):
					MmCollectAcc(ac with src = mmCollectElements(es, ac).src);
			}
		}
	)
}

mmMakeAssertion(statement : MmStat, env : MmCollectAcc) -> MmAssertion {
	getVars = \expr -> {
		fold(expr.symbs,
			makeSet(),
			\acc, symb ->
				if (containsSet(env.vars, symb.literal)) insertSet(acc, symb.literal) else acc
		)
	};
	vars = foldList(env.hyps, getVars(statement.expr), 
		\acc, hyp -> {
			switch (hyp) {
				MmEssential(__, expr): mergeSets(acc, getVars(expr));
				MmFloating(__,__,__): acc;
			}
		}
	);
	hyps = foldList(env.hyps, [],
		\acc, hyp : MmHyp -> switch (hyp) {
			MmEssential(label, expr): 
				concat(acc, [MmEssential(label, mmMarkVarsInExpr(expr, vars))]);
			MmFloating(label, type, var): 
				if (containsSet(vars, var)) concat(acc, [hyp]) else acc;
		}
	);
	inner = foldList(env.hyps, [],
		\acc, hyp : MmHyp -> switch (hyp) {
			MmEssential(label, expr): acc;
			MmFloating(label, type, var): 
				if (!containsSet(vars, var)) concat(acc, [hyp]) else acc;
		}
	);
	MmAssertion(list2array(env.disjs), hyps, inner, mmMarkVarsInStatement(statement, vars));
}

mmMarkVarsInHypothesis(hyp : MmHyp, vars : Set<string>) -> MmHyp {
	switch (hyp) {
		MmEssential(label, expr): MmEssential(label, mmMarkVarsInExpr(expr, vars));
		default: hyp;
	}
}

mmMarkVarsInStatement(stat : MmStat, vars : Set<string>) -> MmStat {
	switch (stat) {
		MmAxiomatic(label, expr): MmAxiomatic(label, mmMarkVarsInExpr(expr, vars));
		MmProvable(label, expr, proof): MmProvable(label, mmMarkVarsInExpr(expr, vars), proof);
	}
}

mmMarkVarsInExpr(expr : MmExpr, vars : Set<string>) -> MmExpr {
	MmExpr(map(expr.symbs, \symb -> 
		MmSymb(symb.literal, containsSet(vars, symb.literal))
	))
}
