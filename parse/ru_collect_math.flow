import math/stringmath;
import parse/ru_parse_exp;
import parse/ru_parse_src;
import ru_math;

export {
	ruCollectMath(parsed : Tree<string, RuParseSource>, conf : RuConf) -> RuMath {
		ruDoCollectMath(parsed, conf, ruMakeRuMath(conf));
	}
	ruSuperTypeName(super : string, infer : string) -> string {
		infer + "-" + super
	}
}

ruDoCollectMath(left : Tree<string, RuParseSource>, conf : RuConf, acc : RuMath) -> RuMath {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.path))
		);
		//println("modules to process: " + strGlue(map(ready, \s -> s.info.file), ", "));
		collected = sequential(true, map(ready, \s -> \-> ruCollectSource(s, acc)));
		new_acc = fold(collected, acc, \ac, coll -> ruMergeRuMath(coll, ac));
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		ruDoCollectMath(new_left, conf, new_acc);
	}
}

RuCollectAcc(
	global : RuMath,
	local : RuMath,
	types : Tree<string, RuTypeEnv>,
	conf : RuConf
);

ruCollectSource(src : RuParseSource, acc : RuMath) -> RuMath {
	start = timestamp();
	switch (lookupTree(acc.sources, src.info.file)) {
		Some(__): {
			acc.conf.onError("source " + src.info.file + " is already defined", []);
			acc
		}
		None(): {
			imps = map(src.imports, \imp -> RuImport(imp.path));
			acc0 = RuCollectAcc(acc, ruMakeRuMath(acc.conf), acc.types, acc.conf);
			acc1 = fold(src.decls, acc0, \ac, block -> 
				switch(block) {
					RuParseDecl(): ruCollectDecl(block, ac);
					RuParseComment(__): ac;
				}
			);
			decls = fold(src.decls, [], \ac, block -> 
				switch (block) {
					RuParseConst(name,__,__):            concat(ac, [lookupTreeDef(acc1.local.consts, name, ruNoConst)]);
					RuParseType(name,__):                concat(ac, [lookupTreeDef(acc1.local.types, name, ruNoTypeEnv).type]);
					RuParseRule(name,__,__):             concat(ac, [lookupTreeDef(acc1.local.rules, name, ruNoRule)]);
					RuParseAxiom(name,__,__,__,__):      concat(ac, [lookupTreeDef(acc1.local.assertions, name, ruNoAxiom)]);
					RuParseTheorem(name,__,__,__,__,__): concat(ac, [lookupTreeDef(acc1.local.assertions, name, ruNoTheorem)]);
					RuParseDef(name,__,__,__,__,__,__):  concat(ac, [lookupTreeDef(acc1.local.assertions, name, ruNoAxiom)]);
					RuParseComment(text):                concat(ac, [RuComment(text)]);
					RuParseTheory(name, __):             ac; // TODO
				}
			);
			if (acc.conf.verbose > 0) {
				println("collected: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
			}
			RuMath(acc1.local with 
				sources = makeTree1(src.info.file, RuSource(imps, decls, src.info))
			);
		}
	}
}

ruCollectDecl(decl : RuParseDecl, acc : RuCollectAcc) -> RuCollectAcc {
	switch (decl) {
		RuParseConst(__,__,__):            ruCollectConst(decl, acc);
		RuParseType(__,__):                ruCollectType(decl, acc);
		RuParseRule(__,__,__):             ruCollectRule(decl, acc);
		RuParseAxiom(__,__,__,__,__):      ruCollectAxiom(decl, acc);
		RuParseTheorem(__,__,__,__,__,__): ruCollectTheorem(decl, acc);
		RuParseDef(__,__,__,__,__,__,__):  ruCollectDef(decl, acc);
		RuParseComment(__):                acc;
		RuParseTheory(name, decls):        acc; // TODO 
	}
}

ruCollectConst(const : RuParseConst, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupConst(acc, const.symb)) {
		Some(__): {
			acc.conf.onError("constant " + const.symb + " is already defined", []);
			acc
		}
		None(): {
			RuCollectAcc(acc with
				local = RuMath(acc.local with 
					consts = setTree(acc.local.consts, const.symb, RuConst(const.symb, const.ascii, const.latex))
				)
			);
		}
	}
}

ruCollectType(type : RuParseType, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupType(acc, type.name)) {
		Some(__): {
			acc.conf.onError("type " + type.name + " is already defined", []);
			acc
		}
		None(): {
			infer = type.name;
			super_rule = \super -> {
				RuRule(
					ruSuperTypeName(super, infer), 
					makeTree1("x", RuVar("x", infer)), 
					RuTerm(super, [RuVarRef("x", infer)])
				);
			}
			supers = fold(type.supers, makeTree(), \ac, s ->
				switch (ruLookupType(acc, s)) {
					Some(env): {
						foldTree(env.supers,
							setTree(ac, s, super_rule(s)), 
							\super, __, a ->
								setTree(a, super, super_rule(super))
						)
					}
					None(): {
						acc.conf.onError("unknown super type " + s + " for a type" + infer, []);
						ac
					}
				}
			);
			super_types = foldTree(supers, acc.types, 
				\sup_name, sup_rule, ac -> {
					env = lookupTreeDef(ac, sup_name, ruNoTypeEnv);
					setTree(ac, sup_name, RuTypeEnv(env with infers = setTree(env.infers, infer, super_rule(sup_name))))
				}
			);
			new_types = setTree(super_types, type.name, 
				RuTypeEnv(
					RuType(type.name, type.supers), 
					ruAddTerm2RuTrie(
						RuTerm(type.name, [RuVarRef("x", type.name)]), 
						None(), //Some(\n, len -> [RuVarRef(n.name, type.name)]), 
						ruTrieEmpty, acc.conf
					), 
					supers, makeTree()
				)
			);
			RuCollectAcc(acc with
				local = RuMath(acc.local with 
					types = new_types,
					rules = foldTree(supers, acc.local.rules, \__, rule, ac -> setTree(ac, rule.name, rule))
				),
				types = new_types
			)
		}
	}
}

ComputeArgsAcc(
	nodes : [RuExpNode],
	pos : int,
	args : [[RuExpNode]]
);

ruComputeExpArgs(nodes : [RuExpNode]) -> [[RuExpNode]] {
	if (length(nodes) == 0) [] else
	ruDoComputeExpArgs(ComputeArgsAcc(nodes, length(nodes) - 1, [])).args
}

ruDoComputeExpArgs(acc : ComputeArgsAcc) -> ComputeArgsAcc {
	if (acc.pos < 0) acc else {
		switch (acc.nodes[acc.pos]) {
			RuRuleRef(r, len): {
				i = acc.pos - (len + 1);
				ruDoComputeExpArgs(ComputeArgsAcc(
					acc.nodes, i, 
					concat(acc.args, [subrange(acc.nodes, i + 1, len + 1)])
				));
			}
			RuVarRef(v, t): 
				ruDoComputeExpArgs(ComputeArgsAcc(
					acc.nodes, acc.pos - 1, 
					concat(acc.args, [[acc.nodes[acc.pos]]])
				));
		}
	}
}

ruCollectRule(rule : RuParseRule, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupRule(acc, rule.name)) {
		Some(__): {
			acc.conf.onError("rule " + rule.name + " is already defined", []);
			acc
		}
		None(): {
			type = rule.term.type;
			vars = fold(rule.vars, makeTree(), \ac, v ->
				switch (ruLookupType(acc, v.type)) {
					Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
					None(): {
						acc.conf.onError("unknown var " + v.name + " type " + v.type, []);
						ac
					}
				}
			);
			term = ruMakeTerm(rule.term, vars, acc, ruAddErr2Conf(acc.conf, "\nat rule: " + rule.name));
			new_rule = RuRule(rule.name, vars, term);
			switch (ruLookupType(acc, rule.term.type)) {
				Some(env): {
					new_types = setTree(acc.types, env.type.name,
						RuTypeEnv(env with 
							trie = ruAddTerm2RuTrie(new_rule.term, 
								Some(\expr -> {
									//println("rule: " + rule.name + " -- " + i2s(length(expr)) + ", args: " + i2s(length(ruComputeExpArgs(expr))) + ", expr: " + ruExpRPN2s(expr));
									concat(expr, [RuRuleRef(rule.name, length(expr))])
								}),
								env.trie, acc.conf
							)
						)
					);
					RuCollectAcc(acc with
						local = RuMath(acc.local with 
							rules = setTree(acc.local.rules, rule.name, new_rule),
							types = new_types
						),
						types = new_types
					);
				}
				None(): {
					acc.conf.onError("unknown type " + rule.term.type, []);
					acc;
				}
			}
		}
	}
}

ruMakeTerm(term : RuParseExp, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> RuTerm {
	expr = fold(term.symbs, [], \ac, symb -> {
		switch (ruLookupConst(acc, symb)) {
			Some(s): concat(ac, [RuConstRef(symb)]);
			None(): 
				switch (lookupTree(vars, symb)) {
					Some(v): concat(ac, [RuVarRef(symb, v.type)]);
					None(): {
						conf.onError("unknown symbol " + symb, []);
						ac
					}
				}
			}
		}
	);
	RuTerm(term.type, expr);
}

RuCollectRet(
	data : ?,
	acc : RuCollectAcc
);



ruFilterMapCollectRet(arr : [?], acc : RuCollectAcc, fun : (?, RuCollectAcc) -> Maybe<RuCollectRet<??>>) -> RuCollectRet<[??]>  {
	fold(arr, RuCollectRet([], acc), \ac, x ->
		eitherMap(fun(x, ac.acc), 
			\y -> RuCollectRet(concat(ac.data, [y.data]), y.acc),
			ac
		)
	)
}

ruCollectAxiom(ax : RuParseAxiom, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupAssertion(acc, ax.name)) {
		Some(__): {
			acc.conf.onError("assertion with name " + ax.name + " is already defined", []);
			acc
		}
		None(): {
			err = \-> { acc.conf.onError("error in axiom " + ax.name, []); acc; }
			conf1 = ruAddErr2Conf(acc.conf, "\nat axiom " + ax.name);
			vars = ruCollectVars(ax.vars, acc, conf1);
			disjs = map(ax.disjs, \d -> RuDisj(d.vars));
			hyps = ruFilterMapCollectRet(ax.hyps, acc, \h, ac -> ruCollectHyp(h, vars, ac, conf1));
			if (length(hyps.data) != length(ax.hyps)) {
				err();
				acc;
			} else {
				switch (ruCollectExp(ax.prop, vars, hyps.acc, conf1)) {
					Some(prop): {
						axiom = RuAxiom(ax.name, vars, disjs, hyps.data, prop.data);
						RuCollectAcc(prop.acc with
							local = RuMath(acc.local with assertions = setTree(acc.local.assertions, ax.name, axiom))
						);
					}
					None(): err();
				}
			}
		}
	}
}

ruAddExp2RuTrie(term : RuTerm, expr : RuExp, trie : RuTrie<string, ([RuExpNode])->[RuExpNode]>) -> RuTrie<string, ([RuExpNode])->[RuExpNode]> {
	term_key = \x -> switch (x) {
		RuConstRef(c):  c;
		RuVarRef(v, t): t;
	}
	action = \nodes -> {
		if (length(nodes) == 0) [RuRuleRef("[term: " + ruTerm2s(term.expr) + ", exp: " + ruExpRPN2s(expr.nodes) + "]", 0)] else {
			//println("worked: [term: " + ruTerm2s(term.expr) + ", exp: " + ruExpRPN2s(expr.nodes) + "]");
			args = ruComputeExpArgs(nodes);
			fold(expr.nodes, Pair([], 0), \acc, node -> 
				switch (node) {
					RuRuleRef(r, len): Pair(concat(acc.first, [node]), acc.second);
					RuVarRef(v, t): Pair(concat(acc.first, args[acc.second]), acc.second + 1);
				}
			).first
		}
	}
	ruAdd2Trie(map(term.expr, term_key), Some(action), trie, \a1, a2 -> a1);
}

ruCollectExp(ex : RuParseExp, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuCollectRet<RuExp>> {
	term = ruMakeTerm(ex, vars, acc, conf);
	switch (ruParseExp(term, acc.types, conf)) {
		Some(e): {
			tenv = lookupTreeDef(acc.types, term.type, ruNoTypeEnv);
			new_trie = tenv.trie; 
			//new_trie = ruAddExp2RuTrie(term, e, tenv.trie);
			new_types = setTree(acc.types, term.type, RuTypeEnv(tenv with trie = new_trie));
			Some(RuCollectRet(e, RuCollectAcc(acc with 
				local = RuMath(acc.local with types = new_types),
				types = new_types,
			)));
		}
		None(): None();
	}
}

ruCollectVars(vars : [RuParseVar], acc : RuCollectAcc, conf : RuConf) -> Tree<string, RuVar> {
	fold(vars, makeTree(), \ac, v ->
		switch (ruLookupType(acc, v.type)) {
			Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
			None(): {
				conf.onError("unknown var " + v.name + " type " + v.type, []);
				ac
			}
		}
	)
}

ruCollectHyp(hyp : RuParseHyp, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuCollectRet<RuHyp>> {
	maybeMap(
		ruCollectExp(hyp.expr, vars, acc, conf), 
		\ret -> RuCollectRet(RuHyp(hyp.ind, ret.data), ret.acc)
	)
}

ruCollectTheorem(th : RuParseTheorem, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupAssertion(acc, th.name)) {
		Some(__): {
			acc.conf.onError("assertion with name " + th.name + " is already defined", []);
			acc
		}
		None(): {
			err = \-> { acc.conf.onError("error in theorem " + th.name, []); acc; }
			conf1 = ruAddErr2Conf(acc.conf, "\nat theorem " + th.name);
			vars = ruCollectVars(th.vars, acc, conf1);
			disjs = map(th.disjs, \d -> RuDisj(d.vars));
			hyps = ruFilterMapCollectRet(th.hyps, acc, \h, ac -> ruCollectHyp(h, vars, ac, conf1));
			if (length(hyps.data) != length(th.hyps)) {
				err();
				acc;
			} else {
				switch (ruCollectExp(th.prop, vars, hyps.acc, conf1)) { 
					Some(prop): {
						switch (ruCollectProof(th.proof, vars, prop.acc, conf1)) {
							Some(proof): {
								theorem = RuTheorem(th.name, vars, disjs, hyps.data, prop.data, proof.data);
								RuCollectAcc(proof.acc with
									local = RuMath(acc.local with assertions = setTree(acc.local.assertions, th.name, theorem))
								);
							}
							None(): err();
						}
					}
					None(): err();
				}
			}
		}
	}
}

ruCollectProof(proof : RuParseProof, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuCollectRet<RuProof>> {
	proof_vars = ruCollectVars(proof.vars, acc, conf);
	proof_disjs = map(proof.disjs, \d -> RuDisj(d.vars));
	all_vars = mergeTree(vars, proof_vars);
	do_ref = \r -> switch (r) {
		RuParseHypRef(i): RuHypRef(i);
		RuParseStepRef(i): RuStepRef(i);
	}
	steps = ruFilterMapCollectRet(proof.steps, acc, 
		\s, ac -> {
			maybeMap(ruCollectExp(s.expr, all_vars, acc, conf), 
				\r -> RuCollectRet(RuStep(s.ind, s.assertion, map(s.refs, do_ref), r.data), r.acc)
			)
		}
	);
	if (length(steps.data) != length(proof.steps)) None() else {
		Some(RuCollectRet(RuProof(proof_vars, proof_disjs, steps.data), steps.acc));
	}
}

ruCollectDef(df : RuParseDef, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupAssertion(acc, df.name)) {
		Some(__): {
			acc.conf.onError("assertion with name " + df.name + " is already defined", []);
			acc
		}
		None(): {
			err = \-> { acc.conf.onError("error in definition " + df.name, []); acc; }
			conf1 = ruAddErr2Conf(acc.conf, "\nat definitoin " + df.name);
			vars = ruCollectVars(df.vars, acc, conf1);
			disjs = map(df.disjs, \d -> RuDisj(d.vars));
			prop_ex = fold(df.def.symbs, [], \ac, s ->
				if (s == "defiendum") concat(ac, df.defm.symbs) else
				if (s == "definiens") concat(ac, df.defs.symbs) else
				concat(ac, [s])
			);
			hyps = ruFilterMapCollectRet(df.hyps, acc, \h, ac -> ruCollectHyp(h, vars, ac, conf1));
			if (length(hyps.data) != length(df.hyps)) {
				err();
				acc;
			} else {
				switch (ruCollectExp(RuParseExp(df.def.type, prop_ex), vars, hyps.acc, conf1)) {
					Some(prop): {
						switch (ruCollectExp(df.defm, vars, prop.acc, conf1)) {
							Some(defm): {
								switch (ruCollectExp(df.defs, vars, defm.acc, conf1)) {
									Some(defs): {
										def = RuDef(df.name, vars, disjs, hyps.data, defm.data, defs.data, prop.data);
										RuCollectAcc(defs.acc with
											local = RuMath(acc.local with assertions = setTree(acc.local.assertions, df.name, def))
										);
									}
									None(): err();
								}
							}
							None(): err();
						}
					}
					None(): err();
				}
			}
		}
	}
}

ruLookupConst(acc : RuCollectAcc, n : string) -> Maybe<RuConst> {
	switch(lookupTree(acc.global.consts, n)) {
		Some(c): Some(c);
		None(): lookupTree(acc.local.consts, n);
	}
}

ruLookupType(acc : RuCollectAcc, n : string) -> Maybe<RuTypeEnv> {
	lookupTree(acc.types, n)
}

ruLookupRule(acc : RuCollectAcc, n : string) -> Maybe<RuRule> {
	switch(lookupTree(acc.global.rules, n)) {
		Some(r): Some(r);
		None(): lookupTree(acc.local.rules, n);
	}
}

ruLookupAssertion(acc : RuCollectAcc, n : string) -> Maybe<RuAssertion> {
	switch(lookupTree(acc.global.assertions, n)) {
		Some(a): Some(a);
		None(): lookupTree(acc.local.assertions, n);
	}
}
