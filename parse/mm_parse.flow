import fs/filesystem;
import sys/concurrent;
import lingo/compiler/syntaxtree_util;
import ru_math;
import parse/ru_load;
import parse/mm_parse_file;
import parse/mm_parse_ast;
import mm_src;

export {
	mmParse(loaded : [RuLoadSource], conf : RuConf) -> Tree<string, MmParseSource>;
}

mmParse(loaded : [RuLoadSource], conf : RuConf) -> Tree<string, MmParseSource> {
	fold(
		filtermap(
			concurrent(true, map(loaded, \l -> \-> mmParseSource(l, conf))),
			idfn
		),
		makeTree(),
		\acc, src -> setTree(acc, src.info.file, src)
	)
}

mmParseSource(loaded : RuLoadSource, conf : RuConf) -> Maybe<MmParseSource> {
	start = timestamp();
	pr1 = parse_mm_source(loaded.src);
	st = pr1.first;
	err = pr1.second;
	if (st.end != strlen(loaded.src)) {
		conf.onError(
			"Syntax error: expected one of " + strGlue(map(err.expected, \e -> "'" + e + "'"), ", ") + 
			(if (err.met != "") " while met: '" + err.met + "'" else ""), 
			[RuPlace(loaded.info.file, err.pos)]
		);
		None()
	} else {
		parsed = mmMakeSrc(loaded, st, conf);
		if (conf.verbose > 0) {
			println("parsed: " + loaded.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
		}
		Some(parsed);
	}
}

mmMakeSrc(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmParseSource {
	elems = ref [];
	includes = ref [];
	iter(get_mm_source_mm_element_s(st),
		\elem -> {
			if (elem.rule == st_mm_comment) {
				refArrayPush(elems, mmMakeComment(loaded, elem, conf));
			} else if (elem.rule == st_mm_include) {
				inc = mmMakeInclude(loaded, elem, conf);
				refArrayPush(includes, inc.file);
				refArrayPush(elems, inc);
			} else if (elem.rule == st_mm_const) {
				refArrayPush(elems, mmMakeConst(loaded, elem, conf));
			} else if (elem.rule == st_mm_vars) {
				refArrayPush(elems, mmMakeVars(loaded, elem, conf));
			} else if (elem.rule == st_mm_disj) {
				refArrayPush(elems, mmMakeDisj(loaded, elem, conf));
			} else if (elem.rule == st_mm_floating) {
				refArrayPush(elems, mmMakeFloating(loaded, elem, conf));
			} else if (elem.rule == st_mm_essential) {
				refArrayPush(elems, mmMakeEssential(loaded, elem, conf));
			} else if (elem.rule == st_mm_axiomatic) {
				refArrayPush(elems, mmMakeAxiomatic(loaded, elem, conf));
			} else if (elem.rule == st_mm_provable) {
				refArrayPush(elems, mmMakeProvable(loaded, elem, conf));
			} else if (elem.rule == st_mm_block) {
				refArrayPush(elems, mmMakeProvable(loaded, elem, conf));
			}
		}
	);
	MmParseSource(^includes, ^elems, loaded.info);
}

mmMakeComment(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmComment {
	MmComment(grabSTText(get_mm_source_mm_comment_text(st), loaded.src));
}

mmMakeInclude(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmInclude { 
	path = ruTrimPath(grabSTText(get_mm_source_mm_path(st), loaded.src), conf);
	MmInclude(path);
}

mmMakeConst(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmConst {
	MmConst(map(get_mm_source_mm_word_s(st), \s -> grabSTText(s, loaded.src)));
}

mmMakeVars(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmVars {
	MmVars(map(get_mm_source_mm_word_s(st), \s -> grabSTText(s, loaded.src)));
}

mmMakeDisj(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmDisj {
	MmDisj(map(get_mm_source_mm_word_s(st), \s -> grabSTText(s, loaded.src)));
}

mmMakeFloating(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmFloating {
	words_st = get_mm_source_mm_word_s(st);
	MmFloating(
		grabSTText(words_st[0], loaded.src),
		grabSTText(words_st[1], loaded.src),
		grabSTText(words_st[2], loaded.src)
	);
}

mmMakeEssential(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmEssential {
	MmEssential(
		grabSTText(get_mm_source_mm_word(st), loaded.src),
		MmExpr(map(get_mm_source_mm_word_s(st), \s -> MmSymb(grabSTText(s, loaded.src), false)))
	);
}

mmMakeAxiomatic(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmAxiomatic {
	MmAxiomatic(
		grabSTText(get_mm_source_mm_word(st), loaded.src),
		MmExpr(map(get_mm_source_mm_word_s(st), \s -> MmSymb(grabSTText(s, loaded.src), false)))
	);
}

mmMakeProvable(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmProvable {
	MmProvable(
		grabSTText(get_mm_source_mm_word(st), loaded.src),
		MmExpr(map(get_mm_source_mm_word_s(st), \s -> MmSymb(grabSTText(s, loaded.src), false))),
		mmMakeProof(loaded, get_mm_source_mm_proof(st), conf)
	);
}

mmMakeProof(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmProof {
	MmProof(
		map(get_mm_source_mm_word_s(st), \s -> grabSTText(s, loaded.src))
	);
}

mmMakeBlock(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> MmBlock {
	elems = ref [];
	iter(get_mm_source_mm_element_s(st),
		\elem -> {
			if (elem.rule == st_mm_comment) {
				refArrayPush(elems, mmMakeComment(loaded, elem, conf));
			} else if (elem.rule == st_mm_include) {
				refArrayPush(elems, mmMakeInclude(loaded, elem, conf));
			} else if (elem.rule == st_mm_const) {
				refArrayPush(elems, mmMakeConst(loaded, elem, conf));
			} else if (elem.rule == st_mm_vars) {
				refArrayPush(elems, mmMakeVars(loaded, elem, conf));
			} else if (elem.rule == st_mm_disj) {
				refArrayPush(elems, mmMakeDisj(loaded, elem, conf));
			} else if (elem.rule == st_mm_floating) {
				refArrayPush(elems, mmMakeFloating(loaded, elem, conf));
			} else if (elem.rule == st_mm_essential) {
				refArrayPush(elems, mmMakeEssential(loaded, elem, conf));
			} else if (elem.rule == st_mm_axiomatic) {
				refArrayPush(elems, mmMakeAxiomatic(loaded, elem, conf));
			} else if (elem.rule == st_mm_provable) {
				refArrayPush(elems, mmMakeProvable(loaded, elem, conf));
			} else if (elem.rule == st_mm_block) {
				refArrayPush(elems, mmMakeProvable(loaded, elem, conf));
			}
		}
	);
	MmBlock(^elems);
}
