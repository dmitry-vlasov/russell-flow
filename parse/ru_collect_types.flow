import parse/ru_parse_exp;

export {
	RuCollectAcc(
		consts : Tree<string, RuConst>,
		types : Tree<string, RuTypeEnv>,
		rules : Tree<string, RuRule>,
		assertions : Tree<string, RuAssertion>
	);
	ruCollectTypes(parsed : Tree<string, RuParseSource>, conf : RuConf) -> RuCollectAcc {
		ruDoCollectTypes(parsed, conf, RuCollectAcc(makeTree(), makeTree(), makeTree(), makeTree()));
	}
	ruSuperTypeName(super : string, infer : string) -> string {
		super + "_sup_" + infer
	}
}

ruDoCollectTypes(left : Tree<string, RuParseSource>, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.path))
		);
		println("modules to process: " + strGlue(map(ready, \s -> s.info.file), ", "));
		new_acc = fold(ready, acc, \ac, src -> ruCollectTypesInSource(src, conf, ac));
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		ruDoCollectTypes(new_left, conf, new_acc);
	}
}

ruCollectTypesInSource(src : RuParseSource, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	fold(src.decls, acc, \ac, decl ->
		switch (decl) {
			RuParseConst(symb, ascii, latex): ruCollectConst(decl, conf, ac);
			RuParseType(name, sups): ruCollectType(decl, conf, ac);
			RuParseRule(name, vs, term): ruCollectRule(decl, conf, ac);
			RuParseAxiom(name, vars, disjs, hyps, prop): ruCollectAxiom(decl, conf, ac);
			default: ac;
		}
	)
}

ruCollectConst(const : RuParseConst, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.consts, const.symb)) {
		Some(__): {
			conf.onError("constant " + const.symb + " is already defined", []);
			acc
		}
		None(): {
			RuCollectAcc(acc with consts = setTree(acc.consts, const.symb, RuConst(const.symb, const.ascii, const.latex)));
		}
	}
}

ruCollectType(type : RuParseType, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.types, type.name)) {
		Some(__): {
			conf.onError("type " + type.name + " is already defined", []);
			acc
		}
		None(): {
			supers = fold(type.supers, makeTree(), \ac, s ->
				switch (lookupTree(acc.types, s)) {
					Some(env):
						foldTree(env.supers, ac, \super, __, a ->
							setTree(a, super, 
								RuRule(
									ruSuperTypeName(super, type.name),
									makeTree1("x", RuVar("x", type.name)),
									RuTerm(super, [RuVarRef("x", type.name)])
								)
							)
						);
					None(): {
						conf.onError("unknown super type " + s + " for a type" + type.name, []);
						ac
					}
				}
			);
			RuCollectAcc(acc with 
				types = setTree(acc.types, type.name, 
					RuTypeEnv(RuType(type.name, type.supers), ruTabEmpty, supers)
				),
				rules = mergeTree(acc.rules, supers)
			);
		}
	}
}

ruCollectRule(rule : RuParseRule, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.rules, rule.name)) {
		Some(__): {
			conf.onError("rule " + rule.name + " is already defined", []);
			acc
		}
		None(): {
			vars = fold(rule.vars, makeTree(), \ac, v ->
				switch (lookupTree(acc.types, v.type)) {
					Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
					None(): {
						conf.onError("unknown var " + v.name + " type " + v.type, []);
						ac
					}
				}
			);
			new_rule = RuRule(rule.name, vars, ruMakeTerm(rule.term, vars, acc.consts, conf));
			switch (lookupTree(acc.types, rule.term.type)) {
				Some(typeEnv): {
					RuCollectAcc(acc with 
						rules = setTree(acc.rules, rule.name, new_rule),
						types = setTree(acc.types, typeEnv.type.name,
							RuTypeEnv(typeEnv.type, ruAddTerm2RuTab(new_rule.term, rule.name, typeEnv.table, conf), typeEnv.supers)
						)
					);
				}
				None(): {
					conf.onError("unknown type " + rule.term.type, []);
					acc;
				}
			}
		}
	}
}

ruMakeTerm(term : RuParseExp, vars : Tree<string, RuVar>, consts : Tree<string, RuConst>, conf : RuConf) -> RuTerm {
	expr = fold(term.symbs, [], \ac, symb -> {
		switch (lookupTree(consts, symb)) {
			Some(s): concat(ac, [RuConstRef(symb)]);
			None(): 
				switch (lookupTree(vars, symb)) {
					Some(v): concat(ac, [RuVarRef(symb, v.type)]);
					None(): {
						conf.onError("unknown symbol " + symb, []);
						ac
					}
				}
			}
		}
	);
	RuTerm(term.type, expr);
}

arrMaybe2maybeArr(arr : [Maybe<?>]) -> Maybe<[?]>  {
	fold(arr, Some([]), \acc, x ->
		switch (acc) {
			None(): acc;
			Some(a): maybeMap(x, \y -> concat(a, [y]));
		}
	)
}

ruCollectAxiom(ax : RuParseAxiom, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.assertions, ax.name)) {
		Some(__): {
			conf.onError("assertion with name " + ax.name + " is already defined", []);
			acc
		}
		None(): {
			vars = fold(ax.vars, makeTree(), \ac, v ->
				switch (lookupTree(acc.types, v.type)) {
					Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
					None(): {
						conf.onError("unknown var " + v.name + " type " + v.type, []);
						ac
					}
				}
			);
			disjs = map(ax.disjs, \d -> RuDisj(d.vars));
			parse_exp = \ex -> ruParseExp(ruMakeTerm(ex, vars, acc.consts, conf), acc.types, conf);
			make_hyp = \h -> maybeMap(parse_exp(h.expr), \e -> RuHyp(h.ind, e));
			maxiom = maybeMap2(\prop, hyps -> 
				RuAxiom(ax.name, vars, disjs, hyps, prop)
			)(parse_exp(ax.prop), arrMaybe2maybeArr(map(ax.hyps, make_hyp)));
			switch (maxiom) {
				Some(axiom): RuCollectAcc(acc with assertions = setTree(acc.assertions, ax.name, axiom));
				None(): acc;
			}
		}
	}
}


