import parse/ru_table;

export {
	RuTypeEnv(
		type : RuType,
		table : RuTab,
	);
	RuCollectAcc(
		consts : Tree<string, RuConst>,
		types : Tree<string, RuTypeEnv>,
		rules : Tree<string, RuRule>
	);
	ruCollectTypes(parsed : Tree<string, RuParseSource>, conf : RuConf) -> RuCollectAcc {
		ruDoCollectTypes(parsed, conf, RuCollectAcc(makeTree(), makeTree(), makeTree()))
	}
}

ruDoCollectTypes(left : Tree<string, RuParseSource>, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.path))
		);
		new_acc = fold(ready, acc, \ac, src -> ruCollectTypesInSource(src, conf, ac));
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		ruDoCollectTypes(new_left, conf, new_acc);
	}
}

ruCollectTypesInSource(src : RuParseSource, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	fold(src.decls, acc, \ac, decl ->
		switch (decl) {
			RuParseConst(symb, ascii, latex): ruCollectConst(decl, conf, ac);
			RuParseType(name, sups): ruCollectType(decl, conf, ac);
			RuParseRule(name, vs, term): ruCollectRule(decl, conf, ac);
			default: ac;
		}
	)
}

ruCollectConst(const : RuParseConst, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.consts, const.symb)) {
		Some(__): {
			conf.onError("constant " + const.symb + " is already defined", []);
			acc
		}
		None(): {
			RuCollectAcc(acc with consts = setTree(acc.consts, const.symb, RuConst(const.symb, const.ascii, const.latex)));
		}
	}
}

ruCollectType(type : RuParseType, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.types, type.name)) {
		Some(__): {
			conf.onError("type " + type.name + " is already defined", []);
			acc
		}
		None(): {
			supers = fold(type.supers, [], \ac, s ->
				switch (lookupTree(acc.types, s)) {
					Some(tp): concat(ac, [s]);
					None(): {
						conf.onError("unknown type " + s, []);
						ac
					}
				}
			);
			RuCollectAcc(acc with 
				types = setTree(acc.types, type.name, 
					RuTypeEnv(RuType(type.name, supers), ruTabEmpty)
				)
			);
		}
	}
}

ruCollectRule(rule : RuParseRule, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.rules, rule.name)) {
		Some(__): {
			conf.onError("rule " + rule.name + " is already defined", []);
			acc
		}
		None(): {
			vars = fold(rule.vars, makeTree(), \ac, v ->
				switch (lookupTree(acc.types, v.type)) {
					Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
					None(): {
						conf.onError("unknown type " + v.type, []);
						ac
					}
				}
			);
			switch (lookupTree(acc.types, rule.term.type)) {
				Some(typeEnv): {
					expr = fold(rule.term.symbs, [], \ac, symb -> {
						switch (lookupTree(acc.consts, symb)) {
							Some(s): concat(ac, [RuConstRef(symb)]);
							None(): 
								switch (find(rule.vars, \v -> v.name == symb)) {
									Some(v): concat(ac, [RuVarRef(symb, v.type)]);
									None(): {
										conf.onError("unknown symbol " + symb, []);
										ac
									}
								}
						}
					});
					new_rule = RuRule(rule.name, vars, RuTerm(rule.term.type, expr));
					RuCollectAcc(acc with 
						rules = setTree(acc.rules, rule.name, new_rule),
						types = setTree(acc.types, typeEnv.type.name,
							RuTypeEnv(typeEnv.type, ruAdd2RuTab(new_rule, typeEnv.table, conf))
						)
					);
				}
				None(): acc;
			}
		}
	}
}

