import parse/ru_table;

export {
	RuTypeEnv(
		type : RuType,
		table : RuTab,
		supers : Tree<string, RuRule>,
		infers : Tree<string, RuRule>
	);

	ruNoTypeEnv = RuTypeEnv(ruNoType, ruTabEmpty, makeTree(), makeTree());

	RuCollectAcc(
		consts : Tree<string, RuConst>,
		types : Tree<string, RuTypeEnv>,
		rules : Tree<string, RuRule>
	);
	ruCollectTypes(parsed : Tree<string, RuParseSource>, conf : RuConf) -> RuCollectAcc {
		acc = ruDoCollectTypes(parsed, conf, RuCollectAcc(makeTree(), makeTree(), makeTree()));
		RuCollectAcc(
			acc.consts,
			ruCollectInfers(acc.types),
			acc.rules
		)
	}
	ruSuperTypeName(super : string, infer : string) -> string {
		super + "_sup_" + infer
	}
}

ruCollectInfers(types : Tree<string, RuTypeEnv>) -> Tree<string, RuTypeEnv> {
	foldTree(types, types, \sup_name, sup_env, acc ->
		setTree(acc, sup_name, RuTypeEnv(
			sup_env.type, sup_env.table, sup_env.supers, 
				foldTree(types, makeTree(), \inf_name, inf_env, infers ->
					switch (lookupTree(inf_env.supers, sup_name)) {
						Some(r): setTree(infers, inf_name, r);
						None(): infers;
					}
				)
			)
		)
	)
}

ruDoCollectTypes(left : Tree<string, RuParseSource>, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.path))
		);
		new_acc = fold(ready, acc, \ac, src -> ruCollectTypesInSource(src, conf, ac));
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		ruDoCollectTypes(new_left, conf, new_acc);
	}
}

ruCollectTypesInSource(src : RuParseSource, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	fold(src.decls, acc, \ac, decl ->
		switch (decl) {
			RuParseConst(symb, ascii, latex): ruCollectConst(decl, conf, ac);
			RuParseType(name, sups): ruCollectType(decl, conf, ac);
			RuParseRule(name, vs, term): ruCollectRule(decl, conf, ac);
			default: ac;
		}
	)
}

ruCollectConst(const : RuParseConst, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.consts, const.symb)) {
		Some(__): {
			conf.onError("constant " + const.symb + " is already defined", []);
			acc
		}
		None(): {
			RuCollectAcc(acc with consts = setTree(acc.consts, const.symb, RuConst(const.symb, const.ascii, const.latex)));
		}
	}
}

ruCollectType(type : RuParseType, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.types, type.name)) {
		Some(__): {
			conf.onError("type " + type.name + " is already defined", []);
			acc
		}
		None(): {
			supers = fold(type.supers, makeTree(), \ac, s ->
				switch (lookupTree(acc.types, s)) {
					Some(env):
						foldTree(env.supers, ac, \super, __, a ->
							setTree(a, super, 
								RuRule(
									ruSuperTypeName(super, type.name),
									makeTree1("x", RuVar("x", type.name)),
									RuTerm(super, [RuVarRef("x", type.name)])
								)
							)
						);
					None(): {
						conf.onError("unknown super type " + s + " for a type" + type.name, []);
						ac
					}
				}
			);
			RuCollectAcc(acc with 
				types = setTree(acc.types, type.name, 
					RuTypeEnv(RuType(type.name, type.supers), ruTabEmpty, supers, makeTree())
				),
				rules = mergeTree(acc.rules, supers)
			);
		}
	}
}

ruCollectRule(rule : RuParseRule, conf : RuConf, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.rules, rule.name)) {
		Some(__): {
			conf.onError("rule " + rule.name + " is already defined", []);
			acc
		}
		None(): {
			vars = fold(rule.vars, makeTree(), \ac, v ->
				switch (lookupTree(acc.types, v.type)) {
					Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
					None(): {
						conf.onError("unknown var " + v.name + " type " + v.type, []);
						ac
					}
				}
			);
			switch (lookupTree(acc.types, rule.term.type)) {
				Some(typeEnv): {
					expr = fold(rule.term.symbs, [], \ac, symb -> {
						switch (lookupTree(acc.consts, symb)) {
							Some(s): concat(ac, [RuConstRef(symb)]);
							None(): 
								switch (find(rule.vars, \v -> v.name == symb)) {
									Some(v): concat(ac, [RuVarRef(symb, v.type)]);
									None(): {
										conf.onError("unknown symbol " + symb, []);
										ac
									}
								}
						}
					});
					new_rule = RuRule(rule.name, vars, RuTerm(rule.term.type, expr));
					RuCollectAcc(acc with 
						rules = setTree(acc.rules, rule.name, new_rule),
						types = setTree(acc.types, typeEnv.type.name,
							RuTypeEnv(typeEnv.type, ruAdd2RuTab(new_rule, typeEnv.table, conf), typeEnv.supers, makeTree())
						)
					);
				}
				None(): acc;
			}
		}
	}
}

