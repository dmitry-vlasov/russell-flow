import fs/filesystem;
import lingo/compiler/syntaxtree_util;
import ru_math;
import ru_parse_file;
import ru_parse_src;

export {
	ruParse(file : string, math : RuMath) -> RuMath;
}

ruParse(file : string, math : RuMath) -> RuMath {
	switch (lookupTree(math.sources, file)) {
		Some(src): math;
		None(): {
			if (fileExists(file)) {
				src_str = getFileContent(file);
				pr1 = parse_source(src_str);
				st = pr1.first;
				err = pr1.second;
				if (st.end != strlen(src_str)) {
					math.onError("Syntax error: expected one of " + strGlue(err.expected, ", ") + " while met: " + err.met, [RuPlace(file, err.pos)]);
					math
				} else {
					ruMakeSrc(file, src_str, st, math);
				}
			} else {
				math.onError("file " + file + " is not found", []);
				math
			}
		}
	}
}

ruMakeSrc(file : string, src_str : string, st : SyntaxTree, math : RuMath) -> RuMath {
	imports = ref [];
	decls = ref [];
	math1 = fold(get_source_decl_s(st), math,
		\acc, decl -> {
			if (decl.rule == st_import) {
				maybeApply(ruMakeImport(file, src_str, decl, math), \imp -> refArrayPush(imports, imp));
				acc
			} else if (decl.rule == st_const) {
				eitherMap(
					ruMakeConst(file, src_str, decl, math), 
					\c -> {
						refArrayPush(decls, c);
						RuMath(math with 
							consts = setTree(math.consts, c.symb, c), 
							symbs = ruAddSymb(c.symb, math.symbs)
						)
					},
					acc
				);
			} else if (decl.rule == st_type) {
				eitherMap(
					ruMakeType(file, src_str, decl, math), 
					\t -> {
						refArrayPush(decls, t);
						RuMath(math with 
							types = setTree(math.types, t.name, t)
						)
					},
					acc
				);
			} else {
				acc
			}
		}
	);
	RuMath(math1 with sources = setTree(math1.sources, file, RuSource(^imports, ^decls)));
}

ruMakeImport(file : string, src_str : string, st : SyntaxTree, math : RuMath) -> Maybe<RuImport> { 
	path = grabSTText(get_source_symb(st), src_str);
	switch (lookupTree(math.sources, path)) {
		Some(src): Some(RuImport(path, src));
		None(): {
			math.onError("import '" + path + "' is not found", [RuPlace(file, get_source_symb(st).start)]);
			None();
		}
	}
}

ruMakeConst(file : string, src_str : string, st : SyntaxTree, math : RuMath) -> Maybe<RuConst> {
	symbs = get_source_symb_s(st);
	symb = grabSTText(get_source_symb(symbs[0]), src_str);
	ascii = if (length(symbs) > 1) grabSTText(get_source_symb(symbs[1]), src_str) else "";
	latex = if (length(symbs) > 2) grabSTText(get_source_symb(symbs[2]), src_str) else "";
	if (containsKeyTree(math.consts, symb)) {
		math.onError("constant '" + symb + "' is already declared", [RuPlace(file, get_source_symb(symbs[0]).start)]);
		None();
	} else {
		Some(RuConst(symb, ascii, latex));
	}
}

ruMakeType(file : string, src_str : string, st : SyntaxTree, math : RuMath) -> Maybe<RuType> {
	all_ids = get_source_id_s(st);
	name = grabSTText(ids[0], src_str);
	if (containsKeyTree(math.types, name)) {
		math.onError("type '" + name + "' is already defined", [RuPlace(file, ids[0].start)]);
		None()
	} else {
		super_ids = tail(all_ids);
		supers = fold(super_ids, Some([]), \acc, sid -> {
			maybeBind(acc, \ac -> {
				id = grabSTText(sid, src_str);
				switch(lookupTree(math.types, id)) {
					Some(st): Some(concat(ac, [st]));
					None(): math.onError("type '" + id + "' is not defined", )
				}
			})
		});
	
	}
	
	ascii = if (length(symbs) > 1) grabSTText(get_source_symb(symbs[1]), src_str) else "";
	latex = if (length(symbs) > 2) grabSTText(get_source_symb(symbs[2]), src_str) else "";
	p = ruAddSymb(symb, math.symbs);
	if (containsKeyTree(math.consts, symb)) {
		math.onError("constant '" + symb + "' is already declared", [RuPlace(file, get_source_symb(symbs[0]).start)]);
		None();
	} else {
		Some(RuConst(symb, ascii, latex));
	}
}
