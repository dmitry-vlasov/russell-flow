import parse/ru_collect_types;

export {
	ruParseExp(term : RuTerm, types : Tree<string, RuTypeEnv>, conf : RuConf) -> Maybe<RuExp> {
		if (length(term.expr) == 0) {
			conf.onError("empty expression met");
			None()
		} else {
			switch (lookupTree(types, term.type)) {
				Some(tenv): 
					maybeMap(
						ruParseExp(term, RuParseExpEnv(tenv.type, 0), types, conf), 
						\ex -> RuExp(ex)
					);
				None(): {
					conf.onError("unknown type: " + term.type);
					None();
				}
			}
		}
	}
}

RuParseExpEnv(
	nodes : [RuTermNode],
	type : RuType,
	start : int, 
	pos : int,
	expr : Maybe<[RuExpNode]>
);

ruParseExpr(nodes : [RuTermNode], pos : int, type : string, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuParseExpEnv {
	if (env.expr == None()) env else {
		switch (rule.term.expr[env.pos]) {
			RuVarRef(v, t): {
				if (env.type == t) {
					[RuVarRef(v, t)];
				} else {
					switch (lookupTree(types, t)) {
						Some(tenv): {
							switch (lookupTree(tenv.supers(type.name))) {
								Some(super): {
									[RuRuleRef(super.name, 1), RuVarRef(v, t)];
								}
								None():
							}
						}
						None(): {
							conf.onError("unknown type: " + t);
						}
					}
				
				}
			}
			RuConstRef(c):   RuTab(add(tab.consts, c, ""), tab.vars);
		}
	}
}

