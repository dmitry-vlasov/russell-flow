import parse/ru_table;

export {
	ruParseExp(term : RuTerm, types : Tree<string, RuTypeEnv>, conf : RuConf) -> Maybe<RuExp> {
		if (length(term.expr) == 0) {
			conf.onError("empty expression met", []);
			None()
		} else {
			ret = switch (lookupTree(types, term.type)) {
				Some(tenv): {
					println("going to parse: " + ruTerm2s(term));
					switch (ruParseExpr(
						RuParseEnv(term.expr, types, conf), 0, 
						RuParseStack(None(), 0, tenv.table, [])
					)) {
						Some(expr): {
							println("successfully parsed: " + ruExpRPN2s(expr));
							Some(RuExp(expr));
						}
						None(): {
							conf.onError("expr was not successfully parsed: " + ruTerm2s(term), []);
							None();
						}
					}
				}
				None(): {
					conf.onError("unknown type: " + term.type, []);
					None();
				}
			}
			if (ret == None()) {
				quit(0);
			}
			ret
		}
	}
	
	ruParseExp1(term : RuTerm, types : Tree<string, RuTypeEnv>, conf : RuConf) -> Maybe<RuExp> {
		if (length(term.expr) == 0) {
			conf.onError("empty expression met", []);
			None()
		} else {
			ret = switch (lookupTree(types, term.type)) {
				Some(tenv): {
					println("going to parse: " + ruTerm2s(term));
					switch (ruParseExpr1(
						RuParseEnv(term.expr, types, conf), 0, 
						RuParseStack1(None(), 0, tenv.trie, [])
					)) {
						Some(expr): {
							println("successfully parsed: " + ruExpRPN2s(expr));
							Some(RuExp(expr));
						}
						None(): {
							conf.onError("expr was not successfully parsed: " + ruTerm2s(term), []);
							None();
						}
					}
				}
				None(): {
					conf.onError("unknown type: " + term.type, []);
					None();
				}
			}
			if (ret == None()) {
				quit(0);
			}
			ret
		}
	}
	
	ruParseExp2(term : RuTerm, types : Tree<string, RuTypeEnv>, conf : RuConf) -> Maybe<RuExp> {
		if (length(term.expr) == 0) {
			conf.onError("empty expression met", []);
			None()
		} else {
			ret = switch (lookupTree(types, term.type)) {
				Some(tenv): {
					println("going to parse: " + ruTerm2s(term));
					switch (ruParseExpr2(
						RuParseEnv(term.expr, types, conf), 0, 
						RuParseStack2(None(), 0, tenv.trie1, [])
					)) {
						Some(expr): {
							println("successfully parsed: " + ruExpRPN2s(expr));
							Some(RuExp(expr));
						}
						None(): {
							conf.onError("expr was not successfully parsed: " + ruTerm2s(term), []);
							None();
						}
					}
				}
				None(): {
					conf.onError("unknown type: " + term.type, []);
					None();
				}
			}
			if (ret == None()) {
				quit(0);
			}
			ret
		}
	}
}

RuParseEnv(
	nodes : [RuTermNode],
	types : Tree<string, RuTypeEnv>, 
	conf : RuConf,
);

RuParseStack(
	parent : Maybe<RuParseStack>,
	start : int,
	table : RuTab<string>,
	expr : [RuExpNode]
);


printStack(stack : RuParseStack) {
	println("stack start: " + i2s(stack.start) + ", nodes: " + ruExpRPN2s(stack.expr))
}

showNode(n : RuTermNode) -> string {
	switch (n) {
		RuVarRef(v, t): "\"" + v + "\"";
		RuConstRef(c): "\"" + c + "\"";
	}
}

ruParseExpr(env : RuParseEnv, pos : int, stack : RuParseStack) -> Maybe<[RuExpNode]> {
	if (pos == length(env.nodes)) None() else {
		println("pos: " + i2s(pos) + ", acc: " + ruExpRPN2s(stack.expr) + ", nodes[pos]: " + showNode(env.nodes[pos]) + ", vars: {" +
			strGlue(getTreeKeys(stack.table.vars), ", ") + "}, consts: {" + strGlue(getTreeKeys(stack.table.consts), ", ") + "}"
		);
		do_step = \st, n -> {
			switch (ruParseExpr(env, pos + 1, RuParseStack(st with table = n.table))) {
				Some(expr): Some(expr);
				None(): {
					if (n.data == "") None() else {
						println("table data: " + n.data);
						switch (st.parent) {
							Some(parent):
								ruParseExpr(env, pos + 1, RuParseStack(parent with 
									expr = concat3(parent.expr, st.expr, [RuRuleRef(n.data, pos - st.start)])
								));
							None(): {
								if (pos + 1 == length(env.nodes)) {
									Some(concat([RuRuleRef(n.data, pos - st.start)], st.expr))
								} else {
									env.conf.onError("pop of an empty stack", []);
									None() 
								}
							}
						}
					}
				}
			}
		}
		ret = switch (env.nodes[pos]) {
			RuVarRef(v, t): {
				switch (lookupTree(stack.table.vars, t)) {
					Some(n): do_step(RuParseStack(stack with expr = concat(stack.expr, [RuVarRef(v, t)])), n);
					None(): {
						supers = lookupTreeDef(env.types, t, ruNoTypeEnv).supers;
						foldTree(stack.table.vars, None(), \tp, n, ac -> 
							if (ac != None()) ac else {
								switch (lookupTree(supers, tp)) {
									Some(r): 
										do_step(RuParseStack(stack with expr = concat(stack.expr, [RuRuleRef(r.name, 1), RuVarRef(v, t)])), n);
									None(): ac;
								}
							}
						);
					}
				}
			}
			RuConstRef(c): {
				switch (lookupTree(stack.table.consts, c)) {
					Some(n): do_step(stack, n);
					None(): {
						foldTree(stack.table.vars, None(), \t, n, ac ->
							if (ac != None()) ac else {
								ruParseExpr(env, pos, 
									RuParseStack(
										Some(RuParseStack(stack with table = n.table)), 
										pos, lookupTreeDef(env.types, t, ruNoTypeEnv).table, []
									), 
								)
							}
						)
					}
				}
			}
		}
		//printRet(ret);
		ret
	}
}


RuParseStack1(
	parent : Maybe<RuParseStack1>,
	start : int,
	trie : RuTrie<string, (RuTermNode, int) -> [RuExpNode]>,
	expr : [RuExpNode]
);

printStack1(stack : RuParseStack1) {
	prn_keys = \mp -> 
	strGlue(
		map(getTreeKeys(mp), 
			\key -> 
				if (isSome(lookupTreeDef(mp, key, ruTrieNodeEmpty).data)) "*" + key else key
		),
		", "
	);
	println(
		strGlue([
			"STACK start: " + i2s(stack.start),
			//"expr: " + ruExpRPN2s(stack.expr),
			"trie keys: {" + prn_keys(stack.trie.map) + "}",
			switch (stack.parent) {
				Some(parent): "parent keys: {" + prn_keys(parent.trie.map) + "}";
				None(): "no parent";
			}
		], ", ")
	)
}


ruParseExpr1(env : RuParseEnv, pos : int, stack : RuParseStack1) -> Maybe<[RuExpNode]> {
	if (pos == length(env.nodes)) None() else {
		println("pos: " + i2s(pos) + /*", acc: " + ruExpRPN2s(stack.expr) +*/ ", nodes[pos]: " + showNode(env.nodes[pos]) + ",");
		printStack1(stack);
		do_step = \st, n -> {
			switch (ruParseExpr1(env, pos + 1, RuParseStack1(st with trie = n.trie))) {
				Some(expr): Some(expr);
				None(): {
					switch (n.data) {
						Some(callback): {
							switch (st.parent) {
								Some(parent): {
									poped = RuParseStack1(parent with 
										expr = concat3(parent.expr, st.expr, callback(env.nodes[pos], pos - st.start))
									);
									println("poped:");
									printStack1(poped);
									ruParseExpr1(env, pos + 1, poped);
								}
								None(): {
									if (pos + 1 == length(env.nodes)) {
										Some(concat(st.expr, callback(env.nodes[pos], pos - st.start)))
									} else {
										env.conf.onError("pop of an empty stack", []);
										None() 
									}
								}
							}
						}
						None(): None();
					}
				}
			}
		}
		switch (env.nodes[pos]) {
			RuVarRef(v, t):
				switch (lookupTree(stack.trie.map, t)) {
					Some(n): do_step(stack, n);
					None(): None();
				}
				/*switch (lookupTree(stack.trie.map, t)) {
					Some(n): do_step(RuParseStack1(stack with expr = concat(stack.expr, [RuVarRef(v, t)])), n);
					None(): {
						supers = lookupTreeDef(env.types, t, ruNoTypeEnv).supers;
						foldTree(stack.trie.map, None(), \tp, n, ac -> 
							if (ac != None()) ac else {
								switch (lookupTree(supers, tp)) {
									Some(r): 
										do_step(RuParseStack1(stack with expr = concat(stack.expr, [RuRuleRef(r.name, 1), RuVarRef(v, t)])), n);
									None(): ac;
								}
							}
						);
					}
				}*/
			RuConstRef(c): {
				switch (lookupTree(stack.trie.map, c)) {
					Some(n): do_step(stack, n);
					None(): {
						foldTree(stack.trie.map, None(), \t, n, ac ->
							if (ac != None()) ac else {
								
								ruParseExpr1(env, pos, 
									RuParseStack1(
										Some(RuParseStack1(stack with trie = n.trie)), 
										pos, 
										lookupTreeDef(env.types, t, ruNoTypeEnv).trie, 
										[]
									), 
								)
							}
						)
					}
				}
			}
		}
	}
}














RuParseStack2(
	parent : Maybe<RuParseStack2>,
	start : int,
	trie : RuTrie1<string, (RuTermNode, int) -> [RuExpNode]>,
	expr : [RuExpNode]
);

printStack2(stack : RuParseStack2) {
	prn_keys = \mp -> 
	strGlue(
		map(getTreeKeys(mp), 
			\key -> 
				if (isSome(lookupTreeDef(mp, key, ruTrie1Empty).data)) "*" + key else key
		),
		", "
	);
	println(
		strGlue([
			"STACK start: " + i2s(stack.start),
			//"expr: " + ruExpRPN2s(stack.expr),
			"trie keys: {" + prn_keys(stack.trie.map) + "}",
			switch (stack.parent) {
				Some(parent): "parent keys: {" + prn_keys(parent.trie.map) + "}";
				None(): "no parent";
			}
		], ", ")
	)
}


ruUnrollStack(env : RuParseEnv, pos : int, stack : RuParseStack2) -> RuParseStack2 {
	switch (stack.trie.data) {
		Some(callback): {
			switch (stack.parent) {
				Some(parent): {
					ruUnrollStack(env, pos, RuParseStack2(parent with
						expr = concat3(parent.expr, stack.expr, callback(env.nodes[pos], pos - stack.start))
					));
				}
				None(): stack;
			}
		}
		None(): stack;
	}
}

ruParseExpr2(env : RuParseEnv, pos : int, stack : RuParseStack2) -> Maybe<[RuExpNode]> {
	if (pos == length(env.nodes)) {
		//None() 
		Some(stack.expr)
	} else {
		println("exr[" + i2s(pos) + "]= " + showNode(env.nodes[pos]) /*", acc: " + ruExpRPN2s(stack.expr) +*/);
		printStack2(stack);

		do_step = \st, n -> {
			switch (ruParseExpr2(env, pos + 1, RuParseStack2(st with trie = n))) {
				Some(expr): Some(expr);
				None(): {
					switch (n.data) {
						Some(callback): {
							switch (st.parent) {
								Some(parent): {
									poped = ruUnrollStack(env, pos, parent);
									println("poped:");
									printStack2(poped);
									ruParseExpr2(env, pos + 1, poped);
								}
								None(): {
									if (pos + 1 == length(env.nodes)) {
										Some(concat(st.expr, callback(env.nodes[pos], pos - st.start)))
									} else {
										env.conf.onError("pop of an empty stack", []);
										None() 
									}
								}
							}
						}
						None(): None();
					}
				}
			}
		}
		switch (env.nodes[pos]) {
			RuVarRef(v, t):
				switch (lookupTree(stack.trie.map, t)) {
					Some(n): {
						ret = do_step(stack, n);
						if (isSome(ret)) ret else {
							supers = lookupTreeDef(env.types, t, ruNoTypeEnv).supers;
							foldTree(stack.trie.map, None(), \tp, m, ac -> 
								if (ac != None()) ac else {
									switch (lookupTree(supers, tp)) {
										Some(r): 
											do_step(RuParseStack2(stack with expr = concat(stack.expr, [RuRuleRef(r.name, 1), RuVarRef(v, t)])), m);
										None(): ac;
									}
								}
							);
						}
					}
					None(): {
						supers = lookupTreeDef(env.types, t, ruNoTypeEnv).supers;
						foldTree(stack.trie.map, None(), \tp, n, ac -> 
							if (ac != None()) ac else {
								switch (lookupTree(supers, tp)) {
									Some(r): 
										do_step(RuParseStack2(stack with expr = concat(stack.expr, [RuRuleRef(r.name, 1), RuVarRef(v, t)])), n);
									None(): ac;
								}
							}
						);
					}
				}
			RuConstRef(c): {
				switch (lookupTree(stack.trie.map, c)) {
					Some(n): do_step(stack, n);
					None(): {
						foldTree(stack.trie.map, None(), \t, n, ac ->
							if (ac != None()) ac else {
								switch (lookupTree(env.types, t)) {
									Some(tenv):
										ruParseExpr2(env, pos, 
											RuParseStack2(
												Some(RuParseStack2(stack with trie = n)), 
												pos, tenv.trie1, []
											)
										);
									None(): ac;
								}
							}
						)
					}
				}
			}
		}
	}
}


