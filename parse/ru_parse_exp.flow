import parse/ru_table;

export {
	ruParseExp(term : RuTerm, types : Tree<string, RuTypeEnv>, conf : RuConf) -> Maybe<RuExp> {
		if (length(term.expr) == 0) {
			conf.onError("empty expression met", []);
			None()
		} else {
			switch (lookupTree(types, term.type)) {
				Some(tenv): {
					ret = ruParseExpr(term.expr, 0, term.type, tenv.table, types, conf);
					if (ret.pos < length(term.expr)) {
						conf.onError("unparsed rest: " + ruTerm2s(term) + " ret.pos: " + i2s(ret.pos), []);
						conf.onError("ret.expr: [" + ruExpRPN2s(ret.expr) + "]", []);
						None();
					} else {
						if (ret.expr == []) {
							conf.onError("expr was not successfully parsed: " + ruTerm2s(term), []);
							None();
						} else {
							Some(RuExp(ret.expr));
						}
					}
				}
				None(): {
					conf.onError("unknown type: " + term.type, []);
					None();
				}
			}
		}
	}
}

RuParseExpRet(
	pos : int,
	expr : [RuExpNode]
);

ruParseExpr(nodes : [RuTermNode], pos : int, type : string, tab : RuTab, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuParseExpRet {
	if (pos == length(nodes)) {
		RuParseExpRet(pos + 1, []) 
	} else {
		switch (nodes[pos]) {
			RuVarRef(v, t): {
				switch (lookupTree(tab.vars, t)) {
					Some(n): RuParseExpRet(pos + 1, [RuVarRef(v, t)]);
					None(): {
						switch (lookupTree(lookupTreeDef(types, t, ruNoTypeEnv).supers, type)) {
							Some(r): RuParseExpRet(pos + 1, [RuRuleRef(r.name, 1), RuVarRef(v, t)]);
							None():  RuParseExpRet(pos + 1, []);
						}
					}
				}
			}
			RuConstRef(c): {
				switch (lookupTree(tab.consts, c)) {
					Some(n): {
						if (n.data == "") {
							ruParseExpr(nodes, pos + 1, type, n.table, types, conf);
						} else {
							x = ruParseExpr(nodes, pos + 1, type, n.table, types, conf);
							if (x.expr != []) x else {
								RuParseExpRet(x.pos, concat([RuRuleRef(n.data, x.pos - pos)], x.expr));
							}
						}
					}
					None(): {
						foldTree(tab.vars, RuParseExpRet(pos + 1, []), \t, n, acc ->
							if (acc.expr != []) acc else {
								ruParseExpr(nodes, pos + 1, t, lookupTreeDef(types, t, ruNoTypeEnv).table, types, conf)
							}
						)
					}
				}
			}
		}
	}
}

