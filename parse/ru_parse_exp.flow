import ru_math;
import parse/ru_parse_src;


export {
	RuTab(
		consts : Tree<string, RuTabNode>,
		vars : Tree<string, RuTabNode>,
	);

	RuTabNode(
		type : string,
		data : string,
		table : RuTab
	);

	ruAdd2RuTab(r : RuRule, t : RuTab, conf : RuConf) -> RuTab {
		ruAdd2RuTable(r, 0, t, conf)
	}
	
	ruParseExp(t : RuTerm, tab : RuTab, types : Tree<string, RuType>) -> RuExp {
		RuExp(ruParseExp(t, 0, tab, types))
	}
}

ruTabEmpty = RuTab(makeTree(), makeTree());

ruAdd2RuTable(rule : RuRule, i : int, tab : RuTab, conf : RuConf) -> RuTab {
	add = \t, c, tp -> {
		if (i + 1 == length(rule.term.expr)) {
			switch (lookupTree(t, c)) {
				Some(node): {
					if (node.data != "") {
						conf.onError("equivalen terms in rule table", []);
					}
					setTree(t, c, RuTabNode(tp, rule.name, node.table));
				}
				None():
					makeTree1(c, RuTabNode(tp, rule.name, ruTabEmpty));
			}
		} else {
			switch (lookupTree(t, c)) {
				Some(node):
					setTree(t, c, RuTabNode(tp, node.data, ruAdd2RuTable(rule, i + 1, node.table, conf)));
				None():
					makeTree1(c, RuTabNode(tp, "", ruAdd2RuTable(rule, i + 1, ruTabEmpty, conf)));
			}
		}
	}
	switch (rule.term.expr[i]) {
		RuVarRef(v, t): RuTab(tab.consts, add(tab.vars, v, t));
		RuConstRef(c):   RuTab(add(tab.consts, c, ""), tab.vars);
	}
}

ruParseExpr(t : RuTerm, i : int, tab : RuTab, types : Tree<string, RuType>) -> [RuExpNode] {
	switch (rule.term.expr[i]) {
		RuVarRef(v, t): [RuVarRef(v, t)];
		RuConstRef(c):   RuTab(add(tab.consts, c, ""), tab.vars);
	}
}

