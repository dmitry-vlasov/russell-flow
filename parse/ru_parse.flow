import fs/filesystem;
import sys/concurrent;
import lingo/compiler/syntaxtree_util;
import ru_math;
import parse/ru_load;
import parse/ru_parse_file;
import parse/ru_parse_src;
import parse/ru_parse_ast;

export {
	ruParse(loaded : [RuLoadSource], conf : RuConf) -> [RuParseSource];
}

ruParse(loaded : [RuLoadSource], conf : RuConf) -> [RuParseSource] {
	filtermap(
		concurrent(true, map(loaded, \l -> \-> ruParseSource(l, conf))),
		idfn
	)
}

ruParseSource(loaded : RuLoadSource, conf : RuConf) -> Maybe<RuParseSource> {
	pr1 = parse_source(loaded.src);
	st = pr1.first;
	err = pr1.second;
	if (st.end != strlen(loaded.src)) {
		conf.onError(
			"Syntax error: expected one of " + strGlue(map(err.expected, \e -> "'" + e + "'"), ", ") + 
			(if (err.met != "") " while met: '" + err.met + "'" else ""), 
			[RuPlace(loaded.info.file, err.pos)]
		);
		None()
	} else {
		Some(ruMakeSrc(loaded, st, conf));
	}
}

ruMakeSrc(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseSource {
	imports = ref [];
	decls = ref [];
	iter(get_source_decl_s(st),
		\decl -> {
			if (decl.rule == st_import) {
				refArrayPush(imports, ruMakeImport(loaded, decl, conf));
			} else if (decl.rule == st_const) {
				refArrayPush(decls, ruMakeConst(loaded, decl, conf));
			} else if (decl.rule == st_type) {
				refArrayPush(decls, ruMakeType(loaded, decl, conf));
			} else if (decl.rule == st_rule) {
				refArrayPush(decls, ruMakeRule(loaded, decl, conf));
			} else if (decl.rule == st_axiom) {
				refArrayPush(decls, ruMakeAxiom(loaded, decl, conf));
			}
		}
	);
	RuParseSource(^imports, ^decls, loaded.info);
}

ruMakeImport(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseImport { 
	path = grabSTText(get_source_symb(st), loaded.src);
	RuParseImport(path);
}

ruMakeConst(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseConst {
	symb = grabSTText(get_source_symb(get_source_symbol(st)), loaded.src);
	ascii_st = get_source_ascii_s(st);
	ascii = if (ascii_st != []) grabSTText(get_source_symb(ascii_st[0]), loaded.src) else "";
	latex_st = get_source_latex_s(st);
	latex = if (latex_st != []) grabSTText(get_source_symb(latex_st[0]), loaded.src) else "";
	RuParseConst(symb, ascii, latex);
}

ruMakeType(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseType {
	name = grabSTText(get_source_id(st), loaded.src);
	//supers_st = get_source_supers(st);
	supers = []; //if (supers_st != failSyntaxTree) ruMakeSupers(loaded, supers_st, conf) else [];
	RuParseType(name, supers)
}

ruMakeSupers(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> [string] {
	id = \t -> grabSTText(get_source_id(t), loaded.src);
	concat([id(st)], map(get_source_super_s(st), id))
}

ruMakeRule(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseRule {
	name = grabSTText(get_source_id(st), loaded.src);
	vars_st = get_source_vars_s(st);
	vars = if (vars_st != []) ruMakeVars(loaded, vars_st[0], conf) else [];
	term = ruMakeExp(loaded, get_source_expr(st), conf);
	RuParseRule(name, vars, term);
}

ruMakeVars(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> [RuParseVar] {
	if (get_source_vars0_s(st) != []) {
		vars0 = get_source_vars0_s(st)[0];
		var = get_source_var(vars0);
		make_var = \t -> ruMakeVar(loaded, t, conf);
		vars1 = get_source_vars1_s(vars0);
		concat([make_var(var)], map(vars1, \v -> make_var(get_source_var(v))))
	} else {
		[]
	}
}

ruMakeVar(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseVar {
	name = grabSTText(get_source_id(st), loaded.src);
	type = grabSTText(get_source_id(get_source_type_id(st)), loaded.src);
	RuParseVar(name, type)
}

ruMakeExp(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseExp {
	type = grabSTText(get_source_id(get_source_type_id(st)), loaded.src);
	symbs = map(get_source_symbws_s(get_source_symbs(st)), \s -> grabSTText(s, loaded.src));
	RuParseExp(type, symbs)
}

ruMakeAxiom(loaded : RuLoadSource, st : SyntaxTree, conf : RuConf) -> RuParseRule {
	name = grabSTText(get_source_id(st), loaded.src);
	vars_st = get_source_vars_s(st);
	vars = if (vars_st != []) ruMakeVars(loaded, vars_st[0], conf) else [];
	prop = ruMakeExp(loaded, get_source_expr(st), conf);
	RuParseRule(name, vars, prop);
}
