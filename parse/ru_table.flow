import ru_src;
import ru_conf;

export {
	RuTrie(
		data : Maybe<??>,
		map : Tree<?, RuTrie<?, ??>>,
	);
	ruTrieEmpty = RuTrie(None(), makeTree());

	ruAdd2Trie(key : [?], data : ??, trie : RuTrie<?, ??>) -> RuTrie<?, ??> {
		if (length(key) == 0) trie else doRuAdd2Trie(0, key, data, trie)
	}
	
	ruTrie2s(t : RuTrie<?, ??>, show_key : (?) -> string, show_val : (??) -> string) -> string {
		foldTree(doRuTrie2tree(t, [], makeTree(), show_key, show_val), "",
			\path, val, acc ->
				acc + strGlue(path, " ") + " --> " + val + "\n"
		)
	}
	
	ruAddTerm2RuTrie(term : RuTerm, data : ?, trie : RuTrie<string, ?>) -> RuTrie<string, ?> {
		term_key = \x -> switch (x) {
			RuConstRef(c):  c;
			RuVarRef(v, t): t;
		}
		ruAdd2Trie(map(term.expr, term_key), data, trie)
	}

	RuTypeEnv(
		type : RuType,
		trie   : RuTrie<string, (RuTermNode, int) -> [RuExpNode]>,
		supers : Tree<string, RuRule>,
		infers : Tree<string, RuRule>
	);

	ruNoTypeEnv = RuTypeEnv(ruNoType, ruTrieEmpty, makeTree(), makeTree());
}

doRuAdd2Trie(i : int, key : [?], data : ??, trie : RuTrie<?, ??>) -> RuTrie<?, ??> {
	n = lookupTreeDef(trie.map, key[i], ruTrieEmpty);
	if (i + 1 == length(key)) {
		RuTrie(n.data, setTree(trie.map, key[i], RuTrie(n with data = Some(data))));
	} else {
		RuTrie(n.data, setTree(trie.map, key[i], doRuAdd2Trie(i + 1, key, data, n)));
	}
}

ruAdd2RuTrie(term : RuTerm, data : ?, i : int, trie : RuTrie<string, ?>) -> RuTrie<string, ?> {
	add = \t, x -> {
		n = lookupTreeDef(t, x, ruTrieEmpty);
		if (i + 1 == length(term.expr)) {
			RuTrie(n.data, setTree(t, x, RuTrie(n with data = Some(data))));
		} else {
			RuTrie(n.data, setTree(t, x, ruAdd2RuTrie(term, data, i + 1, n)));
		}
	}
	switch (term.expr[i]) {
		RuVarRef(v, t): add(trie.map, t);
		RuConstRef(c):  add(trie.map, c);
	}
}

doRuTrie2tree(trie : RuTrie<?, ??>, path : [string], acc : Tree<[string], string>, show_key : (?) -> string, show_val : (??) -> string) -> Tree<[string], string> {
	foldTree(trie.map, acc, 
		\k, v, ac -> {
			path1 = concat(path, [show_key(k)]);
			ac1 = doRuTrie2tree(v, path1, ac, show_key, show_val);
			switch (v.data) {
				None(): ac1;
				Some(d): setTree(ac1, path1, show_val(d));
			}
		}
	)
}
