import ru_src;
import ru_conf;

export {
	RuTab(
		consts : Tree<string, RuTabNode>,
		vars : Tree<string, RuTabNode>,
	);

	RuTabNode(
		data : string,
		table : RuTab
	);

	ruAddTerm2RuTab(x : RuTerm, d : string, t : RuTab, conf : RuConf) -> RuTab {
		if (length(x.expr) == 0) t else {
			ruAdd2RuTable(x, d, 0, t, conf)
		}
	}
	
	ruTabEmpty = RuTab(makeTree(), makeTree());
	
	RuTypeEnv(
		type : RuType,
		table : RuTab,
		supers : Tree<string, RuRule>
	);

	ruNoTypeEnv = RuTypeEnv(ruNoType, ruTabEmpty, makeTree());
	
	ruTab2s(t : RuTab) -> string {
		foldTree(doRuTab2tree(t, [], makeTree()), "",
			\data, path, acc ->
				acc + "\n" + strGlue(map(path, \n -> n.name), " ") + " --> " + data
		)
	}
}

doRuTab2tree(tab : RuTab, path : [RuTermNode], acc : Tree<string, [RuTermNode]>) -> Tree<string, [RuTermNode]> {
	acc1 = foldTree(tab.consts, acc, 
		\c, n, ac -> {
			path1 = concat(path, [RuConstRef(c)]);
			ac1 = doRuTab2tree(n.table, path1, ac);
			if (n.data == "") ac1 else {
				setTree(ac1, n.data, path1);
			}
		}
	);
	foldTree(tab.vars, acc1, 
		\t, n, ac -> {
			path1 = concat(path, [RuVarRef("x_" + t, t)]);
			ac1 = doRuTab2tree(n.table, path1, ac);
			if (n.data == "") ac1 else {
				setTree(ac1, n.data, path1);
			}
		}
	)
}

ruAdd2RuTable(term : RuTerm, data : string, i : int, tab : RuTab, conf : RuConf) -> RuTab {
	add = \t, x -> {
		if (i + 1 == length(term.expr)) {
			switch (lookupTree(t, x)) {
				Some(node): {
					if (node.data != "") {
						conf.onError("equivalen terms in table", []);
					}
					setTree(t, x, RuTabNode(data, node.table));
				}
				None():
					setTree(t, x, RuTabNode(data, ruTabEmpty));
			}
		} else {
			switch (lookupTree(t, x)) {
				Some(node):
					setTree(t, x, RuTabNode(node.data, ruAdd2RuTable(term, data, i + 1, node.table, conf)));
				None():
					setTree(t, x, RuTabNode("", ruAdd2RuTable(term, data, i + 1, ruTabEmpty, conf)));
			}
		}
	}
	switch (term.expr[i]) {
		RuVarRef(v, t): RuTab(tab.consts, add(tab.vars, t));
		RuConstRef(c):  RuTab(add(tab.consts, c), tab.vars);
	}
}

