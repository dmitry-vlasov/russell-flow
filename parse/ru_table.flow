import ru_src;
import ru_conf;
import parse/ru_parse_src;

export {
	RuTab(
		consts : Tree<string, RuTabNode>,
		vars : Tree<string, RuTabNode>,
	);

	RuTabNode(
		data : string,
		table : RuTab
	);

	ruAdd2RuTab(r : RuRule, t : RuTab, conf : RuConf) -> RuTab {
		if (length(r.term.expr) == 0) t else {
			ruAdd2RuTable(r, 0, t, conf)
		}
	}

	ruTabEmpty = RuTab(makeTree(), makeTree());
}

ruAdd2RuTable(rule : RuRule, i : int, tab : RuTab, conf : RuConf) -> RuTab {
	add = \t, x -> {
		if (i + 1 == length(rule.term.expr)) {
			switch (lookupTree(t, x)) {
				Some(node): {
					if (node.data != "") {
						conf.onError("equivalen terms in rule table", []);
					}
					setTree(t, x, RuTabNode(rule.name, node.table));
				}
				None():
					makeTree1(x, RuTabNode(rule.name, ruTabEmpty));
			}
		} else {
			switch (lookupTree(t, x)) {
				Some(node):
					setTree(t, x, RuTabNode(node.data, ruAdd2RuTable(rule, i + 1, node.table, conf)));
				None():
					makeTree1(x, RuTabNode("", ruAdd2RuTable(rule, i + 1, ruTabEmpty, conf)));
			}
		}
	}
	switch (rule.term.expr[i]) {
		RuVarRef(v, t): RuTab(tab.consts, add(tab.vars, t));
		RuConstRef(c):  RuTab(add(tab.consts, c), tab.vars);
	}
}

