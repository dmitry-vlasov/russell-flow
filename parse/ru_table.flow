import ru_src;
import ru_conf;
import parse/ru_parse_src;

export {
	RuTab(
		consts : Tree<string, RuTabNode>,
		vars : Tree<string, RuTabNode>,
	);

	RuTabNode(
		type : string,
		data : string,
		table : RuTab
	);

	ruAdd2RuTab(r : RuRule, t : RuTab, conf : RuConf) -> RuTab {
		if (length(r.term.expr) == 0) t else {
			ruAdd2RuTable(r, 0, t, conf)
		}
	}

	ruTabEmpty = RuTab(makeTree(), makeTree());
}

ruAdd2RuTable(rule : RuRule, i : int, tab : RuTab, conf : RuConf) -> RuTab {
	add = \t, c, tp -> {
		if (i + 1 == length(rule.term.expr)) {
			switch (lookupTree(t, c)) {
				Some(node): {
					if (node.data != "") {
						conf.onError("equivalen terms in rule table", []);
					}
					setTree(t, c, RuTabNode(tp, rule.name, node.table));
				}
				None():
					makeTree1(c, RuTabNode(tp, rule.name, ruTabEmpty));
			}
		} else {
			switch (lookupTree(t, c)) {
				Some(node):
					setTree(t, c, RuTabNode(tp, node.data, ruAdd2RuTable(rule, i + 1, node.table, conf)));
				None():
					makeTree1(c, RuTabNode(tp, "", ruAdd2RuTable(rule, i + 1, ruTabEmpty, conf)));
			}
		}
	}
	switch (rule.term.expr[i]) {
		RuVarRef(v, t): RuTab(tab.consts, add(tab.vars, v, t));
		RuConstRef(c):   RuTab(add(tab.consts, c, ""), tab.vars);
	}
}

