import ru_src;
import ru_conf;

export {
	RuTab(
		consts : Tree<string, RuTabNode<?>>,
		vars : Tree<string, RuTabNode<?>>,
	);

	RuTabNode(
		data : ?,
		table : RuTab<?>
	);
	ruTabEmpty = RuTab(makeTree(), makeTree());
	
	RuTrie(
		map : Tree<string, RuTrieNode<?>>,
	);

	RuTrieNode(
		data : Maybe<?>,
		trie : RuTrie<?>
	);
	ruTrieEmpty = RuTrie(makeTree());
	
	ruAddTerm2RuTab(x : RuTerm, d : string, t : RuTab<string>, conf : RuConf) -> RuTab<string> {
		if (length(x.expr) == 0) t else {
			ruAdd2RuTable(x, d, 0, t, conf)
		}
	}
	
	ruAddTerm2RuTrie(x : RuTerm, data : ?, t : RuTrie<?>) -> RuTrie<?> {
		if (length(x.expr) == 0) t else {
			ruAdd2RuTrie(x, data, 0, t)
		}
	}

	
	RuTypeEnv(
		type : RuType,
		table : RuTab<string>,
		trie : RuTrie<(RuTermNode, int) -> [RuExpNode]>,
		supers : Tree<string, RuRule>,
		infers : Tree<string, RuRule>
	);

	ruNoTypeEnv = RuTypeEnv(ruNoType, ruTabEmpty, ruTrieEmpty, makeTree(), makeTree());
	
	ruTab2s(t : RuTab) -> string {
		foldTree(doRuTab2tree(t, [], makeTree()), "",
			\data, path, acc ->
				acc + "\n" + strGlue(map(path, \n -> n.name), " ") + " --> " + data
		)
	}
}

doRuTab2tree(tab : RuTab, path : [RuTermNode], acc : Tree<string, [RuTermNode]>) -> Tree<string, [RuTermNode]> {
	acc1 = foldTree(tab.consts, acc, 
		\c, n, ac -> {
			path1 = concat(path, [RuConstRef(c)]);
			ac1 = doRuTab2tree(n.table, path1, ac);
			if (n.data == "") ac1 else {
				setTree(ac1, n.data, path1);
			}
		}
	);
	foldTree(tab.vars, acc1, 
		\t, n, ac -> {
			path1 = concat(path, [RuVarRef("x_" + t, t)]);
			ac1 = doRuTab2tree(n.table, path1, ac);
			if (n.data == "") ac1 else {
				setTree(ac1, n.data, path1);
			}
		}
	)
}

ruAdd2RuTable(term : RuTerm, data : string, i : int, tab : RuTab<string>, conf : RuConf) -> RuTab<string> {
	add = \t, x -> {
		if (i + 1 == length(term.expr)) {
			switch (lookupTree(t, x)) {
				Some(node): {
					if (node.data != "") {
						conf.onError("equivalen terms in table", []);
					}
					setTree(t, x, RuTabNode(data, node.table));
				}
				None():
					setTree(t, x, RuTabNode(data, ruTabEmpty));
			}
		} else {
			switch (lookupTree(t, x)) {
				Some(node):
					setTree(t, x, RuTabNode(node.data, ruAdd2RuTable(term, data, i + 1, node.table, conf)));
				None():
					setTree(t, x, RuTabNode("", ruAdd2RuTable(term, data, i + 1, ruTabEmpty, conf)));
			}
		}
	}
	switch (term.expr[i]) {
		RuVarRef(v, t): RuTab(tab.consts, add(tab.vars, t));
		RuConstRef(c):  RuTab(add(tab.consts, c), tab.vars);
	}
}

ruAdd2RuTrie(term : RuTerm, data : ?, i : int, trie : RuTrie<?>) -> RuTrie<?> {
	add = \t, x -> {
		if (i + 1 == length(term.expr)) {
			n = lookupTreeDef(t, x, RuTrieNode(None(), ruTrieEmpty));
			setTree(t, x, RuTrieNode(Some(data), n.trie));
		} else {
			n = lookupTreeDef(t, x, RuTrieNode(None(), ruTrieEmpty));
			setTree(t, x, RuTrieNode(n.data, ruAdd2RuTrie(term, data, i + 1, n.trie)));
		}
	}
	switch (term.expr[i]) {
		RuVarRef(v, t): RuTrie(add(trie.map, t));
		RuConstRef(c):  RuTrie(add(trie.map, c));
	}
}

ruAdd2RuTrie1(term : RuTerm, data : ?, i : int, trie : RuTrie<?>) -> RuTrie<?> {
	add = \t, x -> {
		if (i + 1 == length(term.expr)) {
			n = lookupTreeDef(t, x, RuTrieNode(None(), ruTrieEmpty));
			setTree(t, x, RuTrieNode(Some(data), n.trie));
		} else {
			n = lookupTreeDef(t, x, RuTrieNode(None(), ruTrieEmpty));
			setTree(t, x, RuTrieNode(n.data, ruAdd2RuTrie1(term, data, i + 1, n.trie)));
		}
	}
	switch (term.expr[i]) {
		RuVarRef(v, t): RuTrie(add(trie.map, t));
		RuConstRef(c):  RuTrie(add(trie.map, c));
	}
}


