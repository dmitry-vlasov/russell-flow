import lingo/compiler/syntaxtree_types;
import parse/mm_parse_ast_mnemonics;

export {
	get_source_block(st : SyntaxTree) -> SyntaxTree;
	get_source_element_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_const(st : SyntaxTree) -> SyntaxTree;
	get_source_var(st : SyntaxTree) -> SyntaxTree;
	get_source_disj(st : SyntaxTree) -> SyntaxTree;
	get_source_floating(st : SyntaxTree) -> SyntaxTree;
	get_source_essential(st : SyntaxTree) -> SyntaxTree;
	get_source_axiomatic(st : SyntaxTree) -> SyntaxTree;
	get_source_provable(st : SyntaxTree) -> SyntaxTree;
	get_source_proof(st : SyntaxTree) -> SyntaxTree;
	get_source_expr(st : SyntaxTree) -> SyntaxTree;
	get_source_string(st : SyntaxTree) -> SyntaxTree;
	get_source_symb_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_label(st : SyntaxTree) -> SyntaxTree;
	get_source_label_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_comment(st : SyntaxTree) -> SyntaxTree;
	get_source_include(st : SyntaxTree) -> SyntaxTree;
	get_source_s(st : SyntaxTree) -> SyntaxTree;
	get_source_ws(st : SyntaxTree) -> SyntaxTree;
	get_source_ws__s(st : SyntaxTree) -> [SyntaxTree];
	get_source_char_(st : SyntaxTree) -> SyntaxTree;
	get_source_comment__choice21(st : SyntaxTree) -> SyntaxTree;
	get_source_comment__choice21_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_string__auto22(st : SyntaxTree) -> SyntaxTree;
	get_source_string__auto22_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_symb__auto23(st : SyntaxTree) -> SyntaxTree;
	get_source_symb__auto23_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_label__auto24(st : SyntaxTree) -> SyntaxTree;
	get_source_label__auto24_s(st : SyntaxTree) -> [SyntaxTree];
	get_source_include__auto25(st : SyntaxTree) -> SyntaxTree;
	get_source_include__auto25_s(st : SyntaxTree) -> [SyntaxTree];

}

get_source_block(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_source) {
		st.children[1][0];
	} else if (st.choice == 4 && st.rule == st_element) {
		st.children[1][0];
	} else failSyntaxTree
}
get_source_const(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 6 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_var(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 7 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_disj(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_floating(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 8 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_essential(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_axiomatic(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 5 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_provable(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_proof(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_provable) {
		st.children[4][0];
	} else failSyntaxTree
}
get_source_expr(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_essential) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_axiomatic) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_provable) {
		st.children[2][0];
	} else failSyntaxTree
}
get_source_string(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_const) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_var) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_disj) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_floating) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_floating) {
		st.children[3][0];
	} else failSyntaxTree
}
get_source_label(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_floating) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_essential) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_axiomatic) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_provable) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_comment(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_element) {
		st.children[0][0];
	} else if (st.choice == 4 && st.rule == st_ws_) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_include(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 9 && st.rule == st_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_source_s(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_const) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_var) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_disj) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_floating) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_essential) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_axiomatic) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_provable) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_provable) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_string) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_symb) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_label) {
		st.children[1][0];
	} else failSyntaxTree
}
get_source_ws(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_source) {
		st.children[0][0];
	} else if (st.choice == 4 && st.rule == st_element) {
		st.children[0][0];
	} else if (st.choice == 4 && st.rule == st_element) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_const) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_var) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_disj) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_floating) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_essential) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_axiomatic) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_comment) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_include) {
		st.children[1][0];
	} else failSyntaxTree
}
get_source_char_(st : SyntaxTree) -> SyntaxTree {
	if (get_source_comment__choice21(st).choice == 0) {
		get_source_comment__choice21(st).children[0][0];
	} else if (get_source_comment__choice21(st).choice == 1) {
		get_source_comment__choice21(st).children[0][0];
	} else if (get_source_string__auto22(st).choice == 0) {
		get_source_string__auto22(st).children[0][0];
	} else if (get_source_symb__auto23(st).choice == 0) {
		get_source_symb__auto23(st).children[0][0];
	} else if (get_source_label__auto24(st).choice == 0) {
		get_source_label__auto24(st).children[0][0];
	} else if (get_source_include__auto25(st).choice == 0) {
		get_source_include__auto25(st).children[0][0];
	} else failSyntaxTree
}
get_source_comment__choice21(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_source_string__auto22(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_source_symb__auto23(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_source_label__auto24(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_source_include__auto25(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}

get_source_element_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_block) {
		st.children[0];
	} else []
}
get_source_symb_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_expr) {
		st.children[0];
	} else []
}
get_source_label_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_floating) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_essential) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_axiomatic) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_provable) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_proof) {
		st.children[0];
	} else []
}
get_source_ws__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_s) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_ws) {
		st.children[0];
	} else []
}
get_source_comment__choice21_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_comment) {
		st.children[0];
	} else []
}
get_source_string__auto22_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_string) {
		st.children[0];
	} else []
}
get_source_symb__auto23_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_symb) {
		st.children[0];
	} else []
}
get_source_label__auto24_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_label) {
		st.children[0];
	} else []
}
get_source_include__auto25_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_include) {
		st.children[0];
	} else []
}

