import lingo/compiler/syntaxtree_types;
import parse/mm_parse_ast_mnemonics;

export {
	get_mm_source_mm_element_s(st : SyntaxTree) -> [SyntaxTree];
	get_mm_source_mm_block(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_const(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_vars(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_disj(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_floating(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_essential(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_axiomatic(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_provable(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_proof(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_word(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_word_s(st : SyntaxTree) -> [SyntaxTree];
	get_mm_source_mm_comment(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_include(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_path(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_comment_text(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_s(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_ws(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_ws__s(st : SyntaxTree) -> [SyntaxTree];
	get_mm_source_mm_char(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_word__auto20(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_word__auto20_s(st : SyntaxTree) -> [SyntaxTree];
	get_mm_source_mm_path__auto21(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_path__auto21_s(st : SyntaxTree) -> [SyntaxTree];
	get_mm_source_mm_comment_text__auto22(st : SyntaxTree) -> SyntaxTree;
	get_mm_source_mm_comment_text__auto22_s(st : SyntaxTree) -> [SyntaxTree];

}

get_mm_source_mm_block(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 9 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_const(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 2 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_vars(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 3 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_disj(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 4 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_floating(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 5 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_essential(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 6 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_axiomatic(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 7 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_provable(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 8 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_proof(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_provable) {
		st.children[4][0];
	} else failSyntaxTree
}
get_mm_source_mm_word(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_mm_essential) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_axiomatic) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_provable) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_comment(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_element) {
		st.children[0][0];
	} else if (st.choice == 4 && st.rule == st_mm_ws_) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_include(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 1 && st.rule == st_mm_element) {
		st.children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_path(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_include) {
		st.children[1][0];
	} else failSyntaxTree
}
get_mm_source_mm_comment_text(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_comment) {
		st.children[1][0];
	} else failSyntaxTree
}
get_mm_source_mm_s(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_const) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_vars) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_disj) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_mm_essential) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_mm_axiomatic) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_mm_provable) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_mm_provable) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_mm_word) {
		st.children[1][0];
	} else failSyntaxTree
}
get_mm_source_mm_ws(st : SyntaxTree) -> SyntaxTree {
	if (st.choice == 0 && st.rule == st_mm_source) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_block) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_block) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_mm_const) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_mm_vars) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_mm_disj) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[4][0];
	} else if (st.choice == 0 && st.rule == st_mm_essential) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_mm_axiomatic) {
		st.children[3][0];
	} else if (st.choice == 0 && st.rule == st_mm_proof) {
		st.children[1][0];
	} else if (st.choice == 0 && st.rule == st_mm_comment) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_comment) {
		st.children[2][0];
	} else if (st.choice == 0 && st.rule == st_mm_include) {
		st.children[0][0];
	} else if (st.choice == 0 && st.rule == st_mm_include) {
		st.children[2][0];
	} else failSyntaxTree
}
get_mm_source_mm_char(st : SyntaxTree) -> SyntaxTree {
	if (get_mm_source_mm_word__auto20(st).choice == 0) {
		get_mm_source_mm_word__auto20(st).children[0][0];
	} else failSyntaxTree
}
get_mm_source_mm_word__auto20(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_mm_source_mm_path__auto21(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}
get_mm_source_mm_comment_text__auto22(st : SyntaxTree) -> SyntaxTree {
	failSyntaxTree
}

get_mm_source_mm_element_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_mm_source) {
		st.children[1];
	} else if (st.choice == 0 && st.rule == st_mm_block) {
		st.children[1];
	} else []
}
get_mm_source_mm_word_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_mm_const) {
		st.children[1];
	} else if (st.choice == 0 && st.rule == st_mm_vars) {
		st.children[1];
	} else if (st.choice == 0 && st.rule == st_mm_disj) {
		st.children[1];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_mm_floating) {
		st.children[3];
	} else if (st.choice == 0 && st.rule == st_mm_essential) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_mm_essential) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_mm_axiomatic) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_mm_axiomatic) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_mm_provable) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_mm_provable) {
		st.children[2];
	} else if (st.choice == 0 && st.rule == st_mm_proof) {
		st.children[0];
	} else []
}
get_mm_source_mm_ws__s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_mm_s) {
		st.children[0];
	} else if (st.choice == 0 && st.rule == st_mm_ws) {
		st.children[0];
	} else []
}
get_mm_source_mm_word__auto20_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_mm_word) {
		st.children[0];
	} else []
}
get_mm_source_mm_path__auto21_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_mm_path) {
		st.children[0];
	} else []
}
get_mm_source_mm_comment_text__auto22_s(st : SyntaxTree) -> [SyntaxTree] {
	if (st.choice == 0 && st.rule == st_mm_comment_text) {
		st.children[0];
	} else []
}

