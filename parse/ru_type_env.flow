import ru_src;
import ru_conf;
import parse/ru_trie;

export {
	RuTypeEnv(
		type : RuType,
		trie   : RuTrie<string, ([RuExpNode])->[RuExpNode]>,
		cache  : RuTrie<string, ([RuExpNode])->[RuExpNode]>,
		supers : Tree<string, RuRule>,
		infers : Tree<string, RuRule>
	);
	ruNoTypeEnv = RuTypeEnv(ruNoType, ruTrieEmpty, ruTrieEmpty, makeTree(), makeTree());

	ruAddTerm2RuTrie(term : RuTerm, rule : Maybe<([RuExpNode])->[RuExpNode]>, trie : RuTrie<string, ([RuExpNode])->[RuExpNode]>, conf : RuConf) -> RuTrie<string, ([RuExpNode])->[RuExpNode]> {
		term_key = \x -> switch (x) {
			RuConstRef(c):  c;
			RuVarRef(v, t): t;
		}
		ruAdd2Trie(map(term.expr, term_key), rule, trie, 
			\a1, a2 -> {
				conf.onError("rule term: " + ruTerm2s(term.expr) + " is already used", []);
				a1
			}
		)
	}

	ruMergeRuTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv {
		RuTypeEnv(
			e1.type,
			ruMergeRuTrie(e1.trie, e2.trie, \a1, a2 -> a1),
			ruMergeRuTrie(e1.cache, e2.cache, \a1, a2 -> a1),
			mergeTree(e1.supers, e2.supers),
			mergeTree(e1.infers, e2.infers),
		)
	}

ruAddExp2RuTrie(term : RuTerm, expr : RuExp, trie : RuTrie<string, ([RuExpNode])->[RuExpNode]>) -> RuTrie<string, ([RuExpNode])->[RuExpNode]> {
	term_key = \x -> switch (x) {
		RuConstRef(c):  c;
		RuVarRef(v, t): t;
	}
	action = \nodes -> {
		//println("worked: [term: " + ruTerm2s(term.expr) + ", expr.nodes: " + ruExpRPN2s(expr.nodes) + "]");
		args = ruComputeExpArgs(nodes);
		//println("args: [" + strGlue(map(args, \arg -> ruExpRPN2s(arg)), ", ") + "]");
		fold(expr.nodes, Pair([], 0), \acc, node -> 
			switch (node) {
				RuRuleRef(r, len): Pair(concat(acc.first, [node]), acc.second);
				RuVarRef(v, t): Pair(concat(acc.first, args[acc.second]), acc.second + 1);
			}
		).first
	}
	ruAdd2Trie(map(term.expr, term_key), Some(action), trie, \a1, a2 -> a1);
}

ComputeArgsAcc(
	nodes : [RuExpNode],
	pos : int,
	args : [[RuExpNode]]
);

ruComputeExpArgs(nodes : [RuExpNode]) -> [[RuExpNode]] {
	if (length(nodes) == 0) [] else
	reverseA(ruDoComputeExpArgs(ComputeArgsAcc(nodes, length(nodes) - 1, [])).args)
}

ruDoComputeExpArgs(acc : ComputeArgsAcc) -> ComputeArgsAcc {
	if (acc.pos < 0) acc else {
		switch (acc.nodes[acc.pos]) {
			RuRuleRef(r, len): {
				i = acc.pos - (len + 1);
				ruDoComputeExpArgs(ComputeArgsAcc(
					acc.nodes, i, 
					concat(acc.args, [subrange(acc.nodes, i + 1, len + 1)])
				));
			}
			RuVarRef(v, t): 
				ruDoComputeExpArgs(ComputeArgsAcc(
					acc.nodes, acc.pos - 1, 
					concat(acc.args, [[acc.nodes[acc.pos]]])
				));
		}
	}
}

}
