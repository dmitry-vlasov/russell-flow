import string;
import ds/tree;
import ru_fileinfo;

export {
	RuSource(imps : [RuImport], decls : [RuDecl], info : RuFileInfo);
	RuImport(imp : string);
	RuDecl ::= RuConst, RuType, RuRule, RuAxiom, RuDef, RuTheorem, RuTheory, RuComment;
	RuComment(text : string);
	RuTheory(name : string, decls : [RuDecl]);
	RuConst(symb : string, ascii : string, latex : string);
	RuType(name : string, supers : [string]);
	RuRule(name : string, vars : Tree<string, RuVar>, term : RuTerm);
	RuAxiom(name : string, vars : Tree<string, RuVar>, disj : [RuDisj], hyps : [RuHyp], prop : RuExp);
	RuVar(name : string, type : string);
	RuHyp(ind : int, expr : RuExp);
	RuDisj(vars : [string]);
	RuTheorem(name : string, vars : Tree<string, RuVar>, disj : [RuDisj], hyps : [RuHyp], prop : RuExp, proof : RuProof);
	RuDef(name : string, vars : Tree<string, RuVar>, disj : [RuDisj], hyps : [RuHyp], defm : RuExp, defs : RuExp, prop : RuExp);
	RuProof(vars : Tree<string, RuVar>, disj : [RuDisj], steps : [RuStep]);
	RuStep(ind : int, assertion : string, refs : [RuRef], expr : RuExp);
	RuRef ::= RuHypRef, RuStepRef;
	RuHypRef(ind : int);
	RuStepRef(ind : int);

	RuTerm(type : string, expr : [RuTermNode]);
	RuExp(nodes : [RuExpNode]);
	RuExpNode ::= RuRuleRef, RuVarRef;
	RuTermNode ::= RuConstRef, RuVarRef;
	RuRuleRef(rule : string, len : int);
	RuVarRef(name : string, type : string);
	RuConstRef(name : string);

	RuAssertion ::= RuAxiom, RuTheorem, RuDef;
	RuAny ::= 
		RuSource, RuImport, RuConst, RuType, RuRule, RuAxiom, RuDef, RuTheorem, RuTheory, RuComment,
		RuStep, RuExp, RuHyp, RuProof, RuDisj, RuHypRef, RuStepRef, RuTerm, RuVar, RuVarRef, RuConstRef;

	ruUnknownRule = RuRule("unknown", makeTree(), RuTerm("unknown", []));
		
	ruAny2s(a : RuAny, rules : Tree<string, RuRule>) -> string;
	ruExp2s(nodes : [RuExpNode], rules : Tree<string, RuRule>) -> string;
	ruExpType(expr : RuExp, rules : Tree<string, RuRule>) -> string;
}

ruExpType(expr : RuExp, rules : Tree<string, RuRule>) -> string {
	switch (expr.nodes[0]) {
		RuRuleRef(name, __):
			lookupTreeDef(rules, name, ruUnknownRule).term.type;
		RuVarRef(name, type): type;
	}
}

ruExp2s(nodes : [RuExpNode], rules : Tree<string, RuRule>) -> string {
	ruExp2sAcc(nodes, RuExp2sAcc(0, ""), rules).str
}

RuExp2sAcc(pos : int, str : string);

ruExp2sAcc(nodes : [RuExpNode], acc : RuExp2sAcc, rules : Tree<string, RuRule>) -> RuExp2sAcc {
	switch (nodes[acc.pos]) {
		RuVarRef(var, __): 
			RuExp2sAcc(acc.pos + 1, acc.str + var + " ");
		RuRuleRef(name, len): {
			rule = lookupTreeDef(rules, name, ruUnknownRule);
			new_acc = fold(rule.term.expr, 
				RuExp2sAcc(acc.pos + 1, acc.str + name + "("), 
				\ac, symb -> 
					switch (symb) {
						RuVarRef(__,__): ruExp2sAcc(nodes, acc, rules);
						RuConstRef(s):  RuExp2sAcc(acc.pos + 1, acc.str + s + " ");
					}
			);
			RuExp2sAcc(acc.pos + len, new_acc.str + ")");
		}
	}
}

ruAny2s(a : RuAny, rules : Tree<string, RuRule>) -> string {
	ru2s    = \x -> ruAny2s(x, rules);
	vars2s  = \vars -> if (sizeTree(vars) == 0) "" else 
		"(" + strGlue(map(getTreeValues(vars), ru2s), ", ") + ") ";
	disjs2s = \disjs -> if (disjs == []) "" else "disjointed(" + strGlue(map(disjs, ru2s), ", ") + ") ";
	exp2s   = \expr, delim -> ": " + ruExpType(expr, rules) + " = " + delim + " " + ruExp2s(expr.nodes, rules) + " ;;";
	//term2s  = \term -> ": " + term.type + " = # " + strGlue(term.expr, " ") + " ;;";
	prop2s  = \prop -> "\tprop " + exp2s(prop, "|-") + "\n";
	refs2s  = \refs -> "(" + strGlue(map(refs, ru2s), ", ") + ")";
	hyps2s  = \hyps -> if (hyps == []) "" else strGlue(map(hyps, ru2s), "\n") + "\n";
	switch (a) {
		RuSource(imps, decls, info): 
			(if (imps == []) "" else strGlue(map(imps, ru2s), "\n") + "\n\n") +
			strGlue(map(decls, ru2s), "\n");
		RuImport(path):
			"import " + path + ";;";
		RuConst(symbol, ascii, latex): 
			"constant {\n" + 
				"\tsymbol " + symbol + ";;\n" +
				(if (ascii != "") "\tascii " + ascii + ";;\n" else "") + 
				(if (latex != "") "\tlatex " + latex + ";;\n" else "") +
			"}\n";
		RuType(name, supers): 
			"type " + name + (if (supers == []) "" else " : " + strGlue(supers, ", ")) + " ;;\n";
		RuRule(name, vars, term):
			"rule " + name + " " + vars2s(vars) + "{\n" +
				"\tterm " + ru2s(term) + "\n" +
			"}\n";
		RuAxiom(name, vars, disjs, hyps, prop): 
			"axiom " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				hyps2s(hyps) +
				(if (hyps == []) "" else "\t----------\n") +
				prop2s(prop) +
			"}\n";
		RuDef(name, vars, disjs, hyps, defm, defs, prop): 
			"definition " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				hyps2s(hyps) +
				"\tdefiendum " + exp2s(defm, "#") + "\n" +
				"\tdefiniens " + exp2s(defs, "#") + "\n" +
				"\t-------------\n" +
				prop2s(prop) +
			"}\n";
		RuTheorem(name, vars, disjs, hyps, prop, proof): 
			"theorem " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				hyps2s(hyps) + 
				(if (hyps == []) "" else "\t----------\n") +
				prop2s(prop) +
			"} " + ru2s(proof);
		RuHyp(ind, expr): 
			"\thyp " + i2s(ind) + " " + exp2s(expr, "|-");
		RuProof(vars, disjs, steps): 
			"proof " + " " + vars2s(vars) + " " + disjs2s(disjs) + " {\n" +
				strGlue(map(steps, ru2s), "\n") + "\n" +
			"}\n";
		RuStep(ind, assertion, refs, expr):
			"\tstep " + i2s(ind) + " : " + ruExpType(expr, rules) + " = " + 
				assertion + " " + refs2s(refs) + " |- " + ruExp2s(expr.nodes, rules) + " ;;";
		RuTheory(name, ds): 
			"theory " + name + " {\n" +
				strGlue(map(ds, ru2s), "\n") + "\n" +
			"}\n";
		RuComment(text): text;
		RuDisj(disj): strGlue(disj, " ");
		RuExp(nodes): ruExp2s(nodes, rules);
		RuHypRef(i): "hyp " + i2s(i);
		RuStepRef(i): "step " + i2s(i);
		RuVar(name, type): name + " : " + type;
		RuTerm(type, expr): 
			": " + type + " = # " + strGlue(map(expr, ru2s), " ") + " ;;";
		RuVarRef(name, type): name;
		RuConstRef(name): name;
	}
}
