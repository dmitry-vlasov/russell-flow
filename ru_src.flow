import string;
import ds/tree;

export {
	RuIdTable(s2i : Tree<string, int>, i2s : Tree<int, string>);
	RuSource(imps : [RuImport], decls : [RuDecl], ids : RuIdTable);
	RuImport(imp : string);
	RuDecl ::= RuConst, RuType, RuRule, RuAxiom, RuDef, RuTheorem, RuTheory, RuComment;
	RuComment(text : string);
	RuTheory(name : string, decls : [RuDecl]);
	RuConst(symb : string, ascii : string, latex : string);
	RuType(name : string, supers : [string]);
	RuRule(name : string, vars : [RuVar], term : RuTerm);
	RuAxiom(name : string, vars : [RuVar], disj : [RuDisj], hyps : [RuHyp], prop : RuExp);
	RuHyp(ind : int, expr : RuExp);
	RuVar(id : int, type : string);
	RuDisj(vars : [int]);
	RuTheorem(name : string, vars : [RuVar], disj : [RuDisj], hyps : [RuHyp], prop : RuExp, proof : RuProof);
	RuDef(name : string, vars : [RuVar], disj : [RuDisj], hyps : [RuHyp], defm : RuExp, defs : RuExp, prop : RuExp);
	RuProof(vars : [RuVar], disj : [RuDisj], steps : [RuStep]);
	RuStep(ind : int, assertion : string, refs : [RuRef], expr : RuExp);
	RuRef ::= RuHypRef, RuStepRef;
	RuHypRef(ind : int);
	RuStepRef(ind : int);

	RuTerm(type : string, expr : [int]);
	RuExp(nodes : [RuExpNode]);
	RuExpNode ::= RuRuleRef, RuVar;
	RuRuleRef(rule : RuRule, len : int);

	RuAssertion ::= RuAxiom, RuTheorem, RuDef;
	RuAny ::= 
		RuSource, RuImport, RuConst, RuType, RuRule, RuAxiom, RuDef, RuTheorem, RuTheory, RuComment,
		RuStep, RuExp, RuHyp, RuProof, RuDisj, RuVar, RuHypRef, RuStepRef, RuTerm;

	ruExpType(e : RuExp) -> string {
		switch (e.nodes[0]) {
			RuRuleRef(rule, __): rule.term.type;
			RuVar(__, type): type;
		}
	}

	ruAny2s(a : RuAny, ids : RuIdTable) -> string {
		ru2s    = \x -> ruAny2s(x, ids);
		id2s    = \id -> lookupTreeDef(ids.i2s, id, "<undef>");
		vars2s  = \vars -> if (vars == []) "" else "(" + strGlue(map(vars, ru2s), ", ") + ") ";
		disjs2s = \disjs -> if (disjs == []) "" else "disjointed(" + strGlue(map(disjs, ru2s), ", ") + ") ";
		exp2s   = \expr, delim -> ": " + ruExpType(expr) + " = " + delim + " " + ruExp2s(expr.nodes, ids, 0, "") + " ;;";
		term2s  = \term -> ": " + term.type + " = # " + strGlue(map(term.expr, id2s), " ") + " ;;";
		prop2s  = \prop -> "\tprop " + exp2s(prop, "|-") + "\n";
		refs2s  = \refs -> "(" + strGlue(map(refs, ru2s), ", ") + ")";
		hyps2s  = \hyps -> if (hyps == []) "" else strGlue(map(hyps, ru2s), "\n") + "\n";
		switch (a) {
			RuSource(imps, decls, info): 
				(if (imps == []) "" else strGlue(map(imps, ru2s), "\n") + "\n\n") +
				strGlue(map(decls, ru2s), "\n");
			RuImport(path):
				"import " + path + ";;";
			RuConst(symbol, ascii, latex): 
				"constant {\n" + 
					"\tsymbol " + symbol + ";;\n" +
					(if (ascii != "") "\tascii " + ascii + ";;\n" else "") + 
					(if (latex != "") "\tlatex " + latex + ";;\n" else "") +
				"}\n";
			RuType(name, supers): 
				"type " + name + (if (supers == []) "" else " : " + strGlue(supers, ", ")) + " ;;\n";
			RuRule(name, vars, term):
				"rule " + name + " " + vars2s(vars) + "{\n" +
					"\tterm " + term2s(term) + "\n" +
				"}\n";
			RuAxiom(name, vars, disjs, hyps, prop): 
				"axiom " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
					hyps2s(hyps) +
					(if (hyps == []) "" else "\t----------\n") +
					prop2s(prop) +
				"}\n";
			RuDef(name, vars, disjs, hyps, defm, defs, prop): 
				"definition " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
					hyps2s(hyps) +
					"\tdefiendum " + exp2s(defm, "#") + "\n" +
					"\tdefiniens " + exp2s(defs, "#") + "\n" +
					"\t-------------\n" +
					prop2s(prop) +
				"}\n";
			RuTheorem(name, vars, disjs, hyps, prop, proof): 
				"theorem " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
					hyps2s(hyps) + 
					(if (hyps == []) "" else "\t----------\n") +
					prop2s(prop) +
				"} " + ru2s(proof);
			RuHyp(ind, expr): 
				"\thyp " + i2s(ind) + " " + exp2s(expr, "|-");
			RuProof(vars, disjs, steps): 
				"proof " + " " + vars2s(vars) + " " + disjs2s(disjs) + " {\n" +
					strGlue(map(steps, ru2s), "\n") + "\n" +
				"}\n";
			RuStep(ind, assertion, refs, expr):
				"\tstep " + i2s(ind) + " : " + ruExpType(expr) + " = " + 
					assertion + " " + refs2s(refs) + " |- " + ruExp2s(expr.nodes, ids, 0, "") + " ;;";
			RuTheory(name, ds): 
				"theory " + name + " {\n" +
					strGlue(map(ds, ru2s), "\n") + "\n" +
				"}\n";
			RuComment(text): text;
			RuDisj(disj): strGlue(map(disj, id2s), " ");
			RuExp(nodes): ruExp2s(nodes, ids, 0, "");
			RuHypRef(i): "hyp " + i2s(i);
			RuStepRef(i): "step " + i2s(i);
			RuVar(name, type): id2s(name) + " : " + type;
			RuTerm(type, expr): 
				": " + type + " = # " + strGlue(map(expr, id2s), " ") + " ;;";
		}
	}
}

ruExp2s(nodes : [RuExpNode], ids : RuIdTable, s : int, acc : string) -> string {
	id2s = \id -> lookupTreeDef(ids.i2s, id, "<undef>");
	switch (nodes[s]) {
		RuVar(id, __): acc + id2s(id) + " ";
		RuRuleRef(rule, len): {
			foldi(rule.term.expr, acc, \i, ac, symb -> 
				switch (find(rule.vars, \v -> v.id == symb)) {
					Some(v): ruExp2s(nodes, ids, s + i, acc);
					None(): acc + id2s(symb) + " ";
				}
			);
		}
	}
}
