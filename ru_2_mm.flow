import ru_verify;
import mm_src;

export {
	ruMath2mm(math : RuMath) -> MmMath;
	ruSource2mm(src : RuSource, math : RuMath) -> MmSource;
}

ruMath2mm(math : RuMath) -> MmMath {
	srcs = mapTree(math.sources, \src -> ruSource2mm(src, math));
	labeled = foldTree(srcs, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac : Tree<string, MmLabeled>, decl ->
			switch (decl) {
				MmAssertion(__, hyps, stat):
					fold(hyps, setTree(ac, stat.label, decl), \a, h ->
						setTree(a, h.label, h)
					);
				default: ac;
			}
		)
	);
	MmMath(srcs, labeled)
}

ruMakeMmPath(info : RuFileInfo, conf : RuConf) -> string {
	lookupTreeDef(conf.opts, "mm-root", "") + info.file + ".mm"
}

ruSource2mm(src : RuSource, math : RuMath) -> MmSource {
	MmSource(
		map(src.imports, \imp -> MmInclude(imp.path)),
		fold(src.decls, [], \acc, decl ->
			concat(acc, ruDecl2mm(decl, math))
		),
		RuFileInfo(
			src.info.file,
			ruMakeMmPath(src.info, math.conf),
			0.0, 0.0
		)
	)
}

ruDecl2mm(decl : RuBlock, math : RuMath) -> [MmDecl] {
	term2mm = \t -> map(t.expr, 
		\s -> switch (s) {
			RuVarRef(v, __): MmSymb(v, true);
			RuConstRef(c): MmSymb(c, false);
		}
	);
	expr2mm = \ex -> MmExpr(term2mm(ruExp2Term(ex, math.rules)));
	disj2mm = \disjs -> map(ruDisjs2Array(disjs), \ds -> MmDisj(map(set2array(ds), \d -> d.name)));
	vars2mm = \vs -> map(getTreeValues(vs), \v -> MmFloating(v.name + "_" + v.type, v.type, v.name));
	hyps2mm = \n, hs -> mapi(hs, \i, h -> MmEssential(n + "_" + i2s(i), expr2mm(h.expr)));
	switch (decl) {
		RuComment(text,__): [MmComment(text)];
		RuTheory(name, decls,__): []; // TODO
		RuConst(symb, ascii,__, __): [MmConst([if (ascii != "") ascii else symb])];
		RuType(name,__,__): {
			tenv = lookupTreeDef(math.types, name, ruNoTypeEnv);
			concat(
				[MmConst([name])], 
				concatA(map(getTreeValues(tenv.supers), \r -> ruDecl2mm(r, math)))
			);
		}
		RuRule(name, vars, term, __):
			[MmAssertion(
				[], 
				vars2mm(vars), 
				MmAxiomatic(name, MmExpr(concat([MmSymb(term.type, false)], term2mm(term))))
			)];
		RuAxiom(name, vars, disjs, hyps, prop, __):
			[MmAssertion(
				disj2mm(disjs),
				concat(vars2mm(vars), hyps2mm(name, hyps)),
				MmAxiomatic(name, expr2mm(prop))
			)];
		RuTheorem(name, vars, disjs, hyps, prop, proof, __):
			[MmAssertion(
				disj2mm(mergeSets(disjs, proof.disjs)),
				concat3(vars2mm(vars), vars2mm(proof.vars), hyps2mm(name, hyps)),
				MmProvable(name, expr2mm(prop), MmProof(ruProof2mm(lastElement(proof.steps, ruNoStep), decl, math)))
			)];
		RuDef(name, vars, disjs, hyps, defm, defs, prop, pos):
			[MmAssertion(
				disj2mm(disjs),
				concat(vars2mm(vars), hyps2mm(name, hyps)),
				MmAxiomatic(name, expr2mm(prop))
			)];
	}
}

ruProofExp2mm(ex : RuExp) -> [string] {
	fold(ex.nodes, [], \acc, n ->
		concat(acc, [
			switch (n) {
				RuRuleRef(rule, __,__,__): rule;
				RuVarRef(name, type): name + "_" + type;
			}
		])
	)
}

ruProof2mm(step : RuStep, th : RuTheorem, math : RuMath) -> [string] {
	switch (ruMatchStep(step, th, math)) {
		Some(p): {
			subs = fold(getTreeValues(p.first.vars), [], \acc, v ->
				switch (lookupTree(p.second, RuVarRef(v.name, v.type))) {
					None(): acc;
					Some(ex): concat(acc, ruProofExp2mm(ex));
				}
			)
			refs = fold(step.refs, [], \acc, ref ->
				switch (ref) {
					RuHypRef(ind,__): concat(acc, [th.name + "_" + i2s(ind)]);
					RuStepRef(ind,__): concat(acc, ruProof2mm(th.proof.steps[ind], th, math));
				}
			);
			concat3(subs, refs, [p.first.name]);
		}
		None(): [];
	}
}
