import ru_verify;
import mm_src;

export {
	ruMath2mm(math : RuMath) -> MmMath;
	ruSource2mm(src : RuSource, math : RuMath) -> MmSource;
}

ruMath2mm(math : RuMath) -> MmMath {
	srcs = mapTree(math.sources, \src -> ruSource2mm(src, math));
	labeled = foldTree(srcs, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac : Tree<string, MmLabeled>, decl ->
			switch (decl) {
				MmAssertion(__, hyps, stat):
					fold(hyps, setTree(ac, stat.label, decl), \a, h ->
						setTree(a, h.label, h)
					);
				default: ac;
			}
		)
	);
	ruAddTurnstile(math, MmMath(srcs, labeled))
}


ruAddTurnstile(ru_math : RuMath, mm_math : MmMath) -> MmMath {
	leaf_srcs = mmFindLeafSources(mm_math);
	common_dir = ruPath2s(ruCommonDir(map(leaf_srcs, \src -> ruSplitPath(src.info.path))));
	turnstile = ruMakeTurnstile(ru_math);
	turnstile_path = common_dir + "turnstile.rus";
	turnstile_file = ruTrimPath(turnstile_path, ru_math.conf);
	turnstile_src = MmSource(
		[], 
		[MmConst([turnstile])], 
		RuFileInfo(turnstile_file, turnstile_path, 0.0, 0.0)
	);
	acc1 = MmMath(mm_math with sources = setTree(mm_math.sources, turnstile_file, turnstile_src));
	fold(leaf_srcs, acc1, \acc, src ->
		MmMath(acc with 
			sources = setTree(acc.sources, src.info.file, 
				MmSource([MmInclude(turnstile_file)], src.decls, src.info)
			)
		)
	)
}

ruFindLeafSources(math : RuMath) -> [RuSource] {
	filter(getTreeValues(math.sources), \src -> src.imports == [])
}

ruMakeTurnstile(math : RuMath) -> string {
	ruDoMakeTurnstile(math, "|-")
}

ruDoMakeTurnstile(math : RuMath, turnstile : string) -> string {
	if (!containsKeyTree(math.consts, turnstile)) turnstile else {
		ruDoMakeTurnstile(math, "|" + turnstile)
	}
}

ruMakeMmPath(info : RuFileInfo, conf : RuConf) -> string {
	lookupTreeDef(conf.opts, "mm-root", "") + info.file + ".mm"
}

ruSource2mm(src : RuSource, math : RuMath) -> MmSource {
	turnstile = ruMakeTurnstile(math);
	MmSource(
		map(src.imports, \imp -> MmInclude(imp.path)),
		fold(src.decls, [], \acc, decl ->
			concat(acc, ruDecl2mm(decl, turnstile, math))
		),
		RuFileInfo(
			src.info.file,
			ruMakeMmPath(src.info, math.conf),
			0.0, 0.0
		)
	)
}

ruVar2mm(th : string, var : string) -> string {
	strReplace(th + "_" + var, "+", "_plus_")
}

ruDecl2mm(decl : RuBlock, turnstile : string, math : RuMath) -> [MmDecl] {
	const2mm = \c -> if (c.ascii != "") c.ascii else c.symb;
	term2mm = \t -> map(t.expr, 
		\s -> switch (s) {
			RuVarRef(v, __): 
				MmSymb(v, true);
			RuConstRef(c):
				MmSymb(const2mm(lookupTreeDef(math.consts, c, ruNoConst)), false);
		}
	);
	expr2mm = \ex -> MmExpr(concat([MmSymb(turnstile, false)], term2mm(ruExp2Term(ex, math.rules))));
	disj2mm = \disjs -> map(ruDisjs2Array(disjs), \ds -> MmDisj(map(set2array(ds), \d -> d.name)));
	vars2mm = \n, vs -> map(getTreeValues(vs), \v -> MmFloating(ruVar2mm(n, v.name), v.type, v.name));
	hyps2mm = \n, hs -> mapi(hs, \i, h -> MmEssential(n + "_" + i2s(i), expr2mm(h.expr)));
	comm2mm = \t -> {
		t1 = if (startsWith(t, "/*") || startsWith(t, "//")) strRight(t, 2) else t;
		if (endsWith(t1, "*/")) strLeft(t1, strlen(t1) - 2) else t1;
	}
	switch (decl) {
		RuComment(text,__): [MmComment(comm2mm(text))];
		RuTheory(name, decls,__): []; // TODO
		RuConst(symb, ascii,__, __): [MmConst([const2mm(decl)])];
		RuType(name,__,__): {
			tenv = lookupTreeDef(math.types, name, ruNoTypeEnv);
			concat(
				[MmConst([name])], 
				concatA(map(getTreeValues(tenv.supers), \r -> ruDecl2mm(r, turnstile,math)))
			);
		}
		RuRule(name, vars, term, __):
			[MmAssertion(
				[], 
				vars2mm(name, vars), 
				MmAxiomatic(name, MmExpr(concat([MmSymb(term.type, false)], term2mm(term))))
			)];
		RuAxiom(name, vars, disjs, hyps, prop, __):
			[MmAssertion(
				disj2mm(disjs),
				concat(vars2mm(name, vars), hyps2mm(name, hyps)),
				MmAxiomatic(name, expr2mm(prop))
			)];
		RuTheorem(name, vars, disjs, hyps, prop, proof, __):
			[MmAssertion(
				disj2mm(mergeSets(disjs, proof.disjs)),
				concat3(vars2mm(name, vars), vars2mm(name, proof.vars), hyps2mm(name, hyps)),
				MmProvable(name, expr2mm(prop), MmProof(ruProof2mm(lastElement(proof.steps, ruNoStep), decl, math)))
			)];
		RuDef(name, vars, disjs, hyps, defm, defs, prop, pos):
			[MmAssertion(
				disj2mm(disjs),
				concat(vars2mm(name, vars), hyps2mm(name, hyps)),
				MmAxiomatic(name, expr2mm(prop))
			)];
	}
}

ruProofExp2mm(ex : RuExp, name : string) -> [string] {
	fold(ex.nodes, [], \acc, n ->
		concat(acc, [
			switch (n) {
				RuRuleRef(rule, __,__,__): rule;
				RuVarRef(var, type): ruVar2mm(name, var);
			}
		])
	)
}

ruProof2mm(step : RuStep, th : RuTheorem, math : RuMath) -> [string] {
	switch (ruMatchStep(step, th, math)) {
		Some(p): {
			subs = fold(getTreeValues(p.first.vars), [], \acc, v ->
				switch (lookupTree(p.second, RuVarRef(v.name, v.type))) {
					None(): acc;
					Some(ex): concat(acc, ruProofExp2mm(ex, th.name));
				}
			)
			refs = fold(step.refs, [], \acc, ref ->
				switch (ref) {
					RuHypRef(ind,__): concat(acc, [th.name + "_" + i2s(ind)]);
					RuStepRef(ind,__): concat(acc, ruProof2mm(th.proof.steps[ind], th, math));
				}
			);
			concat3(subs, refs, [p.first.name]);
		}
		None(): [];
	}
}
