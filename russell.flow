import lingo/linecolumn;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import ru_usage;

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

main() -> void {
	println("Russell prover (3rd generation)");
	println("");
	err_count = ref 0;
	onError = \err, places -> {
		err_count := ^err_count + 1;
		println(err + "\n" + strGlue(map(places, ruPlace2s), "\n"));
	}
	switch (ruMakeConf(onError)) {
		Some(conf): {
			if (lookupTreeDef(conf.opts, "help", "0") != "0") {
				ruUsage(conf);
			} else {
				loaded = getTreeValues(ruLoad(conf));
				parsed = ruParse(loaded, conf);
				if (^err_count == 0) {
					math = ruCollectMath(parsed, conf);
					/*traverseInOrder(collected.types, \name, tenv -> {
							println("type: '" + name + "'");
							println("rule trie: ");
							//println(tenv.table);
							println(ruTrie2s(tenv.trie, idfn, idfn));
						}
					)*/
					//traverseInOrder(math.rules, \name, rule -> println(ruAny2s(rule)));
					traverseInOrder(math.assertions, \name, ass -> {
							//println(ruAny2s(ass, collected.rules));
							switch (ass) {
								RuAxiom(__,__,__,__,__): {
									println("ax: " + name);
									println(ruAny2s(ass, math.rules));
								}
								RuDef(__,__,__,__,__,__,__): {
									println(ruAny2s(ass, math.rules));
								}
								default: { }
							}
						}
					)
				}
				quit(0);
			}
		}
		None(): { }
	}
}
