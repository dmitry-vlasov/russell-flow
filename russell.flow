import lingo/linecolumn;
import math/stringmath;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import parse/mm_parse;
import parse/mm_collect_math;
import ru_usage;
import ru_verify;
import ru_2_mm;
import mm_2_ru;
import mm_verify;

RuWriteSource(data : string, info : RuFileInfo);

ruWriteSources(srcs : [RuWriteSource], conf : RuConf) -> void {
	concurrent(true, map(srcs, \src -> 
		\-> {
			path = src.info.path;
			ensureDirectoryExists(ruDirName(path));
			if (conf.verbose > 0) {
				println("writing : " + path);
			}
			ret = setFileContent(path, src.data); 
			if (!ret) {
				println("error while writing " + path);
			}
			ret;
		}
	));
	{}
}

ruProcessMath(math : RuMath) -> void {
	mmRoot0 = lookupTreeDef(math.conf.opts, "mm-root", "");
	if (mmRoot0 != "") {
		mmRoot = if (endsWith(mmRoot0, "/")) mmRoot0 else mmRoot0 + "/";
		mmMath = ruMath2mm(math);
		ruWriteSources(
			map(getTreeValues(mmMath.sources), 
				\src : MmSource ->
					if (lookupTreeDef(math.conf.opts, "mm-strip", "") == "1") {
						RuWriteSource(mm2s(mmStripComments(src)), src.info)
					} else {
						RuWriteSource(mm2s(src), src.info)
					}
			),
			math.conf
		)
	}
	mmFile = lookupTreeDef(math.conf.opts, "mm", "");
	if (mmFile != "") {
		mmMath = ruMath2mm(math);
		mmSrc = if (lookupTreeDef(math.conf.opts, "mm-strip", "") == "1") {
			mmStripComments(mmMath2Source(mmMath, mmFile));
		} else {
			mmMath2Source(mmMath, mmFile);
		}
		ensureDirectoryExists(dirName(mmFile));
		src_text = mm2s(mmSrc);
		ret = setFileContent(mmFile, src_text); 
		if (!ret) {
			println("error at writing output file " + mmFile);
		}
	}
	
	rusRoot = lookupTreeDef(math.conf.opts, "rus-root", "");
	if (rusRoot != "") {
		ruWriteSources(
			map(getTreeValues(math.sources), 
				\src : RuSource -> RuWriteSource(
					ruAny2s(src, math.rules), 
					RuFileInfo(src.info with path = rusRoot + "/" + src.info.file + ".rus";)
				)
			),
			math.conf
		)
	} 

	if (lookupTreeDef(math.conf.opts, "rus-stats", "") == "1") {
		println("stats:\n" + ruMathStats(math) + "\n");
	}
}

mmProcessMath(math : MmMath) -> void {
	ruFile = lookupTreeDef(math.conf.opts, "ru", "");
	if (ruFile != "") {
		pp = mmMath2ru(math);
		traverseInOrder(pp, \__ ,src -> 
			if (!setFileContent(src.info.path, ruParse2s(src))) {
				println("failed to save file: " + src.info.path);
			}
		);
	
		maybeApply(ruCollectMath(mmMath2ru(math), math.conf), \collected -> {
			maybeApply(ruVerifyMath(collected), \verified -> {
					ruSrc = ruMath2Source(verified, ruFile);
					if (!setFileContent(ruFile, ruAny2s(ruSrc, verified.rules))) {
						println("failed to save file: " + ruFile);
					}
				}
			)
			}
		);
	}
}

ruMakeMath(conf : RuConf) -> Maybe<RuMath> {
	maybeBind(ruLoad(conf, ruLoadDescr), \loaded ->
		maybeBind(ruParse(getTreeValues(loaded), conf), \parsed ->
			maybeBind(ruCollectMath(parsed, conf), \collected ->
				ruVerifyMath(collected)
			)
		)
	)
}

mmMakeMath(conf : RuConf) -> Maybe<MmMath> {
	maybeBind(ruLoad(conf, mmLoadDescr), \loaded ->
		maybeBind(mmParse(getTreeValues(loaded), conf), \parsed ->
			maybeBind(mmCollectMath(parsed, conf), \collected ->
				mmVerifyMath(collected)
			)
		)
	)
}

main() -> void {
	println("Russell prover (4th generation)");
	println("");
	onError = \err, places -> println(err + "\n" + strGlue(map(places, ruPlace2s), "\n"));
	switch (ruMakeConf(onError)) {
		Some(conf): {
			if (lookupTreeDef(conf.opts, "help", "0") != "0") {
				ruUsage(conf);
			} else {
				start = timestamp();
				if (conf.ext == ".rus") {
					maybeApply(ruMakeMath(conf), ruProcessMath);
				} else if (conf.ext == ".mm") {
					maybeApply(mmMakeMath(conf), mmProcessMath);
				} else {
					println("file extension should be *.rus or *.mm");
				}
				println("processed in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
				quit(0);
			}
		}
		None(): { }
	}
}
