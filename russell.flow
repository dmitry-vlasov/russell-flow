import lingo/linecolumn;
import math/stringmath;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import ru_usage;

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

main() -> void {
	println("Russell prover (4th generation)");
	println("");
	err_count = ref 0;
	onError = \err, places -> {
		err_count := ^err_count + 1;
		println(err + "\n" + strGlue(map(places, ruPlace2s), "\n"));
	}
	switch (ruMakeConf(onError)) {
		Some(conf): {
			if (lookupTreeDef(conf.opts, "help", "0") != "0") {
				ruUsage(conf);
			} else {
				start_all = timestamp();
				loaded = getTreeValues(ruLoad(conf));
				println("loaded " +i2s(length(loaded)) + " files in: " + d2st((timestamp() - start_all)/ 1000.0, 2) + "s");
				start_parse = timestamp();
				parsed = ruParse(loaded, conf);
				println("parsed " +i2s(sizeTree(parsed)) + " in: " + d2st((timestamp() - start_parse)/ 1000.0, 2) + "s");
				if (^err_count == 0) {
					collect_start = timestamp();
					math = ruCollectMath(parsed, conf);
					/*traverseInOrder(collected.types, \name, tenv -> {
							println("type: '" + name + "'");
							println("rule trie: ");
							//println(tenv.table);
							println(ruTrie2s(tenv.trie, idfn, idfn));
						}
					)*/
					//traverseInOrder(math.rules, \name, rule -> println(ruAny2s(rule)));
					/*traverseInOrder(math.assertions, \name, ass -> {
							//println(ruAny2s(ass, collected.rules));
							switch (ass) {
								RuAxiom(__,__,__,__,__): {
									println("ax: " + name);
									println(ruAny2s(ass, math.rules));
								}
								RuDef(__,__,__,__,__,__,__): {
									println(ruAny2s(ass, math.rules));
								}
								default: { }
							}
						}
					)*/
					println("collected: " +i2s(sizeTree(math.sources)) + " files in " + d2st((timestamp() - collect_start)/ 1000.0, 2) + "s");
					println("stats:\n" + ruMathStats(math) + "\n");
					
					dump = lookupTreeDef(conf.opts, "dump", "");
					if (dump != "") {
						traverseInOrder(math.sources, \name, src -> {
							path = dump + "/" + src.info.file + ".rus";
							ensureDirectoryExists(dirName(path));
							if (conf.verbose > 0) {
								println("dumping: " + path);
							}
							src_text = ruAny2s(src, math.rules);
							if (!setFileContent(path, src_text)) {
								println("error at dumping " + path);
								//println(src_text);
							}
						})
					} 
				}
				println("errors: " + i2s(^err_count) + ", processed: " + d2st((timestamp() - start_all)/ 1000.0, 2) + "s");
				quit(0);
			}
		}
		None(): { }
	}
}
