import lingo/linecolumn;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_types;
import ru_usage;

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

main() -> void {
	println("Russell prover (3rd generation)");
	println("");
	err_count = ref 0;
	onError = \err, places -> {
		err_count := ^err_count + 1;
		println(err + "\n" + strGlue(map(places, ruPlace2s), "\n"));
	}
	switch (ruMakeConf(onError)) {
		Some(conf): {
			if (lookupTreeDef(conf.opts, "help", "0") != "0") {
				ruUsage(conf);
			} else {
				loaded = getTreeValues(ruLoad(conf));
				//println("loaded file:");
				//iter(loaded, \l -> println("file: " + l.info.file));
				parsed = ruParse(loaded, conf);
				/*println("parsed:");
				traverseInOrder(parsed, \name, p -> {
						println("parsed file: " + name);
						//println(ruParse2s(p));
						//println("=====================");
					}
				);*/
				collected = ruCollectTypes(parsed, conf);
				//  (RuTermNode, int) -> [RuExpNode]
				
				/*traverseInOrder(collected.types, \name, tenv -> {
						println("type: '" + name + "'");
						println("rule trie: ");
						//println(tenv.table);
						println(ruTrie2s(tenv.trie, idfn, idfn));
					}
				)
				traverseInOrder(collected.rules, \name, rule -> {
						println("rule: '" + name + "'");
						println("rule body: " + ruTerm2s(rule.term.expr));
					}
				)*/
				traverseInOrder(collected.assertions, \name, ass -> {
				
						println(ruAny2s(ass, collected.rules));
						/*switch (ass) {
							RuAxiom(__,__,__,__,__): {
								println("ax: " + name);
								println(ruAny2s(ass, collected.rules));
							}
							default: { }
						}*/
					}
				)
				quit(0);
			}
		}
		None(): { }
	}
}
