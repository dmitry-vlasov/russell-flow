import lingo/linecolumn;
import math/stringmath;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import ru_usage;
import ru_verify;
import ru_2_mm;

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

main() -> void {
	println("Russell prover (4th generation)");
	println("");
	err_count = ref 0;
	onError = \err, places -> {
		err_count := ^err_count + 1;
		println(err + "\n" + strGlue(map(places, ruPlace2s), "\n"));
	}
	switch (ruMakeConf(onError)) {
		Some(conf): {
			if (lookupTreeDef(conf.opts, "help", "0") != "0") {
				ruUsage(conf);
			} else {
				start_all = timestamp();
				loaded = getTreeValues(ruLoad(conf));
				println("loaded " +i2s(length(loaded)) + " files in: " + d2st((timestamp() - start_all)/ 1000.0, 2) + "s");
				start_parse = timestamp();
				parsed = ruParse(loaded, conf);
				println("parsed " +i2s(sizeTree(parsed)) + " in: " + d2st((timestamp() - start_parse)/ 1000.0, 2) + "s");
				if (^err_count == 0) {
					start_collect = timestamp();
					math = ruCollectMath(parsed, conf);
					/*traverseInOrder(collected.types, \name, tenv -> {
							println("type: '" + name + "'");
							println("rule trie: ");
							//println(tenv.table);
							println(ruTrie2s(tenv.trie, idfn, idfn));
						}
					)*/
					//traverseInOrder(math.rules, \name, rule -> println(ruAny2s(rule)));
					/*traverseInOrder(math.assertions, \name, ass -> {
							//println(ruAny2s(ass, collected.rules));
							switch (ass) {
								RuAxiom(__,__,__,__,__): {
									println("ax: " + name);
									println(ruAny2s(ass, math.rules));
								}
								RuDef(__,__,__,__,__,__,__): {
									println(ruAny2s(ass, math.rules));
								}
								default: { }
							}
						}
					)*/
					println("collected: " +i2s(sizeTree(math.sources)) + " files in " + d2st((timestamp() - start_collect)/ 1000.0, 2) + "s");
					println("stats:\n" + ruMathStats(math) + "\n");
					start_verify = timestamp();
					ruVerifyMath(math);
					println("verified: " +i2s(sizeTree(math.sources)) + " files in " + d2st((timestamp() - start_verify)/ 1000.0, 2) + "s");
					
					mmMath = ruMath2mm(math);
					
					mmRoot = lookupTreeDef(conf.opts, "mm-root", "");
					if (mmRoot != "") {
						concurrent(true, map(getTreeValues(mmMath.sources), \src : MmSource -> 
							\-> {
								path = src.info.path; //mmRoot + "/" + src.info.file + ".rus";
								ensureDirectoryExists(dirName(path));
								if (conf.verbose > 0) {
									println("translating: " + path);
								}
								src_text = mm2s(src);
								ret = setFileContent(path, src_text); 
								if (!ret) {
									println("error at translating " + path);
								}
								ret;
							}
						));
						{}
					} 
					
					dump = lookupTreeDef(conf.opts, "dump", "");
					if (dump != "") {
						concurrent(true, map(getTreeValues(math.sources), \src -> 
							\-> {
								path = dump + "/" + src.info.file + ".rus";
								ensureDirectoryExists(dirName(path));
								if (conf.verbose > 0) {
									println("dumping: " + path);
								}
								src_text = ruAny2s(src, math.rules);
								ret = setFileContent(path, src_text); 
								if (!ret) {
									println("error at dumping " + path);
								}
								ret;
							}
						));
						{}
					} 
				}
				println("errors: " + i2s(^err_count) + ", processed: " + d2st((timestamp() - start_all)/ 1000.0, 2) + "s");
				quit(0);
			}
		}
		None(): { }
	}
}
