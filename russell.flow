import lingo/linecolumn;
import math/stringmath;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import ru_usage;
import ru_verify;
import ru_2_mm;

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

RuWriteSource(data : string, info : RuFileInfo);

ruWriteSources(srcs : [RuWriteSource], conf : RuConf) -> void {
	concurrent(true, map(srcs, \src -> 
		\-> {
			path = src.info.path;
			ensureDirectoryExists(ruDirName(path));
			if (conf.verbose > 0) {
				println("writing : " + path);
			}
			ret = setFileContent(path, src.data); 
			if (!ret) {
				println("error while writing " + path);
			}
			ret;
		}
	));
	{}
}

ruProcessMath(math : RuMath) -> void {
	mmRoot = lookupTreeDef(math.conf.opts, "mm-root", "");
	if (mmRoot != "") {
		mmMath = ruMath2mm(math);
		ruWriteSources(
			map(getTreeValues(mmMath.sources), 
				\src : MmSource ->
					if (lookupTreeDef(math.conf.opts, "mm-strip", "") == "1") {
						RuWriteSource(mm2s(mmStripComments(src)), src.info)
					} else {
						RuWriteSource(mm2s(src), src.info)
					}
			),
			math.conf
		)
	}
	mmFile = lookupTreeDef(math.conf.opts, "mm", "");
	if (mmFile != "") {
		mmMath = ruMath2mm(math);
		mmSrc = if (lookupTreeDef(math.conf.opts, "mm-strip", "") == "1") {
			mmStripComments(mmMath2Source(mmMath, mmFile));
		} else {
			mmMath2Source(mmMath, mmFile);
		}
		ensureDirectoryExists(dirName(mmFile));
		src_text = mm2s(mmSrc);
		ret = setFileContent(mmFile, src_text); 
		if (!ret) {
			println("error at translating " + mmFile);
		}
	}
	
	rusRoot = lookupTreeDef(math.conf.opts, "rus-root", "");
	if (rusRoot != "") {
		ruWriteSources(
			map(getTreeValues(math.sources), 
				\src : RuSource -> RuWriteSource(
					ruAny2s(src, math.rules), 
					RuFileInfo(src.info with path = rusRoot + "/" + src.info.file + ".rus";)
				)
			),
			math.conf
		)
	} 
}

main() -> void {
	println("Russell prover (4th generation)");
	println("");
	err_count = ref 0;
	onError = \err, places -> {
		err_count := ^err_count + 1;
		println(err + "\n" + strGlue(map(places, ruPlace2s), "\n"));
	}
	switch (ruMakeConf(onError)) {
		Some(conf): {
			if (lookupTreeDef(conf.opts, "help", "0") != "0") {
				ruUsage(conf);
			} else {
				start_all = timestamp();
				loaded = getTreeValues(ruLoad(conf, ruLoadDescr));
				println("loaded " +i2s(length(loaded)) + " files in: " + d2st((timestamp() - start_all)/ 1000.0, 2) + "s");
				start_parse = timestamp();
				parsed = ruParse(loaded, conf);
				println("parsed " +i2s(sizeTree(parsed)) + " in: " + d2st((timestamp() - start_parse)/ 1000.0, 2) + "s");
				if (^err_count == 0) {
					start_collect = timestamp();
					math = ruCollectMath(parsed, conf);
					println("collected: " +i2s(sizeTree(math.sources)) + " files in " + d2st((timestamp() - start_collect)/ 1000.0, 2) + "s");
					println("stats:\n" + ruMathStats(math) + "\n");
					start_verify = timestamp();
					vmath = ruVerifyMath(math);
					println("verified: " +i2s(sizeTree(vmath.sources)) + " files in " + d2st((timestamp() - start_verify)/ 1000.0, 2) + "s");
					ruProcessMath(vmath);
				}
				println("errors: " + i2s(^err_count) + ", processed: " + d2st((timestamp() - start_all)/ 1000.0, 2) + "s");
				quit(0);
			}
		}
		None(): { }
	}
}
