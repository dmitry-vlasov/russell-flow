import parse/ru_parse_src;
import ru_src;
import mm_src;

export {
	mmMath2ru(math : MmMath) -> Tree<string, RuParseSource>;
}

mmMath2ru(math : MmMath) -> Tree<string, RuParseSource> {
	start = timestamp();
	syntax = mmMath2Syntax(math); 
	ret = mapTree(math.sources, \src -> mmSource2ru(src, math, syntax));
	if (math.conf.verbose > 0) {
		println("mm translated in: " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

mmSource2ru(src : MmSource, math : MmMath, syntax : MmRuSyntax) -> RuParseSource {
	start = timestamp();
	ret = RuParseSource(
		map(src.includes, \inc -> RuParseImport(inc.file, -1)),
		fold(src.decls, [], \acc, decl ->
			concat(acc, mmDecl2ru(decl, math, syntax))
		),
		RuFileInfo(
			src.info.file,
			mmMakeRuPath(src.info, math.conf),
			0.0, 0.0
		)
	);
	if (math.conf.verbose > 1) {
		println("mm translated: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

mmMakeRuPath(info : RuFileInfo, conf : RuConf) -> string {
	ruRoot0 = lookupTreeDef(conf.opts, "ru-root", "");
	if (ruRoot0 != "") {
		ruRoot = if (endsWith(ruRoot0, "/")) ruRoot0 else ruRoot0 + "/";
		ruRoot + info.file + ".rus"
	} else {
		info.file + ".rus"
	}
}

mmDecl2ru(decl : MmDecl, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	switch (decl) {
		MmComment(text): [RuParseComment(text, -1)];
		MmConst(symbs):
			fold(symbs, [], \acc, s -> 
				switch (lookupTree(syntax.types, s)) {
					Some(t):
						if (containsSet(syntax.supers, t.name)) acc else {
							concat(
								fold(t.supers, acc, \ac, sup -> 
									concat(ac, [lookupTreeDef(syntax.types, sup, ruNoParseType)])
								),
								[t]
							);
						}
					None(): concat(acc, [mmConst2ru(s, math.conf)]);
				}
			);
		MmAssertion(disjs, hyps, inner, stat): mmAssertion2ru(decl, math, syntax);
	}
}

mmSymb2ru(s : string, conf : RuConf) -> string {
	s
}

mmConst2ru(s : string, conf : RuConf) -> RuParseConst {
	RuParseConst(s, "", "", -1)
}

mmAssertion2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	switch (lookupTree(syntax.rules, ass.stat.label)) {
		Some(r):
			if (ruRuleIsSuper(r)) [] else [r];
		None(): {
			switch (ass.stat) {
				MmProvable(__,__,__): 
					mmTheorem2ru(ass, ass.stat, math);
				MmAxiomatic(l,__): 
					if (mmAssertionIsDef(ass)) {
						mmDef2ru(ass, math, syntax); 
					} else {
						mmAxiom2ru(ass, math, syntax);
					}
			}
		}
	}
}

mmAssertionHyps(hyps : [MmHyp]) -> [MmEssential] {
	filtermap(hyps, \h -> 
		switch (h) {
			MmEssential(__,__): Some(h);
			default: None();
		}
	)
}

mmAssertionFlos(hyps : [MmHyp]) -> [MmFloating] {
	filtermap(hyps, \h -> 
		switch (h) {
			MmFloating(__,__,__): Some(h);
			default: None();
		}
	)
}


mmAxiom2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	[RuParseAxiom(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs, mmAssertionVars(ass)), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)), 
		mmExp2ru(ass.stat.expr.symbs), -1
	)];
}

MmDefFactor(
	defm : RuParseExp,
	defs : RuParseExp,
	def : RuParseExp,
);

mmDef2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	defFactor = mmFactorDef(ass.stat.expr);
	[RuParseDef(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs, mmAssertionVars(ass)), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)),
		defFactor.defm, defFactor.defs, defFactor.def, -1
	)];
}

MmFactorDefEqAcc(
	braces : int,
	brackets : int,
	eq : int
);

mmFactorDefEqInd(ex : MmExp) -> int {
	is_eq = ex.symbs[1].literal != "(";
	foldi(ex.symbs, MmFactorDefEqAcc(0, 0, -1), \i, ac, s ->
		if (ac.eq != -1) ac else
		if (s.literal == "(") MmFactorDefEqAcc(ac with brackets = ac.brackets + 1) else 
		if (s.literal == "{") MmFactorDefEqAcc(ac with braces   = ac.braces + 1) else
		if (s.literal == ")") MmFactorDefEqAcc(ac with brackets = ac.brackets - 1) else
		if (s.literal == "}") MmFactorDefEqAcc(ac with braces   = ac.braces - 1) else
		if (s.literal == "="   && is_eq  && ac.braces == 0) MmFactorDefEqAcc(ac with eq = i) else
		if (s.literal == "<->" && !is_eq && ac.brackets == 1) MmFactorDefEqAcc(ac with eq = i) else ac
	).eq
}

mmFactorDef(ex : MmExp) -> MmDefFactor {
	eq_ind = mmFactorDefEqInd(ex);
	is_eq = ex.symbs[eq_ind].literal == "=";
	dfm_beg = if (is_eq) 1 else 2;
	dfm_len = if (is_eq) eq_ind - 1 else eq_ind - 2;
	dfs_beg = eq_ind + 1;
	dfs_len = if (is_eq) length(ex.symbs) - eq_ind - 1 else length(ex.symbs) - eq_ind - 2;
	
	MmDefFactor(
		mmExp2ru(concat(if (is_eq) [MmSymb("class", false)] else [MmSymb("|-", false)], subrange(ex.symbs, dfm_beg, dfm_len))),
		mmExp2ru(concat(if (is_eq) [MmSymb("class", false)] else [MmSymb("|-", false)], subrange(ex.symbs, dfs_beg, dfs_len))),
		RuParseExp("wff", if (is_eq) ["defiendum", "=", "definiens"] else ["(", "defiendum", "<->", "definiens", ")"], -1),
	);
}

mmExp2ru(symbs : [MmSymb]) -> RuParseExp {
	if (symbs[0].literal == "|-") {
		RuParseExp("wff", map(tail(symbs), \s -> s.literal), -1);
	} else {
		RuParseExp(symbs[0].literal, map(tail(symbs), \s -> s.literal), -1);
	}
}

mmStatIsRule(stat : MmStat) -> bool {
	stat.expr.symbs[0].literal != "|-";
}

mmAssertionIsDef(ass : MmAssertion) -> bool {
	if (!startsWith(ass.stat.label, "df-")) false else {
		mmFactorDefEqInd(ass.stat.expr) > -1
	} 
}

ruRuleIsSuper(r : RuParseRule) -> bool {
	length(r.term.symbs) == 1 && length(r.vars) == 1;
}

ruRuleSuperType(r : RuParseRule) -> string {
	r.term.type
}

ruRuleInferType(r : RuParseRule) -> string {
	r.vars[0].type
}

mmRule2ru(ass : MmAssertion) -> RuParseRule {
	RuParseRule(
		ass.stat.label, 
		mmVars2ru(ass.hyps), 
		mmExp2ru(ass.stat.expr.symbs), 
		-1
	);
}

mmVars2ru(hyps : [MmHyp]) -> [RuParseVar] {
	filtermap(hyps, \h ->
		switch (h) {
			MmFloating(__, t, v): Some(RuParseVar(v, t, -1));
			default: None();
		}
	)
}

mmDisjs2ru(disjs : [MmDisj], vars : Set<string>) -> [RuParseDisj] {
	map(disjs, \d -> RuParseDisj(filter(d.vars, \v -> containsSet(vars, v)), -1))
}

MmRuSyntax(
	types : Tree<string, RuParseType>,
	rules : Tree<string, RuParseRule>,
	supers : Set<string>
);

mmMath2Syntax(math : MmMath) -> MmRuSyntax {
	axioms = mmMathAxiomatic(math);
	rules = filtermap(axioms, \ax -> 
		if (mmStatIsRule(ax.stat)) {
			Some(mmRule2ru(ax));
		} else {
			None();
		}
	);
	types = set2array(fold(rules, makeSet(), \acc, r -> 
		fold(r.vars, insertSet(acc, r.term.type), \ac, var -> insertSet(ac, var.type))
	));
	superTypesMap = fold(filter(rules, ruRuleIsSuper), makeTree(), \acc, r ->
		setTree(acc, ruRuleInferType(r), 
			switch (lookupTree(acc, ruRuleInferType(r))) {
				Some(supers): insertSet(supers, ruRuleSuperType(r));
				None():       makeSet1(ruRuleSuperType(r));
			}
		)
	);
	typeMap = values2tree(map(types, \t ->
			RuParseType(t, set2array(lookupTreeDef(superTypesMap, t, makeSet())), -1)
		),
		\t -> t.name
	);
	ruleMap = values2tree(rules, \r -> r.name);
	supers = buildSet(map(filter(rules, ruRuleIsSuper), \r -> r.term.type));
	MmRuSyntax(typeMap, ruleMap, supers);
}

Mm2RuExecAcc(
	stack : Maybe<MmRuStack>,
	subst : Tree<string, MmExp>,
	refs : [RuProofTree]
);

RuProofTree ::= RuProofTreeStep, RuProofTreeHyp, RuProofTreeNone;
	RuProofTreeStep(name  : string, expr  : RuParseExp, refs : [RuProofTree]);
	RuProofTreeHyp(ind : int, expr  : RuParseExp);
	RuProofTreeNone();

MmRuStack(
	parent : Maybe<MmRuStack>,
	expr   : MmExp,
	proof  : RuProofTree,
);

mm2ruPickFromStack(s : Maybe<MmRuStack>, mmHyps : [MmHyp]) -> Mm2RuExecAcc {
	fold(mmHyps, Mm2RuExecAcc(s, makeTree(), []),
		\acc, hyp -> {
			eitherMap(acc.stack,
				\stack -> {
					switch (hyp) {
						MmEssential(__, expr):
							Mm2RuExecAcc(stack.parent, acc.subst, concat([stack.proof], acc.refs));
						MmFloating(__, type, var):
							Mm2RuExecAcc(stack.parent, setTree(acc.subst, var, MmExp(tail(stack.expr.symbs))), acc.refs);
					}
				},
				acc
			)
		}
	)
}

mm2ruExecRPNstep(lab : string, stack : Maybe<MmRuStack>, th_hyps : [MmHyp], labeled : Tree<string, MmLabeled>) -> Maybe<MmRuStack> {
	switch (lookupTreeDef(labeled, lab, mmNoAssertion)) {
		MmAssertion(disj, hyps, inner, stat): {
			acc = mm2ruPickFromStack(stack, reverseA(hyps));
			applied = mmApplySubst(stat.expr, acc.subst);
			Some(MmRuStack(acc.stack, applied, 
				if (mmStatIsRule(stat)) RuProofTreeNone() else RuProofTreeStep(lab, mmExp2ru(applied.symbs), acc.refs)
			));
		}
		MmEssential(l, expr): {
			i = findiDef(th_hyps, \h -> l == h.label, -1);
			switch (th_hyps[i]) {
				MmEssential(__, ex):
					Some(MmRuStack(stack, expr, RuProofTreeHyp(i, mmExp2ru(ex.symbs))));
				default:
					Some(MmRuStack(stack, expr, RuProofTreeNone()));
			}
		}
		MmFloating(__, type, var):
			Some(MmRuStack(stack, MmExp([MmSymb(type, false), MmSymb(var, true)]), RuProofTreeNone()));
	}
}

mmTheorem2ru(ass : MmAssertion, stat : MmProvable, math : MmMath) -> [RuParseBlock] {
	th_hyps = mmAssertionHyps(ass.hyps);
	eitherMap(
		fold(stat.proof.labels, None(), \s, lab -> mm2ruExecRPNstep(lab, s, th_hyps, math.labeled)), 
		\stack -> {
			th_vars = mmVars2ru(ass.hyps);
			
			th_vars_map = fold(th_vars, makeTree(), \acc, v -> setTree(acc, v.name, v.type));
			steps = mmProofTree2ru(stack.proof, th_vars_map);
			vars_map = fold(mmAssertionFlos(concat(ass.hyps, ass.inner)), makeTree(), 
				\acc, v -> setTree(acc, v.var, RuVar(v.var, v.type))
			);
			make_var = \v -> lookupTreeDef(vars_map, v, ruNoVar);
			disj_set = fold(ass.disjs, makeSet(), \acc, disj -> 
				foldi(disj.vars, acc, \i, ac, v1 ->
					foldi(disj.vars, ac, \j, a, v2 ->
						if (i < j && containsKeyTree(vars_map, v1) && containsKeyTree(vars_map, v2)) {
							insertSet(a, RuDisj(make_var(v1), make_var(v2))) 
						} else a
					)
				)
			);
			th_ds = filterSet(disj_set, \d -> containsKeyTree(th_vars_map, d.v1.name) && containsKeyTree(th_vars_map, d.v2.name));
			pr_ds = filterSet(disj_set, \d -> !(containsKeyTree(th_vars_map, d.v1.name) && containsKeyTree(th_vars_map, d.v2.name)));
			
			make_disj = \s -> map(ruDisjs2Array(s), \ds -> RuParseDisj(map(set2array(ds), \d -> d.name), -1));
			if (steps == []) [] else {
				[RuParseTheorem(
					ass.stat.label, 
					th_vars, 
					make_disj(th_ds), 
					mapi(th_hyps, \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)), 
					mmExp2ru(ass.stat.expr.symbs), 
					RuParseProof(
						mmVars2ru(ass.inner), 
						make_disj(pr_ds),
						steps, -1
					), 
					-1
				)]
			}
		},
		[]
	);
}

MmRuProofAcc(
	steps : Tree<RuParseExp, int>,
	linear : [RuParseStep]
);

mmRemoveTrivialSteps(proof : RuProofTree) -> RuProofTree {
	switch (proof) {
		RuProofTreeStep(name, expr, refs): {
			new_proof = RuProofTreeStep(name, expr, map(refs, mmRemoveTrivialSteps));
			if (length(refs) != 1) {
				new_proof; 
			} else {
				switch (new_proof.refs[0]) {
					RuProofTreeStep(__, ex, __): 
						if (ex.symbs == expr.symbs) new_proof.refs[0] else new_proof;
					RuProofTreeHyp(__, ex): {
						if (ex.symbs == expr.symbs) new_proof.refs[0] else new_proof;
					}
					RuProofTreeNone(): new_proof;					
				}
			}
		}
		default: proof;
	}
}

mmProofTree2ru(proof : RuProofTree, vars : Tree<string, string>) -> [RuParseStep] {
	new_proof = mmRemoveTrivialSteps(proof);
	switch (new_proof) {
		RuProofTreeStep(__,__,__): 
			mmDoProofTree2ru(new_proof, MmRuProofAcc(makeTree(), []), vars).linear;
		default: [];
	}
}

mmDoProofTree2ru(proof : RuProofTreeStep, acc0 : MmRuProofAcc, vars : Tree<string, string>) -> MmRuProofAcc {
	acc1 = fold(proof.refs, acc0, \ac, ref -> 
		switch (ref) {
			RuProofTreeStep(__,__,__): mmDoProofTree2ru(ref, ac, vars);
			default: ac;
		}
	);
	switch (lookupTree(acc1.steps, proof.expr)) {
		Some(__): acc1;
		None(): {
			ind = length(acc1.linear);
			refs = fold(proof.refs, [], \ac, ref -> 
				switch (ref) {
					RuProofTreeStep(label, ex, refs):
						concat(ac, [RuParseStepRef(lookupTreeDef(acc1.steps, ex, -1), -1)]);
					RuProofTreeHyp(i,__): 
						concat(ac, [RuParseHypRef(i, -1)]);
					RuProofTreeNone(): ac;
				}
			);
			MmRuProofAcc(
				setTree(acc1.steps, proof.expr, ind),
				concat(acc1.linear, [RuParseStep(ind, proof.name, refs, proof.expr, -1)])
			);
		}
	}
}

ruNoParseType = RuParseType("__no", [], -1);
/*
ruParseMatchExactly(e : RuParseExp, pattern : RuParseExp, vars : Tree<string, string>) -> Maybe<Tree<string, string>> {
	if (length(e.symbs) != length(pattern.symbs)) None() else {
		foldi(e.symbs, Some(makeTree()), \i, acc, s1 -> {
			s2 = pattern.symbs[i];
			maybeBind(acc, \sub ->
				switch (lookupTree(vars, s1)) {
					None():
						switch (lookupTree(vars, s2)) {
							None(): if (s1 == s2) Some(sub) else None();
							Some(__): None();
						}
					Some(t1):
						switch (lookupTree(vars, s2)) {
							None(): None();
							Some(t2): 
								if (t1 != t2) None() else {
									switch (lookupTree(sub, s2)) {
										Some(w1): if (s1 == w1) Some(sub) else None();
										None(): Some(setTree(sub, s2, s1));
									}
								}
						}
				}
			)
		})
	}
}*/
