import parse/ru_parse_src;
import mm_src;

export {
	mmMath2ru(math : MmMath) -> Tree<string, RuParseSource>;
	//mmSource2ru(src : MmSource, math : MmMath, syntax : MmRuSyntax) -> RuParseSource;
}

mmMath2ru(math : MmMath) -> Tree<string, RuParseSource> {
	start = timestamp();
	syntax = mmMath2Syntax(math); 
	ret = mapTree(math.sources, \src -> mmSource2ru(src, math, syntax));
	if (math.conf.verbose > 0) {
		println("all translated to Russell in: " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

mmSource2ru(src : MmSource, math : MmMath, syntax : MmRuSyntax) -> RuParseSource {
	start = timestamp();
	ret = RuParseSource(
		map(src.includes, \inc -> RuParseImport(inc.file, -1)),
		fold(src.decls, [], \acc, decl ->
			concat(acc, mmDecl2ru(decl, math, syntax))
		),
		RuFileInfo(
			src.info.file,
			mmMakeRuPath(src.info, math.conf),
			0.0, 0.0
		)
	);
	if (math.conf.verbose > 1) {
		println("translated toRussell: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

mmMakeRuPath(info : RuFileInfo, conf : RuConf) -> string {
	ruRoot0 = lookupTreeDef(conf.opts, "ru-root", "");
	if (ruRoot0 != "") {
		ruRoot = if (endsWith(ruRoot0, "/")) ruRoot0 else ruRoot0 + "/";
		ruRoot + info.file + ".ru"
	} else {
		info.file + ".ru"
	}
}

mmDecl2ru(decl : MmDecl, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	switch (decl) {
		MmComment(text): [RuParseComment(text, -1)];
		MmConst(symbs):
			fold(symbs, [], \acc, s -> 
				switch (lookupTree(syntax.types, s)) {
					Some(t):
						concat(
							fold(t.supers, acc, \ac, sup -> 
								concat(ac, [lookupTreeDef(syntax.types, sup, ruNoParseType)])
							),
							[t]
						);
					None(): concat(acc, [mmConst2ru(s, math.conf)]);
				}
			);
		MmAssertion(disjs, hyps, inner, stat): mmAssertion2ru(decl, math, syntax);
	}
}

mmSymb2ru(s : string, conf : RuConf) -> string {
	s
}

mmConst2ru(s : string, conf : RuConf) -> RuParseConst {
	RuParseConst(s, s, "", -1)
}

mmAssertion2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	switch (lookupTree(syntax.rules, ass.stat.label)) {
		Some(r): [r];
		None(): {
			switch (ass.stat) {
				MmProvable(__,__,__): 
					mmTheorem2ru(ass, ass.stat, math);
				MmAxiomatic(l,__): 
					if (startsWith(l, "df-")) {
						mmDef2ru(ass, math, syntax); 
					} else {
						mmAxiom2ru(ass, math, syntax);
					}
			}
		}
	}
}

mmAssertionHyps(hyps : [MmHyp]) -> [MmEssential] {
	filtermap(hyps, \h -> 
		switch (h) {
			MmEssential(__,__): Some(h);
			default: None();
		}
	)
}

mmAxiom2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	[RuParseAxiom(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)), 
		mmExp2ru(ass.stat.expr.symbs), -1
	)];
}

MmDefFactor(
	defm : RuParseExp,
	defs : RuParseExp,
	def : RuParseExp,
);

mmDef2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	defFactor = mmFactorDef(ass.stat.expr);
	[RuParseDef(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)),
		defFactor.defm, defFactor.defs, defFactor.def, -1
	)];
}

MmFactorDefEqAcc(
	braces : int,
	brackets : int,
	eq : int
);

mmFactorDefEqInd(ex : MmExp) -> int {
	low_br = \ac -> (ac.braces <= 1 && ac.brackets == 0) || (ac.braces == 0 && ac.brackets <= 1);
	foldi(ex.symbs, MmFactorDefEqAcc(0, 0, -1), \i, ac, s ->
		if (ac.eq != -1) ac else
		if (s.literal == "(") MmFactorDefEqAcc(ac with brackets = ac.brackets + 1) else 
		if (s.literal == "{") MmFactorDefEqAcc(ac with braces   = ac.braces + 1) else
		if (s.literal == ")") MmFactorDefEqAcc(ac with brackets = ac.brackets - 1) else
		if (s.literal == "}") MmFactorDefEqAcc(ac with braces   = ac.braces - 1) else
		if ((s.literal == "=" || s.literal == "<->") && low_br(ac)) MmFactorDefEqAcc(ac with eq = i) else ac
	).eq
}

mmFactorDef(ex : MmExp) -> MmDefFactor {
	eq_ind = mmFactorDefEqInd(ex);
	is_eq = ex.symbs[eq_ind].literal == "=";
	dfm_beg = if (is_eq) 1 else 2;
	dfm_len = if (is_eq) eq_ind - 1 else eq_ind - 2;
	dfs_beg = eq_ind + 1;
	dfs_len = if (is_eq) length(ex.symbs) - eq_ind else length(ex.symbs) - eq_ind - 1;
	
	MmDefFactor(
		mmExp2ru(concat(if (is_eq) [MmSymb("setvar", false)] else [MmSymb("|-", false)], subrange(ex.symbs, dfm_beg, dfm_len))),
		mmExp2ru(concat(if (is_eq) [MmSymb("setvar", false)] else [MmSymb("|-", false)], subrange(ex.symbs, dfs_beg, dfs_len))),
		RuParseExp("wff", if (is_eq) ["defiendum", "=", "definiens"] else ["(", "defiendum", "=", "definiens", ")"], -1),
	);
}

mmExp2ru(symbs : [MmSymb]) -> RuParseExp {
	if (symbs[0].literal == "|-") {
		RuParseExp("wff", map(tail(symbs), \s -> s.literal), -1);
	} else {
		RuParseExp(symbs[0].literal, map(tail(symbs), \s -> s.literal), -1);
	}
}

mmAssertionIsRule(ass : MmAssertion) -> bool {
	ass.stat.expr.symbs[0].literal != "|-";
}

ruRuleIsSuper(r : RuParseRule) -> bool {
	length(r.term.symbs) == 1;
}

ruRuleSuperType(r : RuParseRule) -> string {
	r.term.type
}

ruRuleInferType(r : RuParseRule) -> string {
	r.vars[0].type
}

mmRule2ru(ass : MmAssertion) -> RuParseRule {
	RuParseRule(
		ass.stat.label, 
		mmVars2ru(ass.hyps), 
		mmExpr2ru(ass.stat.expr), 
		-1
	);
}

mmVars2ru(hyps : [MmHyp]) -> [RuParseVar] {
	filtermap(hyps, \h ->
		switch (h) {
			MmFloating(__, v, t): Some(RuParseVar(v, t, -1));
			default: None();
		}
	)
}

mmDisjs2ru(disjs : [MmDisj]) -> [RuParseDisj] {
	map(disjs, \d -> RuParseDisj(d.vars, -1))
}

mmExpr2ru(ex : MmExp) -> RuParseExp {
	RuParseExp(ex.symbs[0].literal, map(tail(ex.symbs), \s -> s.literal), -1);
}

MmRuSyntax(
	types : Tree<string, RuParseType>,
	rules : Tree<string, RuParseRule>,
	supers : Tree<string, RuParseRule>
);

mmMath2Syntax(math : MmMath) -> MmRuSyntax {
	axioms = mmMathAxiomatic(math);
	rules = filtermap(axioms, \ax -> 
		if (mmAssertionIsRule(ax)) {
			Some(mmRule2ru(ax));
		} else {
			None();
		}
	)
	types = set2array(fold(rules, makeSet(), \acc, r -> 
		fold(r.vars, insertSet(acc, r.term.type), \ac, var -> insertSet(ac, var.type))
	));
	superTypesMap = fold(filter(rules, ruRuleIsSuper), makeTree(), \acc, r ->
		setTree(acc, ruRuleInferType(r), 
			switch (lookupTree(acc, ruRuleInferType(r))) {
				Some(supers): insertSet(supers, ruRuleSuperType(r));
				None():       makeSet1(ruRuleSuperType(r));
			}
		)
	);
	typeMap = values2tree(map(types, \t ->
			RuParseType(t, set2array(lookupTreeDef(superTypesMap, t, makeSet())), -1)
		),
		\t -> t.name
	);
	ruleMap = values2tree(filter(rules, \r -> !ruRuleIsSuper(r)), \r -> r.name);
	supersMap = values2tree(filter(rules, ruRuleIsSuper), \r -> r.name);
	MmRuSyntax(typeMap, ruleMap, supersMap);
}

Mm2RuExecAcc(
	stack : Maybe<MmRuStack>,
	subst : Tree<string, MmExp>,
	refs : [RuProofTree]
);

RuProofTree ::= RuProofTreeStep, RuProofTreeHyp, RuProofTreeNone;
	RuProofTreeStep(name  : string, expr  : RuParseExp, refs : [RuProofTree]);
	RuProofTreeHyp(ind : int);
	RuProofTreeNone();

MmRuStack(
	parent : Maybe<MmRuStack>,
	expr   : MmExp,
	proof  : RuProofTree,
);

mm2ruPickFromStack(s : Maybe<MmRuStack>, mmHyps : [MmHyp]) -> Mm2RuExecAcc {
	fold(mmHyps, Mm2RuExecAcc(s, makeTree(), []),
		\acc, hyp -> {
			eitherMap(acc.stack,
				\stack -> {
					switch (hyp) {
						MmEssential(__, expr): {
							Mm2RuExecAcc(
								stack.parent, 
								acc.subst,
								concat([stack.proof], acc.refs), 
							);
						}
						MmFloating(__, type, var): {
							Mm2RuExecAcc(
								stack.parent,
								setTree(acc.subst, var, MmExp(tail(stack.expr.symbs))),
								acc.refs,
							);
						}
					}
				},
				acc
			)
		}
	)
}

mm2ruExecRPNstep(lab : string, stack : Maybe<MmRuStack>, theorem : MmAssertion, labeled : Tree<string, MmLabeled>) -> Maybe<MmRuStack> {
	switch (lookupTreeDef(labeled, lab, mmNoAssertion)) {
		MmAssertion(disj, hyps, inner, statement): {
			acc = mm2ruPickFromStack(stack, reverseA(hyps));
			applied = mmApplySubst(statement.expr, acc.subst);
			Some(MmRuStack(acc.stack, applied, RuProofTreeStep(lab, mmExpr2ru(applied), acc.refs)));
		}
		MmEssential(l, expr):
			Some(MmRuStack(stack, expr, RuProofTreeHyp(findiDef(theorem.hyps, \h -> l == h.label, -1))));
		MmFloating(__, type, var):
			Some(MmRuStack(stack, MmExp([MmSymb(type, false), MmSymb(var, true)]), RuProofTreeNone()));
	}
}

mmTheorem2ru(ass : MmAssertion, stat : MmProvable, math : MmMath) -> [RuParseBlock] {
	mstack = fold(stat.proof.labels, None(), \s, lab -> mm2ruExecRPNstep(lab, s, ass, math.labeled));
	steps = eitherMap(mstack, \stack -> mmProofTree2ru(stack.proof), []);
	[RuParseTheorem(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)), 
		mmExp2ru(ass.stat.expr.symbs), RuParseProof([], [] /* TODO */, steps, -1), -1
	)];
}








MmRuProofAcc(
	steps : Tree<RuParseExp, int>,
	linear : [RuParseStep]
);

mmProofTree2ru(proof : RuProofTree) -> [RuParseStep] {
	switch (proof) {
		RuProofTreeStep(__,__,__): mmDoProofTree2ru(proof, MmRuProofAcc(makeTree(), [])).linear;
		default: [];
	}
}

mmDoProofTree2ru(proof : RuProofTreeStep, acc0 : MmRuProofAcc) -> MmRuProofAcc {
	acc1 = fold(proof.refs, acc0, \ac, ref -> 
		switch (ref) {
			RuProofTreeStep(__,__,__): mmDoProofTree2ru(ref, ac);
			default: ac;
		}
	);
	switch (lookupTree(acc1.steps, proof.expr)) {
		Some(__): acc1;
		None(): {
			ind = length(acc1.linear);
			refs = fold(proof.refs, [], \ac, ref -> 
				switch (ref) {
					RuProofTreeStep(__, ex, __): concat(ac, [RuParseStepRef(lookupTreeDef(acc1.steps, ex, -1), -1)]);
					RuProofTreeHyp(i): concat(ac, [RuParseHypRef(i, -1)]);
					RuProofTreeNone(): ac;
				}
			);
			MmRuProofAcc(
				setTree(acc1.steps, proof.expr, ind),
				concat(acc1.linear, [RuParseStep(ind, proof.name, refs, proof.expr, -1)])
			);
		}
	}
}

ruNoParseType = RuParseType("__no", [], -1);
