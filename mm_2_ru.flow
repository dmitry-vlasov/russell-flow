import parse/ru_parse_src;
import ru_src;
import mm_src;

export {
	mmMath2ru(math : MmMath) -> Tree<string, RuParseSource>;
	//mmSource2ru(src : MmSource, math : MmMath, syntax : MmRuSyntax) -> RuParseSource;
}

mmMath2ru(math : MmMath) -> Tree<string, RuParseSource> {
	start = timestamp();
	syntax = mmMath2Syntax(math); 
	ret = mapTree(math.sources, \src -> mmSource2ru(src, math, syntax));
	if (math.conf.verbose > 0) {
		println("all translated to Russell in: " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

mmSource2ru(src : MmSource, math : MmMath, syntax : MmRuSyntax) -> RuParseSource {
	start = timestamp();
	ret = RuParseSource(
		map(src.includes, \inc -> RuParseImport(inc.file, -1)),
		fold(src.decls, [], \acc, decl ->
			concat(acc, mmDecl2ru(decl, math, syntax))
		),
		RuFileInfo(
			src.info.file,
			mmMakeRuPath(src.info, math.conf),
			0.0, 0.0
		)
	);
	if (math.conf.verbose > 1) {
		println("translated toRussell: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

mmMakeRuPath(info : RuFileInfo, conf : RuConf) -> string {
	ruRoot0 = lookupTreeDef(conf.opts, "ru-root", "");
	if (ruRoot0 != "") {
		ruRoot = if (endsWith(ruRoot0, "/")) ruRoot0 else ruRoot0 + "/";
		ruRoot + info.file + ".rus"
	} else {
		info.file + ".rus"
	}
}

mmDecl2ru(decl : MmDecl, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	switch (decl) {
		MmComment(text): [RuParseComment(text, -1)];
		MmConst(symbs):
			fold(symbs, [], \acc, s -> 
				switch (lookupTree(syntax.types, s)) {
					Some(t):
						concat(
							fold(t.supers, acc, \ac, sup -> 
								concat(ac, [lookupTreeDef(syntax.types, sup, ruNoParseType)])
							),
							[t]
						);
					None(): concat(acc, [mmConst2ru(s, math.conf)]);
				}
			);
		MmAssertion(disjs, hyps, inner, stat): mmAssertion2ru(decl, math, syntax);
	}
}

mmSymb2ru(s : string, conf : RuConf) -> string {
	s
}

mmConst2ru(s : string, conf : RuConf) -> RuParseConst {
	RuParseConst(s, "", "", -1)
}

mmAssertion2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	switch (lookupTree(syntax.rules, ass.stat.label)) {
		Some(r): [r];
		None(): {
			switch (ass.stat) {
				MmProvable(__,__,__): 
					mmTheorem2ru(ass, ass.stat, math);
				MmAxiomatic(l,__): 
					if (mmAssertionIsDef(ass)) {
						mmDef2ru(ass, math, syntax); 
					} else {
						mmAxiom2ru(ass, math, syntax);
					}
			}
		}
	}
}

mmAssertionHyps(hyps : [MmHyp]) -> [MmEssential] {
	filtermap(hyps, \h -> 
		switch (h) {
			MmEssential(__,__): Some(h);
			default: None();
		}
	)
}

mmAssertionFlos(hyps : [MmHyp]) -> [MmFloating] {
	filtermap(hyps, \h -> 
		switch (h) {
			MmFloating(__,__,__): Some(h);
			default: None();
		}
	)
}


mmAxiom2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	[RuParseAxiom(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs, mmAssertionVars(ass)), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)), 
		mmExp2ru(ass.stat.expr.symbs), -1
	)];
}

MmDefFactor(
	defm : RuParseExp,
	defs : RuParseExp,
	def : RuParseExp,
);

mmDef2ru(ass : MmAssertion, math : MmMath, syntax : MmRuSyntax) -> [RuParseBlock] {
	defFactor = mmFactorDef(ass.stat.expr);
	[RuParseDef(ass.stat.label, mmVars2ru(ass.hyps), mmDisjs2ru(ass.disjs, mmAssertionVars(ass)), 
		mapi(mmAssertionHyps(ass.hyps), \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)),
		defFactor.defm, defFactor.defs, defFactor.def, -1
	)];
}

MmFactorDefEqAcc(
	braces : int,
	brackets : int,
	eq : int
);

mmFactorDefEqInd(ex : MmExp) -> int {
	is_eq = ex.symbs[1].literal != "(";
	foldi(ex.symbs, MmFactorDefEqAcc(0, 0, -1), \i, ac, s ->
		if (ac.eq != -1) ac else
		if (s.literal == "(") MmFactorDefEqAcc(ac with brackets = ac.brackets + 1) else 
		if (s.literal == "{") MmFactorDefEqAcc(ac with braces   = ac.braces + 1) else
		if (s.literal == ")") MmFactorDefEqAcc(ac with brackets = ac.brackets - 1) else
		if (s.literal == "}") MmFactorDefEqAcc(ac with braces   = ac.braces - 1) else
		if (s.literal == "="   && is_eq  && ac.braces == 0) MmFactorDefEqAcc(ac with eq = i) else
		if (s.literal == "<->" && !is_eq && ac.brackets == 1) MmFactorDefEqAcc(ac with eq = i) else ac
	).eq
}

mmFactorDef(ex : MmExp) -> MmDefFactor {
	eq_ind = mmFactorDefEqInd(ex);
	is_eq = ex.symbs[eq_ind].literal == "=";
	dfm_beg = if (is_eq) 1 else 2;
	dfm_len = if (is_eq) eq_ind - 1 else eq_ind - 2;
	dfs_beg = eq_ind + 1;
	dfs_len = if (is_eq) length(ex.symbs) - eq_ind - 1 else length(ex.symbs) - eq_ind - 2;
	
	MmDefFactor(
		mmExp2ru(concat(if (is_eq) [MmSymb("class", false)] else [MmSymb("|-", false)], subrange(ex.symbs, dfm_beg, dfm_len))),
		mmExp2ru(concat(if (is_eq) [MmSymb("class", false)] else [MmSymb("|-", false)], subrange(ex.symbs, dfs_beg, dfs_len))),
		RuParseExp("wff", if (is_eq) ["defiendum", "=", "definiens"] else ["(", "defiendum", "<->", "definiens", ")"], -1),
	);
}

mmExp2ru(symbs : [MmSymb]) -> RuParseExp {
	if (symbs[0].literal == "|-") {
		RuParseExp("wff", map(tail(symbs), \s -> s.literal), -1);
	} else {
		RuParseExp(symbs[0].literal, map(tail(symbs), \s -> s.literal), -1);
	}
}

mmAssertionIsRule(ass : MmAssertion) -> bool {
	ass.stat.expr.symbs[0].literal != "|-";
}

mmAssertionIsDef(ass : MmAssertion) -> bool {
	if (!startsWith(ass.stat.label, "df-")) false else {
		mmFactorDefEqInd(ass.stat.expr) > -1
	} 
}

ruRuleIsSuper(r : RuParseRule) -> bool {
	length(r.term.symbs) == 1 && length(r.vars) == 1;
}

ruRuleSuperType(r : RuParseRule) -> string {
	r.term.type
}

ruRuleInferType(r : RuParseRule) -> string {
	r.vars[0].type
}

mmRule2ru(ass : MmAssertion) -> RuParseRule {
	RuParseRule(
		ass.stat.label, 
		mmVars2ru(ass.hyps), 
		mmExp2ru(ass.stat.expr.symbs), 
		-1
	);
}

mmVars2ru(hyps : [MmHyp]) -> [RuParseVar] {
	filtermap(hyps, \h ->
		switch (h) {
			MmFloating(__, t, v): Some(RuParseVar(v, t, -1));
			default: None();
		}
	)
}

mmDisjs2ru(disjs : [MmDisj], vars : Set<string>) -> [RuParseDisj] {
	map(disjs, \d -> RuParseDisj(filter(d.vars, \v -> containsSet(vars, v)), -1))
}

MmRuSyntax(
	types : Tree<string, RuParseType>,
	rules : Tree<string, RuParseRule>
);

mmMath2Syntax(math : MmMath) -> MmRuSyntax {
	axioms = mmMathAxiomatic(math);
	rules = filtermap(axioms, \ax -> 
		if (mmAssertionIsRule(ax)) {
			Some(mmRule2ru(ax));
		} else {
			None();
		}
	)
	//println("rules: " + strGlue(map(rules, \r -> ruParse2s(r)), " "));
	types = set2array(fold(rules, makeSet(), \acc, r -> 
		fold(r.vars, insertSet(acc, r.term.type), \ac, var -> insertSet(ac, var.type))
	));
	//println("types: " + strGlue(types, " "));
	superTypesMap = fold(filter(rules, ruRuleIsSuper), makeTree(), \acc, r ->
		setTree(acc, ruRuleInferType(r), 
			switch (lookupTree(acc, ruRuleInferType(r))) {
				Some(supers): insertSet(supers, ruRuleSuperType(r));
				None():       makeSet1(ruRuleSuperType(r));
			}
		)
	);
	typeMap = values2tree(map(types, \t ->
			RuParseType(t, set2array(lookupTreeDef(superTypesMap, t, makeSet())), -1)
		),
		\t -> t.name
	);
	ruleMap = values2tree(filter(rules, \r -> !ruRuleIsSuper(r)), \r -> r.name);
	//supersMap = values2tree(filter(rules, ruRuleIsSuper), \r -> r.name);
	MmRuSyntax(typeMap, ruleMap);
}

Mm2RuExecAcc(
	stack : Maybe<MmRuStack>,
	subst : Tree<string, MmExp>,
	refs : [RuProofTree]
);

RuProofTree ::= RuProofTreeStep, RuProofTreeHyp, RuProofTreeNone;
	RuProofTreeStep(name  : string, expr  : RuParseExp, refs : [RuProofTree]);
	RuProofTreeHyp(ind : int);
	RuProofTreeNone();

MmRuStack(
	parent : Maybe<MmRuStack>,
	expr   : MmExp,
	proof  : RuProofTree,
);

mm2ruPickFromStack(s : Maybe<MmRuStack>, mmHyps : [MmHyp]) -> Mm2RuExecAcc {
	fold(mmHyps, Mm2RuExecAcc(s, makeTree(), []),
		\acc, hyp -> {
			eitherMap(acc.stack,
				\stack -> {
					switch (hyp) {
						MmEssential(__, expr):
							Mm2RuExecAcc(stack.parent, acc.subst, concat([stack.proof], acc.refs));
						MmFloating(__, type, var):
							Mm2RuExecAcc(stack.parent, setTree(acc.subst, var, MmExp(tail(stack.expr.symbs))), acc.refs);
					}
				},
				acc
			)
		}
	)
}

mm2ruExecRPNstep(lab : string, stack : Maybe<MmRuStack>, th_hyps : [MmHyp], labeled : Tree<string, MmLabeled>) -> Maybe<MmRuStack> {
	switch (lookupTreeDef(labeled, lab, mmNoAssertion)) {
		MmAssertion(disj, hyps, inner, statement): {
			acc = mm2ruPickFromStack(stack, reverseA(hyps));
			applied = mmApplySubst(statement.expr, acc.subst);
			Some(MmRuStack(acc.stack, applied, RuProofTreeStep(lab, mmExp2ru(applied.symbs), acc.refs)));
		}
		MmEssential(l, expr):
			Some(MmRuStack(stack, expr, RuProofTreeHyp(findiDef(th_hyps, \h -> l == h.label, -1))));
		MmFloating(__, type, var):
			Some(MmRuStack(stack, MmExp([MmSymb(type, false), MmSymb(var, true)]), RuProofTreeNone()));
	}
}

mmTheorem2ru(ass : MmAssertion, stat : MmProvable, math : MmMath) -> [RuParseBlock] {
	th_hyps = mmAssertionHyps(ass.hyps);
	eitherMap(
		fold(stat.proof.labels, None(), \s, lab -> mm2ruExecRPNstep(lab, s, th_hyps, math.labeled)), 
		\stack -> {
			steps = mmProofTree2ru(stack.proof);
			th_vars = mmVars2ru(ass.hyps);
			th_vars_set = fold(th_vars, makeSet(), \acc, v -> insertSet(acc, v.name));
			vars_map = fold(mmAssertionFlos(concat(ass.hyps, ass.inner)), makeTree(), 
				\acc, v -> setTree(acc, v.var, RuVar(v.var, v.type))
			);
			make_var = \v -> lookupTreeDef(vars_map, v, ruNoVar);
			disj_set = fold(ass.disjs, makeSet(), \acc, disj -> 
				foldi(disj.vars, acc, \i, ac, v1 ->
					foldi(disj.vars, ac, \j, a, v2 ->
						if (i < j && containsKeyTree(vars_map, v1) && containsKeyTree(vars_map, v2)) {
							insertSet(a, RuDisj(make_var(v1), make_var(v2))) 
						} else a
					)
				)
			);
			th_ds = filterSet(disj_set, \d -> containsSet(th_vars_set, d.v1.name) && containsSet(th_vars_set, d.v2.name));
			pr_ds = filterSet(disj_set, \d -> !(containsSet(th_vars_set, d.v1.name) && containsSet(th_vars_set, d.v2.name)));
			
			make_disj = \s -> map(ruDisjs2Array(s), \ds -> RuParseDisj(map(set2array(ds), \d -> d.name), -1));
			if (steps == []) [] else {
				[RuParseTheorem(
					ass.stat.label, 
					th_vars, 
					make_disj(th_ds), 
					mapi(th_hyps, \i, h -> RuParseHyp(i, mmExp2ru(h.expr.symbs), -1)), 
					mmExp2ru(ass.stat.expr.symbs), 
					RuParseProof(
						mmVars2ru(ass.inner), 
						make_disj(pr_ds),
						steps, -1
					), 
					-1
				)]
			}
		},
		[]
	);
}








MmRuProofAcc(
	steps : Tree<RuParseExp, int>,
	linear : [RuParseStep]
);

mmProofTree2ru(proof : RuProofTree) -> [RuParseStep] {
	switch (proof) {
		RuProofTreeStep(__,__,__): mmDoProofTree2ru(proof, MmRuProofAcc(makeTree(), [])).linear;
		default: [];
	}
}

mmDoProofTree2ru(proof : RuProofTreeStep, acc0 : MmRuProofAcc) -> MmRuProofAcc {
	acc1 = fold(proof.refs, acc0, \ac, ref -> 
		switch (ref) {
			RuProofTreeStep(__,__,__): mmDoProofTree2ru(ref, ac);
			default: ac;
		}
	);
	switch (lookupTree(acc1.steps, proof.expr)) {
		Some(__): acc1;
		None(): {
			ind = length(acc1.linear);
			refs = fold(proof.refs, [], \ac, ref -> 
				switch (ref) {
					RuProofTreeStep(__, ex, __): concat(ac, [RuParseStepRef(lookupTreeDef(acc1.steps, ex, -1), -1)]);
					RuProofTreeHyp(i): concat(ac, [RuParseHypRef(i, -1)]);
					RuProofTreeNone(): ac;
				}
			);
			MmRuProofAcc(
				setTree(acc1.steps, proof.expr, ind),
				concat(acc1.linear, [RuParseStep(ind, proof.name, refs, proof.expr, -1)])
			);
		}
	}
}

ruNoParseType = RuParseType("__no", [], -1);
