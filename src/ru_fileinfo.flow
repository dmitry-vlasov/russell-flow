import ru_conf;

export {

RuFileInfo(
	file : string, // The path as used by flow imports
	path : string, // The full filesystem path
	time : double, // The timestamp of the source file
	//md5sum : string,
	//filesize : double,
	lastupdate : double, // The timestamp of the last successfull compilation
);

ruMakeFileInfo(file : string, path : string) -> RuFileInfo;

ruNoFileInfo = ruMakeFileInfo("__no", "__no");

RuPath(
	dirs : [string],
	file : string
);

ruPath2s(path : RuPath) -> string;
ruSplitPath(path : string) -> RuPath;
ruCommonDir(paths : [RuPath]) -> RuPath;

RuWriteSource(data : string, info : RuFileInfo);
ruWriteSources(srcs : [RuWriteSource], conf : RuConf) -> void;

}

ruWriteSources(srcs : [RuWriteSource], conf : RuConf) -> void {
	start = timestamp();
	ext = ltrim2(getFileExt(srcs[0].info.path), ".");
	write_src = \src -> {
		path = src.info.path;
		ensureDirectoryExists(ruDirName(path));
		if (conf.verbose > 1) {
			println(ext + " writing : " + path);
		}
		if (!setFileContent(path, src.data)) {
			println("error while writing " + path);
		}
	}
	iter(srcs, write_src);
	if (conf.verbose > 0 && srcs != []) {
		println(ext + " written: " + i2s(length(srcs)) + " files in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
}

ruMakeFileInfo(file : string, path : string) -> RuFileInfo {
	RuFileInfo(
		file,
		path,
		fileModified(file),
		timestamp()
	)
}

ruPath2s(path : RuPath) -> string {
	(if (path.dirs != []) strGlue(path.dirs, "/") + "/" else "") + path.file
}

ruSplitPath(path : string) -> RuPath {
	file = fileNameOnly(path);
	dir = ruDirName(path);
	if (dir != "") {
		RuPath(ruSplitDir(dir), file);
	} else {
		RuPath([], file);
	}
}

ruSplitDir(path : string) -> [string] {
	dir = fileNameOnly(path);
	left = ruDirName(path);
	if (left == "" || left == path) [dir] else concat(ruSplitDir(left), [dir]);
}

ruCommonDir(paths : [RuPath]) -> RuPath {
	if (paths == []) RuPath([], "") else {
		RuPath(
			fold(tail(paths), paths[0].dirs, \acc, path ->
				fold(zipWith(path.dirs, acc, \d1, d2 -> Pair(d1, d2)), Pair([], true), \ac, p ->
					if (p.first == p.second && ac.second) Pair(concat(ac.first, [p.first]), true) else Pair(ac.first, false)
				).first
			), 
			""
		);
	}
}
