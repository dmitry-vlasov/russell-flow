import utctime;
import ru_conf;
import ru_println;

export {

	RuFileInfo(
		file : string, // The path as used by flow imports
		path : string, // The full filesystem path
		modified : double, // The timestamp of the source file
		mutable source : string
	);

	ruMakeFileInfo(file : string, path : string) -> RuFileInfo;
	ruUpdateFileInfo(info : RuFileInfo) -> RuFileInfo;

	ruNoFileInfo = ruMakeFileInfo("__no", "__no");

	RuPath(
		dirs : [string],
		file : string
	);

	ruPath2s(path : RuPath) -> string;
	ruSplitPath(path : string) -> RuPath;
	ruCommonDir(paths : [RuPath]) -> RuPath;

	RuWriteSource(data : string, info : RuFileInfo);
	ruWriteSources(srcs : [RuWriteSource], conf : RuConf) -> void;

	ruFileChanged(info : RuFileInfo) -> bool;
	ruFileChangedMessage(info : RuFileInfo) -> string;
}

ruWriteSources(srcs : [RuWriteSource], conf : RuConf) -> void {
	start = timestamp();
	ext = ltrim2(getFileExt(srcs[0].info.path), ".");
	write_src = \src -> {
		path = src.info.path;
		ensureDirectoryExists(ruDirName(path));
		if (conf.verbose > 1) {
			ruPrintln(ext + " writing : " + path);
		}
		if (!setFileContent(path, src.data)) {
			ruPrintln("error while writing " + path);
		}
	}
	iter(srcs, write_src);
	if (conf.verbose > 0 && srcs != []) {
		ruPrintln(ext + " written: " + i2s(length(srcs)) + " files in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
}

ruMakeFileInfo(file : string, path : string) -> RuFileInfo {
	RuFileInfo(file, path, fileModified(path), "");
}

ruUpdateFileInfo(info : RuFileInfo) -> RuFileInfo {
	RuFileInfo(info with modified = fileModified(info.path));
}

ruPath2s(path : RuPath) -> string {
	(if (path.dirs != []) strGlue(path.dirs, "/") + "/" else "") + path.file
}

ruSplitPath(path : string) -> RuPath {
	file = fileNameOnly(path);
	dir = ruDirName(path);
	if (dir != "") {
		RuPath(ruSplitDir(dir), file);
	} else {
		RuPath([], file);
	}
}

ruSplitDir(path : string) -> [string] {
	dir = fileNameOnly(path);
	left = ruDirName(path);
	if (left == "" || left == path) [dir] else concat(ruSplitDir(left), [dir]);
}

ruCommonDir(paths : [RuPath]) -> RuPath {
	if (paths == []) RuPath([], "") else {
		RuPath(
			fold(tail(paths), paths[0].dirs, \acc, path ->
				fold(zipWith(path.dirs, acc, \d1, d2 -> Pair(d1, d2)), Pair([], true), \ac, p ->
					if (p.first == p.second && ac.second) Pair(concat(ac.first, [p.first]), true) else Pair(ac.first, false)
				).first
			), 
			""
		);
	}
}

ruFileChanged(info : RuFileInfo) -> bool {
	info.modified != fileModified(info.path);
}

ruFileChangedMessage(info : RuFileInfo) -> string {
	modified = fileModified(info.path);
	if (!fileExists(info.path)) {
		"file " + info.path + " doesn't exist";
	} else {
		if (info.modified == modified) "" else {
			"file '" + info.file + "' is obsolete with timestamp '" + time2stringUtc(info.modified) + "' while source has '" + time2stringUtc(modified) + "'";
		}
	}
}
