import lsp_types;
import ru_run;

export {

ruDecodeJsonRequest(s : string) -> Json;
ruLspReadRequest() -> Maybe<string>;
ruLspProcessRequest(conf : RuConf, json : Json,  out_cb : (string) ->  void, loop_cb : () -> void, exit_cb : () -> void) -> void;
}

ruJsonObjectHasField(obj : JsonObject, field : string) -> bool {
	exists(obj.members, \member -> member.first == field)
}

ruDecodeJsonRequest(s : string) -> Json {
	json = parseJsonSafe(s);
	switch (json) {
		JsonObject(members): {
			if (ruJsonObjectHasField(json, "jsonrpc") &&
				ruJsonObjectHasField(json, "method")
			) {
				json
			} else {
				JsonNull();
			}
		}
		default: JsonNull();
	}
}

RuLspRequestHeader(
	length : int,  // Content-Length
	type : string, // Content-Type
);

ruLspReadHeader() -> Maybe<RuLspRequestHeader> {
	fold(
		for([], 
			\ls -> trim2(lastElement(ls, "1"), " \n\r\t") != "", 
			\ls -> concat(ls, [trim2(readln(), " \n\r\t")])
		),
		Some(RuLspRequestHeader(-1, "")),
		\acc, line -> maybeBind(acc, \header -> {
			if (line == "") acc else {
				key = trim2(takeBefore(line, ":", ""), " ");
				value = trim2(takeAfter(line, ":", ""), " ");
				if (key == "Content-Length") {
					Some(RuLspRequestHeader(header with length = s2i(value)));
				} else if (key == "Content-Type") {
					Some(RuLspRequestHeader(header with type = value));
				} else {
					None();
				}
			}
		})
	);
}

ruLspReadRequest() -> Maybe<string> {
	maybeBind(ruLspReadHeader(), \header ->
		if (header.length == -1) {
			None();
		} else {
			Some(for("", \s -> strlen(s) + 1 < header.length, \s -> s + readln() + "\n"));
		}
	);
}

RuLspMethodCall(
	conf : RuConf,
	id : Json, 
	params : Json, 
	out_cb : (Json) ->  void, 
	loop_cb : () -> void, 
	exit_cb : () -> void
);

ruLspMethods = pairs2tree([
	Pair("initialize", ruLspInitialize),
	Pair("initialized", ruLspInitialized),
	Pair("shutdown", ruLspShutdown),
	Pair("exit", ruLspExit),
	Pair("textDocument/didOpen", ruLspTextDocumentDidOpen),
	Pair("textDocument/didChange", ruLspTextDocumentDidChange),
	Pair("textDocument/documentSymbol", ruLspTextDocumentDocumentSymbol),
	Pair("textDocument/declaration", ruLspTextDocumentDeclaration),
	Pair("textDocument/definition", ruLspTextDocumentDefinition),
	Pair("textDocument/references", ruLspTextDocumentReferences),
	Pair("textDocument/hover", ruLspTextDocumentHover),
	Pair("textDocument/rename", ruLspTextDocumentRename),
]);

ruLspClientConf : ref Json = ref JsonObject([]);

ruLspErrorResponse(id : Json, code : int, msg : string) -> Json {
	JsonObject([Pair("id", id), Pair("jsonrpc", JsonString("2.0")), Pair("result", JsonNull()), 
		Pair("error", JsonObject(
				[Pair("code", JsonDouble(i2d(code))), Pair("message", JsonString(msg))]
			)
		)
	]);
}

ruLspNormalResponse(id : Json, result : Json) -> Json {
	JsonObject([Pair("id", id), Pair("jsonrpc", JsonString("2.0")), Pair("result", result)]);
}

ruLspProcessRequest(conf : RuConf, json : Json, str_out_cb : (string) ->  void, loop_cb : () -> void, exit_cb : () -> void) -> void {
	id = getJsonFieldValue(json, "id", JsonString(""));
	method = getJsonStringField(json, "method", "");
	params = getJsonFieldValue(json, "params", JsonObject([]));
	out_cb = \msg -> {
		js_out = json2string(msg);
		str_out_cb("Content-Length:" + i2s(strlen(js_out)) + "\r\n\r\n" + js_out);
	}
	if (method == "") {
		out_cb(ruLspErrorResponse(id, 1, "request method is not set"));
		loop_cb();
	} else {
		switch (lookupTree(ruLspMethods, method)) {
			Some(m): m(RuLspMethodCall(conf, id, params, out_cb, loop_cb, exit_cb));
			None(): {
				out_cb(ruLspErrorResponse(id, 1, "request method " + method + " is not found"));
				loop_cb();
			}
		}
	}
}

ruLspShutdown(call : RuLspMethodCall) -> void {
	ruLspClientConf := JsonObject([]);
	ruClearCache(); // reset module cache
	call.loop_cb();
}

ruLspExit(call : RuLspMethodCall) -> void {
	call.exit_cb();
}

ruLspInitialized(call: RuLspMethodCall) -> void {
	call.loop_cb(); // It's a notification, no response.
}

ruLspInitialize(call: RuLspMethodCall) -> void {
	ruLspClientConf := call.params;
	/*{
		"id":1,
		"jsonrpc":"2.0",
		"result":{
			"capabilities":{
				"codeActionProvider":true,
				"completionProvider":{
					"resolveProvider":false,
					"triggerCharacters":[".",">",":"]
				},
				"declarationProvider":true,
				"definitionProvider":true,
				"documentFormattingProvider":true,
				"documentHighlightProvider":true,
				"documentOnTypeFormattingProvider":{
					"firstTriggerCharacter":"\n",
					"moreTriggerCharacter":[]
				},
				"documentRangeFormattingProvider":true,
				"documentSymbolProvider":true,
				"executeCommandProvider":{
					"commands":[
						"clangd.applyFix","clangd.applyTweak"
					]
				},
				"hoverProvider":true,
				"referencesProvider":true,
				"renameProvider":true,
				"signatureHelpProvider":{
					"triggerCharacters":["(",","]
				},
				"textDocumentSync":2,
				"typeHierarchyProvider":true,
				"workspaceSymbolProvider":true
			}
		}
	}
	*/
	call.out_cb(ruLspNormalResponse(call.id, 
		JsonObject([
			Pair("capabilities", JsonObject([
					Pair("declarationProvider", JsonBool(true)),
					Pair("definitionProvider", JsonBool(true)),
					Pair("referencesProvider", JsonBool(true)),
					Pair("workspaceSymbolProvider", JsonBool(true)),
					Pair("documentSymbolProvider", JsonBool(true)),
					Pair("documentSymbolProvider", JsonBool(true)),
					Pair("hoverProvider", JsonBool(true)),
					Pair("renameProvider", JsonBool(true))
				])
			)
		])
	));
	call.loop_cb();
}

ruLspTextDocumentDidOpen(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentItem(getJsonObjectField(call.params, "textDocument"))) {
		Some(textitem): {
			ruRun(
				RuConf(call.conf with file = textitem.uri.path),
				\code -> {
					ruClearOutput(call.conf);
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentDidChange(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentItem(getJsonObjectField(call.params, "textDocument"))) {
		Some(textitem): {
			ruRun(
				RuConf(call.conf with file = textitem.uri.path),
				\code -> {
					ruClearOutput(call.conf);
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentDocumentSymbol(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentIdentifier(getJsonObjectField(call.params, "textDocument"))) {
		Some(textid): {
			ruRun(
				RuConf(call.conf with 
					file = textid.uri.path,
					opts = setTree(call.conf.opts, "print-outline", "1")
				),
				\code -> {
					symbols = ruLspParseSymbols(ruOutput(call.conf));
					ruClearOutput(call.conf);
					call.out_cb(ruLspNormalResponse(call.id, JsonArray(symbols)));
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document id is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

/*
{
    "id": 6,
    "jsonrpc": "2.0",
    "method": "textDocument/declaration",
    "params": {
        "position": {
            "character": 18,
            "line": 1520
        },
        "textDocument": {
            "uri": "file:///home/dmitry/dev/russell/metamath/mmunif.c"
        }
    }
}
*/

// /home/dmitry/area9/flow9/tools/flowc/flowc_find.flow:394:8: uses fcSetSkipPrinting

// ruRun(config : RuConf, globalEnv : FcTypeEnvGlobal, onRunComplete : (int) -> void) 

/*
{
	"id":6,
	"jsonrpc":"2.0",
	"result":[
		{
			"range":{
				"end":{
					"character":19,
					"line":134
				},
				"start":{
					"character":5,
					"line":134
				}
			},
			"uri":"file:///home/dmitry/dev/russell/metamath/mmunif.c"
		}
	]
}
*/


ruLspParseLocations(s : string) -> [Json] {
	isNum = \st -> st != "" && isDigits(st);
	filtermap(strSplit(s, "\n"), \l -> {
		parts = strSplit(l, ":");
		if (length(parts) < 3 || parts[0] == "" || !isNum(parts[1]) || !isNum(parts[2])) None() else {
			path = parts[0];
			sline = s2i(parts[1]) - 1;
			schar = s2i(parts[2]) - 1;
			if (length(parts) < 5 || !isNum(parts[3]) || !isNum(parts[4])) {
				Some(lspLocation2Json(
					LspLocation(
						URI("file", URIAuthority("", "", ""), path, "", ""),
						LspRange(LspPosition(sline, schar), LspPosition(sline, schar + 1))
					)
				));
			} else {
				eline = s2i(parts[3]) - 1;
				echar = s2i(parts[4]) - 1;
				Some(lspLocation2Json(
					LspLocation(
						URI("file", URIAuthority("", "", ""), path, "", ""),
						LspRange(LspPosition(sline, schar), LspPosition(eline, echar))
					)
				));
			}
		}
	});
}

// LspTextDocumentSymbol : (name : string, detail : string, kind : int, deprecated : Maybe<bool>, range : LspRange, selectionRange : LspRange, children : [LspTextDocumentSymbol]);

ruLspParseSymbols(s : string) -> [Json] {
	isNum = \st -> st != "" && isDigits(st);
	filtermap(strSplit(s, "\n"), \l -> {
		parts = strSplit(l, ":");
		if (length(parts) != 4) None() else {
			path = parts[0];
			sline = s2i(parts[1]) - 1;
			schar = s2i(parts[2]) - 1;
			descr_parts = strSplit(trim(parts[3]), " ");
			name = descr_parts[1];
			kind = if (descr_parts[0] == "import") {
				lookupTreeDef(lspSymbolKindName2id, "Module", 0);
			} else if (descr_parts[0] == "forbid") {
				lookupTreeDef(lspSymbolKindName2id, "Package", 0);
			} else if (descr_parts[0] == "export") {
				lookupTreeDef(lspSymbolKindName2id, "Namespace", 0);
			} else if (descr_parts[0] == "struct") {
				lookupTreeDef(lspSymbolKindName2id, "Struct", 0);
			} else if (descr_parts[0] == "union") {
				lookupTreeDef(lspSymbolKindName2id, "Enum", 0);
			} else if (descr_parts[0] == "fundef") {
				lookupTreeDef(lspSymbolKindName2id, "Function", 0);
			} else if (descr_parts[0] == "fundecl") {
				lookupTreeDef(lspSymbolKindName2id, "Interface", 0);
			} else if (descr_parts[0] == "vardef") {
				lookupTreeDef(lspSymbolKindName2id, "Object", 0);
			} else if (descr_parts[0] == "vardecl") {
				lookupTreeDef(lspSymbolKindName2id, "Variable", 0);
			} else if (descr_parts[0] == "natdef") {
				lookupTreeDef(lspSymbolKindName2id, "Method", 0);
			} else if (descr_parts[0] == "natdecl") {
				lookupTreeDef(lspSymbolKindName2id, "Method", 0);
			} else {
				0
			}
			Some(lspTextDocumentSymbol2Json(
				LspTextDocumentSymbol(name, "", kind, None(), 
					LspRange(LspPosition(sline, schar), LspPosition(sline, schar + 1)),
					LspRange(LspPosition(sline, schar), LspPosition(sline, schar + 1)), []
				)
			));
		}
	});
}


ruLspTextDocumentDeclaration(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			ruRun(
				RuConf(call.conf with 
					file = textpos.textDocument.uri.path,
					opts = mergeTree(call.conf.opts, 
						pairs2tree([
							Pair("exp-line", i2s(textpos.position.line)), 
							Pair("exp-column", i2s(textpos.position.character)), 
							Pair("find-declaration", "1")
						])
					)
				),
				\code -> {
					locations = ruLspParseLocations(ruOutput(call.conf));
					ruClearOutput(call.conf);
					call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentDefinition(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			ruRun(
				RuConf(call.conf with 
					file = textpos.textDocument.uri.path,
					opts = mergeTree(call.conf.opts, 
						pairs2tree([
							Pair("exp-line", i2s(textpos.position.line)), 
							Pair("exp-column", i2s(textpos.position.character)), 
							Pair("find-definition", "1")
						])
					)
				),
				\code -> {
					locations = ruLspParseLocations(ruOutput(call.conf));
					ruClearOutput(call.conf);
					call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentReferences(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			ruRun(
				RuConf(call.conf with 
					file = textpos.textDocument.uri.path,
					opts = mergeTree(call.conf.opts, 
						pairs2tree([
							Pair("exp-line", i2s(textpos.position.line)), 
							Pair("exp-column", i2s(textpos.position.character)), 
							Pair("find-uses", "1")
						])
					)
				),
				\code -> {
					locations = ruLspParseLocations(ruOutput(call.conf));
					ruClearOutput(call.conf);
					call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentHover(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			ruRun(
				RuConf(call.conf with 
					file = textpos.textDocument.uri.path,
					opts = mergeTree(call.conf.opts, 
						pairs2tree([
							Pair("exp-line", i2s(textpos.position.line)), 
							Pair("exp-column", i2s(textpos.position.character)), 
							Pair("symbol-info", "1")
						])
					)
				),
				\code -> {
					out = ruOutput(call.conf);
					hover = LspHover([LspMarkedString("", out)], None());
					ruClearOutput(call.conf);
					call.out_cb(ruLspNormalResponse(call.id, lspHover2Json(hover)));
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentRename(call: RuLspMethodCall) -> void {
	switch (json2LspRename(call.params)) {
		Some(rename): {
			ruRun(
				RuConf(call.conf with 
					file = rename.textDocument.uri.path,
					opts = mergeTree(call.conf.opts, 
						pairs2tree([
							Pair("exp-line", i2s(rename.position.line)), 
							Pair("exp-column", i2s(rename.position.character)), 
							Pair("rename", "1"),
							Pair("to", rename.newName),
						])
					)
				),
				\code -> {
					ruClearOutput(call.conf);
					call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}
