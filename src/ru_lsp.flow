import sys/system;
import text/utf8;
import lsp_types;
import ru_run;
import ru_log;

export {
	ruDecodeJsonRequest(s : string) -> Json;
	ruLspReadRequest() -> Maybe<RuLspRequest>;
	RuLspRequest(
		request : string, // the whole request string
		length : int,  // Content-Length
		type : string, // Content-Type
		json : string  // the Json description of request
	);
	ruLspProcessRequest(conf : RuConf, json : Json,  out_cb : (string) ->  void, loop_cb : () -> void, exit_cb : () -> void, run : (RuConf, (int) -> void) -> void) -> void;
}

ruJsonObjectHasField(obj : JsonObject, field : string) -> bool {
	exists(obj.members, \member -> member.first == field)
}

ruDecodeJsonRequest(s : string) -> Json {
	json = parseJsonSafe(s);
	switch (json) {
		JsonObject(members): {
			if (ruJsonObjectHasField(json, "jsonrpc") &&
				ruJsonObjectHasField(json, "method")
			) {
				json
			} else {
				JsonNull();
			}
		}
		default: JsonNull();
	}
}

ruLspReadRequest() -> Maybe<RuLspRequest> {
	header = readUntil("\r\n\r\n"); // \r\n\r\n is included into header
	lines = filtermap(strSplit(header, "\n"), \line -> {
		trimmed = trim2(line, " \r\n\t");
		if (trimmed != "") Some(line) else None();
	});
	key_value = pairs2tree(map(lines, \line -> {
			key_val = strSplit(line, ":");
			if (length(key_val) == 1) {
				Pair(line, line);
			} else {
				Pair(trim2(key_val[0], " \t\n\r"), trim2(key_val[1], " \t\n\r"));
			}
	}));
	switch (lookupTree(key_value, "Content-Length")) {
		Some(len): {
			json = readBytes(s2i(len));
			Some(RuLspRequest(
				header + json,
				s2i(len), 
				lookupTreeDef(key_value, "Content-Type", ""),
				json
			));
		}
		None(): None();
	}
}

RuLspMethodCall(
	conf : RuConf,
	id : Json, 
	params : Json, 
	out_cb : (Json) ->  void, 
	loop_cb : () -> void, 
	exit_cb : () -> void,
	run : (RuConf, (int) -> void) -> void
);

ruLspMethods = pairs2tree([
	Pair("initialize", ruLspInitialize),
	Pair("initialized", ruLspInitialized),
	Pair("shutdown", ruLspShutdown),
	Pair("exit", ruLspExit),
	Pair("textDocument/didOpen", ruLspTextDocumentDidOpen),
	Pair("textDocument/didChange", ruLspTextDocumentDidChange),
	Pair("textDocument/documentSymbol", ruLspTextDocumentDocumentSymbol),
	Pair("textDocument/declaration", ruLspTextDocumentDeclaration),
	Pair("textDocument/definition", ruLspTextDocumentDefinition),
	Pair("textDocument/references", ruLspTextDocumentReferences),
	Pair("textDocument/hover", ruLspTextDocumentHover),
	Pair("textDocument/rename", ruLspTextDocumentRename),
	Pair("workspace/executeCommand", ruLspWorkspaceExecuteCommand),
]);

ruLspClientConf : ref Json = ref JsonObject([]);

ruLspErrorResponse(id : Json, code : int, msg : string) -> Json {
	JsonObject([Pair("id", id), Pair("jsonrpc", JsonString("2.0")), Pair("result", JsonNull()), 
		Pair("error", JsonObject(
				[Pair("code", JsonDouble(i2d(code))), Pair("message", JsonString(msg))]
			)
		)
	]);
}

ruLspNormalResponse(id : Json, result : Json) -> Json {
	JsonObject([Pair("id", id), Pair("jsonrpc", JsonString("2.0")), Pair("result", result)]);
}

ruLspProcessRequest(conf : RuConf, json : Json, str_out_cb : (string) ->  void, loop_cb : () -> void, exit_cb : () -> void, run : (RuConf, (int) -> void) -> void) -> void {
	id = getJsonFieldValue(json, "id", JsonString(""));
	method = getJsonStringField(json, "method", "");
	params = getJsonFieldValue(json, "params", JsonObject([]));
	out_cb = \msg -> {
		js_len = strlen(expandUtf8(json2string(msg)));
		js_out = json2string(msg);
		str_out_cb("Content-Length: " + i2s(js_len) + "\r\n\r\n" + js_out);
	}
	if (method == "") {
		out_cb(ruLspErrorResponse(id, 1, "request method is not set"));
		loop_cb();
	} else {
		switch (lookupTree(ruLspMethods, method)) {
			Some(m): m(RuLspMethodCall(conf, id, params, out_cb, loop_cb, exit_cb, run));
			None(): {
				out_cb(ruLspErrorResponse(id, 1, "request method " + method + " is not found"));
				loop_cb();
			}
		}
	}
}

ruLspShutdown(call : RuLspMethodCall) -> void {
	ruLspClientConf := JsonObject([]);
	ruClearCache(); // reset module cache
	call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
	call.loop_cb();
}

ruLspExit(call : RuLspMethodCall) -> void {
	call.exit_cb();
}

ruLspInitialized(call: RuLspMethodCall) -> void {
	call.loop_cb(); // It's a notification, no response.
}

ruLspInitialize(call: RuLspMethodCall) -> void {
	ruLspClientConf := call.params;
	call.out_cb(ruLspNormalResponse(call.id, 
		JsonObject([
			Pair("capabilities", JsonObject([
					Pair("declarationProvider", JsonBool(true)),
					Pair("definitionProvider", JsonBool(true)),
					Pair("referencesProvider", JsonBool(true)),
					Pair("workspaceSymbolProvider", JsonBool(true)),
					Pair("documentSymbolProvider", JsonBool(true)),
					Pair("documentSymbolProvider", JsonBool(true)),
					Pair("hoverProvider", JsonBool(true)),
					Pair("renameProvider", JsonBool(true)),
					Pair("executeCommandProvider", 
						JsonObject([Pair("commands", JsonArray([JsonString("compile")]))])
					)
				])
			)
		])
	));
	call.loop_cb();
}

ruLspTextDocumentDidOpen(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentItem(getJsonObjectField(call.params, "textDocument"))) {
		Some(textitem): {
			call.run(
				ruLspFileConfig(call.conf, ruCorrectUriPath(textitem.uri.path)),
				\code -> {
					ruClearOutput(call.conf);
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentDidChange(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentItem(getJsonObjectField(call.params, "textDocument"))) {
		Some(textitem): {
			call.run(
				ruLspFileConfig(call.conf, ruCorrectUriPath(textitem.uri.path)),
				\code -> {
					ruClearOutput(call.conf);
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentDocumentSymbol(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentIdentifier(getJsonObjectField(call.params, "textDocument"))) {
		Some(textid): {
			conf = ruLspFileConfig(call.conf, ruCorrectUriPath(textid.uri.path));
			call.run(
				RuConf(conf with
					opts = setTree(conf.opts, "outline", "1")
				),
				\code -> {
					out = ruOutput(call.conf);
					ruClearOutput(call.conf);
					if (ruDetectLspError(out, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						symbols = ruLspParseSymbols(out);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(symbols)));
					}
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document id is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspParseLocations(s : string) -> [Json] {
	isNum = \st -> st != "" && isDigits(st);
	filtermap(strSplit(s, "\n"), \l -> maybeMap(ruLspParseLocation(l), \p -> lspLocation2Json(p.first)));
}

ruLspParseSymbols(s : string) -> [Json] {
	isNum = \st -> st != "" && isDigits(st);
	filtermap(strSplit(s, "\n"), \l -> 
		maybeBind(ruLspParseLocation(l), \p -> {
			loc = p.first;
			descr_parts = strSplit(trim(p.second), " ");

			if (length(descr_parts) == 1) {
				Some(lspTextDocumentSymbol2Json(LspTextDocumentSymbol(p.second, "", 0, false, loc.range, loc.range, [])))
			} else if (length(descr_parts) > 1) {
				name = descr_parts[1];
				kind = if (descr_parts[0] == "import") {
					lookupTreeDef(ruLspSymbolKindName2id, "Module", 0);
				} else if (descr_parts[0] == "forbid") {
					lookupTreeDef(ruLspSymbolKindName2id, "Package", 0);
				} else if (descr_parts[0] == "struct") {
					lookupTreeDef(ruLspSymbolKindName2id, "Struct", 0);
				} else if (descr_parts[0] == "union") {
					lookupTreeDef(ruLspSymbolKindName2id, "Enum", 0);
				} else if (descr_parts[0] == "fundef") {
					lookupTreeDef(ruLspSymbolKindName2id, "Function", 0);
				} else if (descr_parts[0] == "fundecl") {
					lookupTreeDef(ruLspSymbolKindName2id, "Interface", 0);
				} else if (descr_parts[0] == "vardef") {
					lookupTreeDef(ruLspSymbolKindName2id, "Object", 0);
				} else if (descr_parts[0] == "vardecl") {
					lookupTreeDef(ruLspSymbolKindName2id, "Variable", 0);
				} else if (descr_parts[0] == "natdef") {
					lookupTreeDef(ruLspSymbolKindName2id, "Method", 0);
				} else if (descr_parts[0] == "natdecl") {
					lookupTreeDef(ruLspSymbolKindName2id, "Method", 0);
				} else {
					0
				}
				Some(lspTextDocumentSymbol2Json(LspTextDocumentSymbol(name, "", kind, false, loc.range, loc.range, [])));
			} else {
				None();
			}
		})
	);
}


ruLspParseLocation(s : string) -> Maybe<Pair<LspLocation, string>> {
	isNum = \st -> st != "" && isDigits(st);
	parts0 = strSplit(s, ":");
	if (length(parts0) < 3 || strContains(s, "Error: ") || strContains(s, "Fail: ")) None() else {
		// Windows path may start with C:/... and 
		parts = if (!hasTargetName("windows") || !isLetter(parts0[0])) parts0 else {
			concat(["/" + parts0[0] + ":" + parts0[1]], tailFrom(parts0, 2));
		}
		if (length(parts) < 3 || parts[0] == "" || !isNum(parts[1]) || !isNum(parts[2])) {
			None() ;
		} else {
			path = strReplace(parts[0], "\\", "/");
			sline = s2i(parts[1]) - 1;
			schar = s2i(parts[2]) - 1;
			if (length(parts) < 5 || !isNum(parts[3]) || !isNum(parts[4])) {
				Some(Pair(LspLocation(
					URI("file", URIAuthority("", "", ""), path, "", ""),
					LspRange(LspPosition(sline, schar), LspPosition(sline, schar + 1))
					), trim(parts[3]))
				);
			} else {
				eline = s2i(parts[3]) - 1;
				echar = s2i(parts[4]) - 1;
				Some(Pair(LspLocation(
					URI("file", URIAuthority("", "", ""), path, "", ""),
					LspRange(LspPosition(sline, schar), LspPosition(eline, echar))
					), trim(parts[5]))
				);
			}
		}
	}
}

ruLspTextDocumentDeclaration(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			conf = ruLspFileConfig(call.conf, ruCorrectUriPath(textpos.textDocument.uri.path));
			call.run(
				RuConf(conf with
					opts = mergeTree(conf.opts, 
						pairs2tree([
							Pair("line", i2s(textpos.position.line)), 
							Pair("col", i2s(textpos.position.character)), 
							Pair("decl", "1")
						])
					)
				),
				\code -> {
					out = ruOutput(call.conf);
					ruClearOutput(call.conf);
					if (ruDetectLspError(out, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(out);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					}
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentDefinition(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			conf = ruLspFileConfig(call.conf, ruCorrectUriPath(textpos.textDocument.uri.path));
			call.run(
				RuConf(conf with
					opts = mergeTree(conf.opts, 
						pairs2tree([
							Pair("line", i2s(textpos.position.line)), 
							Pair("col", i2s(textpos.position.character)), 
							Pair("decl", "1")
						])
					)
				),
				\code -> {
					out = ruOutput(call.conf);
					ruClearOutput(call.conf);
					if (ruDetectLspError(out, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(out);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					}
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentReferences(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			conf = ruLspFileConfig(call.conf, ruCorrectUriPath(textpos.textDocument.uri.path));
			call.run(
				RuConf(conf with 
					opts = mergeTree(conf.opts, 
						pairs2tree([
							Pair("line", i2s(textpos.position.line)), 
							Pair("col", i2s(textpos.position.character)), 
							Pair("uses", "1")
						])
					)
				),
				\code -> {
					out = ruOutput(call.conf);
					ruClearOutput(call.conf);
					if (ruDetectLspError(out, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(out);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					}
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentHover(call: RuLspMethodCall) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			conf = ruLspFileConfig(call.conf, ruCorrectUriPath(textpos.textDocument.uri.path));
			call.run(
				RuConf(conf with 
					opts = mergeTree(conf.opts, 
						pairs2tree([
							Pair("line", i2s(textpos.position.line)), 
							Pair("col", i2s(textpos.position.character)), 
							Pair("hover", "1")
						])
					)
				),
				\code -> {
					out = ruOutput(call.conf);
					ruClearOutput(call.conf);
					if (ruDetectLspError(out, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						if (isNotSpace(out)) {
							hover = LspHover([LspMarkedString("", out)], None());
							ruDebugLog("out:\n" + json2string(lspHover2Json(hover)), call.conf);
							call.out_cb(ruLspNormalResponse(call.id, lspHover2Json(hover)));
						} else {
							call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
						}
					}
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspTextDocumentRename(call: RuLspMethodCall) -> void {
	switch (json2LspRename(call.params)) {
		Some(rename): {
			conf = ruLspFileConfig(call.conf, ruCorrectUriPath(rename.textDocument.uri.path));
			call.run(
				RuConf(conf with 
					opts = mergeTree(conf.opts, 
						pairs2tree([
							Pair("line", i2s(rename.position.line)), 
							Pair("col", i2s(rename.position.character)), 
							Pair("rename", "1"),
							Pair("to", rename.newName),
						])
					)
				),
				\code -> {
					out = ruOutput(call.conf);
					ruClearOutput(call.conf);
					if (ruDetectLspError(out, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					}
					call.loop_cb();
				}
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
			call.loop_cb();
		}
	}
}

ruLspWorkspaceExecuteCommand(call: RuLspMethodCall) -> void {
	switch (json2LspExecuteCommandParams(call.params)) {
		Some(commandParams): {
			if (commandParams.command == "compile") {
				if (length(commandParams.arguments) == 0) {
					call.out_cb(ruLspErrorResponse(call.id, 1, "no file for compilation is provided"));
					call.loop_cb();
				} else {
					file = ref "";
					params = filtermap(commandParams.arguments, \arg -> 
						switch (arg) {
							JsonString(str): {
								opt_val = strSplit(str, "=");
								if (length(opt_val) == 0) None() else
								if (length(opt_val) == 1) { file := opt_val[0]; None(); } else {
									opt = opt_val[0];
									val = opt_val[1];
									if (opt == "file") {
										file := val;
										None();
									} else {
										Some(Pair(opt, val));
									}
								}
							}
							default: None();
						}
					);
					if (^file == "") {
						call.out_cb(ruLspErrorResponse(call.id, 1, "no file for compilation"));
						call.loop_cb();
					} else {
						conf = ruLspFileConfig(call.conf, ruCorrectUriPath(^file));
						call.run(
							RuConf(conf with opts = mergeTree(conf.opts, pairs2tree(params))),
							\code -> {
								out = ruOutput(call.conf);
								ruClearOutput(call.conf);
								call.out_cb(ruLspNormalResponse(call.id, JsonString(out)));
								call.loop_cb();
							}
						);
					}
				}
			} else {
				call.out_cb(ruLspErrorResponse(call.id, 1, "command " + commandParams.command + " is unknown"));
				call.loop_cb();
			}
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "ExecuteCommand request is illegal"));
			call.loop_cb();
		}
	}
}

/*
 When URI parser parses something like: 
	file:///c:/Users/dmitr/area9/flow9/tools/flowc
 it outputs path as: 
	/c:/Users/dmitr/area9/flow9/tools/flowc
 which is wrong in windows, first slash must be removed.
*/
ruCorrectUriPath(path : string) -> string {
	if (!startsWith(path, "/") || !hasTargetName("windows")) path else {
		path1 = strRight(path, 1);
		// Detect c:, d:, etc.
		if (isLetter(getCharAt(path1, 0)) && getCharAt(path1, 1) == ":") {
			path1
		} else {
			// keep original path 
			path
		}
	}
}

ruDetectLspError(out : string, conf : RuConf) -> bool {
	if (strContains(out, "Error: ") || strContains(out, "Fail: ")) {
		ruServerLog("ERROR: " + out, conf);
		true
	} else false;
}

ruLspFileConfig(def : RuConf, path0 : string) -> RuConf {
	path = ruCorrectUriPath(path0);
	cwd_dir = strReplace(resolveRelativePath("."), "\\", "/");
	ext = getFileExt(path);
	file_dir = dirName(path);
	conf_dir = ruFindConfDir(file_dir);
	if (conf_dir == "") def else {
		switch (ruMakeConf(conf_dir)) {
			Some(conf): {
				if (conf_dir == "") def else {
					conf1 = RuConf(conf with 
						importRoots = uniq(concat(def.importRoots, map(conf.importRoots, \inc ->
							if (isAbsolutePath(inc)) inc else {
								if (inc == ".") {
									conf_dir;
								} else {
									conf_dir + "/" + inc;
								}
							}
						))),
						opts = setTree(mergeTree(def.opts, conf.opts), "working-dir", cwd_dir),
						ext = ext,
						path = path
					);
					RuConf(conf1 with file = ruTrimPath(path, conf1, ext));
				}
			}
			None(): def;
		}
	}
}
