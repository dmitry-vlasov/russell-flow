import net/http;
import base/comms;
import ru/comms;
import mm/comms;
import script/exec;
import help;

export {
	ruRun(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruRunLocal(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruCommandsTree() -> Tree<string, RuComm>;
}

ruRun(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(s, onMessage, onRunComplete);
	} else {
		ruRunRemote(s, onMessage, onMessage, onRunComplete, 
			\code -> ruRunLocal(s, onMessage, onRunComplete)
		);
	}
}

ruRunRemote(s : ScScript, onMessage: (string) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_s = ScSeq([ruSetNoLogging(RuTask("update-conf", makeTree1("working-dir", cwd))), s]);
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruScScript2Json(remote_s))),
		\status, msg, headers -> {
			code = status - 200;
			if (code == 0) {
				onMessage(msg);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + msg);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ru_env = ref ruEmptyState;

ruRunLocal(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	ru_env := ruExecScript(s, onMessage, ^ru_env);
	onRunComplete(0);
}

ruExecScript(s : ScScript, onMessage : (string) -> void, env : RuState) -> RuState {
	either(ruExec(s, ruCommandsTree(), onMessage, env), env);
}

ru_commands_tree : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommandsTree() -> Tree<string, RuComm> {
	init_commands_tree = \-> {
		commands_list = [
			[
				ruCommServerShutdown,
				ruCommRunScript,
				ruCommClearMath,
				ruCommVerifyMetamath,
				ruApplyToProjectRoots(ruCommReadAny),
				ruCommMergeMath(ruExecScript),
			],
			ruHelpCommands(ruCommandsTree),
			ruBaseCommands,
			ruCommands,
			mmCommands
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands_tree, init_commands_tree);
}

ruCommClearMath = RuComm(
	"clear-math", "misc", "clear all math state", "",
	[],
	\__,__ -> { ruClearMemCache(); Some(ruEmptyState); }
);

ruCommReadAny = RuComm(
	"read", "io", "read a Russell/Metamath file depending on extension", "file",
	[RuCommArg("file", true, "input file", "")],
	ruRunReadAny
);

ruRunReadAny(task : RuTask, env : RuState) -> Maybe<RuState> {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruRunRead(task, env);
	} else if (endsWith(file, ".mm")) {
		mmRunRead(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		None();
	}
}

ruCommServerShutdown = RuComm(
	"server-shutdown", "server", "send the command to exit to a server", "", 
	[RuCommArg("server-port", true, "port using by a server", "20001")],
	\task, env -> { Some(env); }
);

ruCommRunScript = RuComm(
	"run-script", "misc", "load a script", "script",
	[RuCommArg("script", false, "the file with russell commands", "")],
	ruRunScript
);

ruRunScript(task : RuTask, env : RuState) -> Maybe<RuState> {
	name = lookupTreeDef(task.args, "script", "");
	file = ruFindScript(name, env.conf);
	maybeMap(
		ruLoadScript(file, task.args, env.conf),
		\script -> ruExecScript(script, env.conf.onMessage, env)
	);
}

ruFindScript(name : string, conf : RuConf) -> string {
	if (fileExists(name)) name else 
	if (fileExists(name + ".rus")) name + ".rus" else {
		scripts_dir = pathCombine(getRussellDir(), "scripts");
		if (fileExists(pathCombine(scripts_dir, name))) pathCombine(scripts_dir, name) else 
		if (fileExists(pathCombine(scripts_dir, name + ".rus"))) pathCombine(scripts_dir, name + ".rus") else {
			conf.onError("Script '" + name + "' is not found", []);
			""
		}
	}
}

ruLoadScript(file : string, args : Tree<string, string>, conf : RuConf) -> Maybe<ScScript> {
	if (!fileExists(file)) {
		conf.onMessage("Script " + file + " is not found");
		None();
	} else {
		src0 = getFileContent(file);
		vars = ruScriptVars(src0);
		vars_without_vals = filter(vars, \var -> !containsKeyTree(args, var));
		if (length(vars_without_vals) > 0) {
			conf.onMessage("Script " + file + " has variables: " + strGlue(map(vars_without_vals, \v -> "$" + v), ", ") + " with no values provided");
			None();
		} else {
			replacing = fold(vars, [], \acc, var -> 
				concat(acc, ["$" + var, lookupTreeDef(args, var, "")])
			);
			src = strReplaces(src0, replacing);
			s = ruParseScScript(src);
			switch (s) {
				Some(script):
					if (conf.verbose >= 2) {
						conf.onMessage("\tAbout to execute script: " + ruScScript2s(script));
					}
				None(): {
					conf.onMessage("\tSyntax error in script: " + src);
				}
			}
			s;
		}
	}
}

ruScriptVars(src : string) -> [string] {
	map(multipleStrIndexOf(src, "$"), \i -> ruScriptVar(src, i + 1, ""));
}

ruScriptVar(src : string, i : int, acc : string) -> string {
	c = getCharAt(src, i);
	if (!(isLetter(c) || isDigit(c))) acc else {
		ruScriptVar(src, i + 1, acc + c);
	}
}

ruCommVerifyMetamath = RuComm(
	"verify-mm", "misc", "verify a file with Metamath", "file",
	[RuCommArg("file", false, "the Metamath file", "")],
	ruRunVerifyMetamath
);

ruRunVerifyMetamath(task : RuTask, env : RuState) -> Maybe<RuState> {
	file = changeFileExt(lookupTreeDef(task.args, "file", ""), ".mm");
	if (env.conf.verbose > 1) {
		env.conf.onMessage("Going to verify " + file + " with Metamath");
	}
	code = execSystemProcess(
		"metamath", 
		["read " + fileNameOnly(file) + "",	"verify proof *", "exit"],
		ruDirName(file),
		\out -> env.conf.onMessage(out),
		\err -> env.conf.onMessage(err),
	);
	if (code != 0) {
		env.conf.onError("Verification of " + file + " with Metamath eneded up with return code: " + i2s(code), []);
	}
	Some(env);
}
