import net/http;
import base/comms;
import ru/comms;
import mm/comms;

export {
	ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruComposeJobFromScript(file : string, conf : RuConf) -> RuJob;
}

ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(job, onMessage, onRunComplete);
	} else {
		ruRunRemote(job, onMessage, onMessage, onRunComplete, 
			\code -> ruRunLocal(job, onMessage, onRunComplete)
		)
	}
}

ruRunRemote(job : RuJob, onData: (string) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_job = RuJob(concat([RuTask("update-conf", makeTree1("working-dir", cwd))], job.tasks));
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(remote_job))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ru_env = ref RuEnv(ruEmptyMath, mmEmptyMath, ruMakeConf(".", []));

ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	ru_env := ruExecJob(job, onMessage, ^ru_env);
	onRunComplete(0);
}

ruExecJob(job : RuJob, onMessage : (string) -> void, env : RuEnv) -> RuEnv {
	fold(job.tasks, env, \acc, task -> {
		switch (lookupTree(ruCommandsTree(), task.command)) {
			Some(command): {
				conf = RuConf(acc.conf with 
					onMessage = onMessage,
					onError = \err, places -> onMessage("Error: " + err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")))
				);
				fold(
					ruPrepareTasks(task, command, conf), 
					RuEnv(acc with conf = conf), 
					\e, t -> command.run(t, e)
				);
			}
			None(): {
				onMessage("Unknown command: '" + task.command + "'");
				acc;
			}
		}
	})
}

ruPrepareTasks(task : RuTask, command : RuComm, conf : RuConf) -> [RuTask] {
	induced_tasks = 
		if (containsKeyTree(task.args, "file") || conf.projectRoots == []) {
			[task];
		 } else {
			map(conf.projectRoots, \root -> RuTask(task with args = setTree(task.args, "file", root)));
		 }
	filtermap(induced_tasks, 
		\t -> {
			args_w_module = eitherMap(
				lookupTree(t.args, "file"), 
				\file -> {
					absolute = resolveRelativePath(file);
					w_file = setTree(t.args, "file", absolute);
					if (containsKeyTree(w_file, "module")) {
						w_file;
					} else {
						setTree(w_file, "module", ruTrimPath(absolute, conf, getFileExt(file)));
					}
				}, 
				t.args
			);
			updated_args = foldTree(args_w_module, makeTree(), \k, v, acc -> 
				if (v != "" || k == command.defarg) setTree(acc, k, v) else setTree(acc, command.defarg, k)
			);
			updated_task = RuTask(t with args = updated_args);
			check = forall(command.args, \arg ->
				if (arg.optional || containsKeyTree(updated_task.args, arg.name)) true else {
					conf.onMessage("Obligatory argument '" + arg.name + "' of the command '" + updated_task.command + "' is missing");
					false;
				}
			);
			if (!check) None() else Some(updated_task);
		}
	);
}

ruCommandsTree() -> Tree<string, RuComm>;

ru_commands_tree : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommandsTree() -> Tree<string, RuComm> {
	init_commands_tree = \-> {
		commands_list = [
			[
				RuComm(
					"help", "help", "help on some topics", "category",
					[RuCommArg("category", true, "category of help", "")],
					ruCommHelp
				),
				RuComm(
					"run-script", "misc", "load a script", "script",
					[RuCommArg("script", false, "the file with russell commands", "")],
					ruCommScript
				),
				RuComm(
					"verify-mm", "misc", "verify a file with Metamath", "file",
					[RuCommArg("file", false, "the Metamath file", "")],
					ruCommVerifyMetamath
				),
				ruApplyToProjectRoots(RuComm(
					"read", "io", "read a Russell file", "file",
					[RuCommArg("file", true, "input file", "")],
					ruCommReadAny
				))
			],
			ruBaseCommands(),
			ruCommands(),
			mmCommands()
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands_tree, init_commands_tree);
}

ruCommReadAny(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruCommRead(task, env);
	} else if (endsWith(file, ".mm")) {
		mmCommRead(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		env;
	}
}

ruCommHelp(task : RuTask, env : RuEnv) -> RuEnv {
	commands = getTreeValues(ruCommandsTree());
	categories = filtermap(
		strSplit(toLowerCase(lookupTreeDef(task.args, "category", "")), ","),
		\cat -> if (cat == "") None() else Some(cat)
	);
	if (categories != []) {
		env.conf.onMessage(strGlue(map(categories, ruHelpOn), ""));
	} else {
		env.conf.onMessage(ruHelpOn(""));
	}
	env;
}

ruHelpOn(category : string) -> string {
	commands = getTreeValues(ruCommandsTree());
	if (category == "" || category == "help") {
		categories = set2array(fold(commands, makeSet(), \acc, comm -> 
			if (comm.category == "") acc else insertSet(acc, comm.category)
		));
		"Help invocation:\n" +
			"\t'russell help <category>'\n" +
			"\t'russell help <command>'\n" +
		"where category is one of:\n" +
			"\thelp, usage, server, " + strGlue(categories, ", ") + ", all\n" +
		"List of all commands may be seen with:\n" +
			"\t'russell help all'\n";
	} else if (category == "usage") {
		"Usage:\n" + 
			"\t'russell <task_1> ; ... ; <task_m>'\n" +
		"where task is:\n" + 
			"\t'<command> <arg_1>=<val_1> ... <arg_n>=<val_n>'\n";
	} else if (category == "server") {
		"Starting a Russell server:\n" + 
			"\t'russell server=<mode>'\n" + 
		"where mode is one of:\n" + 
			"\thttp, lsp, console, repl\n" +
		"here repl is alias to console (i.e. it is the same).\n";
	} else {
		filtered = filter(commands, \comm -> comm.category == category || category == "all");
		if (filtered != []) ruComms2s(filtered, false) else {
			eitherMap(lookupTree(ruCommandsTree(), category), \comm -> ruComm2s(comm, true), "");
		}
	}
}

ru_running_scripts : ref Set<string> = ref makeSet();

ruCommScript(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "script", "");
	script = fileNameOnly(file);
	if (containsSet(^ru_running_scripts, script)) {
		env.conf.onError("Recursive scripts are not allowed.", []);
		env;
	} else {
		job = ruComposeJobFromScript(file, env.conf);
		ru_running_scripts := insertSet(^ru_running_scripts, script);
		new_env = ruExecJob(job, env.conf.onMessage, env);
		ru_running_scripts := removeSet(^ru_running_scripts, script);
		new_env
	}
}

ruComposeJobFromScript(file : string, conf : RuConf) -> RuJob {
	contents = strGlue(
		filtermap(strSplit(getFileContent(file), "\n"), \line -> 
			if (startsWith(line, "#")) None() else Some(line)
		), " "
	);
	params = filtermap(
		strSplit2(contents, [" ", "\r", "\t"]),
		\p -> {
			param = trim2(p, " \n\r\t");
			if (param == "" || startsWith(param, "#")) None() else Some(strSplit(param, "="));
		}
	);
	job = ruMakeJob(params);
	if (conf.verbose >= 2) {
		conf.onMessage("\tAbout to execute script: " + ruJob2s(job));
	}
	job;
}

ruCommVerifyMetamath(task : RuTask, env : RuEnv) -> RuEnv {
	file = changeFileExt(lookupTreeDef(task.args, "file", ""), ".mm");
	if (env.conf.verbose > 1) {
		env.conf.onMessage("Going to verify " + file + " with Metamath");
	}
	code = execSystemProcess(
		"metamath", 
		["read " + fileNameOnly(file) + "",	"verify proof *", "exit"],
		ruDirName(file),
		\out -> env.conf.onMessage(out),
		\err -> env.conf.onMessage(err),
	);
	if (code != 0) {
		env.conf.onError("Verification of " + file + " with Metamath eneded up with return code: " + i2s(code), []);
	}
	env;
}
