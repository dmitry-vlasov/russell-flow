import net/http;
import base/comms;
import ru/comms;
import mm/comms;
import script/exec;
import help;
import clear;

export {
	ruRun(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruRunLocal(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruCommandsTree(conf : RuConf) -> Tree<string, RuComm>;
}

ruRun(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(s, onMessage, onRunComplete);
	} else {
		ruRunRemote(s, onMessage, onMessage, onRunComplete, 
			\code -> ruRunLocal(s, onMessage, onRunComplete)
		);
	}
}

ru_env = ref ruEmptyState;

ruRunRemote(s : ScScript, onMessage: (string) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_s = ScSeq([ruSetNoLogging(ScTask("conf-set", makeTree1("working-dir", cwd))), s]);
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruScript2Json(remote_s))),
		\status, msg, headers -> {
			code = status - 200;
			if (code == 0) {
				onMessage(msg);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + msg);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ruRunLocal(s : ScScript, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	ru_env := ruExecScript(s, onMessage, ^ru_env);
	onRunComplete(0);
}

ruExecScript(s : ScScript, onMessage : (string) -> void, env : RuState) -> RuState {
	either(ruExec(s, ruCommandsTree(env.conf), onMessage, env), env);
}

ru_commands_tree : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommandsTree(conf : RuConf) -> Tree<string, RuComm> {
	init_commands_tree = \-> {
		commands_list = [
			[
				ruCommServerShutdown,
				ruCommRunScript,
				ruCommVerifyMetamath,
				ruApplyToProjectRoots(ruCommReadAny),
				ruCommSplitMathAny,
				ruCommOptimizeImportsAny,
				ruCommMergeMath(ruExecScript),
			],
			ruHelpCommands(ruCommandsTree),
			ruBaseCommands,
			ruClearCommands,
			ruCommands,
			mmCommands
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.descr.name, comm));
    }
    onlyOnce(ru_commands_tree, init_commands_tree);
}

ruCommReadAny = RuComm(
	RuCommDescr(
		"read", "io", "read a Russell/Metamath file depending on extension", "file", true,
		[RuCommArg("file", true, "input file", "")]
	),
	ruChooseRunerByExt(ruRunRead, mmRunRead)
);

ruCommSplitMathAny = RuComm(
	RuCommDescr(
		"split-math", "misc", "split a single Russell/Metamath file into a filesystem depending on extension", "file", true,
		[RuCommArg("file", true, "input file", "")]
	),
	ruChooseRunerByExt(ruRunSplitMath, mmRunSplitMath)
);

ruCommOptimizeImportsAny = RuComm(
	RuCommDescr(
		"optimize-imports", "misc", "optimize imports in Russell/Metamath file depending on extension", "file", true,
		[RuCommArg("file", true, "input file", "")]
	),
	ruChooseRunerByExt(ruRunOptimizeImports, mmRunOptimizeImports)
);

ruChooseRunerByExt( 
	run_ru : (ScTask,RuState) -> Maybe<RuState>,
	run_mm : (ScTask,RuState) -> Maybe<RuState>
) -> (ScTask, RuState) -> Maybe<RuState> {
	\task : ScTask, env : RuState -> {
		file = lookupTreeDef(task.args, "file", "");
		if (endsWith(file, ".ru")) {
			run_ru(task, env);
		} else if (endsWith(file, ".mm")) {
			run_mm(task, env);
		} else {
			env.conf.onError("Unknown file '" + file + "' extension: '" + getFileExt(file) + "', must be '*.ru' or '*.mm'", []);
			None();
		}
	}
}

ruCommServerShutdown = RuComm(
	RuCommDescr(
		"server-shutdown", "server", "send the command to exit to a server", "", false,
		[RuCommArg("server-port", true, "port using by a server", "20001")]
	),
	\task, env -> { Some(env); }
);

ruCommRunScript = RuComm(
	RuCommDescr(
		"run-script", "misc", "load and run a script", "script", false,
		[RuCommArg("script", false, "the file with russell command script", "")]
	),
	ruRunScript
);

ruRunScript(task : ScTask, env : RuState) -> Maybe<RuState> {
	name = lookupTreeDef(task.args, "script", "");
	maybeMap(
		ruLoadScript(name, env.conf),
		\src -> ruExecScript(
			src.script, 
			env.conf.onMessage, 
			RuState(env with 
				vars = mergeTree(env.vars, mapTree(task.args, \s -> 
					ValString(ruApplyScriptVars(s, env.vars, env.conf))
				))
			)
		)
	);
}

ruCommVerifyMetamath = RuComm(
	RuCommDescr(
		"verify-mm", "misc", "verify a file with Metamath", "file", true,
		[RuCommArg("file", false, "the Metamath file", "")]
	),
	ruRunVerifyMetamath
);

ruRunVerifyMetamath(task : ScTask, env : RuState) -> Maybe<RuState> {
	conf = env.conf;
	file = changeFileExt(lookupTreeDef(task.args, "file", ""), ".mm");
	module = ruTrimPath(file, conf, ".mm");
	resolved = ruResolveRelativeFile(file, conf.workingDir);
	dir = ruDirName(resolved);
	if (ruVerbose(conf) > 1) {
		conf.onMessage("Going to verify file: '" + file + "' with Metamath, dir: '" + dir + "', resolved: '" + resolved + "', module: " + module);
	}
	if (!fileExists(resolved)) {
		conf.onError("mm file '" + file + "' doesn't exist", []);
	} else {
		timer = ruMakeTimer();
		lines = ref [];
		code = execSystemProcess(
			"metamath", 
			["read " + fileNameOnly(file), "verify proof *", "exit"],
			if (dir == "") "." else dir,
			\out -> refArrayPush(lines, out),
			\err -> refArrayPush(lines, err),
		);
		conf.onMessage(strGlue(^lines, "\n"));
		if (code != 0) {
			conf.onError("Verification of '" + file + "' with Metamath eneded up with return code: " + i2s(code), []);
		} else {
			if (ruVerbose(conf) > 0) {
				conf.onMessage("mm file '" + module + "' is verified with Metamath in " + ruTimePassed2s(timer));
			}
		}
	}
	Some(env);
}
