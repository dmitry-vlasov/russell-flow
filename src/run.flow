import net/http;
import base/comms;
import ru/comms;
import mm/comms;

export {
	ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruComposeJobFromScript(file : string, conf : RuConf) -> RuJob;
}

ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(job, onMessage, onRunComplete);
	} else {
		ruRunRemote(job, onMessage, onMessage, onRunComplete, 
			\code -> ruRunLocal(job, onMessage, onRunComplete)
		);
	}
}

ruRunRemote(job : RuJob, onMessage: (string) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_job = RuJob(concat([RuTask("update-conf", makeTree1("working-dir", cwd))], job.tasks));
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(remote_job))),
		\status, msg, headers -> {
			code = status - 200;
			if (code == 0) {
				onMessage(msg);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + msg);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ru_env = ref ruEmptyEnv;

ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	ru_env := ruExecJob(job, onMessage, ^ru_env);
	onRunComplete(0);
}

ruExecJob(job : RuJob, onMessage : (string) -> void, env : RuEnv) -> RuEnv {
	upd_conf = \e -> {
		RuEnv(e with 
			conf = RuConf(e.conf with 
				onMessage = onMessage,
				onError = ruMakeOnError(e.conf.opts, onMessage)
			)
		);
	}
	job_start = timestamp();
	ruJobLog("Started job:\n" + strIndent(ruJob2s(job)) + "\n", env.conf);
	ret = fold(job.tasks, Some(upd_conf(env)), \acc, task -> {
		switch (lookupTree(ruCommandsTree(), task.command)) {
			Some(command): {
				fold(ruPrepareTasks(task, command, env.conf), acc,  
					\ac, t -> maybeBind(ac, \e -> {
						task_start = timestamp();
						ruJobLog("Started task: " + ruTask2s(t) + " ... ", env.conf);
						ret = command.run(t, upd_conf(e));
						ruJobLog(
							"Task finished: " +
							(if (isSome(ret)) "Ok " else "Fail ") +
							"in " + d2st((timestamp() - task_start) / 1000.0, 2) + "s", env.conf
						);
						ret;
					})
				);
			}
			None(): {
				onMessage("Unknown command: '" + task.command + "'");
				None();
			}
		}
	});
	ruJobLog(
		"Job finished: " +
		(if (isSome(ret)) "Ok " else "Fail ") + 
		"in " + d2st((timestamp() - job_start) / 1000.0, 2) + "s", env.conf
	);
	either(ret, env);
}

ruPrepareTasks(task : RuTask, command : RuComm, conf : RuConf) -> [RuTask] {
	induced_tasks = 
		if (containsKeyTree(task.args, "file") || conf.projectRoots == []) {
			[task];
		 } else {
			map(conf.projectRoots, \root -> RuTask(task with args = setTree(task.args, "file", root)));
		 }
	filtermap(induced_tasks, 
		\t -> {
			args_w_module = eitherMap(
				lookupTree(t.args, "file"), 
				\file -> {
					absolute = resolveRelativePath(file);
					w_file = setTree(t.args, "file", absolute);
					if (containsKeyTree(w_file, "module")) {
						w_file;
					} else {
						setTree(w_file, "module", ruTrimPath(absolute, conf, getFileExt(file)));
					}
				}, 
				t.args
			);
			args_w_defvals = fold(command.args, args_w_module, \acc, arg ->
				if (arg.defval == "") acc else {
					if (containsKeyTree(acc, arg.name)) acc else setTree(acc, arg.name, arg.defval)
				}
			);
			updated_args = foldTree(args_w_defvals, makeTree(), \k, v, acc -> 
				if (v != "" || k == command.defarg) setTree(acc, k, v) else setTree(acc, command.defarg, k)
			);
			updated_task = RuTask(t with args = updated_args);
			check = forall(command.args, \arg ->
				if (arg.optional || containsKeyTree(updated_task.args, arg.name)) true else {
					conf.onMessage("Obligatory argument '" + arg.name + "' of the command '" + updated_task.command + "' is missing");
					false;
				}
			);
			if (!check) None() else Some(updated_task);
		}
	);
}

ru_commands_tree : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommandsTree() -> Tree<string, RuComm> {
	init_commands_tree = \-> {
		commands_list = [
			[
				ruCommHelp, ruCommUsage, ruCommCategory, ruCommServer, ruCommConfig,
				ruCommServerShutdown,
				ruCommRunScript,
				ruCommClearMath,
				ruCommVerifyMetamath,
				ruApplyToProjectRoots(ruCommReadAny),
				ruCommMergeMath(ruExecJob),
			],
			ruBaseCommands,
			ruCommands,
			mmCommands
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands_tree, init_commands_tree);
}

ruCommClearMath = RuComm(
	"clear-math", "misc", "clear all math state", "",
	[],
	\__,__ -> { ruClearMemCache(); Some(ruEmptyEnv); }
);

ruCommReadAny = RuComm(
	"read", "io", "read a Russell/Metamath file depending on extension", "file",
	[RuCommArg("file", true, "input file", "")],
	ruRunReadAny
);

ruRunReadAny(task : RuTask, env : RuEnv) -> Maybe<RuEnv> {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruRunRead(task, env);
	} else if (endsWith(file, ".mm")) {
		mmRunRead(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		None();
	}
}

ruCommHelp = RuComm(
	"help", "help", "Usage: 'help <command>' or 'help <category>'", "category",
	[RuCommArg("category", true, "category of help. Run 'help-category' to see all categories", "")],
	ruRunHelp
);

ruCommUsage = RuComm(
	"help-usage", "help", "usage message", "", [],
	\task, env -> { env.conf.onMessage(ruUsageMessage()); Some(env); }
);

ruCommCategory = RuComm(
	"help-category", "help", "show all help categories", "", [],
	\task, env -> { env.conf.onMessage(ruCategoryMessage()); Some(env); }
);

ruCommServer = RuComm(
	"help-server", "help", "show all server modes", "", [],
	\task, env -> { env.conf.onMessage(ruServerMessage()); Some(env); }
);

ruCommConfig = RuComm(
	"help-config", "help", "show config options", "", [],
	\task, env -> { env.conf.onMessage(ruConfigMessage()); Some(env); }
);

ruCommServerShutdown = RuComm(
	"server-shutdown", "server", "send the command to exit to a server", "", 
	[RuCommArg("server-port", true, "port using by a server", "20001")],
	\task, env -> { Some(env); }
);

ruRunHelp(task : RuTask, env : RuEnv) -> Maybe<RuEnv> {
	cats = toLowerCase(lookupTreeDef(task.args, "category", ""));
	categories = 
		if (cats == "") {
			if (containsKeyTree(task.args, "category")) ["category"] else []
		} else {
			filtermap(
				strSplit(cats, ","),
				\cat -> if (cat == "") None() else Some(cat)
			);
		}
	if (categories != []) {
		env.conf.onMessage(strGlue(map(categories, ruHelpOn), ""));
	} else {
		env.conf.onMessage(ruHelpOn(""));
	}
	Some(env);
}

ruHelpMessage(detailed : bool) -> string {
	commands = getTreeValues(ruCommandsTree());
	categories = set2array(fold(commands, makeSet(), \acc, comm -> 
		if (comm.category == "") acc else insertSet(acc, comm.category)
	));
	"Help invocation:\n" +
		"\t'russell help <category>,...,<category>'\n" +
		"\t'russell help <command>'\n" +
	(if (!detailed) "" else 
		"Special help commands:\n" +
		"\t'russell help usage'    -- usage message (command format)\n" +
		"\t'russell help category' -- the list of all command categories\n" +
		"\t'russell help server'   -- the list of all server modes\n"
		"\t'russell help config'   -- the list of russell config parameters\n"
	) +
	"List of all commands may be seen with:\n" +
		"\t'russell help all'\n";
}

ruUsageMessage() -> string {
	"Usage:\n" + 
		"\t'russell <task_1> ; ... ; <task_m>'\n" +
	"where task is:\n" + 
		"\t'<command> <arg_1>=<val_1> ... <arg_n>=<val_n>'\n";
}

ruConfigMessage() -> string {
	"Config options:\n" + 
		"\tfile=<name>                         input file\n" +
		"\timport-roots=<dir_1>,...,<dir_n>    relative paths, against which sources are searched\n" +
		"\tproject-roots=<file_1>,...,<file_n> a set of sources, which contain all project data\n" +
		"\tbin-dir=<dir>                       directory, where the binary for russell is stored\n" + 
		"\tworking-dir=<dir>                   a working directory, relative to which all paths are resolved\n" + 
		"\tverbose={0,1,2,3,...}               output verbosity level. Larger means more verbose\n" + 
		"\thalt-on-errors=1                    abort execution of a programm at first error\n" + 
		"\tdisk-caching=0                      disable an external disk cache\n" + 
		"\tmem-caching=0                       disable memory cache\n" + 
		"\tcaching=0                           disable all kinds of caching\n" +
		"\tstrict-file-names=1                 resolve modules paths only against import-roots\n";;
}

ruCategoryMessage() -> string {
	commands = getTreeValues(ruCommandsTree());
	categories = sort(set2array(fold(commands, makeSet(), \acc, comm -> 
		if (comm.category == "") acc else insertSet(acc, comm.category)
	)));
	cat2commands : Tree<string, [string]> = foldTree(ruCommandsTree(), makeTree(), \name, comm, acc ->
		setTree(acc, comm.category, 
			concat(lookupTreeDef(acc, comm.category, []), [name])
		)
	);
	cat_matr = [
		categories,
		map(categories, \cat -> strGlue(lookupTreeDef(cat2commands, cat, []), ", ")),
	];
	"The list of all categories:\n" + 
	ruStringTable2s(cat_matr, Some(["Category", "Commands"])) + "\n";
}

ruServerMessage() -> string {
	"Starting a Russell server:\n" + 
		"\t'russell server=<mode>'\n" + 
	"where mode is one of:\n" + 
		"\thttp, lsp, console, repl\n" +
	"here repl is alias to console (i.e. it is the same).\n";
}

ruHelpOn(category : string) -> string {
	commands = getTreeValues(ruCommandsTree());
	if (category == "") {
		ruHelpMessage(true);
	} else if (category == "usage") {
		ruUsageMessage();
	} else if (category == "category") {
		ruCategoryMessage();
	} else if (category == "server") {
		ruServerMessage();
	} else if (category == "config") {
		ruConfigMessage();
	} else {
		filtered = filter(commands, \comm -> comm.category == category || category == "all");
		if (filtered != []) {
			ruComms2s(filtered, false);
		} else {
			eitherMap(lookupTree(ruCommandsTree(), category), \comm -> ruComm2s(comm, true), "");
		}
	}
}

ru_running_scripts : ref Set<string> = ref makeSet();

ruCommRunScript = RuComm(
	"run-script", "misc", "load a script", "script",
	[RuCommArg("script", false, "the file with russell commands", "")],
	ruRunScript
);

ruRunScript(task : RuTask, env : RuEnv) -> Maybe<RuEnv> {
	file = lookupTreeDef(task.args, "script", "");
	script = fileNameOnly(file);
	if (containsSet(^ru_running_scripts, script)) {
		env.conf.onError("Recursive scripts are not allowed.", []);
		None();
	} else {
		job = ruComposeJobFromScript(file, env.conf);
		ru_running_scripts := insertSet(^ru_running_scripts, script);
		new_env = ruExecJob(job, env.conf.onMessage, env);
		ru_running_scripts := removeSet(^ru_running_scripts, script);
		Some(new_env)
	}
}

ruComposeJobFromScript(file : string, conf : RuConf) -> RuJob {
	if (!fileExists(file)) {
		conf.onMessage("Script " + file + " is not found");
		RuJob([]);
	} else {
		contents = strGlue(
			filtermap(strSplit(getFileContent(file), "\n"), \line -> 
				if (startsWith(line, "#")) None() else Some(line)
			), " "
		);
		params = filtermap(
			strSplit2(contents, [" ", "\r", "\t"]),
			\p -> {
				param = trim2(p, " \n\r\t");
				if (param == "" || startsWith(param, "#")) None() else Some(strSplit(param, "="));
			}
		);
		job = ruMakeJob(params);
		if (conf.verbose >= 2) {
			conf.onMessage("\tAbout to execute script: " + ruJob2s(job));
		}
		job;
	}
}

ruCommVerifyMetamath = RuComm(
	"verify-mm", "misc", "verify a file with Metamath", "file",
	[RuCommArg("file", false, "the Metamath file", "")],
	ruRunVerifyMetamath
);

ruRunVerifyMetamath(task : RuTask, env : RuEnv) -> Maybe<RuEnv> {
	file = changeFileExt(lookupTreeDef(task.args, "file", ""), ".mm");
	if (env.conf.verbose > 1) {
		env.conf.onMessage("Going to verify " + file + " with Metamath");
	}
	code = execSystemProcess(
		"metamath", 
		["read " + fileNameOnly(file) + "",	"verify proof *", "exit"],
		ruDirName(file),
		\out -> env.conf.onMessage(out),
		\err -> env.conf.onMessage(err),
	);
	if (code != 0) {
		env.conf.onError("Verification of " + file + " with Metamath eneded up with return code: " + i2s(code), []);
	}
	Some(env);
}
