import net/http;

import base/usage;
import ru/verify;
import ru/refactor/commands;
import ru/info;
import ru/prover/commands;
import io;

export {
	ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
}

ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(job, onMessage, onRunComplete);
	} else {
		ruRunRemote(job, onMessage, onMessage, onRunComplete, 
			\code -> ruRunLocal(job, onMessage, onRunComplete)
		)
	}
}

ruRunRemote(job : RuJob, onData: (string) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_job = RuJob(concat([RuTask("update-conf", makeTree1("working-dir", cwd))], job.tasks));
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(remote_job))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ru_env = ref RuEnv(ruEmptyMath, mmEmptyMath, ruMakeConf(".", []));

ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	ru_env := fold(job.tasks, ^ru_env, \acc, t -> {
		task = ruPrepareTask(t, acc.conf);
		switch (lookupTree(ruCommands(), task.command)) {
			Some(command): {
				conf = RuConf(acc.conf with 
					onMessage = onMessage,
					onError = \err, places -> onMessage("Error: " + err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")))
				);
				if (ruCheckTaskArgs(task, command, conf)) {
					command.run(task, RuEnv(acc with conf = conf));
				} else {
					acc;
				}
			}
			None(): {
				onMessage("Unknown command: '" + task.command + "'");
				acc;
			}
		}
	});
	onRunComplete(0);
}

ruPrepareTask(task : RuTask, conf : RuConf) -> RuTask {
	switch (lookupTree(task.args, "file")) {
		Some(file): {
			module = ruTrimPath(file, conf, getFileExt(file));
			RuTask(task with args = setTree(task.args, "module", module));
		}
		None(): {
			switch (lookupTree(conf.opts, "root-file")) {
				Some(file): {
					module = ruTrimPath(file, conf, getFileExt(file));
					RuTask(task with 
						args = setTree(setTree(task.args, "file", file), "module", module)
					);
				}
				None(): task;
			}
		}
	}
}

ruCheckTaskArgs(task : RuTask, command : RuComm, conf : RuConf) -> bool {
	forall(command.args, \arg ->
		if (arg.optional || containsKeyTree(task.args, arg.name)) true else {
			conf.onMessage("Obligatory argument '" + arg.name + "' of the command '" + task.command + "' is missing");
			false;
		}
	)
}

ru_commands : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommands() -> Tree<string, RuComm> {
	init_commands = \-> {
		commands_list = [
			[
				RuComm(
					"help", "", "help on some topics", [RuCommArg("category", true, "category of help", "")],
					ruCommHelp
				),
				RuComm(
					"verify", "", "verify entity",
					[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
					ruCommVerify
				),
				RuComm("math-stats", "", "show math statistics", [],
					\task, env -> { 
						env.conf.onMessage("Mathematics statistics:");
						env.conf.onMessage("-----------------------");
						env.conf.onMessage(ruMathStats(env.ruMath));
						env; 
					}
				),
				RuComm("mem-stats", "", "show memory usage statistics", [],
					\task, env -> { 
						start = timestamp();
						n = s2i(lookupTreeDef(task.args, "delay", "0"));
						m = s2i(lookupTreeDef(task.args, "count", "0"));
						for(0, \a -> a < m, \a -> {
							for(0, \b -> b < n, \b -> b + 1);
							a + 1
						});
						env.conf.onMessage(
							"Used: " + ruMemory2s(usedMemory()) + " " + 
							"Free: " + ruMemory2s(freeMemory()) + " " + 
							"Total: " + ruMemory2s(totalMemory()) + " in " + 
							d2st((timestamp() - start) / 1000.0, 2)
						);
						env; 
					}
				),
				RuComm("cache-stats", "", "show cache statistics", [RuCommArg("full", true, "show cached names", "")], 
					\task, env -> {
						env.conf.onMessage(ruCacheInfo(lookupTreeDef(task.args, "full", "") == "1"));
						env;
					}
				),
				RuComm("update-conf", "conf", "update configuration", [], ruCommUpdateConf),
				RuComm("conf",        "conf", "a shortcut for 'update-conf'", [], ruCommUpdateConf),
				RuComm("show-conf",   "conf", "show current configuration key-value pairs", [], ruCommShowConf),
				RuComm("load-conf",   "conf", "load configuration from given directory", [RuCommArg("dir", false, "directory with config file", "")], ruCommLoadConf),
				RuComm("clear-conf",  "conf", "clear configuration", [], ruCommClearConf),
				RuComm(
					"actions", "", "available actions at the given position",
					[
						RuCommArg("file", false, "input file", ""), 
						RuCommArg("line", false, "clear", ""), 
						RuCommArg("col", false, "clear", "")
					], 
					ruCommActions
				),
			],
			ruIoCommands1(),
			ruRefactorCommands(),
			ruProverCommands(),
			ruTranslateCommands(),
			ruInfoCommands(),
			ruFileSyncCommands()
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands, init_commands);
}

ruCommActions(task : RuTask, env : RuEnv) -> RuEnv {
	actions = ["verify", "prove", "reprove", "generalize"];
	file = lookupTreeDef(task.args, "file", "");
	line = s2i(lookupTreeDef(task.args, "line", "-1"));
	col = s2i(lookupTreeDef(task.args, "col", "-1"));
	name = ruNameByLineCol(line, col, getFileContent(file));
	json = if (name == "") JsonArray([]) else {
		JsonArray(map(actions, \action -> 
			lspCodeAction2Json(LspCodeAction(
				action + " " + name, action, [], false, None(),
				Some(LspCommand(
					action + " " + name,
					"command",
					map(["file=" + file, "read", ";", action, "target=" + name], 
						\arg -> JsonString(arg)
					)
				))
			))
		));
	}
	env.conf.onMessage(json2string(json));
	env;
}

ruCommHelp(task : RuTask, env : RuEnv) -> RuEnv {
	category = lookupTreeDef(task.args, "category", "");
	filtered = if (category == "") getTreeValues(ruCommands()) else 
		filter(getTreeValues(ruCommands()), \comm -> comm.category == category);
	env.conf.onMessage("usage: '<task_1> ; ... ; <task_m>' where");
	env.conf.onMessage("task is: '<command> <arg_1>=<val_1> ... <arg_n>=<val_n>'");
	env.conf.onMessage(ruComms2s(filtered));
	env;
}

ruCommUpdateConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with conf = ruMergeConfs(env.conf, ruTree2Conf(task.args)));
}

ruCommShowConf(task : RuTask, env : RuEnv) -> RuEnv {
	env.conf.onMessage("Configuration:");
	traverseInOrder(ruConf2Tree(env.conf), \key, val -> env.conf.onMessage("\t" + key + "=" + val));
	env;
}

ruCommLoadConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with 
		conf = ruMergeConfs(
			env.conf, 
			ruMakeConf(lookupTreeDef(task.args, "dir", ""), [])
		)
	);
}

ruCommClearConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with conf = ruTree2Conf(makeTree()));
}

ruFileSyncCommands() -> [RuComm] {[
	RuComm(
		"load-cache", "file-sync", "read cached sources",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> { ruLoadToCache(lookupTreeDef(task.args, "file", ""), env.conf); env; }
	),
	RuComm(
		"save-cache", "file-sync", "save cached sources",
		[RuCommArg("file", true, "input file", "")],
		\task, env -> { 
			file = lookupTreeDef(task.args, "file", "");
			if (file == "") {
				ruSaveCache(env.conf); 
			} else {
				ruSaveCacheFile(file, env.conf); 
			}
			env; 
		}
	),
	RuComm(
		"file-source", "file-sync", "load an updated file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("text", false, "updated source", "")],
		\task, env -> { ruSetFileSource(lookupTreeDef(task.args, "file", ""), lookupTreeDef(task.args, "text", "")); env; }
	),
	RuComm(
		"file-changed", "file-sync", "apply changes to a file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("change", false, "change in JSON format", "")],
		\task, env -> {
			json = lookupTreeDef(task.args, "change-json", "");
			switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
				Some(params): {
					path = ruCorrectUriPath(params.textDocument.uri.path);
					contents = ruFileSource(path);
					changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
					ruSetFileSource(path, changed);
				}
				None(): {
					env.conf.onMessage("file-change: An option 'change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams");
				}
			}
			env;
		}
	),
	RuComm(
		"file-saved", "file-sync", "file was saved",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> { ruLoadFileSource(lookupTreeDef(task.args, "file", "")); env; }
	)
]}