import net/http;
import base/comms;
import ru/comms;
import mm/comms;

export {
	ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void;
	ruComposeJobFromScript(file : string, conf : RuConf) -> RuJob;
}

ruRun(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(job, onMessage, onRunComplete);
	} else {
		ruRunRemote(job, onMessage, onMessage, onRunComplete, 
			\code -> ruRunLocal(job, onMessage, onRunComplete)
		)
	}
}

ruRunRemote(job : RuJob, onData: (string) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_job = RuJob(concat([RuTask("update-conf", makeTree1("working-dir", cwd))], job.tasks));
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(remote_job))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ru_env = ref RuEnv(ruEmptyMath, mmEmptyMath, ruMakeConf(".", []));

ruRunLocal(job : RuJob, onMessage : (string) -> void, onRunComplete : (int) -> void) -> void {
	ru_env := ruExecJob(job, onMessage, ^ru_env);
	onRunComplete(0);
}

ruExecJob(job : RuJob, onMessage : (string) -> void, env : RuEnv) -> RuEnv {
	fold(job.tasks, env, \acc, task -> {
		switch (lookupTree(ruCommandsTree(), task.command)) {
			Some(command): {
				conf = RuConf(acc.conf with 
					onMessage = onMessage,
					onError = \err, places -> onMessage("Error: " + err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")))
				);
				fold(
					ruPrepareTasks(task, command, conf), 
					RuEnv(acc with conf = conf), 
					\e, t -> command.run(t, e)
				);
			}
			None(): {
				onMessage("Unknown command: '" + task.command + "'");
				acc;
			}
		}
	})
}

ruPrepareTasks(task : RuTask, command : RuComm, conf : RuConf) -> [RuTask] {
	induced_tasks = 
		if (containsKeyTree(task.args, "file") || conf.projectRoots == []) {
			[task];
		 } else {
			map(conf.projectRoots, \root -> RuTask(task with args = setTree(task.args, "file", root)));
		 }
	filtermap(induced_tasks, 
		\t -> {
			args_w_module = eitherMap(
				lookupTree(t.args, "file"), 
				\file -> {
					absolute = resolveRelativePath(file);
					w_file = setTree(t.args, "file", absolute);
					if (containsKeyTree(w_file, "module")) {
						w_file;
					} else {
						setTree(w_file, "module", ruTrimPath(absolute, conf, getFileExt(file)));
					}
				}, 
				t.args
			);
			args_w_defvals = fold(command.args, args_w_module, \acc, arg ->
				if (arg.defval == "") acc else {
					if (containsKeyTree(acc, arg.name)) acc else setTree(acc, arg.name, arg.defval)
				}
			);
			updated_args = foldTree(args_w_defvals, makeTree(), \k, v, acc -> 
				if (v != "" || k == command.defarg) setTree(acc, k, v) else setTree(acc, command.defarg, k)
			);
			updated_task = RuTask(t with args = updated_args);
			check = forall(command.args, \arg ->
				if (arg.optional || containsKeyTree(updated_task.args, arg.name)) true else {
					conf.onMessage("Obligatory argument '" + arg.name + "' of the command '" + updated_task.command + "' is missing");
					false;
				}
			);
			if (!check) None() else Some(updated_task);
		}
	);
}

ru_commands_tree : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommandsTree() -> Tree<string, RuComm> {
	init_commands_tree = \-> {
		commands_list = [
			[
				ruCommHelp, ruCommUsage, ruCommCategory, ruCommServer,
				ruCommRunScript,
				ruCommVerifyMetamath,
				ruApplyToProjectRoots(ruCommReadAny)
			],
			ruBaseCommands,
			ruCommands,
			mmCommands
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands_tree, init_commands_tree);
}

ruCommReadAny = RuComm(
	"read", "io", "read a Russell/Metamath file depending on extension", "file",
	[RuCommArg("file", true, "input file", "")],
	ruRunReadAny
);

ruRunReadAny(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruRunRead(task, env);
	} else if (endsWith(file, ".mm")) {
		mmRunRead(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		env;
	}
}

ruCommHelp = RuComm(
	"help", "help", "Usage: 'help <command>' or 'help <category>'", "category",
	[RuCommArg("category", true, "category of help. Run 'help-category' to see all categories", "")],
	ruRunHelp
);

ruCommUsage = RuComm(
	"help-usage", "help", "usage message", "", [],
	\task, env -> { env.conf.onMessage(ruUsageMessage()); env;	}
);

ruCommCategory = RuComm(
	"help-category", "help", "show all help categories", "", [],
	\task, env -> { env.conf.onMessage(ruCategoryMessage()); env;	}
);

ruCommServer = RuComm(
	"help-server", "help", "show all server modes", "", [],
	\task, env -> { env.conf.onMessage(ruServerMessage()); env;	}
);

ruRunHelp(task : RuTask, env : RuEnv) -> RuEnv {
	commands = getTreeValues(ruCommandsTree());
	cats = toLowerCase(lookupTreeDef(task.args, "category", ""));
	categories = 
		if (cats == "") {
			if (containsKeyTree(task.args, "category")) ["category"] else []
		} else {
			filtermap(
				strSplit(cats, ","),
				\cat -> if (cat == "") None() else Some(cat)
			);
		}
	if (categories != []) {
		env.conf.onMessage(strGlue(map(categories, ruHelpOn), ""));
	} else {
		env.conf.onMessage(ruHelpOn(""));
	}
	env;
}

ruHelpMessage(detailed : bool) -> string {
	commands = getTreeValues(ruCommandsTree());
	categories = set2array(fold(commands, makeSet(), \acc, comm -> 
		if (comm.category == "") acc else insertSet(acc, comm.category)
	));
	"Help invocation:\n" +
		"\t'russell help <category>,...,<category>'\n" +
		"\t'russell help <command>'\n" +
	(if (!detailed) "" else 
		"Special help commands:\n" +
		"\t'russell help usage'    -- usage message (command format)\n" +
		"\t'russell help category' -- the list of all command categories\n" +
		"\t'russell help server'   -- the list of all server modes\n"
	) +
	"List of all commands may be seen with:\n" +
		"\t'russell help all'\n";
}

ruUsageMessage() -> string {
	"Usage:\n" + 
		"\t'russell <task_1> ; ... ; <task_m>'\n" +
	"where task is:\n" + 
		"\t'<command> <arg_1>=<val_1> ... <arg_n>=<val_n>'\n";
}

ruCategoryMessage() -> string {
	commands = getTreeValues(ruCommandsTree());
	categories = sort(set2array(fold(commands, makeSet(), \acc, comm -> 
		if (comm.category == "") acc else insertSet(acc, comm.category)
	)));
	cat2commands : Tree<string, [string]> = foldTree(ruCommandsTree(), makeTree(), \name, comm, acc ->
		setTree(acc, comm.category, 
			concat(lookupTreeDef(acc, comm.category, []), [name])
		)
	);
	cat_matr = [
		categories,
		map(categories, \cat -> strGlue(lookupTreeDef(cat2commands, cat, []), ", ")),
	];
	"The list of all categories:\n" + 
	ruStringTable2s(cat_matr, Some(["Category", "Commands"])) + "\n";
}

ruServerMessage() -> string {
	"Starting a Russell server:\n" + 
		"\t'russell server=<mode>'\n" + 
	"where mode is one of:\n" + 
		"\thttp, lsp, console, repl\n" +
	"here repl is alias to console (i.e. it is the same).\n";
}

ruHelpOn(category : string) -> string {
	commands = getTreeValues(ruCommandsTree());
	if (category == "") {
		ruHelpMessage(true);
	} else if (category == "usage") {
		ruUsageMessage();
	} else if (category == "category") {
		ruCategoryMessage();
	} else if (category == "server") {
		ruServerMessage();
	} else {
		filtered = filter(commands, \comm -> comm.category == category || category == "all");
		if (filtered != []) ruComms2s(filtered, false) else {
			eitherMap(lookupTree(ruCommandsTree(), category), \comm -> ruComm2s(comm, true), "");
		}
	}
}

ru_running_scripts : ref Set<string> = ref makeSet();

ruCommRunScript = RuComm(
	"run-script", "misc", "load a script", "script",
	[RuCommArg("script", false, "the file with russell commands", "")],
	ruRunScript
);

ruRunScript(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "script", "");
	script = fileNameOnly(file);
	if (containsSet(^ru_running_scripts, script)) {
		env.conf.onError("Recursive scripts are not allowed.", []);
		env;
	} else {
		job = ruComposeJobFromScript(file, env.conf);
		ru_running_scripts := insertSet(^ru_running_scripts, script);
		new_env = ruExecJob(job, env.conf.onMessage, env);
		ru_running_scripts := removeSet(^ru_running_scripts, script);
		new_env
	}
}

ruComposeJobFromScript(file : string, conf : RuConf) -> RuJob {
	contents = strGlue(
		filtermap(strSplit(getFileContent(file), "\n"), \line -> 
			if (startsWith(line, "#")) None() else Some(line)
		), " "
	);
	params = filtermap(
		strSplit2(contents, [" ", "\r", "\t"]),
		\p -> {
			param = trim2(p, " \n\r\t");
			if (param == "" || startsWith(param, "#")) None() else Some(strSplit(param, "="));
		}
	);
	job = ruMakeJob(params);
	if (conf.verbose >= 2) {
		conf.onMessage("\tAbout to execute script: " + ruJob2s(job));
	}
	job;
}

ruCommVerifyMetamath = RuComm(
	"verify-mm", "misc", "verify a file with Metamath", "file",
	[RuCommArg("file", false, "the Metamath file", "")],
	ruRunVerifyMetamath
);

ruRunVerifyMetamath(task : RuTask, env : RuEnv) -> RuEnv {
	file = changeFileExt(lookupTreeDef(task.args, "file", ""), ".mm");
	if (env.conf.verbose > 1) {
		env.conf.onMessage("Going to verify " + file + " with Metamath");
	}
	code = execSystemProcess(
		"metamath", 
		["read " + fileNameOnly(file) + "",	"verify proof *", "exit"],
		ruDirName(file),
		\out -> env.conf.onMessage(out),
		\err -> env.conf.onMessage(err),
	);
	if (code != 0) {
		env.conf.onError("Verification of " + file + " with Metamath eneded up with return code: " + i2s(code), []);
	}
	env;
}
