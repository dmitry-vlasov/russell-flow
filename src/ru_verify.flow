import math/stringmath;
import ru_subst;

export {
	ruVerifyTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem>;
	ruVerifySource(src : RuSource, math : RuMath) -> Maybe<RuSource>;
	ruVerifyMath(math : RuMath) -> Maybe<RuMath>;
	ruMatchStep(step : RuStep, th : RuTheorem, math : RuMath) -> Maybe<Pair<RuAssertion, Tree<RuVar, RuExp>>>;
	ruCommandVerify(math : RuMath) -> RuMath;
}

ruVerifyMath(math0 : RuMath) -> Maybe<RuMath> {
	err_count = ref 0;
	math = RuMath(math0 with conf = ruAddErrCounter(math0.conf, err_count));
	start = timestamp();
	verified = ruDoVerifyMath(math.sources, math);
	if (math.conf.verbose > 0) {
		println("ru verified: " +i2s(sizeTree(verified.sources)) + " files in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	if (^err_count == 0) {
		Some(verified);
	} else {
		None();
	}
}



ruDoVerifyMath(left : Tree<string, RuSource>, acc : RuMath) -> RuMath {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.path))
		);
		verified = filtermap(ruConcurrent(map(ready, \s -> \-> ruVerifySource(s, acc))), idfn);
		new_acc = fold(verified, acc, \ac, v_src -> {
			new_assertions = fold(v_src.decls, ac.assertions, \a, decl ->
				switch (decl) {
					RuTheorem(name,__,__,__,__,__,__,__): setTree(a, name, decl);
					default: a;
				}
			);
			RuMath(ac with 
				assertions = new_assertions, 
				sources = setTree(ac.sources, v_src.info.file, v_src)
			);
		});
		new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.file));
		ruDoVerifyMath(new_left, new_acc);
	}
}

ruVerifySource(src : RuSource, acc : RuMath) -> Maybe<RuSource> {
	start = timestamp();
	correct = ref true;
	decls_acc = fold(src.decls, Pair([], acc), \ac, decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): {
				eitherMap(ruVerifyTheorem(decl, ac.second),
					\th -> Pair(
						concat(ac.first, [th]), 
						RuMath(ac.second with assertions = setTree(ac.second.assertions, th.name, th))
					),
					{ correct := false; ac }
				);
			}
			default: Pair(concat(ac.first, [decl]), ac.second);
		}
	);
	if (acc.conf.verbose > 1) {
		println("\tru verified: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	if (^correct) {
		Some(RuSource(src with decls = decls_acc.first));
	} else {
		None();
	}
}

ruStepRefExp(ref : RuRef, th : RuTheorem) -> RuExp {
	switch (ref) {
		RuHypRef(i,__): th.hyps[i].expr;
		RuStepRef(i,__): th.proof.steps[i].expr;
	}
}

ruMatchStep(step : RuStep, th : RuTheorem, math0 : RuMath) -> Maybe<Pair<RuAssertion, Tree<RuVar, RuExp>>> {
	step_ass_mgs = \ ->
		switch (lookupTree(math0.assertions, step.assertion)) {
			Some(ass): "\nstep assertion:\n" + ruAssertion2s(ass, math0.rules);
			None(): "";
		}
	math = RuMath(math0 with conf = ruAddErr2Conf(math0.conf, "\nstep match failed, step: " + ru2s(step, math0.rules) + step_ass_mgs()));
	matchExps = \e1, e2 -> {
		switch (ruMatchExp(e1, e2, math)) {
			Some(v): Some(v);
			None(): {
				math.conf.onError(
					"expression:\n\t" + ru2s(e1, math.rules) + "\ndo not match with:\n\t" + ru2s(e2, math.rules), 
					[RuPlace(ruNameSource(th.name, math).info.file, step.pos)]
				);
				None();
			}
		}
	}
	joinSubst = \s1, s2 -> {
		switch (ruMergeSubst(s1, s2)) {
			Some(s): Some(s);
			None(): {
				math.conf.onError(
					"substution:\n" + ruSubst2s(s1, math) + "\ncannot be joined with:\n" + ruSubst2s(s2, math), 
					[RuPlace(ruNameSource(th.name, math).info.file, step.pos)]
				);
				None();
			}
		}
	}
	switch (lookupTree(math.assertions, step.assertion)) {
		Some(ass0): {
			ass : RuAssertion = ass0;
			if (length(step.refs) != length(ass.hyps)) {
				math.conf.onError(
					"number of refs: " + i2s(length(step.refs)) + " mismatch assertion arity: " + i2s(length(ass.hyps)), 
					[RuPlace(ruNameSource(th.name, math).info.file, step.pos)]
				);
				None();
			} else
			maybeMap(
				maybeBind(
					foldi(ass.hyps, Some(makeTree()), \i, ac, h -> {
						switch (ac) {
							None(): None();
							Some(s): 
								if (i >= length(step.refs)) None() else
								maybeBind(
									matchExps(ruStepRefExp(step.refs[i], th), h.expr),
									\x -> joinSubst(s, x)
								);
						}
					}), 
					\s -> maybeBind(
						matchExps(step.expr, ass.prop),
						\x -> joinSubst(s, x)
					)
				),
				\subst -> Pair(ass, subst)
			);
		}
		None(): {
			math.conf.onError(
				"unknown assertion " + step.assertion, 
				[RuPlace(ruNameSource(th.name, math).info.file, step.pos)]
			);
			None();
		}
	}
}

ruVerifyTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem> {
	ret = maybeMap(
		fold(th.proof.steps, Some(makeSet()), \acc, step ->
			switch (acc) {
				None(): acc;
				Some(disjs): {
					switch (ruMatchStep(step, th, math)) {
						Some(p): ruComputeTheoremDisjs(p.second, disjs, p.first.disjs, th, math);
						None(): None();
					}
				}
			}
		), 
		\ds -> {
			th_vars = ruAssertion2Vars(th);
			th_ds = filterSet(ds, \d -> containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2));
			pr_ds = filterSet(ds, \d -> !(containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2)));
			RuTheorem(th with 
				disjs = th_ds,
				proof = RuProof(th.proof with disjs = pr_ds)
			)
		}
	)
	if (isNone(ret)) {
		math.conf.onError("verification of theorem failed\n" + ru2s(th, math.rules),[RuPlace(ruNameSource(th.name, math).info.file, th.pos)]);
		quit(0);
	} else if (math.conf.verbose > 2) {
		println("ru theorem verified: " + th.name);
	}
	ret;
}

ruComputeTheoremDisjs(s : Tree<RuVar, RuExp>, th_disjs : Set<RuDisj>, a_disjs : Set<RuDisj>, th : RuTheorem, math : RuMath) -> Maybe<Set<RuDisj>> {
	foldSet(a_disjs, Some(th_disjs), \acc, disj -> 
		maybeBind(acc, \th_dsj -> {
			e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], th.pos));
			e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], th.pos));
			e1_vars = ruExp2Vars(e1.nodes);
			e2_vars = ruExp2Vars(e2.nodes);
			common_vars = intersectSets(e1_vars, e2_vars);
			if (!isEmptySet(common_vars)) {
				math.conf.onError(
					"disjointed variables violation, variables: " + disj.v1.name + " and " + disj.v2.name +
					" are mappped onto expressions, with common vars: " + strGlue(map(set2array(common_vars), \v -> v.name), ", "), 
					[RuPlace(ruNameSource(th.name, math).info.file, th.pos)]
				);
				None();
			} else {
				Some(foldSet(e1_vars, th_dsj, \ac, w1 ->
					foldSet(e2_vars, ac, \a, w2 ->
						if (w1.name < w2.name) insertSet(a, RuDisj(w1, w2)) else 
						if (w2.name < w1.name) insertSet(a, RuDisj(w2, w1)) else a
					)
				));
			}
		})
	)
}

ruCommandVerify(math : RuMath) -> RuMath {
	target = lookupTreeDef(math.conf.opts, "default", "");
	if (target == "" || target == "all" || target == "1") {
		either(ruVerifyMath(math), math);
	} else {
		switch (lookupTree(math.assertions, target)) {
			Some(th): {
				switch (th) {
					RuTheorem(__,__,__,__,__,__,__,__): {
						start = timestamp();
						verified = ruVerifyTheorem(th, math);
						ret = eitherMap(verified, \t -> ruReplaceTheorem(t, math), math);
						if (math.conf.verbose > 0 && isSome(verified)) {
							println("theorem " + target + " is verified " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
						}
						ret;
					}
					default: {
						println("assertion " + target + " is not a theorem");
						math;
					}
				}
			}
			None(): {
				switch (lookupTree(math.sources, target)) {
					Some(src): {
						start = timestamp();
						switch (ruVerifySource(src, math)) {
							Some(verified): {
								ret = fold(ruSourceTheorems(verified), math, \acc, th -> ruReplaceTheorem(th, acc));
								if (math.conf.verbose > 0) {
									println("source " + target + " is verified in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
								}
								ret;
							}
							None(): {
								if (math.conf.verbose > 0) {
									println("verification of source " + target + " failed in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
								}
								math
							}
						}
					}
					None(): {
						println("verification target " + target + " is not found");
						math;
					}
				}
			}
		}
	}
}
