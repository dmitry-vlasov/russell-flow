import prover/ru_prover_tree;
import ru_index;
import ru_stats;

export {
	// Theorem with non-changeable variables replaced by constants
	RuConstTheorem(
		original : RuTheorem,
		const    : RuTheorem,
		doconst  : (RuExp) -> RuExp,
		unconst  : (RuExp) -> RuExp,
		math     : RuMath
	);

	ruInitAssertionsIndex(th_name : string, math : RuMath, conf : RuConf) -> RuIndex<RuAssertion>;
	ruInitGlobalAssertionsIndex(math : RuMath) -> RuIndex<RuAssertion>;
	ruInitPremisesIndex(th : RuTheorem) -> RuIndex<RuHyp>;
	ruConstTheorem(th : RuTheorem, math0 : RuMath) -> RuConstTheorem;

	ruExpIsLess(e : RuExp, maxLen : int) -> bool;
	ruSubIsLess(s : Tree<RuVar, RuExp>, maxLen : int) -> bool;
}

ruInitAssertionsIndex(th_name : string, math : RuMath, conf : RuConf) -> RuIndex<RuAssertion> {
	t = timestamp();
	switch (ruNameSource(th_name, math)) {
		Some(th_src): {
			all_imported = removeSet(ruCollectAllImported(th_name, math), th_src);
			index = foldTree(math.assertions, ruMakeIndex(), 
				\name, ws, acc -> {
					ass = ws.item;
					switch (ruNameSource(name, math)) {
						Some(ass_src): {
							if (containsSet(all_imported, ass_src)) {
								ruSetIndex(ass.prop, ass, acc);
							} else if (ass_src == th_src) {
								if (ruIndexOfDecl(name, ass_src) < ruIndexOfDecl(th_name, th_src)) {
									ruSetIndex(ass.prop, ass, acc);
								} else {
									acc
								}
							} else {
								acc
							}
						}
						None(): {
							conf.onMessage("assertion: '" + name + "' is not found");
							acc;
						}
					}
				}
			);
			stats = RuStatsRow("theorem: " + th_name, 
				pairs2tree([Pair("size", i2d(sizeSet(all_imported))), Pair("time", timestamp() - t)])
			);
			ruAddStats("init_assertion_index", stats);
			index;
		}
		None(): {
			conf.onMessage("theorem: '" + th_name + "' is not found");
			ruMakeIndex();
		}
	}
}

ruInitGlobalAssertionsIndex(math : RuMath) -> RuIndex<RuAssertion> {
	foldTree(math.assertions, ruMakeIndex(), \name, ass, acc ->
		ruSetIndex(ass.item.prop, ass.item, acc)
	);
}


ruInitPremisesIndex(th : RuTheorem) -> RuIndex<RuHyp> {
	fold(th.hyps, ruMakeIndex(), \acc, h -> ruSetIndex(h.expr, h, acc));
}

ruConstTheorem(th : RuTheorem, math0 : RuMath) -> RuConstTheorem {
	th_vars = set2array(mergeSets(ruAssertion2Vars(th), ruProof2Vars(th.proof)));
	cv_vars = filter(th_vars, \v -> !containsSet(th.meta, v.name));
	cv_name = \cv -> "_" + cv.name;
	cv_rules = map(cv_vars, \cv -> RuWithSource(RuRule(cv_name(cv), makeTree(), RuTerm(cv.type, [RuConstRef(cv_name(cv))], -1), -1), ""));
	math = RuMath(math0 with rules = mergeTree(math0.rules, values2tree(cv_rules, \r -> r.item.name)));
	cv_map = keys2tree(cv_vars, \cv -> RuRuleRef(cv_name(cv), cv.type, 0, 0));
	cv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(cv_map, n, n)), e.pos);
	uncv_map = foldTree(cv_map, makeTree(), \v, cv, acc -> setTree(acc, cv, v));
	uncv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(uncv_map, n, n)), e.pos);
	RuConstTheorem(
		th,
		ruTransformTheorem(th, cv_exp),
		cv_exp,
		uncv_exp,
		math
	);
}

ruExpIsLess(e : RuExp, maxLen : int) -> bool {
	maxLen == -1 || length(e.nodes) <= maxLen;
}

ruSubIsLess(s : Tree<RuVar, RuExp>, maxLen : int) -> bool {
	allTreeSatisfies(s, \__, ex -> ruExpIsLess(ex, maxLen));
}
