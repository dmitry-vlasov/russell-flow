import prover/ru_prover;

export {
	ruCommandReproveTask(math : RuMath) -> RuMath;
	ruCommandExpressionLenStats(math : RuMath) -> void;
}

ruCommandExpressionLenStats(math : RuMath) -> void {
	traverseInOrder(ruMathTheorems(math), \__, th ->
		iter(th.proof.steps, \step ->
			ruAddStats("expr_lens", RuStatsRow(
					ru2s(step.expr, math.rules), 
					pairs2tree([Pair("size", length(step.expr.nodes)), Pair("count", 1)])
				)
			)
		)
	);
	println("<< expression lens stats >>");
	println("distrib lens: ");
	println(ruIndent(ruProcStats("expr_lens", ruDistribLinSumStats("size", "count", 10))));
	println("max size:   " + ruProcStats("expr_lens", ruMaxStats("size")));
	println("avg size:   " + ruProcStats("expr_lens", ruAvgStats("size")));
	println("sigma size: " + ruProcStats("expr_lens", ruSigmaStats("size")));
}

ruReproveTactic(theorem : RuTheorem, math : RuMath, mapping : ref Tree<RuProverProp, RuProofStep>) -> (RuProverTree) -> Maybe<RuProverProp> {
	proof = ruMakeTreeProof(theorem, math);
	leafs = ref [];
	queue = ref [];
	\tree -> {
		if (length(^queue) == 0) {
			if (sizeTree(^mapping) == 0) {
				traverseInOrder(tree.leafs, \__, n -> 
					if (length(^queue) == 0) {
						switch (n.parent) {
							RuProverRoot(__,__,__):
								if (n.assertion == proof.assertion) {
									queue := [Pair(n, proof)];
								}
							default: {}
						}
					}
				);
			} else if (length(^leafs) > 0) {
				n = ^leafs[0].first;
				s = ^leafs[0].second;
				leafs := tail(^leafs);
				iteri(^(n.children), \i, child -> {
					step_child = s.children[i];
					switch (step_child) {
						RuProofStep(assertion,__,__) : {
							iter(^(child.children), \grand ->
								if (grand.assertion == assertion) {
									refArrayPush(queue, Pair(grand, step_child));
								}
							);
						}
						default: { }
					}
				});
			}
		}
		if (length(^queue) > 0) {
			n = ^queue[0].first;
			s = ^queue[0].second;
			queue := tail(^queue);
			if (exists(s.children, \ch -> switch (ch) { RuProofStep(__,__,__): true; default: false; })) {
				refArrayPush(leafs, Pair(n, s));
			}
			mapping := setTree(^mapping, n, s);
			Some(n);
		} else {
			None();
		}
	}
}

ruReproveUnifyPremise(unify : (RuProverHyp) -> [RuUnified<RuHyp>], mapping : ref Tree<RuProverProp, RuProofStep>, math : RuMath) -> (RuProverHyp) -> [RuUnified<RuHyp>] {
	if (ruOptIsTrue("reprove-singletons", math.conf)) {
		\hyp : RuProverHyp ->  {
			unif = unify(hyp);
			switch (hyp) {
				RuProverExp(i, __,__,__, parent): {
					switch (lookupTree(^mapping, parent)) {
						Some(step): {
							switch (step.children[i]) {
								RuProofStep(__,__,__): [];
								RuProofHyp(h,__): filter(unif, \un -> un.data.ind == h.ind);
							}
						}
						None(): {
							println("must not happen");
							quit(-1);
							[]; // must not be
						}
					}
				}
				RuProverRoot(__,__,__): unif;
			}
		}
	} else unify;
}

ruReproveUnifyAssertion(unify : (RuProverHyp) -> [RuUnified<RuAssertion>], mapping : ref Tree<RuProverProp, RuProofStep>, math : RuMath) -> (RuProverHyp) -> [RuUnified<RuAssertion>] {
	if (ruOptIsTrue("reprove-singletons", math.conf)) {
		\hyp : RuProverHyp ->  {
			switch (hyp) {
				RuProverExp(i, __,__,__, parent): {
					switch (lookupTree(^mapping, parent)) {
						Some(step): {
							switch (step.children[i]) {
								RuProofStep(assertion, children, expr): {
									e1 = hyp.expr;
									e2 = assertion.prop;
									eitherMap(
										ruUnifyExps([e1, e2],makeTree(), math),
										\sub -> [RuUnified(sub, assertion, ruApplySubst(e1, sub))], []
									);
								}
								RuProofHyp(h,__): [];
							}
						}
						None(): {
							println("must not happen");
							quit(-1);
							[]; // must not be
						}
					}
				}
				RuProverRoot(__,__,__): unify(hyp);
			}
		}
	} else unify;
}

ruCommandReproveTask(math : RuMath) -> RuMath {
	target = lookupTreeDef(math.conf.opts, "default", "1");
	reproved_count = ref 0;
	failed_count = ref 0;
	failed_th_names = ref [];
	max_time = ref 0.0;
	max_th_name = ref "";
	reprove_th = \th, index -> {
		start = timestamp();
		mapping = ref makeTree();
		env0 = ruInitProver(th, math, index);
		env = RuProverEnv(env0 with
			reproveMap = mapping,
			unifyAssertion = ruReproveUnifyAssertion(env0.unifyAssertion, mapping, math),
			unifyPremise = ruReproveUnifyPremise(env0.unifyPremise, mapping, math),
		);
		if (ruOptIsTrue("reprove-stats", env.math.conf)) {
			init_stats = RuStatsRow("reprove init " + th.name, 
				pairs2tree([Pair("size", length(th.proof.steps)), Pair("time", cast(timestamp() - start : double -> int))])
			);
			ruAddStats("reprove_init", init_stats);
		}
		t = timestamp();
		ruProve(env, ruReproveTactic(th, math, mapping));
		tm = cast(timestamp() - start : double -> int);
		time = (timestamp() - start)/ 1000.0;
		if (time > ^max_time) {
			max_time := time;
			max_th_name := th.name;
		}
		if (ruOptIsTrue("reprove-stats", env.math.conf)) {
			reprove_stats = RuStatsRow("reprove do " + th.name, 
				pairs2tree([Pair("size", ruSizeProverTree(env.tree.root)), Pair("time", cast(timestamp() - t : double -> int))])
			);
			ruAddStats("reprove_do", reprove_stats);
			stats = RuStatsRow("reproved all " + th.name, 
				pairs2tree([Pair("size", ruSizeProverTree(env.tree.root)), Pair("time", tm)])
			);
			ruAddStats("reprove_all", stats);
		}
		if (^(env.proofs) == []) {
			atomicRefIntAddition(failed_count, 1);
			println("theorem " + th.name + " was NOT reproved in " + d2st(time, 2) + "s");
			println(ru2s(th, math.rules));
			refArrayPush(failed_th_names, th.name);
			//quit(-1);
			false;
		} else {
			if (math.conf.verbose > 0) {
				atomicRefIntAddition(reproved_count, 1);
				println(i2s(^reproved_count) + " theorem " + th.name + " was REPROVED in " + d2st(time, 2) + "s");
			}
			true;
		}
	}
	reprove_ass = \ass : RuAssertion -> 
		switch (ass) {
			RuTheorem(__,__,__,__,__,__,__,__): reprove_th(ass, None());
			default: true;
		}
	reprove_decl = \decl : RuBlock ->
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): reprove_th(decl, None());
			default: true;
		}
	reprove_decls = \decls ->
		all(ruConcurrent(map(decls, \d -> \-> reprove_decl(d))));
	start = timestamp();
	ret = if (target == "all" || target == "1") {
		decls = filtermap(concatA(map(ruOrderSources(math), \src -> src.decls)), ruBlock2Assertion);
		chunks = splitByNumber(decls, s2i(ruOptDef("reprove-split-num", "256", math.conf)));
		fold(chunks, Pair(ruMakeIndex(), true), \acc, chunk -> {
			indexes = foldi(chunk, Pair(acc.first, []), \i, ac, ass ->
				Pair(ruSetIndex(ass.prop, ass, ac.first), concat(ac.second, [ac.first]))
			);
			ret = all(ruConcurrent(mapi(chunk, \i, ass -> 
					\-> eitherMap(ruAssertion2Theorem(ass), \th -> reprove_th(th, Some(indexes.second[i])), true)
			)));
			Pair(indexes.first, ret && acc.second)
		}).second;
	} else if (target == "1-seq" || target == "all-seq") {
		reprove_decls(concatA(map(ruOrderSources(math), \src -> src.decls)));
	} else {
		switch (lookupTree(math.sources, target)) {
			Some(src): reprove_decls(src.decls);
			None(): {
				switch (lookupTree(math.assertions, target)) {
					Some(ass): reprove_ass(ass);
					None(): {
						println("no target for reproving");
						false
					}
				}
			}
		}
	}
	if (math.conf.verbose > 0) {
		println("ru reproved in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
		println("Max time: " + d2st(^max_time, 2) + "s for a theorem: " + ^max_th_name);
	}
	if (/*math.conf.verbose > 0 ||*/ ^failed_count > 0) {
		println("Reproved: " + i2s(^reproved_count) + " theorems,");
		println("Failed to reprove: " + i2s(^failed_count) + " theorems:");
		iter(^failed_th_names, \th -> println("\t" + th));
	}
	if (ruOptIsTrue("reprove-stats", math.conf)) {
		println("<< reprove all >>");
		println("complete reprove distrib: ");
		println(ruIndent(ruProcStats("reprove_all", ruDistribLogSumStats("size", "time", 2))));
		println("sum reprove all time: " + ruProcStats("reprove_all", ruSumStats("time")));
		println("max size: " + ruProcStats("reprove_all", ruMaxStats("size")));
		println("max time: " + ruProcStats("reprove_all", ruMaxStats("time")));
		println("");
	
		println("<< reprove init >>");
		println("reprove init distrib: ");
		println(ruIndent(ruProcStats("reprove_init", ruDistribLogSumStats("size", "time", 2))));
		println("sum init time: " + ruProcStats("reprove_init", ruSumStats("time")));
		println("max size: " + ruProcStats("reprove_init", ruMaxStats("size")));
		println("max time: " + ruProcStats("reprove_init", ruMaxStats("time")));
		println("");
	
		println("<< unify_assertion >>");
		println(ruIndent(ruProcStats("unify_assertion", ruDistribLogSumStats("size", "time", 2))));
		println("sum unify_assertion time: " + ruProcStats("unify_assertion", ruSumStats("time")));
		println("max size: " + ruProcStats("unify_assertion", ruMaxStats("size")));
		println("max rets: " + ruProcStats("unify_assertion", ruMaxStats("rets")));
		println("max time: " + ruProcStats("unify_assertion", ruMaxStats("time")));
		println("");

		println("<< unify_premise >>");
		println(ruIndent(ruProcStats("unify_premise", ruDistribLogSumStats("size", "time", 2))));
		println("sum unify_premise time: " + ruProcStats("unify_premise", ruSumStats("time")));
		println("max size: " + ruProcStats("unify_premise", ruMaxStats("size")));
		println("max rets: " + ruProcStats("unify_premise", ruMaxStats("rets")));
		println("max time: " + ruProcStats("unify_premise", ruMaxStats("time")));
		println("");

		println("<< ruExpandProp >>");
		println(ruIndent(ruProcStats("ruExpandProp", ruDistribLogSumStats("time", "count", 2))));
		println("sum ruExpandProp time: " + ruProcStats("ruExpandProp", ruSumStats("time")));
		println("max time: " + ruProcStats("ruExpandProp", ruMaxStats("time")));
		println("");
		
		println("<< choice >>");
		println(ruIndent(ruProcStats("choice", ruDistribLogSumStats("size", "time", 2))));
		println("sum choice time: " + ruProcStats("choice", ruSumStats("time")));
		println("max time: " + ruProcStats("choice", ruMaxStats("time")));
		println("max size: " + ruProcStats("choice", ruMaxStats("size")));
		println("");

		println("<< ruExpandHyp >>");
		println(ruIndent(ruProcStats("ruExpandHyp", ruDistribLogSumStats("time", "count", 2))));
		println("sum ruExpandHyp time: " + ruProcStats("ruExpandHyp", ruSumStats("time")));
		println("max time: " + ruProcStats("ruExpandHyp", ruMaxStats("time")));
		println("");

		println("<< removeFirst >>");
		println(ruIndent(ruProcStats("removeFirst", ruDistribLogSumStats("time", "count", 2))));
		println("sum removeFirst time: " + ruProcStats("removeFirst", ruSumStats("time")));
		println("max time: " + ruProcStats("removeFirst", ruMaxStats("time")));
		println("");
		
		println("<< add_unified >>");
		println(ruIndent(ruProcStats("add_unified", ruDistribLogSumStats("time", "count", 2))));
		println(ruIndent(ruProcStats("add_unified", ruDistribLogSumStats("size", "time", 2))));
		println("sum add_unified count: " + ruProcStats("add_unified", ruSumStats("count")));
		println("sum add_unified time: " + ruProcStats("add_unified", ruSumStats("time")));
		println("sum add_unified time2: " + ruProcStats("add_unified", ruSumStats("time2")));
		println("sum add_unified time3: " + ruProcStats("add_unified", ruSumStats("time3")));
		println("sum add_unified time4: " + ruProcStats("add_unified", ruSumStats("time4")));
		println("sum add_unified time5: " + ruProcStats("add_unified", ruSumStats("time5")));
		println("sum add_unified time6: " + ruProcStats("add_unified", ruSumStats("time6")));
		println("max time: " + ruProcStats("add_unified", ruMaxStats("time")));
		println("max time2: " + ruProcStats("add_unified", ruMaxStats("time2")));
		println("max time3: " + ruProcStats("add_unified", ruMaxStats("time3")));
		println("max time4: " + ruProcStats("add_unified", ruMaxStats("time4")));		
		println("max time5: " + ruProcStats("add_unified", ruMaxStats("time5")));
		println("max time6: " + ruProcStats("add_unified", ruMaxStats("time6")));
		println("");

		println("<< ruBuildPropProofs >>");
		println(ruIndent(ruProcStats("ruBuildPropProofs", ruDistribLogSumStats("time", "count", 2))));
		println("sum ruBuildPropProofs time: " + ruProcStats("ruBuildPropProofs", ruSumStats("time")));
		println("max time: " + ruProcStats("ruBuildPropProofs", ruMaxStats("time")));
		println("");

		println("<< reprove do >>");
		println("do reprove distrib sum: ");
		println(ruIndent(ruProcStats("reprove_do", ruDistribLogSumStats("size", "time", 2))));
		println("do reprove distrib avg: ");
		println(ruIndent(ruProcStats("reprove_do", ruDistribLogAvgStats("size", "time", 2))));
		println("sum do reprove: " + ruProcStats("reprove_do", ruSumStats("time")));
		println("max size: " + ruProcStats("reprove_do", ruMaxStats("size")));
		println("max time: " + ruProcStats("reprove_do", ruMaxStats("time")));
		println("avg time: " + ruProcStats("reprove_do", ruAvgStats("time")));
		println("");
	
		/*println("<< init_assertion_index >>");
		println("init_assertion_index times: ");
		println(ruIndent(ruProcStats("init_assertion_index", ruDistribLogSumStats("size", "time", 2))));
		println("sum init_assertion_index time: " + ruProcStats("init_assertion_index", ruSumStats("time")));
		println("max size: " + ruProcStats("init_assertion_index", ruMaxStats("size")));
		println("max time: " + ruProcStats("init_assertion_index", ruMaxStats("time")));
		println("");*/
	
		println("<< add_proof >>");
		println("prod times: ");
		println(ruIndent(ruProcStats("add_proof_prod", ruDistribLogSumStats("size", "time", 10))));
		println("sum prod time: " + ruProcStats("add_proof_prod", ruSumStats("time")));
		println("tree times: ");
		println(ruIndent(ruProcStats("add_proof_tree", ruDistribLogSumStats("size", "time", 10))));
		println("sum tree time: " + ruProcStats("add_proof_tree", ruSumStats("time")));
		println("max size: " + ruProcStats("add_proof", ruMaxStats("size")));
		println("max time: " + ruProcStats("add_proof", ruMaxStats("time")));
		println("max rets: " + ruProcStats("add_proof", ruMaxStats("rets")));
		//println("data len: " + ruProcStats("add_proof", \rows -> i2s(length(rows))));
		println("");

		println("<< unif_index_prod >>");
		println("max size: " + ruProcStats("unif_index_prod", ruMaxStats("size")));
		println("max time: " + ruProcStats("unif_index_prod", ruMaxStats("time")));
		println("max rets: " + ruProcStats("unif_index_prod", ruMaxStats("rets")));
		println("sum time: " + ruProcStats("unif_index_prod", ruSumStats("time")));
		println("");

		println("<< intersect_index_prod >>");
		println("max size: " + ruProcStats("intersect_index_prod", ruMaxStats("size")));
		println("max time: " + ruProcStats("intersect_index_prod", ruMaxStats("time")));
		println("max rets: " + ruProcStats("intersect_index_prod", ruMaxStats("rets")));
		println("sum time: " + ruProcStats("intersect_index_prod", ruSumStats("time")));
		println("");

		println("<< unfy_subs_index_prod >>");
		println("max size: " + ruProcStats("unfy_subs_index_prod", ruMaxStats("size")));
		println("max time: " + ruProcStats("unfy_subs_index_prod", ruMaxStats("time")));
		println("max rets: " + ruProcStats("unfy_subs_index_prod", ruMaxStats("rets")));
		println("sum time: " + ruProcStats("unfy_subs_index_prod", ruSumStats("time")));
		println("");
	}
	math
}
