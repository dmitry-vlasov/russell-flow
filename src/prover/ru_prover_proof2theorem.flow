import prover/ru_prover_prove;
import prover/ru_prover_stats;
import ru_reindex_theorem_vars;

export {
	ruProof2Theorem(name : string, proof : RuDAG<string>, math : RuMath, conf : RuConf, time_limit : double) -> Maybe<RuTheorem>;
}

ruProof2Theorem(name : string, proof : RuDAG<string>, math : RuMath, conf : RuConf, time_limit : double) -> Maybe<RuTheorem> {
	steps = ref [];
	premises = ref ruMakeIndex();
	ruProve(ruInitBuildProofEnv(proof, math, conf, time_limit, steps, premises));
	hyps = sortCustom(ruIndexValues(^premises), \hyp -> hyp.ind, true);
	prop = (^steps)[length(^steps) - 1].expr;
	vars = foldSet(
		fold(hyps, ruExp2Vars(prop.nodes), \acc, hyp -> mergeSets(acc, ruExp2Vars(hyp.expr.nodes))), 
		makeTree(),	\acc, v -> setTree(acc, v.name, v)
	);
	th = RuTheorem(name, vars, makeSet(), makeSet(), hyps, prop, ruNoProof, -1);
	maybeBind(
		ruUpdateTheoremWithSteps(th, ^steps, math, conf),
		\updated -> {
			reindexed = ruReindexTheoremVars(updated, conf);
			ruVerifyTheorem(reindexed, math, conf);
		}
	);
}

ruInitBuildProofEnv(
	proof : RuDAG<string>, 
	math : RuMath, conf : RuConf, ms_time_limit : double, 
	steps : ref [RuStep], premises : ref RuIndex<RuHyp>
) -> RuProverEnv {
	find_ass = \name -> lookupTreeDef(math.assertions, name, RuWithSource(ruNoAxiom, "")).item;
	root_ass = find_ass(proof.data);
	mapping : ref Tree<RuProverProp, RuDAG<string>> = ref makeTree();
	vars = ref makeTree();
	fresher = \v -> {
		vars := setTree(^vars, v, lookupTreeDef(^vars, v, 0) + 1);
		RuVar(v.name + "_" + i2s(lookupTreeDef(^vars, v, 0)), v.type);
	}
	root_exp = ruApplySubst(
		root_ass.prop,
		ruMakeFresh(set2array(ruExp2Vars(root_ass.prop.nodes)), fresher)
	);
	root = RuProverRoot(ref [], root_exp, ref []);
	id = ref 0;
	env = RuProverEnv(
		{ started = timestamp(); \-> timestamp() - started > ms_time_limit },
		\__ -> true,
		RuProverTree(makeTree(), root),
		ruBuildUnifyAssertion(math, conf, mapping, root_ass),
		ruBuildUnifyPremise(math, conf, mapping, premises),
		ruBuildTactic(),
		math,
		conf,
		fresher,
		idfn,
		\s -> steps := s,
		ruBuildOnProp(conf, mapping, proof),
		\ -> { ret = ^id; id := ^id + 1; ret; },
	);
	ruExpandHyp(env.tree.root, env);
}

ruBuildUnifyAssertion(
	math : RuMath, 
	conf : RuConf, 
	mapping : ref Tree<RuProverProp, RuDAG<string>>,
	root_ass : RuAssertion
) -> (RuProverHyp) -> [RuUnified<RuAssertion>] {
	\hyp -> {
		switch (hyp) {
			RuProverExp(ind,__,expr,__,parent): {
				switch (lookupTree(^mapping, parent)) {
					Some(node): {
						switch (lookupTree(math.assertions, node.children[ind].data)) {
							Some(ws): {
								a = ws.item;
								switch (ruUnifyExps([expr, a.prop], makeTree(), math, conf)) {
									Some(theta): [RuUnified(theta, a, ruApplySubst(a.prop, theta))];
									None(): [];
								}
							}
							None(): [];
						}
					}
					None(): {
						conf.onMessage("must not happen");
						quit(-1);
						[];
					}
				}
			}
			RuProverRoot(__,expr,__): {
				switch (ruUnifyExps([expr, root_ass.prop], makeTree(), math, conf)) {
					Some(theta): [RuUnified(theta, root_ass, ruApplySubst(root_ass.prop, theta))];
					None(): [];
				}
			}
		}
	}
}

ruBuildUnifyPremise(
	math : RuMath, 
	conf : RuConf, 
	mapping : ref Tree<RuProverProp, RuDAG<string>>,
	premises : ref RuIndex<RuHyp>
) -> (RuProverHyp) -> [RuUnified<RuHyp>] {
	hyp_parent = \hyp -> {
		switch (hyp) {
			RuProverExp(__,__,__,__,parent): parent;
			default: ruNoProverProp;
		}
	}
	\hyp -> {
		switch (lookupTree(^mapping, hyp_parent(hyp))) {
			Some(node): {
				if (node.children != []) [] else {
					hyps = ruFindIndex(hyp.expr, ^premises, math);
					if (hyps == []) {
						h = RuHyp(ruIndexDataCount(^premises), hyp.expr, -1);
						premises := ruSetIndex(hyp.expr, h, ^premises);
						[RuUnified(makeTree(), h, hyp.expr)];
					} else {
						[RuUnified(makeTree(), hyps[0], hyp.expr)];
					}
				}
			}
			None(): {
				conf.onMessage("must not happen");
				quit(-1);
				[];
			}
		}
	}
}

ruBuildTactic() -> (RuProverTree) -> Maybe<RuProverProp> {
	\tree -> {
		switch (tree.leafs) {
			TreeNode(__,prop,__,__,__): Some(prop);
			TreeEmpty(): None();
		}
	}
}

ruBuildOnProp(conf : RuConf, mapping : ref Tree<RuProverProp, RuDAG<string>>, proof : RuDAG<string>) -> (RuProverProp) -> void {
	\prop -> {
		hyp = prop.parent;
		switch (hyp) {
			RuProverExp(ind,__,__,__,parent): {
				switch (lookupTree(^mapping, parent)) {
					Some(grand): mapping := setTree(^mapping, prop, grand.children[ind]);
					None(): {
						conf.onMessage("must not happen");
						quit(-1);
					}
				}		
			}
			RuProverRoot(__,__,__): {
				mapping := setTree(^mapping, prop, proof);
			}
		}
	}
}

