import prover/ru_prover_prove;
import prover/ru_prover_stats;

export {
	ruBuildProof(proof : RuDAG<string>, math : RuMath, conf : RuConf, time_limit : double) -> [RuStep];
}

ruBuildProof(proof : RuDAG<string>, math : RuMath, conf : RuConf, time_limit : double) -> [RuStep] {
	steps = ref [];
	ruProve(ruInitBuildProofEnv(proof, math, conf, time_limit, steps));
	^steps;
}

ruInitBuildProofEnv(proof : RuDAG<string>, math : RuMath, conf : RuConf, ms_time_limit : double, steps : ref [RuStep]) -> RuProverEnv {
	find_ass = \name -> lookupTreeDef(math.assertions, name, RuWithSource(ruNoAxiom, "")).item;
	root_ass = find_ass(proof.data);
	mapping : ref Tree<RuProverProp, RuDAG<string>> = ref makeTree();
	vars = ref makeTree();
	root = RuProverRoot(ref [], root_ass.prop, ref []);
	premises = ref ruMakeIndex();
	id = ref 0;
	env = RuProverEnv(
		{ started = timestamp(); \-> timestamp() - started > ms_time_limit },
		\__ -> true,
		RuProverTree(makeTree(), root),
		ruBuildUnifyAssertion(math, conf, mapping, root_ass),
		ruBuildUnifyPremise(math, conf, mapping, premises),
		ruBuildTactic(),
		math,
		conf,
		\v -> {
			vars := setTree(^vars, v, lookupTreeDef(^vars, v, 0) + 1);
			RuVar(v.name + "_" + i2s(lookupTreeDef(^vars, v, 0)), v.type);
		},
		idfn,
		\s -> steps := s,
		ruBuildOnProp(conf, mapping, proof),
		\ -> { ret = ^id; id := ^id + 1; ret; },
	);
	ruExpandHyp(env.tree.root, env);
}

ruBuildUnifyAssertion(
	math : RuMath, 
	conf : RuConf, 
	mapping : ref Tree<RuProverProp, RuDAG<string>>,
	root_ass : RuAssertion
) -> (RuProverHyp) -> [RuUnified<RuAssertion>] {
	\hyp -> {
		switch (hyp) {
			RuProverExp(ind,__,__,__,parent): {
				switch (lookupTree(^mapping, parent)) {
					Some(node): {
						switch (lookupTree(math.assertions, node.children[ind].data)) {
							Some(ws): {
								a = ws.item;
								switch (ruUnifyExps([hyp.expr, a.prop], makeTree(), math, conf)) {
									Some(theta): [RuUnified(theta, a, ruApplySubst(a.prop, theta))];
									None(): [];
								}
							}
							None(): [];
						}
					}
					None(): {
						conf.onMessage("must not happen");
						quit(-1);
						[];
					}
				}
			}
			RuProverRoot(__,e,__): {
				[RuUnified(makeTree(), root_ass, e)];
			}
		}
	}
}

ruBuildUnifyPremise(
	math : RuMath, 
	conf : RuConf, 
	mapping : ref Tree<RuProverProp, RuDAG<string>>,
	premises : ref RuIndex<RuHyp>
) -> (RuProverHyp) -> [RuUnified<RuHyp>] {
	hyp_parent = \hyp -> {
		switch (hyp) {
			RuProverExp(__,__,__,__,parent): parent;
			default: ruNoProverProp;
		}
	}
	\hyp -> {
		switch (lookupTree(^mapping, hyp_parent(hyp))) {
			Some(node): {
				if (node.children != []) [] else {
					hyps = ruFindIndex(hyp.expr, ^premises, math);
					if (hyps == []) {
						h = RuHyp(ruIndexDataCount(^premises), hyp.expr, -1);
						premises := ruSetIndex(hyp.expr, h, ^premises);
						[RuUnified(makeTree(), h, hyp.expr)];
					} else {
						[RuUnified(makeTree(), hyps[0], hyp.expr)];
					}
				}
			}
			None(): {
				conf.onMessage("must not happen");
				quit(-1);
				[];
			}
		}
	}
}

ruBuildTactic() -> (RuProverTree) -> Maybe<RuProverProp> {
	\tree -> {
		switch (tree.leafs) {
			TreeNode(__,prop,__,__,__): Some(prop);
			TreeEmpty(): None();
		}
	}
}

ruBuildOnProp(conf : RuConf, mapping : ref Tree<RuProverProp, RuDAG<string>>, proof : RuDAG<string>) -> (RuProverProp) -> void {
	\prop -> {
		hyp = prop.parent;
		switch (hyp) {
			RuProverExp(ind,__,__,__,parent): {
				switch (lookupTree(^mapping, parent)) {
					Some(grand): mapping := setTree(^mapping, prop, grand.children[ind]);
					None(): {
						conf.onMessage("must not happen");
						quit(-1);
					}
				}		
			}
			RuProverRoot(__,__,__): {
				mapping := setTree(^mapping, prop, proof);
			}
		}
	}
}

