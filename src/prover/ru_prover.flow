import prover/ru_prover_tree;
import ru_index;

export {
	RuProverEnv(
		tree : RuProverTree,
		assertions : RuIndex<RuAssertion>,
		premises : RuIndex<RuHyp>
	);

	ruInitProver(theorem : RuTheorem, math : RuMath) -> RuProverEnv;
}

ruInitProver(th : RuTheorem, math : RuMath) -> RuProverEnv {
	th_vars = set2array(ruAssertion2Vars(th));
	cv_vars = filter(th_vars, \v -> !containsSet(th.meta, v.name));
	cv_name = \cv -> "__cv_" + cv.name;
	cv_rules = map(cv_vars, \cv -> RuRule(cv_name(cv), makeTree(), RuTerm(cv.type, [RuConstRef(cv.name)], -1), -1));
	cv_map = keys2tree(cv_vars, \cv -> RuRuleRef(cv_name(cv), cv.type, 0, 0));
	cv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(cv_map, n, n)), e.pos);
	th_prop = cv_exp(th.prop);
	th_hyps = map(th.hyps, \h -> RuHyp(h.ind, cv_exp(h.expr), h.pos));
	premises = fold(th_hyps, ruMakeIndex(), \acc, h -> ruSetIndex(h.expr, Some(h), acc, \h1, h2 -> h1));
	
	all_imported = foldSet(ruCollectAllImported(th.name, math), ruMakeIndex(), 
		\acc, src
	)
	
	RuProverEnv(
		RuProverTree([], RuProverHyp([], None(), [], th_prop)),
		ruMakeIndex(),
		premises
	)
}


