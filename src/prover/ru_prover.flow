import prover/ru_prover_util;
import ru_verify;
import ru_stats;
import ru_prod;

export {

	RuProverEnv(
		timeLimit : () -> bool,
		maxExLen : int,
		theorem : RuTheorem,
		tree : RuProverTree,
		unifyAssertion : (hyp : RuProverHyp) -> [RuUnified<RuAssertion>],
		unifyPremise   : (hyp : RuProverHyp) -> [RuUnified<RuHyp>],
		math : RuMath,
		fresher : (RuVar) -> RuVar,
		unconst : (RuExp) -> RuExp,
		proofs : ref [RuProof],
		idxer : () -> int,
		reproveMap : ref Tree<RuProverProp, RuProofStep>
	);

	ruInitProver(theorem : RuTheorem, math : RuMath, asses : Maybe<RuIndex<RuAssertion>>) -> RuProverEnv;
	ruExpandProp(prop : RuProverProp, env : RuProverEnv) -> RuProverEnv;
	ruProve(env : RuProverEnv, tactic : (RuProverTree) -> Maybe<RuProverProp>) -> RuProverEnv;

	ruCommandReproveTask(math : RuMath) -> RuMath;
	ruCommandExpressionLenStats(math : RuMath) -> void;
}

ruEstimateMaxExp(index : RuIndex<RuAssertion>) -> int {
	len_num_max = ruFoldIndex(index, Triple(0.0, 0, 0), \acc, ass ->
		eitherMap(ruAssertion2Theorem(ass), \th ->
			fold(th.proof.steps, acc, \ac, step -> {
				len = length(step.expr.nodes);
				Triple(ac.first + cast(len : int -> double), ac.second + 1, max(acc.third, len))
			}),
			acc
		)
	);
	if (len_num_max.second < 4096) 256 else {
		avg_len = len_num_max.first / cast(len_num_max.second : int -> double);
		sigma_sum = ruFoldIndex(index, 0.0, \acc, ass ->
			eitherMap(ruAssertion2Theorem(ass), \th ->
				fold(th.proof.steps, acc, \ac, step -> {
					delta = cast(length(step.expr.nodes) : int -> double) - avg_len;
					ac + delta * delta;
				}),
				acc
			)
		);
		sigma = sqrt(sigma_sum / cast(len_num_max.second : int -> double));
		cast(avg_len + 3.0 * sigma : double -> int);
	}
	len_num_max.third + 64;
}

ruInitProver(th : RuTheorem, math0 : RuMath, asses : Maybe<RuIndex<RuAssertion>>) -> RuProverEnv {
	cth = ruConstTheorem(th, math0);
	math = cth.math;
	assertions = eitherFn(asses, idfn, \ -> ruInitAssertionsIndex(th.name, math));	
	premises = ruInitPremisesIndex(cth.const);
	vars = ref makeTree();
	root = RuProverRoot(ref [], cth.const.prop, ref []);
	id = ref 0;
	env = RuProverEnv(
		{
			started = timestamp();
			limit = cast(s2i(ruOptDef("prove-time-limit", "5", math.conf)) * 1000 : int -> double);
			\-> timestamp() - started > limit
		},
		ruEstimateMaxExp(assertions),
		th, //cth.const,
		RuProverTree(makeTree(), root),
		\hyp -> ruUnifyIndex(hyp.expr, assertions, makeTree(), math),
		\hyp -> ruUnifyIndex(hyp.expr, premises, makeTree(), math),
		math,
		\v -> {
			vars := setTree(^vars, v, lookupTreeDef(^vars, v, 0) + 1);
			RuVar(v.name + "_" + i2s(lookupTreeDef(^vars, v, 0)), v.type);
		},
		cth.unconst,
		ref [],
		\-> { ret = ^id; id := ^id + 1; ret; },
		ref makeTree()
	);
	ruExpandHyp(root, env);
}

ruMakeFresh(vars : Set<RuVar>, env : RuProverEnv) -> Tree<RuVar, RuExp> {
	foldSet(vars, makeTree(), \acc, v -> setTree(acc, v, RuExp([env.fresher(v)], -1)));
}

ruExpandHyp(hyp : RuProverHyp, env : RuProverEnv) -> RuProverEnv {
	t1 = timestamp();
	unified = env.unifyAssertion(hyp);
	if (ruOptIsTrue("reprove-stats", env.math.conf)) {
		ruAddStats("unify_assertion", RuStatsRow("unifying " + ru2s(hyp.expr, env.math.rules), 
			pairs2tree([
				Pair("size", length(hyp.expr.nodes)), 
				Pair("time", cast(timestamp() - t1 : double -> int)), 
				Pair("rets", length(unified))
			])
		));
	}
	leafs_removed = switch (hyp) {
		RuProverExp(__,__,__,__, parent): removeFromTree(env.tree.leafs, parent.id);
		RuProverRoot(__,__,__): env.tree.leafs;
	};
	proc_unified = \unif -> {
		t2 = timestamp();
		a_vars  = ruAssertion2Vars(unif.data);
		t2_ = cast(timestamp() - t2 : double -> int);
		
		t3 = timestamp();
		fresher = ruMakeFresh(differenceSets(a_vars, buildSet(getTreeKeys(unif.sub))), env);
		t3_ = cast(timestamp() - t3 : double -> int);
		
		
		t4 = timestamp();
		s_all = ruUnsafeCompose(unif.sub, fresher);
		t4_ = cast(timestamp() - t4 : double -> int);
		
		t = cast(timestamp() - t2 : double -> int);
		
		if (ruOptIsTrue("reprove-stats", env.math.conf)) {
			ruAddStats("add_unified", RuStatsRow("adding " + ru2s(hyp.expr, env.math.rules) + " for " + unif.data.name, 
				pairs2tree([
					//Pair("size", length(hyp.expr.nodes)), 
					Pair("time",  t), 
					Pair("time2", t2_), 
					Pair("time3", t3_),
					Pair("time4", t4_),
					Pair("count", 1)
				])
			));
		}
		RuProverProp(
			env.idxer(),
			unif.data, ref [], 
			filterTree(s_all, \v, __ -> !containsSet(a_vars, v)),
			filterTree(s_all, \v, __ -> containsSet(a_vars, v)),
			ref [],
			hyp
		);
	}
	regular_expand = \-> {
		fold(unified, leafs_removed,
			\acc, unif -> {
				t2 = timestamp();
				a_vars  = ruAssertion2Vars(unif.data);
				t2_ = cast(timestamp() - t2 : double -> int);
				
				t3 = timestamp();
				fresher = ruMakeFresh(differenceSets(a_vars, buildSet(getTreeKeys(unif.sub))), env);
				t3_ = cast(timestamp() - t3 : double -> int);
				
				
				t4 = timestamp();
				s_all = ruUnsafeCompose(unif.sub, fresher);
				t4_ = cast(timestamp() - t4 : double -> int);
				
				t = cast(timestamp() - t2 : double -> int);
				
				if (ruOptIsTrue("reprove-stats", env.math.conf)) {
					ruAddStats("add_unified", RuStatsRow("adding " + ru2s(hyp.expr, env.math.rules) + " for " + unif.data.name, 
						pairs2tree([
							//Pair("size", length(hyp.expr.nodes)), 
							Pair("time",  t), 
							Pair("time2", t2_), 
							Pair("time3", t3_),
							Pair("time4", t4_),
							Pair("count", 1)
						])
					));
				}
				prop = RuProverProp(
					env.idxer(),
					unif.data, ref [], 
					filterTree(s_all, \v, __ -> !containsSet(a_vars, v)),
					filterTree(s_all, \v, __ -> containsSet(a_vars, v)),
					ref [],
					hyp
				);
				refArrayPush(hyp.children, prop);
				t5 = timestamp();
				ret = setTree(acc, prop.id, prop);
				if (ruOptIsTrue("reprove-stats", env.math.conf)) {
					ruAddStats("add_unified_set_tree", RuStatsRow("adding " + ru2s(hyp.expr, env.math.rules) + " for " + unif.data.name, 
						pairs2tree([
							Pair("time",  cast(timestamp() - t5 : double -> int)),
							Pair("count", 1)
						])
					));
				}
				ret
			}
		);
	}
	leafs = if (!ruOptIsSet("reprove", env.math.conf) || !ruOptIsTrue("reprove-singletons", env.math.conf)) regular_expand() else {
		switch (hyp) {
			RuProverExp(i,__,__,__, parent): {
				p = lookupTreeDef(^(env.reproveMap), parent, RuProofStep(ruNoAxiom, [], ruNoExp));
				switch (p.children[i]) {
					RuProofStep(ass,__,__): {
						switch (find(unified, \unif -> unif.data.name == ass.name)) {
							Some(unif): {
								prop = proc_unified(unif);
								refArrayPush(hyp.children, prop);
								setTree(leafs_removed, prop.id, prop);
							}
							None(): leafs_removed;
						}
					}
					RuProofHyp(__,__): leafs_removed;
				}
			}
			RuProverRoot(__,__,__): regular_expand();
		}
	}
	RuProverEnv(env with 
		tree = RuProverTree(leafs, env.tree.root)
	);
}

ruExpandProp(prop : RuProverProp, env : RuProverEnv) -> RuProverEnv {
	if (length(prop.assertion.hyps) == 0) {
		refArrayPush(prop.proofs, RuProverProofProp(prop, prop.sub, []));
		RuProverEnv(env with tree = RuProverTree(env.tree with leafs = removeFromTree(env.tree.leafs, prop.id)));
	} else {
		env1 = foldi(prop.assertion.hyps, env, \i, acc, h -> {
			ex = ruApplySubst(ruApplySubst(h.expr, prop.sub), prop.outer);
			if (!ruExpIsLess(ex, env.maxExLen)) acc else {
				hyp = RuProverExp(i, ref [], ex, ref [], prop);
				refArrayPush(prop.children, hyp);
				t1 = timestamp();
				unified = env.unifyPremise(hyp);
				if (ruOptIsTrue("reprove-stats", env.math.conf)) {
					ruAddStats("unify_premise", RuStatsRow("unifying " + ru2s(hyp.expr, env.math.rules), 
						pairs2tree([
							Pair("size", length(hyp.expr.nodes)), 
							Pair("time", cast(timestamp() - t1 : double -> int)), 
							Pair("rets", length(unified))
						])
					));
				}
				iter(unified, \unif -> {
					hypProof = RuProverProofTop(hyp, unif.expr, unif.data, unif.sub);
					refArrayPush(hyp.proofs, hypProof);
					ruAddProof(prop, hypProof, acc);
				});
				t2 = timestamp();
				ret = ruExpandHyp(hyp, acc);
				if (ruOptIsTrue("reprove-stats", env.math.conf)) {
					ruAddStats("ruExpandHyp", RuStatsRow("expanding " + ru2s(hyp.expr, env.math.rules), 
						pairs2tree([
							Pair("time", cast(timestamp() - t2 : double -> int)), 
							Pair("count", 1)
						])
					));
				}
				ret
			}
		});
		RuProverEnv(env1 with tree = RuProverTree(env1.tree with leafs = removeFromTree(env1.tree.leafs, prop.id)));
	}
}

ruCheckTests(test1 : Tree<[RuProverProofHyp], RuProverProofProp>, test2 : Tree<[RuProverProofHyp], RuProverProofProp>) -> bool {
	ret = ref true;
	traverseInOrder(test1, \k1, p1 -> {
		switch (lookupTree(test2, k1)) {
			None(): ret := false;
			Some(p2): {
				switch (ruSubsAreSim(p1.sub, p2.sub)) {
					Some(__): { }
					None(): ret := false;
				}
			}
		}
	});
	^ret;
}

ruAddProof(prop : RuProverProp, hypProof : RuProverProofHyp, env : RuProverEnv) -> void {
	if (length(^(prop.children)) == ruArity(prop.assertion)) {
	
		prod = map(^(prop.children), \hyp ->
			if (hyp == hypProof.node) [hypProof] else ^(hyp.proofs)
		);
		size = ruSizeCart(prod);
		new_proofs = if (size < 1024) {
			t = timestamp();
			new_proofs = ruAddProof1(prop, hypProof, env);
			if (ruOptIsTrue("reprove-stats", env.math.conf)) {
				time = cast(timestamp() - t : double -> int);
				stats = RuStatsRow("prod " + ruProd2s(prod), 
					pairs2tree([Pair("size", size), Pair("time", time), Pair("rets", length(new_proofs))])
				);
				ruAddStats("add_proof", stats);
				ruAddStats("add_proof_prod", stats);
			}
			new_proofs;
		} else {
			t = timestamp();
			new_proofs = ruAddProof2(prop, hypProof, env);
			if (ruOptIsTrue("reprove-stats", env.math.conf)) {
				time = cast(timestamp() - t : double -> int);
				stats = RuStatsRow("tree " + ruProd2s(prod), 
					pairs2tree([Pair("size", size), Pair("time", time), Pair("rets", length(new_proofs))])
				);
				ruAddStats("add_proof", stats);
				ruAddStats("add_proof_tree", stats);
			}
			new_proofs;
		}
		iter(new_proofs, \p -> 
			if (length(^(prop.proofs)) <= 128 || !env.timeLimit()) {
				refArrayPush(prop.proofs, p)
			}
		);
		/*
		if (size <= 100000) {
		k = ruLogN(size, 10);
			max_k := max(^max_k, k);
			max_size := max(^max_size, size);
		
			t1 = timestamp();
			proofs1 = ruAddProof1(prop, hypProof, env);
			time1 = timestamp() - t1;
			setConcurrentHashMap(prod_times, k, getConcurrentHashMap(prod_times, k, 0.0) + time1);

			t2 = timestamp();
			proofs2 = ruAddProof2(prop, hypProof, env);
			time2 = timestamp() - t2;
			setConcurrentHashMap(tree_times, k, getConcurrentHashMap(tree_times, k, 0.0) + time2);

			test1 = values2tree(proofs1, \p -> p.children);
			test2 = values2tree(proofs2, \p -> p.children);
			if (proofs1 != [] && (!ruCheckTests(test1, test2) || !ruCheckTests(test2, test1))) {
				println("proofs differ:\n");
				println("proofs1:");
				iteri(proofs1, \i, pr -> println(i2s(i) + "\n" + ruIndent(ruSubst2s(pr.sub, env.math))));
				println("proofs2:");
				iteri(proofs2, \i, pr -> println(i2s(i) + "\n" + ruIndent(ruSubst2s(pr.sub, env.math))));
				
				println("matrix:");
				subs = map(^(prop.children), \hyp ->
					if (hyp == hypProof.node) [RuSubData(hypProof.sub, hypProof)] else 
					map(^(hyp.proofs), \p -> RuSubData(p.sub, p))
				);
				println(ruSubsMatrix2s(ruMakeSubsMatrix(subs), env.math));
				debugUnifySubsProd := true;
				ruAddProof2(prop, hypProof, env);
				quit(-1);
			}
			iter(proofs1, \p -> refArrayPush(prop.proofs, p));
		}*/
	}
}

ruAddProof2(prop : RuProverProp, hypProof : RuProverProofHyp, env : RuProverEnv) -> [RuProverProofProp] {
	subs = map(^(prop.children), \hyp ->
		if (hyp == hypProof.node) [RuSubData(hypProof.sub, hypProof)] else 
		map(^(hyp.proofs), \p -> RuSubData(p.sub, p))
	);
	filtermap(ruUnifySubsProd(subs, env.maxExLen, env.timeLimit, env.math), \unif ->
		maybeBind(ruCompose(prop.sub, unif.sub), \theta ->
			if (!ruCheckDisjs(theta, prop.assertion.disjs)) None() else {
				Some(RuProverProofProp(prop, theta, unif.data));
			}
		)
	);
}

ruAddProof1(prop : RuProverProp, hypProof : RuProverProofHyp, env : RuProverEnv) -> [RuProverProofProp] {
	prod = map(^(prop.children), \hyp ->
		if (hyp == hypProof.node) [hypProof] else ^(hyp.proofs)
	);
	if (ruSizeCart(prod) == 0) [] else {
		if (ruSizeCart(prod) > 100000) {
			println("ruSizeCart(prod)=" + i2s(ruSizeCart(prod)));
			[]
		} else {
			ruFiltermapCart(prod, \hypProofs -> 
				maybeBind(ruUnifySubs(map(hypProofs, \hp -> hp.sub), env.math),
					\s ->
						maybeBind(ruCompose(prop.sub, s), \theta ->
							if (!ruCheckDisjs(theta, prop.assertion.disjs)) None() else {
								Some(RuProverProofProp(prop, theta, hypProofs))
							} 
						)
				)
			)
		}
	}
}

ruBuildPropProofs(parent : RuProverHyp, proofs : [RuProverProofProp], env : RuProverEnv) -> void {
	n = length(^(parent.proofs));
	iter(proofs, \proof -> 
		refArrayPush(parent.proofs, 
			RuProverProofExp(
				parent,
				ruApplySubst(parent.expr, proof.sub),
				proof.sub,
				proof
			)
		)
	);
	switch (parent) {
		RuProverExp(__,__,__,__,grand): 
			ruBuildHypProofs(grand, tailFrom(^(parent.proofs), n), env);
		RuProverRoot(__,__,__):
			iter(tailFrom(^(parent.proofs), n), \root -> {
				steps = map(ruMakeLinearProof(ruMakeProofNode(root)), \step -> RuStep(step with expr = env.unconst(step.expr)));
				vars = values2tree(set2array(differenceSets(
					fold(steps, makeSet(), \acc, step -> mergeSets(acc, ruExp2Vars(step.expr.nodes))),
					ruAssertion2Vars(env.theorem)
				)), \v -> v.name);
				proof = RuProof(vars, makeSet(), steps, -1);
				err_message = ref "";
				check_math = RuMath(env.math with conf = RuConf(env.math.conf with onError = \msg, __ -> err_message := ^err_message + msg));
				switch (ruVerifyTheorem(RuTheorem(env.theorem with proof = proof), check_math)) {
					Some(th): refArrayPush(env.proofs, proof);
					None(): {
						if (strContains(^err_message, "step match failed")) {
							println("wrong proof found: \n" + ^err_message);
							println(ruProofNode2s(ruMakeProofNode(root), env.math));
							quit(-1);
						}
					}
				}
			});
	}
}

ruBuildHypProofs(parent : RuProverProp, proofs : [RuProverProofHyp], env : RuProverEnv) -> void {
	n = length(^(parent.proofs));
	iter(proofs, \proof -> ruAddProof(parent, proof, env));
	ruBuildPropProofs(parent.parent, tailFrom(^(parent.proofs), n), env);
}

ruProve(env : RuProverEnv, tactic : (RuProverTree) -> Maybe<RuProverProp>) -> RuProverEnv {
	t0 = timestamp();
	choice = tactic(env.tree);
	if (ruOptIsTrue("reprove-stats", env.math.conf)) {
		ruAddStats("choice", RuStatsRow("choice ", 
			pairs2tree([
				Pair("size", sizeTree(env.tree.leafs)), 
				Pair("time", cast(timestamp() - t0 : double -> int)), 
				Pair("count", 1)
			])
		));
	}
	switch (choice) {
		Some(prop): {
			t1 = timestamp();
			env1 = ruExpandProp(prop, env);
			if (ruOptIsTrue("reprove-stats", env.math.conf)) {
				ruAddStats("ruExpandProp", RuStatsRow("expanding " + prop.assertion.name, 
					pairs2tree([
						Pair("time", cast(timestamp() - t1 : double -> int)), 
						Pair("count", 1)
					])
				));
			}
			t2 = timestamp();
			ruBuildPropProofs(prop.parent, ^(prop.proofs), env1);
			if (ruOptIsTrue("reprove-stats", env.math.conf)) {
				ruAddStats("ruBuildPropProofs", RuStatsRow("building proofs for " + prop.assertion.name, 
					pairs2tree([
						Pair("time", cast(timestamp() - t2 : double -> int)), 
						Pair("count", 1)
					])
				));
			}
			ruProve(env1, tactic);
		}
		None(): env;
	}
}

ruReproveTactic(theorem : RuTheorem, math : RuMath, mapping : ref Tree<RuProverProp, RuProofStep>) -> (RuProverTree) -> Maybe<RuProverProp> {
	proof = ruMakeTreeProof(theorem, math);
	leafs = ref [];
	queue = ref [];
	\tree -> {
		if (length(^queue) == 0) {
			if (sizeTree(^mapping) == 0) {
				traverseInOrder(tree.leafs, \__, n -> 
					if (length(^queue) == 0) {
						switch (n.parent) {
							RuProverRoot(__,__,__):
								if (n.assertion == proof.assertion) {
									queue := [Pair(n, proof)];
								}
							default: {}
						}
					}
				);
			} else if (length(^leafs) > 0) {
				n = ^leafs[0].first;
				s = ^leafs[0].second;
				leafs := tail(^leafs);
				iteri(^(n.children), \i, child -> {
					step_child = s.children[i];
					switch (step_child) {
						RuProofStep(assertion,__,__) : {
							iter(^(child.children), \grand ->
								if (grand.assertion == assertion) {
									refArrayPush(queue, Pair(grand, step_child));
								}
							);
						}
						default: { }
					}
				});
			}
		}
		if (length(^queue) > 0) {
			n = ^queue[0].first;
			s = ^queue[0].second;
			queue := tail(^queue);
			if (exists(s.children, \ch -> switch (ch) { RuProofStep(__,__,__): true; default: false; })) {
				refArrayPush(leafs, Pair(n, s));
			}
			mapping := setTree(^mapping, n, s);
			Some(n);
		} else {
			None();
		}
	}
}

ruCommandExpressionLenStats(math : RuMath) -> void {
	traverseInOrder(ruMathTheorems(math), \__, th ->
		iter(th.proof.steps, \step ->
			ruAddStats("expr_lens", RuStatsRow(
					ru2s(step.expr, math.rules), 
					pairs2tree([Pair("size", length(step.expr.nodes)), Pair("count", 1)])
				)
			)
		)
	);
	println("<< expression lens stats >>");
	println("distrib lens: ");
	println(ruIndent(ruProcStats("expr_lens", ruDistribLinSumStats("size", "count", 10))));
	println("max size:   " + ruProcStats("expr_lens", ruMaxStats("size")));
	println("avg size:   " + ruProcStats("expr_lens", ruAvgStats("size")));
	println("sigma size: " + ruProcStats("expr_lens", ruSigmaStats("size")));
}

ruCommandReproveTask(math : RuMath) -> RuMath {
	target = lookupTreeDef(math.conf.opts, "default", "1");
	reproved_count = ref 0;
	failed_count = ref 0;
	failed_th_names = ref [];
	max_time = ref 0.0;
	max_th_name = ref "";
	reprove_th = \th, index -> {
		start = timestamp();
		mapping = ref makeTree();
		env0 = ruInitProver(th, math, index);
		env = RuProverEnv(env0 with
			reproveMap = mapping,
			unifyPremise = if (ruOptIsTrue("reprove-singletons", math.conf)) {
				\hyp : RuProverHyp ->  {
					unif = env0.unifyPremise(hyp);
					switch (hyp) {
						RuProverExp(i, __,__,__, parent): {
							switch (lookupTree(^mapping, parent)) {
								Some(step): {
									switch (step.children[i]) {
										RuProofStep(__,__,__): [];
										RuProofHyp(h,__): filter(unif, \un -> un.data.ind == h.ind);
									}
								}
								None(): {
									println("must not happen");
									quit(-1);
									[]; // must not be
								}
							}
						}
						RuProverRoot(__,__,__): unif;
					}
				}
			} else env0.unifyPremise
		);
		if (ruOptIsTrue("reprove-stats", env.math.conf)) {
			init_stats = RuStatsRow("reprove init " + th.name, 
				pairs2tree([Pair("size", length(th.proof.steps)), Pair("time", cast(timestamp() - start : double -> int))])
			);
			ruAddStats("reprove_init", init_stats);
		}
		t = timestamp();
		ruProve(env, ruReproveTactic(th, math, mapping));
		tm = cast(timestamp() - start : double -> int);
		time = (timestamp() - start)/ 1000.0;
		if (time > ^max_time) {
			max_time := time;
			max_th_name := th.name;
		}
		if (ruOptIsTrue("reprove-stats", env.math.conf)) {
			reprove_stats = RuStatsRow("reprove do " + th.name, 
				pairs2tree([Pair("size", ruSizeProverTree(env.tree.root)), Pair("time", cast(timestamp() - t : double -> int))])
			);
			ruAddStats("reprove_do", reprove_stats);
			stats = RuStatsRow("reproved all " + th.name, 
				pairs2tree([Pair("size", ruSizeProverTree(env.tree.root)), Pair("time", tm)])
			);
			ruAddStats("reprove_all", stats);
		}
		if (^(env.proofs) == []) {
			atomicRefIntAddition(failed_count, 1);
			println("theorem " + th.name + " was NOT reproved in " + d2st(time, 2) + "s");
			println(ru2s(th, math.rules));
			refArrayPush(failed_th_names, th.name);
			//quit(-1);
			false;
		} else {
			if (math.conf.verbose > 0) {
				atomicRefIntAddition(reproved_count, 1);
				println(i2s(^reproved_count) + " theorem " + th.name + " was REPROVED in " + d2st(time, 2) + "s");
			}
			true;
		}
	}
	reprove_ass = \ass : RuAssertion -> 
		switch (ass) {
			RuTheorem(__,__,__,__,__,__,__,__): reprove_th(ass, None());
			default: true;
		}
	reprove_decl = \decl : RuBlock ->
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): reprove_th(decl, None());
			default: true;
		}
	reprove_decls = \decls ->
		all(ruConcurrent(map(decls, \d -> \-> reprove_decl(d))));
	start = timestamp();
	ret = if (target == "all" || target == "1") {
		decls = filtermap(concatA(map(ruOrderSources(math), \src -> src.decls)), ruBlock2Assertion);
		chunks = splitByNumber(decls, s2i(ruOptDef("reprove-split-num", "256", math.conf)));
		fold(chunks, Pair(ruMakeIndex(), true), \acc, chunk -> {
			indexes = foldi(chunk, Pair(acc.first, []), \i, ac, ass ->
				Pair(ruSetIndex(ass.prop, ass, ac.first), concat(ac.second, [ac.first]))
			);
			ret = all(ruConcurrent(mapi(chunk, \i, ass -> 
					\-> eitherMap(ruAssertion2Theorem(ass), \th -> reprove_th(th, Some(indexes.second[i])), true)
			)));
			Pair(indexes.first, ret && acc.second)
		}).second;
	} else if (target == "1-seq" || target == "all-seq") {
		reprove_decls(concatA(map(ruOrderSources(math), \src -> src.decls)));
	} else {
		switch (lookupTree(math.sources, target)) {
			Some(src): reprove_decls(src.decls);
			None(): {
				switch (lookupTree(math.assertions, target)) {
					Some(ass): reprove_ass(ass);
					None(): {
						println("no target for reproving");
						false
					}
				}
			}
		}
	}
	if (math.conf.verbose > 0) {
		println("ru reproved in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
		println("Max time: " + d2st(^max_time, 2) + "s for a theorem: " + ^max_th_name);
	}
	if (math.conf.verbose > 0 || ^failed_count > 0) {
		println("Reproved: " + i2s(^reproved_count) + " theorems,");
		println("Failed to reprove: " + i2s(^failed_count) + " theorems:");
		iter(^failed_th_names, \th -> println("\t" + th));
	}
	if (math.conf.verbose > 0 && ruOptIsTrue("reprove-stats", math.conf)) {
		println("<< reprove all >>");
		println("complete reprove distrib: ");
		println(ruIndent(ruProcStats("reprove_all", ruDistribLogSumStats("size", "time", 2))));
		println("sum reprove all time: " + ruProcStats("reprove_all", ruSumStats("time")));
		println("max size: " + ruProcStats("reprove_all", ruMaxStats("size")));
		println("max time: " + ruProcStats("reprove_all", ruMaxStats("time")));
		println("");
	
		println("<< reprove init >>");
		println("reprove init distrib: ");
		println(ruIndent(ruProcStats("reprove_init", ruDistribLogSumStats("size", "time", 2))));
		println("sum init time: " + ruProcStats("reprove_init", ruSumStats("time")));
		println("max size: " + ruProcStats("reprove_init", ruMaxStats("size")));
		println("max time: " + ruProcStats("reprove_init", ruMaxStats("time")));
		println("");
	
		println("<< unify_assertion >>");
		println(ruIndent(ruProcStats("unify_assertion", ruDistribLogSumStats("size", "time", 2))));
		println("sum unify_assertion time: " + ruProcStats("unify_assertion", ruSumStats("time")));
		println("max size: " + ruProcStats("unify_assertion", ruMaxStats("size")));
		println("max rets: " + ruProcStats("unify_assertion", ruMaxStats("rets")));
		println("max time: " + ruProcStats("unify_assertion", ruMaxStats("time")));
		println("");

		println("<< unify_premise >>");
		println(ruIndent(ruProcStats("unify_premise", ruDistribLogSumStats("size", "time", 2))));
		println("sum unify_premise time: " + ruProcStats("unify_premise", ruSumStats("time")));
		println("max size: " + ruProcStats("unify_premise", ruMaxStats("size")));
		println("max rets: " + ruProcStats("unify_premise", ruMaxStats("rets")));
		println("max time: " + ruProcStats("unify_premise", ruMaxStats("time")));
		println("");

		println("<< ruExpandProp >>");
		println(ruIndent(ruProcStats("ruExpandProp", ruDistribLogSumStats("time", "count", 2))));
		println("sum ruExpandProp time: " + ruProcStats("ruExpandProp", ruSumStats("time")));
		println("max time: " + ruProcStats("ruExpandProp", ruMaxStats("time")));
		println("");
		
		println("<< choice >>");
		println(ruIndent(ruProcStats("choice", ruDistribLogSumStats("size", "time", 2))));
		println("sum choice time: " + ruProcStats("choice", ruSumStats("time")));
		println("max time: " + ruProcStats("choice", ruMaxStats("time")));
		println("max size: " + ruProcStats("choice", ruMaxStats("size")));
		println("");

		println("<< ruExpandHyp >>");
		println(ruIndent(ruProcStats("ruExpandHyp", ruDistribLogSumStats("time", "count", 2))));
		println("sum ruExpandHyp time: " + ruProcStats("ruExpandHyp", ruSumStats("time")));
		println("max time: " + ruProcStats("ruExpandHyp", ruMaxStats("time")));
		println("");

		println("<< removeFirst >>");
		println(ruIndent(ruProcStats("removeFirst", ruDistribLogSumStats("time", "count", 2))));
		println("sum removeFirst time: " + ruProcStats("removeFirst", ruSumStats("time")));
		println("max time: " + ruProcStats("removeFirst", ruMaxStats("time")));
		println("");
		
		println("<< add_unified >>");
		println(ruIndent(ruProcStats("add_unified", ruDistribLogSumStats("time", "count", 2))));
		println("sum add_unified count: " + ruProcStats("add_unified", ruSumStats("count")));
		println("sum add_unified time: " + ruProcStats("add_unified", ruSumStats("time")));
		println("sum add_unified time2: " + ruProcStats("add_unified", ruSumStats("time2")));
		println("sum add_unified time3: " + ruProcStats("add_unified", ruSumStats("time3")));
		println("sum add_unified time4: " + ruProcStats("add_unified", ruSumStats("time4")));
		println("max time: " + ruProcStats("add_unified", ruMaxStats("time")));
		println("max time2: " + ruProcStats("add_unified", ruMaxStats("time2")));
		println("max time3: " + ruProcStats("add_unified", ruMaxStats("time3")));
		println("max time4: " + ruProcStats("add_unified", ruMaxStats("time4")));
		println("max time (add_unified_set_tree): " + ruProcStats("add_unified_set_tree", ruMaxStats("time")));
		println("sum time (add_unified_set_tree): " + ruProcStats("add_unified_set_tree", ruSumStats("time")));
		println(ruIndent(ruProcStats("add_unified_set_tree", ruDistribLogSumStats("time", "count", 2))));
		println("");

		println("<< ruBuildPropProofs >>");
		println(ruIndent(ruProcStats("ruBuildPropProofs", ruDistribLogSumStats("time", "count", 2))));
		println("sum ruBuildPropProofs time: " + ruProcStats("ruBuildPropProofs", ruSumStats("time")));
		println("max time: " + ruProcStats("ruBuildPropProofs", ruMaxStats("time")));
		println("");

		println("<< reprove do >>");
		println("do reprove distrib sum: ");
		println(ruIndent(ruProcStats("reprove_do", ruDistribLogSumStats("size", "time", 2))));
		println("do reprove distrib avg: ");
		println(ruIndent(ruProcStats("reprove_do", ruDistribLogAvgStats("size", "time", 2))));
		println("sum do reprove: " + ruProcStats("reprove_do", ruSumStats("time")));
		println("max size: " + ruProcStats("reprove_do", ruMaxStats("size")));
		println("max time: " + ruProcStats("reprove_do", ruMaxStats("time")));
		println("avg time: " + ruProcStats("reprove_do", ruAvgStats("time")));
		println("");
	
		/*println("<< init_assertion_index >>");
		println("init_assertion_index times: ");
		println(ruIndent(ruProcStats("init_assertion_index", ruDistribLogSumStats("size", "time", 2))));
		println("sum init_assertion_index time: " + ruProcStats("init_assertion_index", ruSumStats("time")));
		println("max size: " + ruProcStats("init_assertion_index", ruMaxStats("size")));
		println("max time: " + ruProcStats("init_assertion_index", ruMaxStats("time")));
		println("");*/
	
		println("<< add_proof >>");
		println("prod times: ");
		println(ruIndent(ruProcStats("add_proof_prod", ruDistribLogSumStats("size", "time", 10))));
		println("sum prod time: " + ruProcStats("add_proof_prod", ruSumStats("time")));
		println("tree times: ");
		println(ruIndent(ruProcStats("add_proof_tree", ruDistribLogSumStats("size", "time", 10))));
		println("sum tree time: " + ruProcStats("add_proof_tree", ruSumStats("time")));
		println("max size: " + ruProcStats("add_proof", ruMaxStats("size")));
		println("max time: " + ruProcStats("add_proof", ruMaxStats("time")));
		println("max rets: " + ruProcStats("add_proof", ruMaxStats("rets")));
		//println("data len: " + ruProcStats("add_proof", \rows -> i2s(length(rows))));
		println("");

		println("<< unif_index_prod >>");
		println("max size: " + ruProcStats("unif_index_prod", ruMaxStats("size")));
		println("max time: " + ruProcStats("unif_index_prod", ruMaxStats("time")));
		println("max rets: " + ruProcStats("unif_index_prod", ruMaxStats("rets")));
		println("sum time: " + ruProcStats("unif_index_prod", ruSumStats("time")));
		println("");

		println("<< intersect_index_prod >>");
		println("max size: " + ruProcStats("intersect_index_prod", ruMaxStats("size")));
		println("max time: " + ruProcStats("intersect_index_prod", ruMaxStats("time")));
		println("max rets: " + ruProcStats("intersect_index_prod", ruMaxStats("rets")));
		println("sum time: " + ruProcStats("intersect_index_prod", ruSumStats("time")));
		println("");

		println("<< unfy_subs_index_prod >>");
		println("max size: " + ruProcStats("unfy_subs_index_prod", ruMaxStats("size")));
		println("max time: " + ruProcStats("unfy_subs_index_prod", ruMaxStats("time")));
		println("max rets: " + ruProcStats("unfy_subs_index_prod", ruMaxStats("rets")));
		println("sum time: " + ruProcStats("unfy_subs_index_prod", ruSumStats("time")));
		println("");
	}
	math
}

ruInitGeneralizer(th : RuTheorem, math : RuMath) -> RuProverEnv {
	dag = ruProofToDAG(th.proof);
	ass = lookupTreeDef(math.assertions, dag.data, ruNoAxiom);
	mapping = ref makeTree();
	vars = ref makeTree();
	root = RuProverRoot(ref [], ass.prop, ref []);
	mapping := setTree(^mapping, root, dag);
	hyps = ref [];
	id = ref 0;
	env = RuProverEnv(
		{
			started = timestamp();
			limit = cast(s2i(ruOptDef("prove-time-limit", "5", math.conf)) * 1000 : int -> double);
			\-> timestamp() - started > limit
		},
		-1,
		th,
		RuProverTree(makeTree(), root),
		\hyp -> {
			switch (lookupTree(^mapping, hyp)) {
				Some(node): {
					a = lookupTreeDef(math.assertions, node.data, ruNoAxiom);
					switch (ruUnifyExps([hyp.expr, a.prop], makeTree(), math)) {
						Some(theta): [RuUnified(theta, a, ruApplySubst(a.prop, theta))];
						None(): [];
					}
				}
				None(): {
					println("must not happen");
					quit(-1);
					[];
				}
			}
		},
		\hyp -> {
			switch (hyp) {
				RuProverExp(__,__,__,__,parent):
					switch (lookupTree(^mapping, parent.parent)) {
						Some(node): {
							if (node.data != "") [] else {
								switch (find(^hyps, \h -> h.expr == hyp.expr)) {
									Some(h): [RuUnified(makeTree(), h, h.expr)];
									None(): {
										h = RuHyp(length(^hyps), hyp.expr, -1);
										refArrayPush(hyps, h);
										[RuUnified(makeTree(), h, h.expr)];
									}
								}
							}
						}
						None(): {
							println("must not happen");
							quit(-1);
							[];
						}
					}
				default: {
					println("must not happen");
					quit(-1);
					[];
				}
			}
		},
		math,
		\v -> {
			vars := setTree(^vars, v, lookupTreeDef(^vars, v, 0) + 1);
			RuVar(v.name + "_" + i2s(lookupTreeDef(^vars, v, 0)), v.type);
		},
		idfn,
		ref [],
		\ -> { ret = ^id; id := ^id + 1; ret; },
		ref makeTree()
	);
	ruExpandHyp(root, env);
}

