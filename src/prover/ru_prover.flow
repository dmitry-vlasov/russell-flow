import prover/ru_prover_expand;

export {
	ruInitProver(theorem : RuTheorem, math : RuMath, asses : Maybe<RuIndex<RuAssertion>>) -> RuProverEnv;
	ruInitGeneralizer(theorem : RuTheorem, math : RuMath) -> RuProverEnv;
	
	ruProve(env : RuProverEnv, tactic : (RuProverTree) -> Maybe<RuProverProp>) -> RuProverEnv;
	ruReproveTactic(theorem : RuTheorem, math : RuMath, mapping : ref Tree<RuProverProp, RuProofStep>) -> (RuProverTree) -> Maybe<RuProverProp>;
}

ruInitProver(th : RuTheorem, math : RuMath, asses : Maybe<RuIndex<RuAssertion>>) -> RuProverEnv {
	env = ruInitProverEnv(th, math, asses);
	ruExpandHyp(env.tree.root, env);
}

ruInitGeneralizer(th : RuTheorem, math : RuMath) -> RuProverEnv {
	env = ruInitGeneralizerEnv(th, math);
	ruExpandHyp(env.tree.root, env);
}

ruProve(env : RuProverEnv, tactic : (RuProverTree) -> Maybe<RuProverProp>) -> RuProverEnv {
	t0 = timestamp();
	choice = tactic(env.tree);
	if (ruOptIsTrue("reprove-stats", env.math.conf)) {
		ruAddStats("choice", RuStatsRow("choice ", 
			pairs2tree([
				Pair("size", sizeTree(env.tree.leafs)), 
				Pair("time", cast(timestamp() - t0 : double -> int)), 
				Pair("count", 1)
			])
		));
	}
	switch (choice) {
		Some(prop): {
			t1 = timestamp();
			env1 = ruExpandProp(prop, env);
			if (ruOptIsTrue("reprove-stats", env.math.conf)) {
				ruAddStats("ruExpandProp", RuStatsRow("expanding " + prop.assertion.name, 
					pairs2tree([
						Pair("time", cast(timestamp() - t1 : double -> int)), 
						Pair("count", 1)
					])
				));
			}
			t2 = timestamp();
			ruBuildPropProofs(prop.parent, ^(prop.proofs), env1);
			if (ruOptIsTrue("reprove-stats", env.math.conf)) {
				ruAddStats("ruBuildPropProofs", RuStatsRow("building proofs for " + prop.assertion.name, 
					pairs2tree([
						Pair("time", cast(timestamp() - t2 : double -> int)), 
						Pair("count", 1)
					])
				));
			}
			ruProve(env1, tactic);
		}
		None(): env;
	}
}

ruReproveTactic(theorem : RuTheorem, math : RuMath, mapping : ref Tree<RuProverProp, RuProofStep>) -> (RuProverTree) -> Maybe<RuProverProp> {
	proof = ruMakeTreeProof(theorem, math);
	leafs = ref [];
	queue = ref [];
	\tree -> {
		if (length(^queue) == 0) {
			if (sizeTree(^mapping) == 0) {
				traverseInOrder(tree.leafs, \__, n -> 
					if (length(^queue) == 0) {
						switch (n.parent) {
							RuProverRoot(__,__,__):
								if (n.assertion == proof.assertion) {
									queue := [Pair(n, proof)];
								}
							default: {}
						}
					}
				);
			} else if (length(^leafs) > 0) {
				n = ^leafs[0].first;
				s = ^leafs[0].second;
				leafs := tail(^leafs);
				iteri(^(n.children), \i, child -> {
					step_child = s.children[i];
					switch (step_child) {
						RuProofStep(assertion,__,__) : {
							iter(^(child.children), \grand ->
								if (grand.assertion == assertion) {
									refArrayPush(queue, Pair(grand, step_child));
								}
							);
						}
						default: { }
					}
				});
			}
		}
		if (length(^queue) > 0) {
			n = ^queue[0].first;
			s = ^queue[0].second;
			queue := tail(^queue);
			if (exists(s.children, \ch -> switch (ch) { RuProofStep(__,__,__): true; default: false; })) {
				refArrayPush(leafs, Pair(n, s));
			}
			mapping := setTree(^mapping, n, s);
			Some(n);
		} else {
			None();
		}
	}
}
