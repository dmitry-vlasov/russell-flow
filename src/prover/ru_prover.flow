import prover/ru_prover_tree;
import ru_index;
import ru_verify;

export {

	RuProverEnv(
		theorem : RuTheorem,
		tree : RuProverTree,
		assertions : RuIndex<RuAssertion>,
		premises : RuIndex<RuHyp>,
		math : RuMath,
		fresher : (RuVar) -> RuVar,
		unconst : (RuExp) -> RuExp,
		proofs : ref [RuProof]
	);

	ruInitProver(theorem : RuTheorem, math : RuMath) -> RuProverEnv;
	ruExpandProp(prop : RuProverProp, env : RuProverEnv) -> RuProverEnv;
	ruProve(env : RuProverEnv, tactic : (RuProverTree) -> Maybe<RuProverProp>) -> RuProverEnv;

	ruReproveTask(math : RuMath, target : string) -> void;
}

ruInitProver(th : RuTheorem, math0 : RuMath) -> RuProverEnv {

	//println("proving:\n" + ru2s(th, math0.rules));

	th_vars = set2array(ruAssertion2Vars(th));
	cv_vars = filter(th_vars, \v -> !containsSet(th.meta, v.name));
	cv_name = \cv -> "_" + cv.name;
	cv_rules = map(cv_vars, \cv -> RuRule(cv_name(cv), makeTree(), RuTerm(cv.type, [RuConstRef(cv_name(cv))], -1), -1));
	math = RuMath(math0 with rules = mergeTree(math0.rules, values2tree(cv_rules, \r -> r.name)));
	cv_map = keys2tree(cv_vars, \cv -> RuRuleRef(cv_name(cv), cv.type, 0, 0));
	cv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(cv_map, n, n)), e.pos);
	th_prop = cv_exp(th.prop);
	th_hyps = map(th.hyps, \h -> RuHyp(h.ind, cv_exp(h.expr), h.pos));
	premises = fold(th_hyps, ruMakeIndex(), \acc, h -> ruSetIndex(h.expr, h, acc));
	
	//println("premises:\n" + ruIndex2s(premises, \hyp -> i2s(hyp.ind), math));
	//println("nodes num: " + i2s(length(^(premises.nodes))));
	//println("premises:\n" + ruIndexRaw2s(premises));

	uncv_map = foldTree(cv_map, makeTree(), \v, cv, acc -> setTree(acc, cv, v));
	uncv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(uncv_map, n, n)), e.pos);
	
	th_src = lookupTreeDef(math.names, th.name, ruNoSource);
	all_imported = removeSet(ruCollectAllImported(th.name, math), th_src);
	assertions = foldTree(math.assertions, ruMakeIndex(), \name, ass, acc -> {
			ass_src = lookupTreeDef(math.names, name, ruNoSource);
			if (containsSet(all_imported, ass_src)) {
				//println("adding: " + ru2s(ass.prop, math.rules));
				ruSetIndex(ass.prop, ass, acc);
			} else if (ass_src == th_src) {
				if (ruIndexOfDecl(name, ass_src) < ruIndexOfDecl(th.name, th_src)) {
					//println("adding: " + ru2s(ass.prop, math.rules));
					ruSetIndex(ass.prop, ass, acc);
				} else {
					acc
				}
			} else {
				acc
			}
		}
	);
	
	//println("assertions:\n" + ruIndex2s(assertions, \ass -> ass.name, math));
	//println("nodes num: " + i2s(length(^(assertions.nodes))));
	//println("assertions:\n" + ruIndexRaw2s(assertions));
	
	vars = ref makeTree();
	root = RuProverRoot(ref [], th_prop, ref []);
	
	//println("root: " + ruProverNode2s(root, math));
	
	env = RuProverEnv(
		th,
		RuProverTree([], root),
		assertions,
		premises,
		math,
		\v -> {
			vars := setTree(^vars, v, lookupTreeDef(^vars, v, 0) + 1);
			RuVar(v.name + "_" + i2s(lookupTreeDef(^vars, v, 0)), v.type);
		},
		uncv_exp,
		ref []
	);
	ruExpandHyp(root, env);
}

ruExpandHyp(hyp : RuProverHyp, env : RuProverEnv) -> RuProverEnv {
	make_fresh = \vars, fresher -> foldSet(vars, makeTree(), \acc, v -> setTree(acc, v, RuExp([fresher(v)], -1)));
	
	//println("unifying prop " + ru2s(hyp.expr, env.math.rules));
	//println("with\n" + ruIndex2s(env.assertions, \ass -> ass.name, env.math));
	
	unified = ruUnifyIndex(hyp.expr, env.assertions, env.math);
	
	//println("got: " + i2s(length(unified)) + " unified");
	
	iter(unified, \unif -> {
			//println("unified prop: " + unif.data.name);
			a = unif.data;
			a_vars  = ruAssertion2Vars(a);
			fresher = make_fresh(differenceSets(a_vars, buildSet(getTreeKeys(unif.sub))), env.fresher);
			maybeApply(ruCompose(unif.sub, fresher), \s_all -> {
				sub = filterTree(s_all, \v, __ -> !containsSet(a_vars, v));
				refArrayPush(
					hyp.children,
					RuProverProp(a, ref [], 
						filterTree(s_all, \v, __ -> !containsSet(a_vars, v)),
						filterTree(s_all, \v, __ -> containsSet(a_vars, v)),
						ref [],
						hyp
					)
				);
			})
		}
	);
	leafs = switch (hyp) {
		RuProverExp(__,__,__, parent): removeFirst(env.tree.leafs, parent);
		RuProverRoot(__,__,__): [];
	}
	RuProverEnv(env with tree = RuProverTree(
		fold(^(hyp.children), leafs, \acc, p -> concat(acc, [p])),
		env.tree.root
	));
}

ruExpandProp(prop : RuProverProp, env : RuProverEnv) -> RuProverEnv {
	if (length(prop.assertion.hyps) == 0) {
		refArrayPush(prop.proofs, RuProverProofProp(prop, prop.sub, []));
		RuProverEnv(env with tree = RuProverTree(env.tree with leafs = removeFirst(env.tree.leafs, prop)));
	} else {
		env1 = fold(prop.assertion.hyps, env, \acc, h -> {
			ex = ruApplySubst(ruApplySubst(h.expr, prop.sub), prop.outer);
			hyp = RuProverExp(ref [], ex, ref [], prop);
			refArrayPush(prop.children, hyp);
			
			//println("unifying hyp " + ru2s(hyp.expr, acc.math.rules));
			//println("with\n" + ruIndex2s(acc.premises, \hp -> ru2s(hp, acc.math.rules), acc.math));
			//println("premises raw:\n" + ruIndexRaw2s(acc.premises));
			
			unified = ruUnifyIndex(ex, acc.premises, acc.math);
			
			//println("got: " + i2s(length(unified)) + " unified");
			
			iter(unified, \unif -> {
				//println("unified hyp: " + ru2s(unif.data, acc.math.rules));
				//println("unified sub:\n" + ruSubst2s(unif.sub, acc.math));
				hex = ruApplySubst(unif.data.expr, unif.sub);
				hypProof = RuProverProofTop(hyp, hex, unif.data, unif.sub);
				refArrayPush(hyp.proofs, hypProof);
				ruAddProof(prop, hypProof, acc);
			});
			
			ruExpandHyp(hyp, acc);
		});
		RuProverEnv(env1 with tree = RuProverTree(env1.tree with leafs = removeFirst(env1.tree.leafs, prop)));
	}
}

ruNextCart(v : [int], prod : [[?]]) -> Maybe<[int]> {
	keep = ref false;
	next = mapi(v, \i, n -> {
		if (^keep) n else 
		if (n + 1 < length(prod[i])) {
			keep := true;
			n + 1;
		} else 0
	});
	if (^keep) Some(next) else None();
}

ruCardCart(prod : [[?]]) -> int {
	fold (prod, 1, \acc, p -> acc * length(p));
}

ruProd2s(prod : [[?]]) -> string {
	"dims=[" + strGlue(map(prod, \p -> i2s(length(p))), ", ") + "]"
}

ruAddProof(prop : RuProverProp, hypProof : RuProverProofHyp, env : RuProverEnv) -> void {
	if (length(^(prop.children)) == ruArity(prop.assertion)) {
		prod = map(^(prop.children), \hyp ->
			if (hyp == hypProof.node) [hypProof] else ^(hyp.proofs)
		);
		if (ruCardCart(prod) > 0) {
			//println("prod: " + ruProd2s(prod));
			ruAddProofVariant(prop, map(prod, \__ -> 0), prod, env);
		}
	}
}

ruAddProofVariant(prop : RuProverProp, v : [int], prod : [[RuProverProofHyp]], env : RuProverEnv) -> void {
	//println("proof variant: [" + strGlue(map(v, i2s), ", ") + "]");
	hypProofs = mapi(v, \i, n -> prod[i][n]);
	switch (ruUnifySubstVect(map(hypProofs, \hp -> hp.sub), env.math)) {
		Some(s):
			maybeApply(ruCompose(prop.sub, s), \theta -> 
				if (ruCheckDisjs(theta, prop.assertion.disjs)) {
					proof = RuProverProofProp(prop, theta, hypProofs);
					/*println("found a proof variant");
					println("unif sub:\n" + ruIndent(ruSubst2s(theta, env.math)));
					println("hyp subs:");
					iteri(hypProofs, \i, h -> println("hyp " + i2s(i) + "\n" + ruIndent(ruSubst2s(h.sub, env.math))));
					println("proof:\n" + ruProofNode2s(ruMakeProofNode(proof), env.math) + "\n");*/
					refArrayPush(prop.proofs, proof);
				}
			);
		None(): { }
	}
	switch(ruNextCart(v, prod)) {
		Some(n): ruAddProofVariant(prop, n, prod, env);
		None(): { }
	}
}

ruBuildPropProofs(parent : RuProverHyp, proofs : [RuProverProofProp], env : RuProverEnv) -> void {
	n = length(^(parent.proofs));
	iter(proofs, \proof -> 
		refArrayPush(parent.proofs, 
			RuProverProofExp(
				parent,
				ruApplySubst(parent.expr, proof.sub),
				proof.sub,
				proof
			)
		)
	);
	switch (parent) {
		RuProverExp(__,__,__,grand): 
			ruBuildHypProofs(grand, tailFrom(^(parent.proofs), n), env);
		RuProverRoot(__,__,__):
			iter(tailFrom(^(parent.proofs), n), \root -> {
				steps = map(ruMakeLinearProof(ruMakeProofNode(root)), \step -> RuStep(step with expr = env.unconst(step.expr)));
				vars = values2tree(set2array(differenceSets(
					fold(steps, makeSet(), \acc, step -> mergeSets(acc, ruExp2Vars(step.expr.nodes))),
					ruAssertion2Vars(env.theorem)
				)), \v -> v.name);
				proof = RuProof(vars, makeSet(), steps, -1);
				//println("found a proof:\n" + ru2s(proof, env.math.rules));
				switch (ruVerifyTheorem(RuTheorem(env.theorem with proof = proof), env.math)) {
					Some(th): refArrayPush(env.proofs, proof);
					None(): {
						println("wrong proof");
						println(ruProofNode2s(ruMakeProofNode(root), env.math));
					}
				}
				
				/*maybeApply(
					ruVerifyTheorem(RuTheorem(env.theorem with proof = proof), env.math),
					\th -> refArrayPush(env.proofs, proof)
				);*/
			});
	}
}

ruBuildHypProofs(parent : RuProverProp, proofs : [RuProverProofHyp], env : RuProverEnv) -> void {
	n = length(^(parent.proofs));
	iter(proofs, \proof -> ruAddProof(parent, proof, env));
	ruBuildPropProofs(parent.parent, tailFrom(^(parent.proofs), n), env);
}

ruProve(env : RuProverEnv, tactic : (RuProverTree) -> Maybe<RuProverProp>) -> RuProverEnv {
	switch (tactic(env.tree)) {
		Some(prop): {
			env1 = ruExpandProp(prop, env);
			ruBuildPropProofs(prop.parent, ^(prop.proofs), env1);
			//println("step:\n" + ruProverTree2s(env1.tree.root, env.math));
			ruProve(env1, tactic);
		}
		None(): env;
	}
}

ruReproveTactic(theorem : RuTheorem, math : RuMath) -> (RuProverTree) -> Maybe<RuProverProp> {
	proof = ruMakeTreeProof(theorem, math);
	//println("proof:\n" + ruProofNode2s(proof, math));
	mapping = ref makeTree();
	\tree -> {
		switch (fold(tree.leafs, None(), \acc, n : RuProverProp -> 
			if (isSome(acc)) acc else {
				switch (n.parent) {
					RuProverExp(__,__,children, grand):
						switch (lookupTree(^mapping, grand)) {
							Some(m): {
								i = findiDef(^(grand.children), \x -> x == n.parent, -1);
								ch = m.children[i];
								switch (ch) {
									RuProofStep(assertion,__,__): 
										if (n.assertion == assertion) {
											Some(Pair(n, ch));
										} else None();
									RuProofHyp(__,__): None();
								}
							}
							None(): None();
						}
					RuProverRoot(__,__,__): 
						if (n.assertion == proof.assertion) {
							Some(Pair(n, proof));
						} else None();
				}
			}
		)) {
			Some(p): {
				mapping := setTree(^mapping, p.first, p.second);
				Some(p.first);
			}
			None(): None();
		}
	}
}

ruReproveTask(math : RuMath, target : string) -> void {
	reprove_th = \th -> {
		env = ruInitProver(th, math);
		ruProve(env, ruReproveTactic(th, math));
		if (^(env.proofs) == []) {
			println("theorem " + th.name + " was NOT reproved");
			quit(-1);
		} else if (math.conf.verbose > 0) {
			println("theorem " + th.name + " was REPROVED");
		}
	}
	reprove_ass = \ass -> 
		switch (ass) {
			RuTheorem(__,__,__,__,__,__,__,__): reprove_th(ass);
			default: { }
		}
	reprove_decl = \decl ->
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): reprove_th(decl);
			default: { }
		}
	if (target == "1" || target == "all") {
		traverseInOrder(math.assertions, \__, ass -> reprove_ass(ass))
	} else {
		switch (lookupTree(math.sources, target)) {
			Some(src): iter(src.decls, reprove_decl);
			None(): {
				switch (lookupTree(math.assertions, target)) {
					Some(ass): reprove_ass(ass);
					None(): {
						println("no target for reproving");
					}
				}
			}
		}
	}
}
