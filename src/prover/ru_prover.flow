import prover/ru_prover_tree;
import ru_index;

export {

	RuProverEnv(
		tree : RuProverTree,
		assertions : RuIndex<RuAssertion>,
		premises : RuIndex<RuHyp>,
		math : RuMath,
		fresher : (RuVar) -> RuVar
	);

	ruInitProver(theorem : RuTheorem, math : RuMath) -> RuProverEnv;
}

ruInitProver(th : RuTheorem, math : RuMath) -> RuProverEnv {
	th_vars = set2array(ruAssertion2Vars(th));
	cv_vars = filter(th_vars, \v -> !containsSet(th.meta, v.name));
	cv_name = \cv -> "__cv_" + cv.name;
	cv_rules = map(cv_vars, \cv -> RuRule(cv_name(cv), makeTree(), RuTerm(cv.type, [RuConstRef(cv.name)], -1), -1));
	cv_map = keys2tree(cv_vars, \cv -> RuRuleRef(cv_name(cv), cv.type, 0, 0));
	cv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(cv_map, n, n)), e.pos);
	th_prop = cv_exp(th.prop);
	th_hyps = map(th.hyps, \h -> RuHyp(h.ind, cv_exp(h.expr), h.pos));
	premises = fold(th_hyps, ruMakeIndex(), \acc, h -> ruSetIndex(h.expr, Some(h), acc, \h1, h2 -> h1));

	th_src = lookupTreeDef(math.names, th.name, ruNoSource);
	all_imported = removeSet(ruCollectAllImported(th.name, math), th_src);
	assertions = foldTree(math.assertions, ruMakeIndex(), \name, ass, acc -> {
			ass_src = lookupTreeDef(math.names, name, ruNoSource);
			if (containsSet(all_imported, ass_src)) {
				ruSetIndex(ass.prop, Some(ass), acc, \a1, a2 -> a1);
			} else if (ass_src == th_src) {
				if (ruIndexOfDecl(name, ass_src) < ruIndexOfDecl(th.name, th_src)) {
					ruSetIndex(ass.prop, Some(ass), acc, \a1, a2 -> a1);
				} else {
					acc
				}
			} else {
				acc
			}
		}
	);
	//unified = ruUnifyIndex(hyp.expr, env.assertions, math);
	//children = map(unified, \unif -> RuProverProp(unif.data, ref [], ))
	
	vars = ref makeTree();
	RuProverEnv(
		RuProverTree([], RuProverRoot(ref [], th_prop, [])),
		assertions,
		premises,
		math,
		\v -> {
			vars := setTree(^vars, v, lookupTreeDef(^vars, v, 0) + 1);
			RuVar(v.name + "_" + i2s(lookupTreeDef(^vars, v, 0)), v.type);
		}
	)
}

/*

	RuProverProp(
		assertion : RuAssertion,
		proofs : ref [RuProverProofProp],
		sub : Tree<RuVar, RuExp>,
		outer : Tree<RuVar, RuExp>,
		fresher : Tree<RuVar, RuExp>,
		children : ref [RuProverHyp],
		parent : RuProverHyp,
	);

RuUnified(
		sub1 : Tree<RuVar, RuExp>,
		sub2 : Tree<RuVar, RuExp>,
		data : Maybe<?>
	);
	ruUnifyIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [RuUnified<?>];
*/

/*
ruUnifyExp(expr : RuExp, assertions : RuIndex<RuAssertion>, math : RuMath) -> [RuProverProp] {
	unified = ruUnifyIndex(expr, assertions, math);
	children = map(unified, \unif -> {
			RuProverProp(unif.data, ref [], )
		}
	)
}

ruExpandRoot(hyp : RuProverRoot, env : RuProverEnv) -> RuProverTree {
	unified = ruUnifyIndex(hyp.expr, env.assertions, env.math);
	
}

ruExpandExp(hyp : RuProverExp, env : RuProverEnv) -> RuProverTree {
	unified = ruUnifyIndex(hyp.expr, env.assertions, math)
}


ruExpandProp(prop : RuProverProp, env : RuProverEnv) -> RuProverTree {
	

*/
