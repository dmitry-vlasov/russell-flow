import string;
import ds/tree;
import ru_fileinfo;

export {
	RuSource(imports : [RuImport], decls : [RuBlock], info : RuFileInfo);
	RuImport(path : string, pos : int);
	RuBlock ::= RuDecl, RuComment;
	RuDecl ::= RuConst, RuType, RuRule, RuAxiom, RuDef, RuTheorem, RuTheory;
	RuComment(text : string, pos : int);
	RuTheory(name : string, decls : [RuDecl], pos : int);
	RuConst(name : string, ascii : string, latex : string, pos : int);
	RuType(name : string, supers : [string], pos : int);
	RuRule(name : string, vars : Tree<string, RuVar>, term : RuTerm, pos : int);
	RuAxiom(name : string, vars : Tree<string, RuVar>, disjs : Set<RuDisj>, hyps : [RuHyp], prop : RuExp, pos : int);
	RuVar(name : string, type : string);
	RuHyp(ind : int, expr : RuExp, pos : int);
	RuDisj(v1 : RuVar, v2 : RuVar);
	RuTheorem(name : string, vars : Tree<string, RuVar>, disjs : Set<RuDisj>, meta : Set<string>, hyps : [RuHyp], prop : RuExp, proof : RuProof, pos : int);
	RuDef(name : string, vars : Tree<string, RuVar>, disjs : Set<RuDisj>, hyps : [RuHyp], defm : RuExp, defs : RuExp, prop : RuExp, pos : int);
	RuProof(vars : Tree<string, RuVar>, disjs : Set<RuDisj>, steps : [RuStep], pos : int);
	RuStep(ind : int, assertion : string, refs : [RuRef], expr : RuExp, pos : int);
	RuRef ::= RuHypRef, RuStepRef;
	RuHypRef(ind : int, pos : int);
	RuStepRef(ind : int, pos : int);

	RuTerm(type : string, expr : [RuTermNode], pos : int);
	RuExp(nodes : [RuExpNode], pos : int);
	RuExpNode ::= RuRuleRef, RuVar;
	RuTermNode ::= RuConstRef, RuVar;
	RuRuleRef(name : string, type : string, arity : int, len : int);
	RuConstRef(name : string);

	RuAssertion ::= RuAxiom, RuTheorem, RuDef;
	RuAny ::= 
		RuSource, RuImport, RuConst, RuType, RuRule, RuAxiom, RuDef, RuTheorem, RuTheory, RuComment,
		RuStep, RuExp, RuHyp, RuProof, RuDisj, RuHypRef, RuStepRef, RuTerm, RuVar, RuConstRef;

	ruNoVar = RuVar("__no", "__no");
	ruNoConst = RuConst("__no", "", "", -1);
	ruNoType = RuType("__no", [], -1);
	ruNoRule = RuRule("__no", makeTree(), ruNoTerm, -1);
	ruNoAxiom = RuAxiom("__no", makeTree(), makeSet(), [], ruNoExp, -1);
	ruNoTheorem = RuTheorem("__no", makeTree(), makeSet(), makeSet(), [], ruNoExp, ruNoProof, -1);
	ruNoProof = RuProof(makeTree(), makeSet(), [], -1);
	ruNoStep = RuStep(-1, "__no", [], ruNoExp, -1);
	ruNoSource = RuSource([], [], ruNoFileInfo);
	
	ruNoTerm = RuTerm("__no", [], -1);
	ruNoExpNode = ruNoVar;
	ruNoExp = RuExp([], -1);
		
	ru2s(a : RuAny, rules : Tree<string, RuRule>) -> string;
	ruExp2s(e : RuExp, rules : Tree<string, RuRule>) -> string;
	ruExp2Term(e : RuExp, rules : Tree<string, RuRule>) -> RuTerm;
	ruSteps2s(steps : [RuStep], rules : Tree<string, RuRule>) -> string;
	ruBlock2s(b : RuBlock) -> string;
	ruAssertion2s(ass : RuAssertion, rules : Tree<string, RuRule>) -> string;

	ruExpType(nodes : [RuExpNode]) -> string;
	ruTerm2s(nodes : [RuTermNode]) -> string;
	ruTermWVars2s(nodes : [RuTermNode]) -> string;
	ruExpRPN2s(nodes : [RuExpNode]) -> string;
	ruExp2Vars(nodes : [RuExpNode]) -> Set<RuVar>;
	ruAssertion2Vars(ass : RuAssertion) -> Set<RuVar>;
	ruProof2Vars(proof : RuProof) -> Set<RuVar>;
	ruDisjs2Array(disjs : Set<RuDisj>) -> [Set<RuVar>];
	
	ruContainsOnlyComments(src : RuSource) -> bool;
	ruIndexOfDecl(name : string, src : RuSource) -> int;
	ruCheckDisjs(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>) -> bool;
	ruArity(a : RuAssertion) -> int;

	RuDAG(data : ?, children : [RuDAG<?>]);
	ruProofToDAG(proof : RuProof) -> RuDAG<string>;
	ruDAG2s(dag : RuDAG<?>, show_data : (?) -> string) -> string;
	ruProofDAG2s(dag : RuDAG<string>) -> string;

	ruUpdateTheoremVars(theorem : RuTheorem) -> RuTheorem;
	ruUpdateProofVars(proof : RuProof) -> RuProof;
}

ruArity(a : RuAssertion) -> int {
	length(a.hyps);
}

ruTerm2s(nodes : [RuTermNode]) -> string {
	strGlue(map(nodes, \n -> n.name), " ")
}
ruTermWVars2s(nodes : [RuTermNode]) -> string {
	strGlue(map(nodes, \n -> 
		switch (n) {
			RuConstRef(name): name;
			RuVar(name, type): name + ":" + type;
		}
	), " ")
}
ruExpRPN2s(nodes : [RuExpNode]) -> string {
	strGlue(map(nodes, \n -> {
		switch (n) {
			RuRuleRef(r, t, a, l): r + "-" + i2s(l);
			RuVar(v, t): v;
		}
	}), " ")
}

ruExp2Vars(nodes : [RuExpNode]) -> Set<RuVar> {
	fold(nodes, makeSet(), \acc, n ->
		switch (n) {
			RuRuleRef(__,__,__,__): acc;
			RuVar(__,__): insertSet(acc, n);
		}
	)
}
ruAssertion2Vars(ass : RuAssertion) -> Set<RuVar> {
	fold(ass.hyps, ruExp2Vars(ass.prop.nodes), \acc, h ->
		mergeSets(acc, ruExp2Vars(h.expr.nodes))
	)
}

ruProof2Vars(proof : RuProof) -> Set<RuVar> {
	fold(proof.steps, makeSet(), \acc, step ->
		mergeSets(acc, ruExp2Vars(step.expr.nodes))
	)
}

ruExpType(nodes : [RuExpNode]) -> string {
	nodes[0].type
}

ruBlock2s(b : RuBlock) -> string {
	switch (b) {
		RuConst(symbol, ascii, latex, __): symbol;
		RuType(name, supers, __): name;
		RuRule(name, vars, term, __): name;
		RuAxiom(name, vars, disjs, hyps, prop, __): name;
		RuDef(name, vars, disjs, hyps, defm, defs, prop, __): name;
		RuTheorem(name, vars, disjs, meta, hyps, prop, proof, __): name;
		RuTheory(name, ds, __): name;
		RuComment(text, __): text;
	}
}

ruAssertion2s(ass : RuAssertion, rules : Tree<string, RuRule>) -> string {
	str = ru2s(ass, rules);
	strLeft(str, strIndexOf(str, "proof"));
}

ruExp2s(e : RuExp, rules : Tree<string, RuRule>) -> string {
	ruTerm2s(ruExp2Term(e, rules).expr)
}

ruExp2Term(e : RuExp, rules : Tree<string, RuRule>) -> RuTerm {
	switch (foldr(e.nodes, None(), \acc, n -> ruExp2sAccOperation(n, acc, rules))) {
		Some(stack): RuTerm(ruExpType(e.nodes), stack.nodes, e.pos);
		None(): ruNoTerm;
	}
}

RuExp2sStack(
	parent : Maybe<RuExp2sStack>,
	nodes : [RuTermNode]
);

ruExp2sAccOperation(node : RuExpNode, stack : Maybe<RuExp2sStack>, rules : Tree<string, RuRule>) -> Maybe<RuExp2sStack> {
	switch (node) {
		RuVar(var, __): 
			Some(RuExp2sStack(stack, [node]));
		RuRuleRef(name, type, arity, len): {
			rule = lookupTreeDef(rules, name, ruNoRule);
			stack_str = fold(rule.term.expr, Pair(stack, []), 
				\ac, symb -> {
					switch (symb) {
						RuVar(__,__): {
							switch (ac.first) {
								Some(st): Pair(st.parent, concat(ac.second, st.nodes));
								None(): ac;
							}
						}
						RuConstRef(s):
							Pair(ac.first, concat(ac.second, [symb]));
					}
				}
			);
			Some(RuExp2sStack(stack_str.first, stack_str.second));
		}
	}
}

ru2s(a : RuAny, rules : Tree<string, RuRule>) -> string {
	aru2s   = \x -> ru2s(x, rules);
	vars2s  = \vars -> if (sizeTree(vars) == 0) "" else "(" + strGlue(map(getTreeValues(vars), \v -> v.name + " : " + v.type), ", ") + ") ";
	disjs2s = \disjs -> if (sizeSet(disjs) == 0) "" else
		"disjointed(" + strGlue(map(ruDisjs2Array(disjs), \s -> strGlue(map(set2array(s), \v -> v.name), " ")), ", ") + ") ";
	meta2s  = \meta -> if (sizeSet(meta) == 0) "" else "meta(" + strGlue(set2array(meta), ", ") + ") ";
	exp2s   = \expr, delim -> ": " + ruExpType(expr.nodes) + " = " + delim + " " + ruExp2s(expr, rules) + " ;;";
	prop2s  = \prop -> "\tprop " + exp2s(prop, "|-") + "\n";
	refs2s  = \refs -> "(" + strGlue(map(refs, aru2s), ", ") + ")";
	hyps2s  = \hyps -> if (hyps == []) "" else strGlue(map(hyps, aru2s), "\n") + "\n";
	switch (a) {
		RuSource(imps, decls, info): 
			(if (imps == []) "" else strGlue(map(imps, aru2s), "\n") + "\n\n") +
			strGlue(map(decls, aru2s), "\n");
		RuImport(path, __):
			"import " + path + ";;";
		RuConst(symbol, ascii, latex, __): 
			"constant {\n" + 
				"\tsymbol " + symbol + " ;;\n" +
				(if (ascii != "") "\tascii " + ascii + " ;;\n" else "") + 
				(if (latex != "") "\tlatex " + latex + " ;;\n" else "") +
			"}\n";
		RuType(name, supers, __): 
			"type " + name + (if (supers == []) "" else " : " + strGlue(supers, ", ")) + " ;;\n";
		RuRule(name, vars, term, __):
			"rule " + name + " " + vars2s(vars) + "{\n" +
				"\tterm " + aru2s(term) + "\n" +
			"}\n";
		RuAxiom(name, vars, disjs, hyps, prop, __): 
			"axiom " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				hyps2s(hyps) +
				(if (hyps == []) "" else "\t----------\n") +
				prop2s(prop) +
			"}\n";
		RuDef(name, vars, disjs, hyps, defm, defs, prop, __): 
			"definition " + name + " " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				hyps2s(hyps) +
				"\tdefiendum " + exp2s(defm, "#") + "\n" +
				"\tdefiniens " + exp2s(defs, "#") + "\n" +
				"\t-------------\n" +
				prop2s(ruMakeDefProp(prop.nodes, defm.nodes, defs.nodes, rules)) +
			"}\n";
		RuTheorem(name, vars, disjs, meta, hyps, prop, proof, __): 
			"theorem " + name + " " + vars2s(vars) + disjs2s(disjs) + meta2s(meta) + "{\n" +
				hyps2s(hyps) + 
				(if (hyps == []) "" else "\t----------\n") +
				prop2s(prop) +
			"} " + aru2s(proof);
		RuHyp(ind, expr, __): 
			"\thyp " + i2s(ind + 1) + " " + exp2s(expr, "|-");
		RuProof(vars, disjs, steps, __): 
			"proof " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				strGlue(map(steps, aru2s), "\n") + "\n" +
			"}\n";
		RuStep(ind, assertion, refs, expr, __):
			"\tstep " + i2s(ind + 1) + " : " + ruExpType(expr.nodes) + " = " + 
				assertion + " " + refs2s(refs) + " |- " + ruExp2s(expr, rules) + " ;;";
		RuTheory(name, ds, __): 
			"theory " + name + " {\n" +
				strGlue(map(ds, aru2s), "\n") + "\n" +
			"}\n";
		RuComment(text, __): "/* " + text + "*/\n";
		RuDisj(v1, v2): v1.name + " " + v2.name;
		RuExp(nodes, __): ruExp2s(a, rules);
		RuHypRef(i, __): "hyp " + i2s(i + 1);
		RuStepRef(i, __): "step " + i2s(i + 1);
		RuVar(name, type): name;
		RuTerm(type, expr, __): 
			": " + type + " = # " + strGlue(map(expr, aru2s), " ") + " ;;";
		RuConstRef(name): name;
	}
}

ruSteps2s(steps : [RuStep], rules : Tree<string, RuRule>) -> string {
	strGlue(map(steps, \s -> ru2s(s, rules)), "\n");
}

ruDisjs2Array(disjs : Set<RuDisj>) -> [Set<RuVar>] {
	make_disj = \v, w -> if (v.name < w.name) RuDisj(v, w) else RuDisj(w, v);
	may_be_added = \v, s ->
		forall(set2array(s), \w -> 
			if (v == w) true else {
				containsSet(disjs, make_disj(v, w))
			}
		);
	foldSet(disjs, [], \acc, disj ->
		if (exists(acc, \s -> containsSet(s, disj.v1) && containsSet(s, disj.v2))) acc else {
			switch (findi(acc, \s -> containsSet(s, disj.v1) && may_be_added(disj.v2, s))) {
				Some(i): replace(acc, i, insertSet(acc[i], disj.v2));
				None(): 
					switch (findi(acc, \s -> containsSet(s, disj.v2) && may_be_added(disj.v1, s))) {
						Some(i): replace(acc, i, insertSet(acc[i], disj.v1));
						None(): concat(acc, [insertSet(makeSet1(disj.v1), disj.v2)]);
					}
			}
		}
	);
}

ruIndOfArr(arr1 : [?], arr2 : [?]) -> int {
	foldi(arr1, -1, \i, ac, x -> 
		if (ac >= 0) ac else {
			if (i <= length(arr1) - length(arr2)) {
				ind = fold(arr2, i, \j, y ->
					if (j == -1) -1 else
					if (y == arr1[j]) j + 1 else -1
				);
				if (ind != -1) i else -1;
			} else {
				-1
			}
		}
	)
}

ruMakeDefProp(prop : [RuExpNode], dfm : [RuExpNode], dfs: [RuExpNode], rules : Tree<string, RuRule>) -> RuExp {
	dfs_i = ruIndOfArr(prop, dfs);
	dfm_i = ruIndOfArr(prop, dfm);
	dfs_len = length(dfs);
	dfm_len = length(dfm);
	if (dfs_i == -1 || dfm_i == -1) {
		ruNoExp
	} else {
		RuExp(foldi(prop, [], \i, ac, s ->
			if (i == dfm_i) concat(ac, [RuVar("defiendum", "__no")]) else
			if (dfm_i < i && i < dfm_i + dfm_len) ac else
			if (i == dfs_i) concat(ac, [RuVar("definiens", "__no")]) else
			if (dfs_i < i && i < dfs_i + dfs_len) ac else
			concat(ac, [s])
		), -1)
	}
}

ruContainsOnlyComments(src : RuSource) -> bool {
	forall(src.decls, \decl -> 
		switch (decl) {
			RuComment(__,__): true;
			default: false;
		}
	)
}

ruIndexOfDecl(name : string, src : RuSource) -> int {
	findiDef(src.decls, 
		\decl -> switch (decl) {
			RuTheory(n,__,__): n == name;
			RuConst(n,__,__,__): n == name;
			RuType(n,__,__): n == name;
			RuRule(n,__,__,__): n == name;
			RuAxiom(n,__,__,__,__,__): n == name;
			RuTheorem(n,__,__,__,__,__,__,__): n == name;
			RuDef(n,__,__,__,__,__,__,__): n == name;
			default: false;
		},
		-1
	)
}

ruCheckDisjs(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>) -> bool {
	forall(set2array(disjs), \disj -> {
		e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], -1));
		e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], -1));
		e1_vars = ruExp2Vars(e1.nodes);
		e2_vars = ruExp2Vars(e2.nodes);
		isEmptySet(intersectSets(e1_vars, e2_vars));
	})
}

ruProofToDAG(proof : RuProof) -> RuDAG<string> {
	ruDoProofToDAG(proof.steps, lastElement(proof.steps, ruNoStep));
}

ruDoProofToDAG(steps : [RuStep], curr : RuStep) -> RuDAG<string> {
	RuDAG(curr.assertion, map(curr.refs, \ref -> 
		switch(ref) {
			RuStepRef(i,__): ruDoProofToDAG(steps, steps[i]);
			RuHypRef(i,__): RuDAG("", []);
		}
	));
}

ruDAG2s(dag : RuDAG<?>, show_data : (?) -> string) -> string {
	show_data(dag.data) + " {\n" +
		ruIndent(strGlue(map(dag.children, \ch -> ruDAG2s(ch, show_data)), ""))
	+ "}\n"
}

ruProofDAG2s(dag : RuDAG<string>) -> string {
	ruDAG2s(dag, \str -> if (str == "") "hyp" else str);
}

ruUpdateProofVars(proof : RuProof) -> RuProof {
	proof_vars = ruProof2Vars(proof);
	RuProof(proof with
		vars = filterTree(proof.vars, \__,v -> containsSet(proof_vars, v)),
		disjs = filterSet(proof.disjs, \d -> containsSet(proof_vars, d.v1) && containsSet(proof_vars, d.v2))
	);
}

ruUpdateTheoremVars(theorem : RuTheorem) -> RuTheorem {
	ass_vars = ruAssertion2Vars(theorem);
	RuTheorem(theorem with 
		vars = filterTree(theorem.vars, \__,v -> containsSet(ass_vars, v)),
		disjs = filterSet(theorem.disjs, \d -> containsSet(ass_vars, d.v1) && containsSet(ass_vars, d.v2)),
		proof = ruUpdateProofVars(theorem.proof)
	);
}
