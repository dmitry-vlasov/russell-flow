import lingo/linecolumn;
import math/stringmath;
import formats/json/json;
import ru_util;

export {
	RuPlace(file : string, pos : int);
	
	RuConf(
		file : string,
		path : string,
		ext : string,
		importRoots : [string],
		workingDir : string,
        verbose : int,
		opts : Tree<string, string>,
		threadId : int,
		onError : (string, [RuPlace]) -> void
	);

	ruNoConf = RuConf("__no", "__no", "__no", [], "", 0, makeTree(), 0, nop2);

	RuCommand(
		name : string,
		conf : RuConf
	);

	ruMakeConf(dir : string) -> Maybe<RuConf>;
	ruFindConfDir(dir : string) -> string;
	ruTrimPath(file : string, conf : RuConf, ext : string) -> string;
	ruFindPath(file : string, conf : RuConf, ext : string) -> string;
	ruAddErr2Conf(conf : RuConf, msg : string) -> RuConf;
	ruAddErrCounter(conf : RuConf, err_count : ref int) -> RuConf;
	ruPlace2s(place : RuPlace) -> string;
	ruOptIsSet(opt : string, conf : RuConf) -> bool;
	ruAllOptsAreSet(opt : [string], conf : RuConf) -> bool;
	ruSomeOptsAreSet(opt : [string], conf : RuConf) -> bool;
	ruOptIsTrue(opt : string, conf : RuConf) -> bool;
	ruOptIsFalse(opt : string, conf : RuConf) -> bool;
	ruAllOptsAreTrue(opt : [string], conf : RuConf) -> bool;
	ruSomeOptsAreTrue(opt : [string], conf : RuConf) -> bool;
	ruSetOpt(opt : string, val : string, conf : RuConf) -> RuConf;
	ruRemoveOpt(opt : string, conf : RuConf) -> RuConf;
	ruRemoveOpts(opts : [string], conf : RuConf) -> RuConf;
	ruOpt(opt : string, conf : RuConf) -> string;
	ruOptDef(opt : string, def : string, conf : RuConf) -> string;
	ruConf2Commands(conf : RuConf) -> [RuCommand];
	ruConf2Json(conf : RuConf) -> Json;
	ruOptsDescr(opts : Tree<string, string>) -> string;
	ruJson2Conf(json : Json) -> Maybe<RuConf>;
	ruMakeOpts(args : [string]) -> Tree<string, string>;
	getRussellDir() -> string;
}

ruMakeConf(dir : string) -> Maybe<RuConf> {
	onError = \err, places -> println("Error: " + err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")));
	err_count = ref 0;
	find_file = \opts -> {
		foldTree(opts, "", \name, val, acc -> {
			if (name == "file" || val == "") {
				if (acc == "") {
					if (name == "file") val else name
				} else if (acc != val) {
					onError("target file is set up more then once: '" + val + "' and '" + acc + "'", []);
					err_count := ^err_count + 1;
					""
				} else acc;
			} else acc
		});
	}
	url_opts = fold(getAllUrlParametersArray(), makeTree(), \acc, p -> setTree(acc, p[0], p[1]));
	conf_dir1 = ruFindConfDir(dir);
	conf_dir = if (conf_dir1 != "") conf_dir1 else {
		file = find_file(url_opts);
		if (file == "") "" else {
			ruFindConfDir(ruDirName(file));
		}
	}
	//ruDebugLog1("conf_dir: " + conf_dir);
	conf_opts = ruReadConfFileFromDir(conf_dir);
	//ruDebugLog1("conf_opts: " + strGlue(map(tree2pairs(conf_opts), \p -> p.first + "=" + p.second), ", "));
	opts = mergeTree(conf_opts, url_opts);
	//ruDebugLog1("opts: " + strGlue(map(tree2pairs(opts), \p -> p.first + "=" + p.second), ", "));
	file = find_file(opts);
	//ruDebugLog1("FILE: " + file);
	ext = getFileExt(file);
	//ruDebugLog1("EXT: " + ext);
	verbose = s2i(lookupTreeDef(opts, "verbose", "0"));
	importRoots = switch (lookupTree(opts, "import-roots")) {
		Some(roots): {
			filtermap(strSplit(roots, ","), \imp -> {
				imp_dir = rtrim2(strReplace(imp, "\\", "/"), "/") + "/";
				if (!isDirectory(imp_dir)) {
					onError("import root directory " + imp_dir + " does not exist, untrimmed: " + imp, []);
					err_count := ^err_count + 1;
					None();
				} else {
					Some(strReplace(resolveRelativePath(imp_dir), "\\", "/"));
				}
			});
		}
		None(): [];
	}
	//ruDebugLog1("importRoots: " + strGlue(importRoots, ", "));
	workingDir = lookupTreeDef(opts, "working-dir", "");
	conf1 = RuConf(file, file, ext, importRoots, workingDir, verbose, opts, s2i(getThreadId()), onError);
	path = resolveRelativePath(file);
	//ruDebugLog1("PATH: " + path);
	trimmed = ruTrimPath(path, conf1, ext);
	//ruDebugLog1("TRIMMED: " + trimmed);
	if (^err_count > 0) {
		None() 
	} else {
		Some(RuConf(
			trimmed, path, ext,
			importRoots, workingDir, verbose, opts, s2i(getThreadId()), onError
		));
	}
}

ruFindConfDir(dir : string) -> string {
	path = dir + "/russell.conf";
	if (fileExists(path)) dir else 
	if (dir == "/" || dir == "") "" else {
		ruFindConfDir(ruDirName(dir));
	}
}

ruReadConfFileFromDir(dir : string) -> Tree<string, string> {
	path = dir + "/russell.conf";
	if (!fileExists(path)) makeTree() else {
		config = getFileContent(path);
		lines = strSplit(config, "\n");
		fold(lines, makeTree(), \acc, l -> {
			// Skip comment lines in russell.conf
			if (!startsWith(ltrim2(l, " \t"), "#") && !startsWith(ltrim2(l, " \t"), "//")) {
				opts = strSplit(l, "=");
				if (length(opts) == 1) {
					opt = trim2(opts[0], " \t\r");
					setTree(acc, opt, "");
				} else if (length(opts) == 2) {
					opt = trim2(opts[0], " \t\r");
					val = trim2(opts[1], " \t\r");
					setTree(acc, opt, val)
				} else acc;
			} else acc;
		});
	}
}

ruTrimPath(file : string, conf : RuConf, ext0 : string) -> string {
	//ruDebugLog1("file: " + file);
	//ruDebugLog1("ext: " + ext);
	ext = if (startsWith(ext0, ".")) ext0 else "." + ext0;
	noext = strReplace(ruRemoveExt(file, ext), "\\", "/");
	//ruDebugLog1("noext: " + noext);
	shift = if (conf.workingDir == "") "" else relatingPath(conf.workingDir, resolveRelativePath("."));
	pathShift = if (shift == "") shift else shift + "/";
	processImportRoot = \acc, impRoot -> {
		resolved = strReplace(resolveRelativePath(impRoot), "\\", "/");
		if (startsWith(toLowerCase(acc), toLowerCase(resolved))) {
			strRight(acc, strlen(resolved));
		} else if (startsWith(toLowerCase(acc), toLowerCase(impRoot))) {
			strRight(acc, strlen(impRoot));
		} else acc
	};
	trimmed = fold(conf.importRoots, noext, \acc, impRoot -> {
		acc1 = if (pathShift != "") {
			processImportRoot(acc, pathShift + impRoot)
		} else acc;
		processImportRoot(acc1, impRoot)
	});
	if (trimmed == file) file else trim2(trimmed, "/");
}

ruFindPath(file : string, conf : RuConf, ext0 : string) -> string {
	ext = if (startsWith(ext0, ".")) ext0 else "." + ext0;
	withRus = if (endsWith(file, ext)) file else file + ext;
	shift = if (conf.workingDir == "") "" else relatingPath(conf.workingDir, resolveRelativePath("."));
	if (fileExists(withRus)) {
		resolveRelativePath(withRus);
	} else {
		ruDoFindPath(withRus, if (shift == "") shift else shift + "/", conf.importRoots);
	}
}

ruDoFindPath(withRus : string, pathShift : string, importRoots : [string]) -> string {
	if (importRoots == []) withRus
	else {
		head = importRoots[0];
		directPath = head + (if (endsWith(head, "/")) "" else "/") + withRus;
		if (fileExists(directPath)) {
			resolveRelativePath(directPath);
		} else {
			shiftedPath = pathShift + directPath;
			if (fileExists(shiftedPath)) {
				resolveRelativePath(shiftedPath);
			} else {
				ruDoFindPath(withRus, pathShift, tail(importRoots));
			}
		}
	}
}

ruAddErr2Conf(conf : RuConf, msg : string) -> RuConf {
	RuConf(conf with onError = \str, pos -> conf.onError(str + msg, pos))
}

ruAddErrCounter(conf : RuConf, err_count : ref int) -> RuConf {
	RuConf(conf with onError = 
		\err, places -> {
			err_count := ^err_count + 1;
			conf.onError(err, places);
		}
	)
}

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		"file " + place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

ruOptIsSet(opt : string, conf : RuConf) -> bool {
	containsKeyTree(conf.opts, opt)
}

ruAllOptsAreSet(opts : [string], conf : RuConf) -> bool {
	forall(opts, \opt -> ruOptIsSet(opt, conf))
}

ruSomeOptsAreSet(opts : [string], conf : RuConf) -> bool {
	exists(opts, \opt -> ruOptIsSet(opt, conf))
}

ruOptIsTrue(opt : string, conf : RuConf) -> bool {
	lookupTreeDef(conf.opts, opt, "") == "1"
}

ruOptIsFalse(opt : string, conf : RuConf) -> bool {
	lookupTreeDef(conf.opts, opt, "1") == "0"
}

ruAllOptsAreTrue(opts : [string], conf : RuConf) -> bool {
	forall(opts, \opt -> ruOptIsTrue(opt, conf))
}

ruSomeOptsAreTrue(opts : [string], conf : RuConf) -> bool {
	exists(opts, \opt -> ruOptIsTrue(opt, conf))
}

ruSetOpt(opt : string, val : string, conf : RuConf) -> RuConf {
	RuConf(conf with opts = setTree(conf.opts, opt, val))
}

ruRemoveOpt(opt : string, conf : RuConf) -> RuConf {
	RuConf(conf with opts = removeFromTree(conf.opts, opt));
}

ruRemoveOpts(opts : [string], conf : RuConf) -> RuConf {
	fold(opts, conf, \acc, opt -> ruRemoveOpt(opt, acc));
}

ruOpt(opt : string, conf : RuConf) -> string {
	lookupTreeDef(conf.opts, opt, "")
}

ruOptDef(opt : string, def : string, conf : RuConf) -> string {
	lookupTreeDef(conf.opts, opt, def)
}

ruConf2Commands(conf : RuConf) -> [RuCommand] {
	getTreeValues(foldTree(conf.opts, makeTree(), \id, opt, acc ->
		if (!isDigits(id)) acc else {
			splitted = strSplit(opt, ",");
			if (length(splitted) == 0) acc else {
				setTree(acc, s2i(id), 
					RuCommand(splitted[0], RuConf(conf with opts = ruMakeOpts(tail(splitted))))
				);
			}
		}
	));
}

ruConf2Json(conf : RuConf) -> Json {
	JsonObject([Pair("conf",
		JsonObject([
			Pair("file", JsonString(conf.file)),
			Pair("path", JsonString(conf.path)),
			Pair("ext", JsonString(conf.ext)),
			Pair("importRoots", JsonArray(map(conf.importRoots, \root -> JsonString(root)))),
			Pair("workingDir", JsonString(conf.workingDir)),
			Pair("verbose", JsonString(i2s(conf.verbose))),
			Pair("opts", JsonArray(map(tree2pairs(conf.opts), 
				\opt -> JsonObject([
					Pair("key", JsonString(opt.first)),
					Pair("value", JsonString(opt.second))
				])
			))),
			Pair("threadId", JsonString(i2s(conf.threadId))),
		])
	)]);
}

ruJson2Conf(json : Json) -> Maybe<RuConf> {
	conf = getJsonObjectField(json, "conf");
	switch (conf) {
		JsonObject(members):
			if (members == []) {
				None();
			} else {
				Some(RuConf(
					getJsonStringField(conf, "file", ""),
					getJsonStringField(conf, "path", ""),
					getJsonStringField(conf, "ext", ""),
					map(getJsonArrayField(conf, "importRoots"), \root -> getJsonStringValue(root, "")),
					getJsonStringField(conf, "workingDir", ""),
					s2i(getJsonStringField(conf, "verbose", "")),
					pairs2tree(map(getJsonArrayField(conf, "opts"), 
						\opt -> Pair(getJsonStringField(opt, "key", ""), getJsonStringField(opt, "value", ""))
					)),
					s2i(getJsonStringField(conf, "threadId", "")),
					\err, places -> println(err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")))
				));
			}
		default:
			None();
	}
}

ruOptsDescr(opts : Tree<string, string>) -> string {
	keys_of_interest = buildSet([
		"did-open", "did-change", "did-save", "verify",
		"decl", "uses", "hover", "rename", "outline", "find"
	]);
	strGlue(
		map(tree2pairs(filterTree(opts, \key, val -> 
			(val == "1" || val == "all") || containsSet(keys_of_interest, key)
		)),
		\p -> p.first + "=" + p.second), ", "
	);
}

ruMakeOpts(args : [string]) -> Tree<string, string> {
	fold(args, makeTree(), \acc, opt ->
		if (opt == "") acc else {
			eqi = strIndexOf(opt, "=");
			if (eqi == -1) {
				setTree(acc, "default", opt);
			} else {
				key = substring(opt, 0, eqi);
				val = substring(opt, eqi + 1, strlen(opt));
				setTree(acc, key, val);
			}
		}
	);
}

ruRussellDir : ref Maybe<string> = ref None();

getRussellDir() -> string {
	init_dir = \-> {
		// Use the path of the executable
		appPath = strReplace(getApplicationPath(), "\\", "/");
		russellDefDir = if (strContains(appPath, "russell/bin/")) {
			takeBefore(appPath, "/bin/", appPath) + "/"
		} else if (strContains(appPath, "russell-flow/bin/")) {
			takeBefore(appPath, "/bin/", appPath)
		} else if (strContains(appPath, "russell-flow/src/russell")) {
			takeBefore(appPath, "src/russell", appPath)
		} else if (strContains(appPath, "russell/src/russell")) {
			takeBefore(appPath, "src/russell", appPath)
		} else if (strContains(appPath, "bin/")) {
			takeBefore(appPath, "bin/", appPath)
		} else {
			println("WARNING: Could not determine the russell directory.");
			println("Defaults to ../flow9/. Use bin-dir=<path> to specify where the flow folder is");
			"../russell/";
		}
		binDir = getUrlParameter("bin-dir");
		russelldir = if (binDir == "") {
			russellDefDir
		} else {
			if (endsWith(binDir, "bin/") || endsWith(binDir, "bin\\"))
				substring(binDir, 0, strlen(binDir)-4)
			else
				substring(binDir, 0, strlen(binDir)-3);
		}
		strReplace(russelldir, "\\", "/");
    }
    onlyOnce(ruRussellDir, init_dir);
}
