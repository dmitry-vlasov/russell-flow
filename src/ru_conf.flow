import ds/tree;
import fs/filesystem;
import net/url_parameter;
import sys/concurrent;
import lingo/linecolumn;
import math/stringmath;

export {
	RuPlace(file : string, pos : int);
	
	RuConf(
		file : string,
		ext : string,
		importRoots : [string],
		workingDir : string,
        verbose : int,
		opts : Tree<string, string>,
		threadId : int,
		onError : (string, [RuPlace]) -> void
	);

	ruNoConf = RuConf("__no", "__no", [], "", 0, makeTree(), 0, nop2);
	
	ruDirName(path : string) -> string;
	ruMakeConf(onError : (string, [RuPlace]) -> void) -> Maybe<RuConf>;
	ruTrimPath(file : string, conf : RuConf, ext : string) -> string;
	ruFindPath(file : string, conf : RuConf, ext : string) -> string;
	ruRemoveExt(file : string, ext : string) -> string;
	ruAddErr2Conf(conf : RuConf, msg : string) -> RuConf;
	ruAddErrCounter(conf : RuConf, err_count : ref int) -> RuConf;
	ruPlace2s(place : RuPlace) -> string;
	ruIndent(str : string) -> string;
	ruOptIsSet(opt : string, conf : RuConf) -> bool;
	ruAllOptsAreSet(opt : [string], conf : RuConf) -> bool;
	ruSomeOptsAreSet(opt : [string], conf : RuConf) -> bool;
	ruOptIsTrue(opt : string, conf : RuConf) -> bool;
	ruAllOptsAreTrue(opt : [string], conf : RuConf) -> bool;
	ruSomeOptsAreTrue(opt : [string], conf : RuConf) -> bool;
	ruSetOpt(opt : string, val : string, conf : RuConf) -> RuConf;
	ruRemoveOpt(opt : string, conf : RuConf) -> RuConf;
	ruRemoveOpts(opts : [string], conf : RuConf) -> RuConf;
	ruOpt(opt : string, conf : RuConf) -> string;
	
	ruIf(cond : bool, val : ?, f : (?) -> ?) -> ?;

	ruConcurrent(jobs : [() -> ?]) -> [?];

	RuTask(
		id : string,
		job  : () -> ??,
		fork : (?) -> ?,
		join : (?, ??) -> ?,
	);
	
	RuTaskFactory(
		produce : (?) -> [RuTask<?, ??>],
		complete : (?) -> bool
	);

	ruConcurrentTasks(factory : RuTaskFactory, init : ref ?) -> ? {
		ruDoConcurrentTasks(factory, init, initConcurrentHashMap(), ref makeSet());
		^init
	}
}

ruDoConcurrentTasks(factory : RuTaskFactory, acc : ref ?, results : native, running : ref Set<string>) -> void {
	if (!factory.complete(^acc)) {
		tasks = factory.produce(^acc);
		iter(tasks, \task -> {
			acc := task.fork(^acc);
			running := insertSet(^running, task.id);
			concurrentAsyncCallback(
				\__, cb -> cb(task.job()),
				\w -> setConcurrentHashMap(results, task.id, \a -> task.join(a, w))
			)
		});
		iter(set2array(^running), \id ->
			if (containsConcurrentHashMap(results, id)) {
				acc := getConcurrentHashMap(results, id)(^acc);
				running := removeSet(^running, id);
			}
		);
		ruDoConcurrentTasks(factory, acc, results, running);
	}
}

ruIndent(str : string) -> string {
	strGlue(map(strSplit(str, "\n"), \s -> "\t" + s), "\n")
}

ruMakeConf(onError : (string, [RuPlace]) -> void) -> Maybe<RuConf> {
	err_count = ref 0;
	conf_opts = ruReadConfFileFromDir(resolveRelativePath("."));
	opts = fold(getAllUrlParametersArray(), conf_opts, \acc, p -> setTree(acc, p[0], p[1]));
	file = foldTree(opts, "", \name, val, acc -> 
		if (name == "file" || val == "") {
			if (acc == "") {
				if (name == "file") val else name
			} else if (acc != val) {
				err_count := ^err_count + 1;
				onError("target file is set up more then once: '" + val + "' and '" + acc + "'", []);
				""
			} else acc;
		} else acc
	);
	ext = getFileExt(file);
	verbose = s2i(lookupTreeDef(opts, "verbose", "0"));
	importRoots = filtermap(strSplit(lookupTreeDef(opts, "import-roots", ""), ","), \imp -> {
		dir = rtrim2(strReplace(imp, "\\", "/"), "/") + "/";
		if (!isDirectory(dir)) {
			onError("import root directory " + dir + " does not exist", []);
			err_count := ^err_count + 1;
			None();
		} else {
			Some(strReplace(resolveRelativePath(dir), "\\", "/"));
		}
	});
	workingDir = lookupTreeDef(opts, "working-dir", "");
	conf1 = RuConf(file, ext, importRoots, workingDir, verbose, opts, s2i(getThreadId()), onError);
	trimmed = ruTrimPath(resolveRelativePath(file), conf1, ext);
	num_cpus = availableProcessors();
	setThreadPoolSize(num_cpus);
	if (verbose > 1) {
		println("cpus: " + i2s(num_cpus));
	}
	if (file == "" || ^err_count > 0) {
		onError("target file is not set", []);
		None() 
	} else {
		Some(RuConf(
			trimmed, ext,
			importRoots, workingDir, verbose, opts, s2i(getThreadId()), onError
		));
	}
}

ruReadConfFileFromDir(dir : string) -> Tree<string, string> {
	path = dir + "/russell.conf";
	if (fileExists(path)) {
		config = getFileContent(path);
		lines = strSplit(config, "\n");
		fold(lines, makeTree(), \acc, l -> {
			// Skip comment lines in russell.conf
			if (!startsWith(ltrim2(l, " \t"), "#") && !startsWith(ltrim2(l, " \t"), "//")) {
				opts = strSplit(l, "=");
				if (length(opts) == 1) {
					opt = trim2(opts[0], " \t\r");
					setTree(acc, opt, "");
				} else if (length(opts) == 2) {
					opt = trim2(opts[0], " \t\r");
					val = trim2(opts[1], " \t\r");
					setTree(acc, opt, val)
				} else acc;
			} else acc;
		});
	} else if (dir == "/" || dir == "") {
		makeTree();
	} else {
		ruReadConfFileFromDir(ruDirName(dir));
	}
}

ruDirName(path : string) -> string {
	path1 = strReplace(path, "\\", "/");
	if (!strContains(path1, "/")) "" else {
		strLeft(path1, strLastIndexOf(path1, "/"));
	}
}

ruRemoveExt(file : string, ext : string) -> string {
	if (endsWith(file, ext)) strsubsmart(file, 0, -strlen(ext)) else file
}

ruTrimPath(file : string, conf : RuConf, ext : string) -> string {
	noext = strReplace(ruRemoveExt(file, ext), "\\", "/");
	shift = if (conf.workingDir == "") "" else relatingPath(conf.workingDir, resolveRelativePath("."));
	pathShift = if (shift == "") shift else shift + "/";
	processImportRoot = \acc, impRoot -> {
		resolved = strReplace(resolveRelativePath(impRoot), "\\", "/");
		if (startsWith(toLowerCase(acc), toLowerCase(resolved))) {
			strRight(acc, strlen(resolved));
		} else if (startsWith(toLowerCase(acc), toLowerCase(impRoot))) {
			strRight(acc, strlen(impRoot));
		} else acc
	};
	trimmed = fold(conf.importRoots, noext, \acc, impRoot -> {
		acc1 = if (pathShift != "") {
			processImportRoot(acc, pathShift + impRoot)
		} else acc;
		processImportRoot(acc1, impRoot)
	});
	if (trimmed == file) file else trim2(trimmed, "/");
}

ruFindPath(file : string, conf : RuConf, ext : string) -> string {
	withRus = if (endsWith(file, ext)) file else file + ext;
	shift = if (conf.workingDir == "") "" else relatingPath(conf.workingDir, resolveRelativePath("."));
	if (fileExists(withRus)) {
		resolveRelativePath(withRus);
	} else {
		ruDoFindPath(withRus, if (shift == "") shift else shift + "/", conf.importRoots);
	}
}

ruDoFindPath(withRus : string, pathShift : string, importRoots : [string]) -> string {
	if (importRoots == []) withRus
	else {
		head = importRoots[0];
		directPath = head + (if (endsWith(head, "/")) "" else "/") + withRus;
		if (fileExists(directPath)) {
			resolveRelativePath(directPath);
		} else {
			shiftedPath = pathShift + directPath;
			if (fileExists(shiftedPath)) {
				resolveRelativePath(shiftedPath);
			} else {
				ruDoFindPath(withRus, pathShift, tail(importRoots));
			}
		}
	}
}

ruAddErr2Conf(conf : RuConf, msg : string) -> RuConf {
	RuConf(conf with onError = \str, pos -> conf.onError(str + msg, pos))
}

ruAddErrCounter(conf : RuConf, err_count : ref int) -> RuConf {
	RuConf(conf with onError = 
		\err, places -> {
			err_count := ^err_count + 1;
			conf.onError(err, places);
		}
	)
}

ruPlace2s(place : RuPlace) -> string {
	if (place.file == "" || place.pos == -1) "" else {
		code = getFileContent(place.file);
		resolver = makeLineResolver(code);
		pos = findLine(resolver, place.pos);
		"file " + place.file + ": line " + i2s(pos.lineno) + ", col " + i2s(pos.column)
	}
}

ruOptIsSet(opt : string, conf : RuConf) -> bool {
	containsKeyTree(conf.opts, opt)
}

ruAllOptsAreSet(opts : [string], conf : RuConf) -> bool {
	forall(opts, \opt -> ruOptIsSet(opt, conf))
}

ruSomeOptsAreSet(opts : [string], conf : RuConf) -> bool {
	exists(opts, \opt -> ruOptIsSet(opt, conf))
}

ruOptIsTrue(opt : string, conf : RuConf) -> bool {
	lookupTreeDef(conf.opts, opt, "") == "1"
}

ruAllOptsAreTrue(opts : [string], conf : RuConf) -> bool {
	forall(opts, \opt -> ruOptIsTrue(opt, conf))
}

ruSomeOptsAreTrue(opts : [string], conf : RuConf) -> bool {
	exists(opts, \opt -> ruOptIsTrue(opt, conf))
}

ruSetOpt(opt : string, val : string, conf : RuConf) -> RuConf {
	RuConf(conf with opts = setTree(conf.opts, opt, val))
}

ruRemoveOpt(opt : string, conf : RuConf) -> RuConf {
	RuConf(conf with opts = removeFromTree(conf.opts, opt));
}

ruRemoveOpts(opts : [string], conf : RuConf) -> RuConf {
	fold(opts, conf, \acc, opt -> ruRemoveOpt(opt, acc));
}

ruOpt(opt : string, conf : RuConf) -> string {

	lookupTreeDef(conf.opts, opt, "")
}

ruIf(cond : bool, val : ?, f : (?) -> ?) -> ? {
	if (cond) f(val) else val
}

ruConcurrent(jobs : [() -> ?]) -> [?] {
	concurrent(true, jobs)
	/*concatA(map(
		splitByNumber(jobs, availableProcessors()),
		\tasks -> concurrent(true, tasks)
	))*/
}
