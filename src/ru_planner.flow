import math/math;
import ds/tree;

export {
	// f(x) = a[0] * exp(x) + a[1] + a[2] * x + ... + a[k] * x^{k - 1}
	RuApprox(a : [double]);

	RuPlanner(
		start : double, // When the task group is started
		limit : double, // Time limit for the task group
		num : int,      // Number of tasks in the group
		approx : RuApprox // Appproximation for the time
	);

	RuApproxStats(
		stats : Tree<double, double>
	);

	ruEvalApprox(approx : RuApprox, x : double) -> double;
	ruApproxDiscrepancy(stats : RuApproxStats, approx : RuApprox) -> double;
	ruEnhanceApprox(stats : RuApproxStats, approx : RuApprox) -> RuApprox;
}

ruEvalApprox(approx : RuApprox, x : double) -> double {
	approx.a[0] * exp(x) + foldi(approx.a, 0.0, \i, acc, c -> if (i == 0) acc else acc + c * dpow(x, i2d(i - 1)));
}

ruApproxDiscrepancy(s : RuApproxStats, approx : RuApprox) -> double {
	foldTree(s.stats, 0.0, \x, y, acc -> {
		delta = y - ruEvalApprox(approx, x);
		acc + delta * delta;
	});
}

ruEnhanceApprox(stats : RuApproxStats, app : RuApprox) -> RuApprox {
	ruDoEnhanceApprox(stats, RuApproxEnhaceEnv(app, map(app.a, \__ -> 1.0), 0)).app;
}

RuApproxEnhaceEnv(
	app : RuApprox, 
	deltas : [double],
	count : int,
);

ruDoEnhanceApprox(stats : RuApproxStats, env : RuApproxEnhaceEnv) -> RuApproxEnhaceEnv {
	d0 = ruApproxDiscrepancy(stats, env.app);
	env1 = ruDoEnhanceApproxIteration(stats, env);
	d1 = ruApproxDiscrepancy(stats, env1.app);
	if (d1 > d0) {
		println("ruDoEnhanceApprox: d1 > d0: somth. wrond - should not be");
		quit(-1);
	}
	if (d0 - d1 < 0.001) env else
	ruDoEnhanceApprox(stats, RuApproxEnhaceEnv(env with count = env.count + 1));
}

ruDoEnhanceApproxIteration(stats : RuApproxStats, env : RuApproxEnhaceEnv) -> RuApproxEnhaceEnv {
	foldi(env.app.a, env, \i, acc, __ -> ruDoEnhanceApproxStep(stats, i, acc));
}

ruDoEnhanceApproxStep(stats : RuApproxStats, i : int, env : RuApproxEnhaceEnv) -> RuApproxEnhaceEnv {
	d0 = ruApproxDiscrepancy(stats, env.app);
	aDP = RuApprox(env.app with a = replace(env.app.a, i, env.app.a[i] + env.deltas[i] * 2.0));
	aDM = RuApprox(env.app with a = replace(env.app.a, i, env.app.a[i] - env.deltas[i] * 2.0));
	aHP = RuApprox(env.app with a = replace(env.app.a, i, env.app.a[i] + env.deltas[i] / 2.0));
	aHM = RuApprox(env.app with a = replace(env.app.a, i, env.app.a[i] - env.deltas[i] / 2.0));
	dDP = ruApproxDiscrepancy(stats, aDP);
	dDM = ruApproxDiscrepancy(stats, aDM);
	dHP = ruApproxDiscrepancy(stats, aHP);
	dHM = ruApproxDiscrepancy(stats, aHM);
	minD = min(d0, min(dDP, min(dDM, min(dHP, dHM))));
	if (minD == dDP) RuApproxEnhaceEnv(aDP, replace(env.deltas, i, env.deltas[i] * 2.0), env.count) else
	if (minD == dDM) RuApproxEnhaceEnv(aDM, replace(env.deltas, i, env.deltas[i] * 2.0), env.count) else
	if (minD == dHP) RuApproxEnhaceEnv(aHP, replace(env.deltas, i, env.deltas[i] / 2.0), env.count) else
	if (minD == dHM) RuApproxEnhaceEnv(aHM, replace(env.deltas, i, env.deltas[i] / 2.0), env.count) else env;
}


