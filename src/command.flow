import ru/math;
import mm/src;

export {
	RuEnv(
		ruMath : RuMath, 
		mmMath : MmMath,
		conf   : RuConf
	);
	RuCommArg(
		name : string,
		optional : bool,
		help : string,
		defval : string
	);
	RuComm(
		name : string,
		category : string,
		help : string,
		defarg : string,
		args : [RuCommArg],
		run : (RuTask, RuEnv) -> Maybe<RuEnv>
	);

	ruCommArg2s(arg : RuCommArg) -> string;
	ruComm2s(comm : RuComm, with_args : bool) -> string;
	ruComms2s(comms : [RuComm], with_args : bool) -> string;

	// A struct describing a general function, which operates on decls.
	// pred - the predicate, which selects decls to process.
	// measure - the function, which return the relative 'size' of the decl. Used to balance time limits.
	// func - the function to be applied. Second argument is a lime limit.
	RuApplyFn(
		name : string, 
		pred : (RuDecl) -> bool, 
		measure : (RuDecl) -> double, 
		func : (RuDecl, double) -> bool
	);

	// Apply 'f.func' to the decls from 'target' task option. 
	// Selects decls to process with 'fn.pred' parameter.
	// Balances the time limit between all admitted decls
	// proportionally to the 'fn.measure'.
	ruApplyFnComm(task : RuTask, env : RuEnv, f : RuApplyFn) -> void;

	// If 'file' option is not set, it will be applied to all files in 'project-root' list.
	ruApplyToProjectRoots(comm : RuComm) -> RuComm;
}

ruCommArg2s(arg : RuCommArg) -> string {
	arg.name + " " + 
	(if (arg.optional) "(optional) " else "") + arg.help + 
	(if (arg.defval == "") "" else " defval: " + arg.defval);
}

ruCommArgs2s(args : [RuCommArg]) -> string {
	has_defval = exists(args, \arg -> arg.defval != "");
	arg_matr = filtermap([
		Some(map(args, \arg -> arg.name)),
		Some(map(args, \arg -> b2s(arg.optional))),
		Some(map(args, \arg -> arg.help)),
		if (has_defval) Some(map(args, \arg -> arg.defval)) else None(),
	], idfn);
	headers = filtermap([
		Some("Name"), 
		Some("Optional"),
		Some("Help"),
		if (has_defval) Some("Default") else None()
	], idfn);
	ruStringTable2s(arg_matr, Some(headers));
}

ruComm2s(comm : RuComm, with_args : bool) -> string {
	"Command:\n\t" + comm.name + "\n" + 
	(if (comm.category == "") "" else "Category:\n\t" + comm.category + "\n") + 
	(if (comm.defarg == "") "" else "Default argument:\n\t" + comm.defarg + "\n") + 
	"Description:\n" + strIndent(comm.help) + "\n" +
	if (!with_args || comm.args == []) "" else {
		"Arguments:\n" + strIndent(ruCommArgs2s(comm.args)) + "\n";
	}
}

ruComms2s(comms : [RuComm], with_args : bool) -> string {
	comm_matr = filtermap([
		Some(map(comms, \comm -> comm.name)),
		Some(map(comms, \comm -> comm.category)),
		Some(map(comms, \comm -> comm.help)),
		if (with_args) Some(map(comms, \comm -> strGlue(map(comm.args, ruCommArg2s), ", "))) else None()
	], idfn);
	headers = filtermap([
		Some("Command name"), 
		Some("Category"),
		Some("Help"),
		if (with_args) Some("Arguments") else None()
	], idfn);
	ruStringTable2s(comm_matr, Some(headers)) + "\n";
}

ruApplyFnComm(task : RuTask, env : RuEnv, f : RuApplyFn) -> void {
	file = lookupTreeDef(task.args, "file", "");
	math = env.ruMath;
	conf = env.conf;
	if (conf.verbose >= 3) {
		conf.onMessage("\t\tApply '" + f.name + "' task: " + ruTask2s(task));
	}
	target0 = lookupTreeDef(task.args, "target", file);
	target = ruTrimPath(target0, env.conf, ".ru");
	failure = ref 0;
	success = ref 0;
	failed_names = ref [];
	max_time = ref 0.0;
	max_name = ref "";
	time_limit2s = \limit -> (if (limit == doubleMax) "no" else d2st(limit / 1000.0, 2) + "s");
	apply_decl = \decl, time_limit -> {
		if (conf.verbose >= 3) {
			conf.onMessage("\t\tTime limit on decl '" + ruDeclName(decl) + "': " + time_limit2s(time_limit));
		}
		start = timestamp();
		ret = if (f.func(decl, time_limit)) {
			atomicRefIntAddition(success, 1);
			true 
		} else {
			atomicRefIntAddition(failure, 1);
			refArrayPush(failed_names, ruDeclName(decl));
			false;
		} 
		time = timestamp() - start;
		if (time > ^max_time) {
			max_time := time;
			max_name := ruDeclName(decl);
		}
		ret;
	}
	decls2measures = \decls : [RuDecl] -> {
		map(decls, \d -> f.measure(d));
	}
	start = timestamp();
	calc_time_limit = \decls -> {
		opt = switch (lookupTree(task.args, "time-limit")) {
			Some(limit): limit;
			None(): lookupTreeDef(conf.opts, "time-limit", "300");
		}
		if (opt == "auto") {
			// By default we set 3 ms per one measure unit
			measures = decls2measures(decls);
			ruSumDoublesFromArray(measures) * 3.0;
		} else if (opt == "no") doubleMax else {
			i2d(s2i(opt) * 1000);
		}
	}
	decls = if (target == "all" || target == "1" || target == "1-seq" || target == "all-seq") {
		filter(filtermap(concatA(map(ruOrderSources(math), \src -> src.decls)), ruBlock2Decl), f.pred);
	} else {
		switch (lookupTree(math.sources, target)) {
			Some(src): 
				filter(filtermap(src.decls, ruBlock2Decl), f.pred);
			None(): {
				switch (lookupTree(math.assertions, target)) {
					Some(ass): [ass];
					None(): {
						conf.onError("no target found for " + f.name, []);
						[];
					}
				}
			}
		}
	}
	time_limit = calc_time_limit(decls);
	if (conf.verbose > 0) {
		conf.onMessage(
			"\tgoing to process " + i2s(length(decls)) + 
			"\n\ttime limit: " + time_limit2s(time_limit) +
			(if (conf.verbose >=2) "\n\ttime limit per unit: " + d2st(time_limit / i2d(length(decls)), 3) else "")
		);
	}
	ret = if (target == "1-seq" || target == "all-seq") {
		measures = decls2measures(decls);
		sum_measure = ruSumDoublesFromArray(measures);
		all(mapi(decls, \i, d ->
			apply_decl(d, time_limit * measures[i] / sum_measure)
		));
	} else {
		chunks = splitByNumber(decls, s2i(lookupTreeDef(conf.opts, "decls-split-num", "256")));
		chunk_measures = map(chunks, decls2measures);
		sum_chunk_measures = map(chunk_measures, ruSumDoublesFromArray);
		total_measure = ruSumDoublesFromArray(sum_chunk_measures);
		foldi(chunks, true, \n, acc, chunk -> {
			left_time = time_limit - (timestamp() - start);
			if (left_time <= 0.0) false else {
				time_left_on_chunk = left_time * i2d(availableProcessors()) * sum_chunk_measures[n] / total_measure * 2.0;
				acc && all(ruConcurrent(mapi(chunk, \i, decl -> 
						\-> apply_decl(decl, time_left_on_chunk * chunk_measures[n][i] / sum_chunk_measures[n])
				)));
			}
		});
	}
	time = timestamp() - start;
	if (conf.verbose > 0 && length(decls) > 0) {
		msg = if (length(decls) == 1) { 
			"ru applied '" + f.name + "' to '" + target + "' in " + d2st(time / 1000.0, 2) + "s";
		} else {
			"ru applied '" + f.name + "' to '" + target + "'" + 
				"\n\ttotal time: " + d2st(time / 1000.0, 2) + "s" +
				"\n\tavg time:   " + d2st((time / i2d(length(decls))) / 1000.0, 3) + "s" +
				"\n\tdecls num:  " + i2s(^success)
		}
		conf.onMessage(msg);
	}
	if (^failure > 0) {
		msg = 
			(if (conf.verbose > 0) "" else "ru applied '" + f.name + "' to '" + target + "' in " + d2st(time / 1000.0, 2) + "s\n") +
				"\tfailures: " + i2s(^failure) + 
				"\n\tsuccess:  " + i2s(^success) +
				//(if (conf.verbose >=2) "\n\tfailed:\n" + strGlue(map(^failed_names, \n -> "\t\t" + n), "\n") else "");
				"\n\tfailed:\n" + strGlue(map(^failed_names, \n -> "\t\t" + n), "\n");
		conf.onMessage(msg);
	}
}

ruApplyToProjectRoots(comm : RuComm) -> RuComm {
	RuComm(comm with
		args = map(comm.args, \arg -> if (arg.name != "file") arg else RuCommArg(arg with optional = true)),
		run = \task, env -> {
			if (containsKeyTree(task.args, "file")) {
				comm.run(task, env);
			} else {
				fold(env.conf.projectRoots, Some(env), \acc, file ->
					maybeBind(acc, \e -> comm.run(RuTask(task with args = setTree(task.args, "file", file)), e))
				);
			}
		}
	);
}
