import base/util/timer;
import ru/math_utils;
import mm/math_utils;
import script/script;
import script/value;

export {
	RuState(
		ruMath : RuMath, 
		mmMath : MmMath,
		vars   : Tree<string, ValValue>,
		conf   : RuConf,
	);

	ruEmptyState = RuState(ruEmptyMath, mmEmptyMath, makeTree(), ruMakeConf(".", []));

	RuCommArg(
		name : string,
		optional : bool,
		help : string,
		defval : string
	);
	RuCommDescr(
		name : string,
		category : string,
		help : string,
		defarg : string,
		inducesRoots : bool,
		args : [RuCommArg]
	);
	RuComm(
		descr : RuCommDescr,
		run : (ScTask, RuState) -> Maybe<RuState>
	);

	ruCommArg2s(arg : RuCommArg) -> string;
	ruCommDescr2s(descr : RuCommDescr, with_args : bool) -> string;
	ruComm2s(comm : RuComm, with_args : bool) -> string;
	ruComms2s(comms : [RuComm], with_args : bool) -> string;
	ruChainRuns(runs : [(ScTask, RuState) -> Maybe<RuState>]) -> (ScTask, RuState) -> Maybe<RuState>;

	// A struct describing a general function, which operates on decls.
	// pred - the predicate, which selects decls to process.
	// measure - the function, which return the relative 'size' of the decl. Used to balance time limits.
	RuFnDescr(
		name : string, 
		pred : (RuDecl) -> bool, 
		measure : (RuDecl) -> double, 
	);

	// Application function: returns bool value (success or failure).
	RuApplyFn(
		descr : RuFnDescr,
		func : (RuDecl, double) -> bool
	);

	// Mapping function: transforms (possibly) a decl. If None is returned, old one is kept.
	RuMapFn(
		descr : RuFnDescr,
		func : (RuDecl, double) -> Maybe<RuDecl>
	);

	// Apply 'f.func' to the decls from 'target' task option. 
	// Selects decls to process with 'fn.descr.pred' parameter.
	// Balances the time limit between all admitted decls
	// proportionally to the 'fn.descr.measure'.
	ruApplyFnComm(task : ScTask, env : RuState, f : RuApplyFn) -> void;

	// Map 'f.func' to the decls from 'target' task option. 
	// Selects decls to process with 'fn.descr.pred' parameter.
	// Balances the time limit between all admitted decls
	// proportionally to the 'fn.descr.measure'.
	ruMapFnComm(task : ScTask, env : RuState, f : RuMapFn) -> RuState;

	// If 'file' option is not set, it will be applied to all files in 'project-root' list.
	ruApplyToProjectRoots(comm : RuComm) -> RuComm;
}

ruCommArg2s(arg : RuCommArg) -> string {
	arg.name + " " + 
	(if (arg.optional) "(optional) " else "") + arg.help + 
	(if (arg.defval == "") "" else " defval: " + arg.defval);
}

ruCommArgs2s(args : [RuCommArg]) -> string {
	has_defval = exists(args, \arg -> arg.defval != "");
	arg_matr = filtermap([
		Some(map(args, \arg -> arg.name)),
		Some(map(args, \arg -> b2s(arg.optional))),
		Some(map(args, \arg -> arg.help)),
		if (has_defval) Some(map(args, \arg -> arg.defval)) else None(),
	], idfn);
	headers = filtermap([
		Some("Name"), 
		Some("Optional"),
		Some("Help"),
		if (has_defval) Some("Default") else None()
	], idfn);
	ruStringTable2s(arg_matr, Some(headers));
}

ruCommDescr2s(descr : RuCommDescr, with_args : bool) -> string {
	"Command:\n\t" + descr.name + "\n" + 
	(if (descr.category == "") "" else "Category:\n\t" + descr.category + "\n") + 
	(if (descr.defarg == "") "" else "Default argument:\n\t" + descr.defarg + "\n") + 
	"Description:\n" + strIndent(descr.help) + "\n" +
	if (!with_args || descr.args == []) "" else {
		"Arguments:\n" + strIndent(ruCommArgs2s(descr.args)) + "\n";
	}
}

ruComm2s(comm : RuComm, with_args : bool) -> string {
	ruCommDescr2s(comm.descr, with_args);
}

ruComms2s(comms : [RuComm], with_args : bool) -> string {
	comm_matr = filtermap([
		Some(map(comms, \comm -> comm.descr.name)),
		Some(map(comms, \comm -> comm.descr.category)),
		Some(map(comms, \comm -> comm.descr.help)),
		if (with_args) Some(map(comms, \comm -> strGlue(map(comm.descr.args, ruCommArg2s), ", "))) else None()
	], idfn);
	headers = filtermap([
		Some("Command name"), 
		Some("Category"),
		Some("Help"),
		if (with_args) Some("Arguments") else None()
	], idfn);
	ruStringTable2s(comm_matr, Some(headers)) + "\n";
}

ruChainRuns(runs : [(ScTask, RuState) -> Maybe<RuState>]) -> (ScTask, RuState) -> Maybe<RuState> {
	\task, state -> fold(runs, Some(state), \acc, run ->
		maybeBind(acc, \st ->run(task, st))
	);
}

ruApplyFnComm(task : ScTask, env : RuState, f : RuApplyFn) -> void {
	file = lookupTreeDef(task.args, "file", "");
	math = env.ruMath;
	conf = env.conf;
	if (ruVerbose(conf) >= 3) {
		conf.onMessage("\t\tApply '" + f.descr.name + "' task: " + ruTask2s(task));
	}
	target0 = lookupTreeDef(task.args, "target", file);
	target = ruTrimPath(target0, env.conf, ".ru");
	failure = ref 0;
	success = ref 0;
	failed_names = ref [];
	max_time = ref 0.0;
	max_id = ref -1;
	time_limit2s = \limit -> if (limit == doubleMax) "no" else ruTime2s(limit);
	apply_decl = \decl, time_limit -> {
		if (ruVerbose(conf) >= 3) {
			conf.onMessage("\t\tTime limit on decl '" + id2s(decl.descr.id) + "': " + time_limit2s(time_limit));
		}
		timer = ruMakeTimer();
		ret = if (f.func(decl, time_limit)) {
			atomicRefIntAddition(success, 1);
			true 
		} else {
			atomicRefIntAddition(failure, 1);
			refArrayPush(failed_names, decl.descr.id);
			false;
		} 
		passed = ruTimePassed(timer);
		if (passed > ^max_time) {
			max_time := passed;
			max_id := decl.descr.id;
		}
		ret;
	}
	decls2measures = \decls : [RuDecl] -> {
		map(decls, \d -> f.descr.measure(d));
	}
	timer = ruMakeTimer();
	calc_time_limit = \decls -> {
		opt = switch (lookupTree(task.args, "time-limit")) {
			Some(limit): limit;
			None(): lookupTreeDef(conf.opts, "time-limit", "300");
		}
		if (opt == "auto") {
			// By default we set 3 ms per one measure unit
			measures = decls2measures(decls);
			ruSumDoublesFromArray(measures) * 3.0;
		} else if (opt == "no") doubleMax else {
			i2d(s2i(opt) * 1000);
		}
	}
	decls = if (target == "all" || target == "1" || target == "1-seq" || target == "all-seq") {
		filter(concatA(map(ruOrderSources(math), \src -> src.decls)), f.descr.pred);
	} else {
		id = s2id(target);
		switch (lookupTree(math.sources, id)) {
			Some(src): 
				filter(src.decls, f.descr.pred);
			None(): {
				switch (lookupTree(math.assertions, id)) {
					Some(ass): [ass];
					None(): {
						conf.onError("no target found for " + f.descr.name, []);
						[];
					}
				}
			}
		}
	}
	time_limit = calc_time_limit(decls);
	if (ruVerbose(conf) > 0) {
		conf.onMessage(
			"\tgoing to process " + i2s(length(decls)) + 
			"\n\ttime limit: " + time_limit2s(time_limit) +
			(if (ruVerbose(conf) >=2) "\n\ttime limit per unit: " + d2st(time_limit / i2d(length(decls)), 3) else "")
		);
		if (ruVerbose(conf) > 2) {
			conf.onMessage("\tdecls:\n" + 
				strGlue(map(decls, \d -> "\t" + id2s(d.descr.id)), "\n") + "\n\n"
			);
		}
	}
	ret = if (target == "1-seq" || target == "all-seq") {
		measures = decls2measures(decls);
		sum_measure = ruSumDoublesFromArray(measures);
		all(mapi(decls, \i, d ->
			apply_decl(d, time_limit * measures[i] / sum_measure)
		));
	} else {
		chunks = splitByNumber(decls, s2i(lookupTreeDef(conf.opts, "decls-split-num", "256")));
		chunk_measures = map(chunks, decls2measures);
		sum_chunk_measures = map(chunk_measures, ruSumDoublesFromArray);
		total_measure = ruSumDoublesFromArray(sum_chunk_measures);
		foldi(chunks, true, \n, acc, chunk -> {
			left_time = time_limit - ruTimePassed(timer);
			if (left_time <= 0.0) false else {
				time_left_on_chunk = left_time * i2d(availableProcessors()) * sum_chunk_measures[n] / total_measure;
				acc && all(ruConcurrent(mapi(chunk, \i, decl -> 
						\-> apply_decl(decl, time_left_on_chunk * chunk_measures[n][i] / sum_chunk_measures[n])
				)));
			}
		});
	}
	passed = ruTimePassed(timer);
	if (ruVerbose(conf) > 0 && length(decls) > 0) {
		msg = if (length(decls) == 1) { 
			"ru applied '" + f.descr.name + "' to '" + target + "' in " + ruTime2s(passed);
		} else {
			"ru applied '" + f.descr.name + "' to '" + target + "'" + "\n" +
				"\ttotal time: " + ruTime2s(passed) + "\n"
				"\tavg time:   " + ruTime2s(passed / i2d(length(decls))) + "\n"
				"\tdecls num:  " + i2s(^success)
		}
		conf.onMessage(msg);
	}
	if (^failure > 0) {
		msg = 
			(if (ruVerbose(conf) > 0) "" else "ru applied '" + f.descr.name + "' to '" + target + "' in " + ruTime2s(passed) + "\n") +
				"\tfailures:  " + i2s(^failure) + "\n" +
				"\tsuccess: " + i2s(^success) +
				(if (ruVerbose(conf) >=2) "\n\tfailed:\n" + strGlue(map(^failed_names, \n -> "\t\t" + id2s(n)), "\n") else "");
				//"\n\tfailed:\n" + strGlue(map(^failed_names, \n -> "\t\t" + id2s(n)), "\n");
		conf.onMessage(msg);
	}
}

ruMapFnComm(task : ScTask, env : RuState, f : RuMapFn) -> RuState {
	file = lookupTreeDef(task.args, "file", "");
	math = env.ruMath;
	conf = env.conf;
	if (ruVerbose(conf) >= 3) {
		conf.onMessage("\t\tMap '" + f.descr.name + "' task: " + ruTask2s(task));
	}
	target0 = lookupTreeDef(task.args, "target", file);
	target = ruTrimPath(target0, env.conf, ".ru");
	not_mapped = ref 0;
	was_mapped = ref 0;
	processed  = ref 0;
	failed_names = ref [];
	max_time = ref 0.0;
	max_id = ref -1;
	time_limit2s = \limit -> if (limit == doubleMax) "no" else ruTime2s(limit);
	map_decl = \decl, time_limit -> {
		if (ruVerbose(conf) >= 3) {
			conf.onMessage("\t\tTime limit on decl '" + id2s(decl.descr.id) + "': " + time_limit2s(time_limit));
		}
		timer = ruMakeTimer();
		ret = f.func(decl, time_limit);
		atomicRefIntAddition(processed, 1);
		if (isSome(ret)) {
			atomicRefIntAddition(was_mapped, 1);
		} else {
			atomicRefIntAddition(not_mapped, 1);
		} 
		time = ruTimePassed(timer);
		if (time > ^max_time) {
			max_time := time;
			max_id := decl.descr.id;
		}
		ret;
	}
	decls2measures = \decls : [RuDecl] -> {
		map(decls, \d -> f.descr.measure(d));
	}
	calc_time_limit = \decls -> {
		opt = switch (lookupTree(task.args, "time-limit")) {
			Some(limit): limit;
			None(): lookupTreeDef(conf.opts, "time-limit", "300");
		}
		if (opt == "auto") {
			// By default we set 3 ms per one measure unit
			measures = decls2measures(decls);
			ruSumDoublesFromArray(measures) * 3.0;
		} else if (opt == "no") doubleMax else {
			i2d(s2i(opt) * 1000);
		}
	}
	decls = if (target == "all" || target == "1" || target == "1-seq" || target == "all-seq") {
		filter(concatA(map(ruOrderSources(math), \src -> src.decls)), f.descr.pred);
	} else {
		id = s2id(target);
		switch (lookupTree(math.sources, id)) {
			Some(src): 
				filter(src.decls, f.descr.pred);
			None(): {
				switch (lookupTree(math.assertions, id)) {
					Some(ass): [ass];
					None(): {
						conf.onError("no target found for " + f.descr.name, []);
						[];
					}
				}
			}
		}
	}
	time_limit = calc_time_limit(decls);
	if (ruVerbose(conf) > 0) {
		conf.onMessage(
			"\tgoing to process " + i2s(length(decls)) + "\n" +
			"\ttime limit: " + time_limit2s(time_limit) + " (" + d2st(time_limit, 2) + "s)" +
			(if (ruVerbose(conf) >=2) "\n\ttime limit per unit: " + ruTime2s(time_limit / i2d(length(decls))) else "")
		);
		if (ruVerbose(conf) > 2) {
			conf.onMessage("\tdecls:\n" + 
				strGlue(map(decls, \d -> "\t" + id2s(d.descr.id)), "\n") + "\n\n"
			);
		}
	}
	timer = ruMakeLimitedTimer(time_limit);
	mapped_math = if (target == "1-seq" || target == "all-seq") {
		measures = decls2measures(decls);
		sum_measure = ruSumDoublesFromArray(measures);
		foldi(decls, math, \i, acc, d ->
			eitherMap(
				map_decl(d, time_limit * measures[i] / sum_measure),
				\mapped_d -> ruReplaceDecl(mapped_d, acc, conf),
				acc
			)
		);
	} else {
		chunks = splitByNumber(decls, s2i(lookupTreeDef(conf.opts, "decls-split-num", "256")));
		chunk_measures = map(chunks, decls2measures);
		sum_chunk_measures = map(chunk_measures, ruSumDoublesFromArray);
		total_measure = ruSumDoublesFromArray(sum_chunk_measures);
		planned_times = map(sum_chunk_measures, \m -> 
			time_limit * m / total_measure
		);
		planned_passed = mapi(sum_chunk_measures, \i,__ -> 
			ruSumDoublesFromArray(map(enumFromTo(0, i - 1), \j -> planned_times[j]))
		);
		planned_left = map(planned_passed, \passed -> time_limit - passed);
		foldi(chunks, math, \n, acc, chunk -> {
			left_time = ruTimeLeft(timer);
			if (left_time <= 0.0) acc else {
				time_planned_on_chunk = time_limit * sum_chunk_measures[n] / total_measure;
				time_left_on_chunk = time_planned_on_chunk * left_time / planned_left[n];
				scaled_time_limit_on_chunk = time_left_on_chunk * i2d(availableProcessors());
				mapped = ruConcurrent(mapi(chunk, \i, decl -> 
					\-> map_decl(decl, scaled_time_limit_on_chunk * chunk_measures[n][i] / sum_chunk_measures[n])
				));
				fold(mapped, acc, \ac, d -> 
					eitherMap(d,
						\mapped_d -> ruReplaceDecl(mapped_d, ac, conf),
						ac
					)
				)
			}
		});
	}
	if (ruVerbose(conf) > 0 && length(decls) > 0) {
		msg = if (length(decls) == 1) { 
			"ru mapped '" + f.descr.name + "' to '" + target + "' in " + ruTime2s(ruTimePassed(timer));
		} else {
			"ru mapped '" + f.descr.name + "' to '" + target + "'" + 
				"\n\ttotal time: " + ruTime2s(ruTimePassed(timer)) +
				"\n\tavg time:   " + ruTime2s(ruTimePassed(timer) / i2d(length(decls))) +
				"\n\twas mapped: " + i2s(^was_mapped) +
				"\n\tnot mapped: " + i2s(^not_mapped) + 
				"\n\t%processed: " + d2st(100.0 * i2d(^was_mapped + ^not_mapped) / i2d(length(decls)), 2);
		}
		conf.onMessage(msg);
	}
	RuState(env with ruMath = mapped_math);
}

ruApplyToProjectRoots(comm : RuComm) -> RuComm {
	RuComm(comm with
		descr = RuCommDescr(comm.descr with
			args = map(comm.descr.args, \arg -> if (arg.name != "file") arg else RuCommArg(arg with optional = true))
		),
		run = \task, env -> {
			if (containsKeyTree(task.args, "file")) {
				comm.run(task, env);
			} else {
				fold(env.conf.projectRoots, Some(env), \acc, file ->
					maybeBind(acc, \e -> comm.run(ScTask(task with args = setTree(task.args, "file", file)), e))
				);
			}
		}
	);
}
