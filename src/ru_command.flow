import ru/ru_math;
import mm/src;

export {
	RuEnv(
		ruMath : RuMath, 
		mmMath : MmMath,
		conf   : RuConf
	);
	RuCommArg(
		name : string,
		optional : bool,
		help : string,
		defval : string
	);
	RuComm(
		name : string,
		category : string,
		help : string,
		args : [RuCommArg],
		run : (RuTask, RuEnv) -> RuEnv
	);

	ruCommArg2s(arg : RuCommArg) -> string;
	ruComm2s(comm : RuComm) -> string;
	ruComms2s(comms : [RuComm]) -> string ;
}

ruCommArg2s(arg : RuCommArg) -> string {
	arg.name + " " + 
	(if (arg.optional) "(optional) " else "") + arg.help + 
	(if (arg.defval == "") "" else " defval: " + arg.defval);
}

ruComm2s(comm : RuComm) -> string {
	"    " + comm.name + "\t[" + comm.category + "]\t" + comm.help + 
	if (comm.args == []) "" else 
		", arguments: " + strGlue(map(comm.args, ruCommArg2s), ", ");
}

ruComms2s(comms : [RuComm]) -> string {
	max_name = ruMaxIntFromArray(map(comms, \comm -> strlen(comm.name)));
	max_category = ruMaxIntFromArray(map(comms, \comm -> strlen(comm.category)));
	"    " + 
	"command" + strRepeat(" ", max_name - strlen("command") + 3) + 
	"[category]" + strRepeat(" ", max_category - strlen("category") + 3) +
	"description\n" +
	"    " + 
	"-------" + strRepeat(" ", max_name - strlen("-------") + 3) + 
	"----------" + strRepeat(" ", max_category - strlen("----------") + 5) +
	"-------------\n" +
	strGlue(
		map(comms, \comm ->
			"    " + 
			comm.name + strRepeat(" ", max_name - strlen(comm.name) + 3) + 
			"[" + comm.category + "]" + strRepeat(" ", max_category - strlen(comm.category) + 3) +
			comm.help + if (comm.args == []) "" else ", arguments: " + strGlue(map(comm.args, ruCommArg2s), ", ")
		),
		"\n"
	);
}
/*
ruApplyTheoremComm(fn_name : string, fn : (RuTheorem, double, RuEnv) -> RuEnv) -> (task : RuTask, env : RuEnv) -> RuEnv {
	\task : RuTask, env : RuEnv -> {
		file = lookupTreeDef(task.args, "file", "");
		math = env.ruMath;
		conf = env.conf;
		target0 = lookupTreeDef(task.args, "target", file);
		target = ruTrimPath(target0, env.conf, ".ru");
		if (conf.verbose > 0) {
			conf.onMessage(fn_name + " target: " + target);
		}
		gen_level = s2i(lookupTreeDef(task.args, "level", "2"));
		generalized_count = ref 0;
		gen_array : ref [Pair<RuTheorem, RuTheorem>] = ref [];
		failed_count = ref 0;
		failed_th_names = ref [];
		max_time = ref 0.0;
		max_th_name = ref "";
		apply_th = \th, time_limit -> fn(th, time_limit, evalActionExp);
		generalize_ass = \ass : RuAssertion, time_limit -> 
			switch (ass) {
				RuTheorem(__,__,__,__,__,__,__,__): apply_th(ass, time_limit);
				default: true;
			}
		generalize_decl = \decl : RuBlock, time_limit ->
			switch (decl) {
				RuTheorem(__,__,__,__,__,__,__,__): apply_th(decl, time_limit);
				default: true;
			}
		generalize_decls = \decls, time_limit -> {
			proof_lens = map(decls, \d -> {
				switch (d) {
					RuTheorem(__,__,__,__,__,__,proof,__): length(proof.steps);
					default: 0;
				}
			});
			sum_proof_lens = i2d(fold(proof_lens, 0, \acc, len -> acc + len));
			all(ruConcurrent(mapi(decls, \i, d -> {
				limit = time_limit * i2d(availableProcessors()) * i2d(proof_lens[i]) / sum_proof_lens;
				\-> generalize_decl(d, limit)
			})));
		}
		start = timestamp();
		calc_total_steps = \decls -> fold(decls, 0, \acc, d ->
			switch (d) {
				RuTheorem(__,__,__,__,__,__,proof,__): acc + length(proof.steps);
				default: acc;
			}
		);
		calc_time_limit = \decls -> {
			opt = lookupTreeDef(conf.opts, "time-limit", "600");
			limit = if (opt == "auto") {
				i2d(calc_total_steps(decls)) * 3.0;
			} else {
				i2d(s2i(opt) * 1000);
			}
			if (conf.verbose > 0) {
				conf.onMessage("time limit: " + d2s(limit / 1000.0) + ".s");
			}
			limit
		}
		ret = if (target == "all" || target == "1") {
			decls = filtermap(concatA(map(ruOrderSources(math), \src -> src.decls)), ruBlock2Assertion);
			ms_time_limit = calc_time_limit(decls);
			chunks = splitByNumber(decls, s2i(lookupTreeDef(conf.opts, "decls-split-num", "256")));
			//time_limit = ms_time_limit * i2d(availableProcessors());
			//conf.onMessage("generalize concurrent time limit: " + d2s(time_limit / 1000.0) + ".s");
			proof_lens = map(chunks, \chunk ->
				map(chunk, \d ->
					switch (d) {
						RuTheorem(__,__,__,__,__,__,proof,__): length(proof.steps);
						default: 0;
					}
				)
			);
			sum_proof_lens = map(proof_lens, \lens -> i2d(fold(lens, 0, \ac, len -> ac + len)));
			total_steps = fold(sum_proof_lens, 0.0, \acc, len -> acc + len);
			r = foldi(chunks, true, \n, acc, chunk -> {
				left_time = ms_time_limit - (timestamp() - start);
				if (left_time <= 0.0) false else {
					time_left_on_chunk = left_time * i2d(availableProcessors()) * sum_proof_lens[n] / total_steps * 2.0;
					acc && all(ruConcurrent(mapi(chunk, \i, ass -> 
							\-> eitherMap(ruAssertion2Theorem(ass), 
								\th -> {
									limit = time_left_on_chunk * i2d(proof_lens[n][i]) / sum_proof_lens[n];
									apply_th(th, limit);
								}, 
								true
							)
					)));
				}
			});
			conf.onMessage("average time per step: " + d2s((timestamp() - start) / total_steps));
			r;
		} else if (target == "1-seq" || target == "all-seq") {
			decls = concatA(map(ruOrderSources(math), \src -> src.decls));
			ms_time_limit = calc_time_limit(decls);
			all(mapi(decls, \i, d -> {
				passed = (timestamp() - start);
				left_time = ms_time_limit - passed;
				if (left_time <= 0.0) false else { 
					limit_on_one = left_time / i2d(length(decls) - i);
					//conf.onMessage("limit_on_one: " + d2s(limit_on_one / 1000.0) + ".s");
					generalize_decl(d, limit_on_one);
				}
			}));
		} else {
			switch (lookupTree(math.sources, target)) {
				Some(src): {
					ms_time_limit = calc_time_limit(src.decls);
					generalize_decls(src.decls, ms_time_limit);
				}
				None(): {
					switch (lookupTree(math.assertions, target)) {
						Some(ass): {
							ms_time_limit = calc_time_limit([ass.item]);
							generalize_ass(ass.item, ms_time_limit);
						}
						None(): {
							conf.onMessage("no target for generalizing");
							false
						}
					}
				}
			}
		}
		if (conf.verbose > 0 && ^failed_count == 0) {
			conf.onMessage("ru generalized in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
			conf.onMessage("Max time: " + d2st(^max_time, 2) + "s for a theorem: " + ^max_th_name);
			iter(^gen_array, \p -> {
				conf.onMessage("Generalization IS MORE GENERAL:");
				conf.onMessage(ru2s(p.second, math.rules));
				conf.onMessage("ORIGINAL:");
				conf.onMessage(ru2s(p.first, math.rules));
			});
		}
		if (^failed_count > 0) {
			conf.onMessage("Generalized: " + i2s(^generalized_count) + " theorems,");
			conf.onMessage("Failed to generalize: " + i2s(^failed_count) + " theorems:");
			iter(^failed_th_names, \th -> conf.onMessage("\t" + th));
		}
		RuEnv(env with ruMath = math);
	}
}
*/