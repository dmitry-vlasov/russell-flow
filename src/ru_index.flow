import ru_exp;

export {

	RuIndex(
		rules : Tree<string, RuIndexNode<?>>,
		vars  : Tree<string, RuIndexNode<?>>,
	);

	ruMakeIndex() -> RuIndex<?>;

	ruSetIndex(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?>;

	ruIndexSize(ind : RuIndex<?>) -> int;

	RuUnified(
		sub1 : Tree<RuVar, RuExp>,
		sub2 : Tree<RuVar, RuExp>,
		data : Maybe<?>
	);
	ruUnifyIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [RuUnified<?>];
}

RuIndexNode(
	name  : string, // var or rule name
	type  : string, 
	arity : int,    // -1 means that it is a variable, not rule

	ends  : [RuIndexNode<?>], // ends of subterms, starting at this node
	lens  : [int],            // distances to the beginnings of subterms, starting at this node

	data  : Maybe<?>,

	index : RuIndex<?>, // children nodes
	mutable parent : Maybe<RuIndexNode<?>>,
);

ruMakeIndex() -> RuIndex<?> {
	ruIndexEmpty
}

ruIndexEmpty = RuIndex(makeTree(), makeTree());

ruIndexSize(ind : RuIndex<?>) -> int {
	s1 = foldTree(ind.rules, 0, \__, n, acc -> acc + ruIndexSize(n.index));
	s2 = foldTree(ind.vars, 0, \__, n, acc -> acc + ruIndexSize(n.index));
	s1 + s2 + 1;
}

ruSetIndex(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?> {
	ruDoAdd2Index(0, None(), index, RuIndexStacks(None(), None()), RuIndexAddEnv(key.nodes, data, conflict)).ind
}

RuIndexAddEnv(
	key : [RuExpNode], 
	data : Maybe<?>,
	conflict : (?, ?) -> ?,
);

RuIndexEndStack(
	parent : Maybe<RuIndexEndStack>,
	i   : int,
	len : int
);

RuIndexBegStack(
	parent : Maybe<RuIndexBegStack<?>>,
	i    : int,
	len : int,
	node : RuIndexNode<?>
);

RuIndexStacks(
	ends : Maybe<RuIndexEndStack>,
	begs : Maybe<RuIndexBegStack<?>>
);

RuIndexAddRet(
	ind  : RuIndex<?>,
	node : RuIndexNode<?>,
	begs : Maybe<RuIndexBegStack<?>>,
);

ruProcIndexEnd(i : int, n : RuIndexNode<?>, stacks : RuIndexStacks) -> RuIndexStacks {
	switch (stacks.ends) {
		Some(end):
			if (end.i + end.len != i) stacks else {
				ruProcIndexEnd(i, n,
					RuIndexStacks(
						end.parent, 
						Some(RuIndexBegStack(stacks.begs, end.i, end.len, n))
					)
				)
			}
		None(): stacks;
	}
}

ruProcIndexBeg(i : int, n : RuIndexNode<?>, ret : RuIndexAddRet) -> RuIndexAddRet {
	switch (ret.begs) {
		Some(beg):
			if (beg.i != i) ret else {
				ruProcIndexBeg(i, n,
					RuIndexAddRet(ret with
						node = RuIndexNode(ret.node with 
							ends = concat(ret.node.ends, [n])
						),
						begs = beg.parent
					)
				)
			}
		None(): ret;
	}
}

ruDoAdd2Index(i : int, parent : Maybe<RuIndexNode<?>>, index : RuIndex<?>, stacks : RuIndexStacks<?>, env : RuIndexAddEnv<?>) -> RuIndexAddRet {
	insert_data = \md1, md2 ->
		eitherMap(md1, \d1 -> eitherMap(md2, \d2 -> Some(env.conflict(d1, d2)), md1), md2);
	update_node = \n, s -> 
		if (i + 1 == length(env.key)) {
			RuIndexAddRet(index, RuIndexNode(n with data = insert_data(n.data, env.data)), stacks.begs);
		} else {
			ruProcIndexBeg(i, n, ruDoAdd2Index(i + 1, Some(n), n.index, ruProcIndexEnd(i, n, s), env));
		}
	make_ret = \ind, r -> {
		traverseInOrder(ind.rules, \__, n -> n.parent ::= Some(r.node));
		traverseInOrder(ind.vars, \__, n -> n.parent ::= Some(r.node));
		RuIndexAddRet(r with ind = ind);
	}
	switch (env.key[i]) {
		RuRuleRef(name, type, arity, len): {
			n = lookupTreeDef(index.rules, name, RuIndexNode(name, type, arity, [], [], None(), ruIndexEmpty, parent));
			r = update_node(n, RuIndexStacks(stacks with ends = Some(RuIndexEndStack(stacks.ends, i, len))));
			make_ret(RuIndex(index with rules = setTree(index.rules, name, r.node)), r);
		}
		RuVar(name, type): {
			n = lookupTreeDef(index.vars, name, RuIndexNode(name, type, -1, [], [], None(), ruIndexEmpty, parent));
			r = update_node(n, stacks);
			make_ret(RuIndex(index with vars = setTree(index.vars, name, r.node)), r);
		}
	}
}


ruUnifyIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [RuUnified<?>] {
	[] //ruDoUnifyIndex(0, index, math, RuUnifyEnv(e.nodes, makeTree(), makeTree()))
}

RuUnifyEnv(
	nodes : [RuExpNode],
	sub1 : Tree<RuVar, RuExp>,
	sub2 : Tree<RuVar, RuExp>,
);
/*
ruIndexBranch(beg : RuIndex<?>, end : RuIndex<?>, acc : [RuIndex<?>]) -> [RuIndex<?>] {
	if (beg == end) concat([beg], acc) else {
		ruIndexBranch(beg, either(end.parent, beg), concat([end], acc));
	}
}
*/
/*
ruIndexSubexpr(beg : RuIndex<?>, end : RuIndex<?>) -> RuExp {
	branch = ruIndexBranch(beg, end, []);
	lens = foldi(branch, makeTree(), \acc, ind -> 
		if (ind.len == -1) acc else setTree(acc, i - ind.len, ind.len)
	);
	RuExp(
		foldi(branch, [], \acc, ind ->
			
		), -1
	)
}
*/
//ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule>;

/*
ruDoUnifyIndex(i : int, index : RuIndex<?>, math : RuMath, env : RuUnifyEnv) -> [RuUnified<?>] {
	if (i == length(env.nodes)) [RuUnified(env.sub1, env.sub2, index.data)] else {
		switch (env.nodes[i]) {
			RuRuleRef(name, type, arity, len): {
				r1 = switch (lookupTree(index.rules, name)) {
					Some(ind): ruDoUnifyIndex(i + 1, ind, math, env);
					None(): [];
				}
				r2 = foldTree(index.vars, [], \v, n, acc ->
					if (type == n.type) {
						ex = RuExp(subrange(env.nodes, i, i + len + 1), -1);
						switch (ruAdd2Subst(env.sub1, RuVar(v, n.type), ex)) {
							Some(s1): 
								concat(acc, ruDoUnifyIndex(i + len + 1, n.index, math, RuUnifyEnv(env with sub1 = s1)));
							None(): acc;
						}
					} else {
						switch (ruSuperRule(type, n.type, math)) {
							Some(sr): {
								ex = RuExp(concat([RuRuleRef(sr.name, n.type, 1, 1)], subrange(env.nodes, i, i + len + 1)), -1);
								switch (ruAdd2Subst(env.sub1, RuVar(v, n.type), ex)) {
									Some(s1): 
										concat(acc, ruDoUnifyIndex(i + len + 1, n.index, math, RuUnifyEnv(env with sub1 = s1)));
									None(): acc;
								}
							}
							None(): acc;
						}
					}
				);
				concat(r1, r2);
			}
			RuVar(name, type): {
				r1 = fold(index.ends, [], \acc, end -> acc
					/*if (type == n.type) {
						fold()
						ex = RuExp([RuVar(name, type)], -1);
						switch (ruAdd2Subst(env.sub1, RuVar(v, n.type), ex)) {
							Some(s1): 
								concat(acc, ruDoUnifyIndex(i + 1, n.index, math, RuUnifyEnv(env with sub1 = s1)));
							None(): acc;
						}
					} else {
						switch (ruSuperRule(type, n.type, math)) {
							Some(sr): {
								ex = RuExp(reverseA(concat([RuRuleRef(sr.name, n.type, 1, 1)], [RuVar(name, type)])), -1);
								switch (ruAdd2Subst(env.sub1, RuVar(v, n.type), ex)) {
									Some(s1): 
										concat(acc, ruDoUnifyIndex(i + 1, n.index, math, RuUnifyEnv(env with sub1 = s1)));
									None(): acc;
								}
							}
							None(): acc;
						}
					}* /
				);
				r2 = foldTree(index.vars, [], \v, n, acc ->
					if (type == n.type) {
						ex = RuExp([RuVar(name, type)], -1);
						switch (ruAdd2Subst(env.sub1, RuVar(v, n.type), ex)) {
							Some(s1): 
								concat(acc, ruDoUnifyIndex(i + 1, n.index, math, RuUnifyEnv(env with sub1 = s1)));
							None(): acc;
						}
					} else {
						switch (ruSuperRule(type, n.type, math)) {
							Some(sr): {
								ex = RuExp(concat([RuRuleRef(sr.name, n.type, 1, 1)], [RuVar(name, type)]), -1);
								switch (ruAdd2Subst(env.sub1, RuVar(v, n.type), ex)) {
									Some(s1): 
										concat(acc, ruDoUnifyIndex(i + 1, n.index, math, RuUnifyEnv(env with sub1 = s1)));
									None(): acc;
								}
							}
							None(): acc;
						}
					}
				);
				concat(r1, r2);
			}
		}
	}
}
*/
