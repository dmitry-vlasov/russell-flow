import ru_exp;

export {

	RuIndex(
		rules : Tree<string, RuIndexNode<?>>,
		vars  : Tree<string, RuIndexNode<?>>,
		nodes : ref [RuIndexNode<?>]
	);

	ruMakeIndex() -> RuIndex<?>;

	ruSetIndex(key : RuExp, data : ?, index : RuIndex<?>) -> RuIndex<?>;

	ruIndexSize(ind : RuIndex<?>) -> int;

	RuUnified(
		sub : Tree<RuVar, RuExp>,
		data : ?,
		expr : RuExp
	);
	ruUnifyIndex(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath) -> [RuUnified<?>];
	ruUnifyIndexes(inds : [RuIndex<?>], sub : Tree<RuVar, RuExp>, math : RuMath) -> [RuUnified<[Set<?>]>];

	debugUnifyIndexes = ref false;

	ruFindIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [?];
	ruIndex2s(index : RuIndex<?>, show_data : (?) -> string, math : RuMath) -> string;
	ruIndexRaw2s(index : RuIndex<?>) -> string;
}

RuIndexNode(
	id    : int,
	name  : string, // var or rule name
	type  : string, 
	arity : int,    // -1 means that it is a variable, not rule

	ends  : Set<int>, // ends of subterms, starting at this node
	lens  : Set<int>, // distances to the beginnings of subterms, with end at this node

	data  : [?],
	expr  : Maybe<RuExp>,

	index : RuIndex<?>, // children nodes
	parent : int,
);

ruNoIndexNode = RuIndexNode(-1, "", "", -1, makeSet(), makeSet(), [], None(), ruMakeIndex(), -1);

ruIndexNode2s(n : RuIndexNode<?>) -> string {
	"id: " + i2s(n.id) + ", " + n.name + ":" + n.type + ", a=" + i2s(n.arity) + ", " +
	"lens=[" + strGlue(map(set2array(n.lens), i2s), ", ") + "], " + 
	"ends=[" + strGlue(map(set2array(n.ends), i2s), ", ") + "], " + 
	"data=" + i2s(length(n.data)) + ", " +
	(switch (n.expr){ Some(e): "expr=" + ruExpRPN2s(e.nodes) + ", "; None(): ""}) + 
	"parent=" + i2s(n.parent) + ", ends=[" + strGlue(map(set2array(n.ends), i2s), ", ") + "]"
}

ruMakeIndex() -> RuIndex<?> {
	RuIndex(makeTree(), makeTree(), ref []);
}

ruIndexSize(ind : RuIndex<?>) -> int {
	s1 = foldTree(ind.rules, 0, \__, n, acc -> acc + ruIndexSize(n.index));
	s2 = foldTree(ind.vars, 0, \__, n, acc -> acc + ruIndexSize(n.index));
	s1 + s2 + 1;
}

ruSetIndex(key : RuExp, data : ?, index : RuIndex<?>) -> RuIndex<?> {
	insert_int = \t, i, v -> {
		w = lookupTreeDef(t, i, makeSet());
		setTree(t, i, insertSet(w, v));
	}
	env0 = RuIndexAddEnv(key, data, makeTree(), makeTree(), ref makeTree());
	env = foldi(key.nodes, env0, \i, acc, n ->
		switch (n) {
			RuRuleRef(__,__,__, len): 
				RuIndexAddEnv(acc with 
					lens = insert_int(acc.lens, i + len, len),
					ends = insert_int(acc.ends, i, i + len),
				);
			RuVar(__,__): acc;
		}
	);
	ruDoAdd2Index(0, index, -1, env);
}

RuIndexAddEnv(
	key : RuExp, 
	data : ?,
	lens : Tree<int, Set<int>>,
	ends : Tree<int, Set<int>>,
	branch : ref Tree<int, int>
);

ruDoAdd2Index(i : int, index : RuIndex<?>, parent : int, env : RuIndexAddEnv<?>) -> RuIndex<?> {
	new_node = \n, t, a -> {
		m = RuIndexNode(length(^(index.nodes)), n, t, a, makeSet(), makeSet(), [], None(), 
			RuIndex(makeTree(), makeTree(), index.nodes), parent
		);
		refArrayPush(index.nodes, m);
		m
	}
	switch (env.key.nodes[i]) {
		RuRuleRef(name, type, arity, len): {
			n = switch(lookupTree(index.rules, name)) {
				Some(x): x;
				None(): new_node(name, type, arity);
			}
			m = ruDoAdd2IndexNode(i, n, env);
			RuIndex(index with rules = setTree(index.rules, name, m));
		}
		RuVar(name, type): {
			n = switch(lookupTree(index.vars, name)) {
				Some(x): x;
				None(): new_node(name, type, -1);
			}
			m = ruDoAdd2IndexNode(i, n, env);
			RuIndex(index with vars = setTree(index.vars, name, m));
		}
	}
}

ruDoAdd2IndexNode(i : int, n : RuIndexNode<?>, env : RuIndexAddEnv<?>) -> RuIndexNode<?> {
	n1 = if (i + 1 == length(env.key.nodes)) {
		RuIndexNode(n with data = concat(n.data, [env.data]), expr = Some(env.key));
	} else {
		RuIndexNode(n with index = ruDoAdd2Index(i + 1, n.index, n.id, env));
	}
	n2 = RuIndexNode(n1 with 
		lens = mergeSets(n1.lens, lookupTreeDef(env.lens, i, makeSet())),
	);
	n3 = RuIndexNode(n2 with ends = 
		eitherMap(lookupTree(env.ends, i), \ends -> 
			mergeSets(n2.ends, mapSet(ends, \end -> 
				lookupTreeDef(^(env.branch), end, if (i == end) n.id else -1)
			)), 
		n2.ends)
	);
	env.branch := setTree(^(env.branch), i, n3.id);
	nodes = n.index.nodes;
	n.index.nodes := ruReplaceArray(^nodes, n.id, n3);
	n3
}

ruUnifyIndex(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath) -> [RuUnified<?>] {
	ruDoUnifyIndex(0, index, math, RuUnifyEnv(e, sub))
}

RuUnifyEnv(
	expr : RuExp,
	sub : Tree<RuVar, RuExp>
);

ruIndexBranch(beg : RuIndexNode<?>, end : int) -> [RuIndexNode<?>] {
	if (beg.id == end) [beg] else {
		n = ^(beg.index.nodes)[end];
		concat(ruIndexBranch(beg, n.parent), [n]);
	}
}

ruIndexSubexpr(beg : RuIndexNode<?>, end : RuIndexNode<?>) -> RuExp {
	branch = ruIndexBranch(beg, end.id);
	lens = foldi(branch, makeTree(), \i, acc, n -> 
		foldSet(n.lens, acc, \ac, len -> setTree(ac, i - len, len))
	);
	RuExp(
		foldi(branch, [], \i, acc, n ->
			if (n.arity == -1) {
				concat(acc, [RuVar(n.name, n.type)]);
			} else {
				switch (lookupTree(lens, i)) {
					Some(len): concat(acc, [RuRuleRef(n.name, n.type, n.arity, len)]);
					None(): {
						println("ruIndexSubexpr: must not happen");
						quit(-1);
						acc
					}
				}
			}
		)
		, -1
	);
}

ruDoUnifyIndex(i : int, index : RuIndex<?>, math : RuMath, env : RuUnifyEnv) -> [RuUnified<?>] {
	unify_step = \j, var, end, ex -> {
		switch (lookupTree(env.sub, var)) {
			Some(ex1): {
				switch (ruUnifyExps([ex1, ex], env.sub, math)) {
					Some(s): ruDoUnifyIndexNode(j, end, math, RuUnifyEnv(env with sub = s));
					None(): [];
				}
			}
			None():
				switch (ruAdd2Subst(env.sub, var, ex)) {
					Some(s): ruDoUnifyIndexNode(j, end, math, RuUnifyEnv(env with sub = s));
					None(): [];
				}
		}
	}
	unify_var = \j, var, ex_type, end, e ->
		if (ex_type == var.type) unify_step(j, var, end, e())
		else {
			switch (ruSuperRule(var.type, ex_type, math)) {
				Some(sr): {
					ex = RuExp(concat([RuRuleRef(sr.name, var.type, 1, 1)], e().nodes), -1);
					unify_step(j, var, end, ex);
				}
				None(): []
			}
		}
	if (i == length(env.expr.nodes)) [] else {
		switch (env.expr.nodes[i]) {
			RuRuleRef(name, type, arity, len): {
				r1 = switch (lookupTree(index.rules, name)) {
					Some(n): ruDoUnifyIndexNode(i, n, math, env);
					None(): [];
				}
				r2 = foldTree(index.vars, [], \v, n, acc -> 
					concat(acc, unify_var(i + len, RuVar(n.name, n.type), type, n, 
						\-> RuExp(subrange(env.expr.nodes, i, len + 1), -1)
					))
				);
				concat(r1, r2);
			}
			RuVar(name, type): {
				r1 = foldTree(index.rules, [], \nm, n, acc -> {
					foldSet(n.ends, acc, \ac, e -> {
						end = ^(index.nodes)[e];
						concat(ac, unify_var(i, RuVar(name, type), n.type, end, 
							\-> ruIndexSubexpr(n, end)
						))
					})
				});
				r2 = foldTree(index.vars, [], \v, n, acc -> 
					concat(acc, unify_var(i, RuVar(n.name, n.type), type, n, 
						\-> RuExp([RuVar(name, type)], -1)
					))
				);
				concat(r1, r2);
			}
		}
	}
}

ruDoUnifyIndexNode(i : int, node : RuIndexNode<?>, math : RuMath, env : RuUnifyEnv) -> [RuUnified<?>] {
	concat(
		if (i + 1 != length(env.expr.nodes)) [] else {
			fold(node.data, [], \acc, d -> concat(acc, [RuUnified(env.sub, d, ruApplySubst(env.expr, env.sub))]));
		},
		ruDoUnifyIndex(i + 1, node.index, math, env)
	)
}

ruIndex2s(index : RuIndex<?>, show_data : (?) -> string, math : RuMath) -> string {
	ruDoIndex2s(index, show_data, None(), "", math)
}

ruDoIndex2s(index : RuIndex<?>, show_data : (?) -> string, beg : Maybe<RuIndexNode<?>>, acc : string, math : RuMath) -> string {
	begin = \n -> switch (beg) {
		Some(b): b;
		None(): n;
	}
	acc1 = foldTree(index.rules, acc, \__, n, ac ->
		ruDoIndexNode2s(n, show_data, begin(n), ac, math, index.nodes)
	);
	foldTree(index.vars, acc1, \__, n, ac ->
		ruDoIndexNode2s(n, show_data, begin(n), ac, math, index.nodes)
	);
}

ruDoIndexNode2s(node : RuIndexNode<?>, show_data : (?) -> string, beg : RuIndexNode<?>, acc : string, math : RuMath, nodes : ref [RuIndexNode<?>]) -> string {
	acc1 = if (node.data == []) acc else {
		acc + 
		ru2s(ruIndexSubexpr(beg, node), math.rules) + " --> {" + 
		strGlue(map(node.data, show_data), ", ") + "}\n";
	}
	ruDoIndex2s(node.index, show_data, Some(beg), acc1, math);
}

ruIndexRaw2s(index : RuIndex<?>) -> string {
	ruDoIndexRaw2s(index, [], "")
}

ruDoIndexRaw2s(index : RuIndex<?>, nodes : [RuIndexNode<?>], acc : string) -> string {
	acc1 = foldTree(index.rules, acc, \__, n, ac ->
		ruDoIndexNodeRaw2s(n, concat(nodes, [n]), ac)
	);
	foldTree(index.vars, acc1, \__, n, ac ->
		ruDoIndexNodeRaw2s(n, concat(nodes, [n]), ac)
	);
}

ruDoIndexNodeRaw2s(node : RuIndexNode<?>, nodes : [RuIndexNode<?>], acc : string) -> string {
	acc1 = if (node.data == []) acc else {
		acc + strGlue(
			map(nodes, \n -> 
				i2s(n.id) + "=" + n.name + ":" + n.type + 
				",lens=[" + strGlue(map(set2array(n.lens), i2s), ", ") + "]" + 
				",ends=[" + strGlue(map(set2array(n.ends), i2s), ", ") + "]" + 
				(if (length(n.data) > 0) "*" else "")
			), 
		" ") + " --> " + i2s(length(node.data)) + "\n";
	};
	ruDoIndexRaw2s(node.index, nodes, acc1);
}

ruFindIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [?] {
	ruDoFindIndex(0, e, index, math)
}

ruDoFindIndex(i : int, e : RuExp, index : RuIndex<?>, math : RuMath) -> [?] {
	switch (e.nodes[i]) {
		RuRuleRef(name, type, arity, len):
			switch(lookupTree(index.rules, name)) {
				Some(n): 
					if (i + 1 == length(e.nodes)) n.data 
					else ruDoFindIndex(i + 1, e, n.index, math);
				None(): [];
			}
		RuVar(name, type): {
			switch(lookupTree(index.vars, name)) {
				Some(n):
					if (i + 1 == length(e.nodes)) n.data 
					else ruDoFindIndex(i + 1, e, n.index, math);
				None(): [];
			}
		}
	}
}

RuSubIndex(
	start : RuIndexNode<?>, 
	ind   : RuIndex<?>,
	ends  : Set<int>
);

RuUnifyIndexesAcc(
	sub  : Tree<RuVar, RuExp>,
	inds : [RuSubIndex<?>],
	math : RuMath
);

RuUnifyIndexesStepAcc(
	is_var: [bool],
	vars  : [RuVar],
	exprs : [RuExp],
	inds  : [RuSubIndex<?>],
	rule  : string,
	type  : string,
	ok    : bool
);

ruUnifyIndexesStepAcc2s(step : RuUnifyIndexesStepAcc<?>, math : RuMath) -> string {
	"rule: " + step.rule + ", type: " + step.type + ", ok: " + b2s(step.ok) + "\n"
	"is_var: " + strGlue(map(step.is_var, b2s), ", ")  + "\n" +
	"vars: " + strGlue(map(step.vars, \v -> ru2s(v, math.rules)), ", ")  + "\n" +
	"exprs:\n" + ruIndent(strGlue(map(step.exprs, \e -> ru2s(e, math.rules)), "\n"))  + "\n"
}

ruUnifyIndexesStepVar(step : RuUnifyIndexesStepAcc<?>, math : RuMath) -> Maybe<RuVar> {
	maybeBind(
		fold(tail(step.vars), Some(step.vars[0]), \acc, v ->
			maybeBind(acc, \t -> 
				if (v.type == t.type || isSome(ruSuperRule(v.type, t.type, math))) Some(v) else
				if (v.type == t.type || isSome(ruSuperRule(t.type, v.type, math))) Some(t) else None()
			)
		),
		\v -> if (step.type == "" || v.type == step.type || isSome(ruSuperRule(v.type, step.type, math))) Some(v) else None()
	)
}

ruDoUnifyIndexesStep(ns : [RuIndexNode<?>], acc : RuUnifyIndexesAcc<?>) -> RuUnifyIndexesStepAcc<?> {
	foldi(
		ns,
		RuUnifyIndexesStepAcc([], [], [], [], "", "", true), 
		\i, ac, n ->
			if (n.arity == -1) {
				switch (lookupTree(acc.sub, RuVar(n.name, n.type))) {
					None():
						RuUnifyIndexesStepAcc(ac with
							is_var = concat(ac.is_var, [true]),
							vars = concat(ac.vars, [RuVar(n.name, n.type)])
						);
					Some(ex): {
						m = ex.nodes[0];
						switch (m) {
							RuRuleRef(rule, type, __,len):
								RuUnifyIndexesStepAcc(ac with
									is_var = concat(ac.is_var, [true]),
									exprs = concat(ac.exprs, [ex]),
									rule = rule,
									type = type,
									ok = ac.ok && (ac.rule == "" || rule == ac.rule)
								);
							RuVar(v, t):
								RuUnifyIndexesStepAcc(ac with 
									is_var = concat(ac.is_var, [true]),
									vars = concat(ac.vars, [m])
								);
						}
					}
				}
			} else {
				RuUnifyIndexesStepAcc(ac with
					is_var = concat(ac.is_var, [false]),
					inds = concat(ac.inds, [RuSubIndex(n, n.index, n.ends)]),
					rule = n.name, 
					type = n.type, 
					ok = ac.ok && (ac.rule == "" || n.name == ac.rule)
				);
			}
	);
}

RuUnifiyIndexesRet(
	vect : [int],
	sub  : Tree<RuVar, RuExp>,
	expr : RuExp
);

ruDoUnifyIndexNodes(nodes : [RuIndexNode<?>], acc : RuUnifyIndexesAcc) -> [RuUnifiyIndexesRet] {
	step = ruDoUnifyIndexesStep(nodes, acc);
	if (^debugUnifyIndexes) {
		println("step:\n" + ruUnifyIndexesStepAcc2s(step, acc.math));
	}
	is_end = \ -> {
		vect = map(nodes, \n -> n.id);
		ends = mapi(acc.inds, \i, ind -> containsSet(ind.ends, vect[i]) || step.is_var[i]);
		all(ends);
	}
	unify_next = \s, new_inds -> {
		vect = map(nodes, \n -> n.id);
		if (^debugUnifyIndexes) {
			println("unify_next, vect: <" + strGlue(map(vect, i2s), ",") + ">");
			println("unify_next, nodes: {" + strGlue(mapi(vect, \i, n -> ^(acc.inds[i].ind.nodes)[n].name), ",") + "}");
			println("unify_next, ends: {" + strGlue(mapi(vect, \i, __ -> "[" + strGlue(map(set2array(acc.inds[i].ends), i2s), ",") + "]"), ",") + "}");
		}
		ends = mapi(acc.inds, \i, ind -> containsSet(ind.ends, vect[i]) || step.is_var[i]);
		if (^debugUnifyIndexes) {
			println("ends: [" + strGlue(map(ends, b2s), ",") + "]");
		}
		if (!is_end()) {
			if (^debugUnifyIndexes) {
				println("YYY");
			};
			ruDoUnifyIndexes(
				RuUnifyIndexesAcc(acc with sub = s, inds = new_inds)
			);
		} else {
			if (^debugUnifyIndexes) {
				println("XXX");
			};
			[RuUnifiyIndexesRet(vect, s, ruApplySubst(ruIndexSubexpr(acc.inds[0].start, nodes[0]) , s))];
		}
	}
	next_inds = \vect -> {
		foldi(nodes, Pair([], 0), \i, ac, n -> 
			if (step.is_var[i]) {
				Pair(
					concat(ac.first, [RuSubIndex(acc.inds[i].start, n.index, acc.inds[i].ends)]), 
					ac.second
				);
			} else {
				Pair(
					concat(ac.first, 
						[RuSubIndex(acc.inds[i].start, ^(acc.inds[i].ind.nodes)[vect[ac.second]].index, acc.inds[i].ends)]
					), 
					ac.second + 1
				);
			}
		).first;
	}
	if (!step.ok) [] else {
		if (step.rule != "") {
			if (any(step.is_var)) {
				vect = map(nodes, \n -> n.id);
				if (!is_end()) {
					concatA(filtermap(ruDoUnifyIndexes(RuUnifyIndexesAcc(acc.sub, step.inds, acc.math)), \ret -> {
						ex0 = ruApplySubst(ruIndexSubexpr(acc.inds[0].start, ^(acc.inds[0].ind.nodes)[ret.vect[0]]), ret.sub);
						maybeBind(ruUnifyExps(concat(step.exprs, [ex0]), ret.sub, acc.math), \s -> {
							ex = ruApplySubst(step.exprs[0], s);
							maybeBind(
								fold(step.vars, Some(s), \ac, var -> 
									maybeBind(ac, \s1 -> ruAdd2Subst1(s1, var, ex, acc.math))
								),
								\s1 -> Some(unify_next(s1, next_inds(ret.vect)))
							);
						});
					}));
				} else {
					c = RuRuleRef(step.rule, step.type, 0, 0);
					if (^debugUnifyIndexes) {
						println("AAA: " + step.rule);
					}
					eitherMap(
						fold(step.vars, Some(acc.sub), \ac, var -> 
							maybeBind(ac, \s1 -> ruAdd2Subst1(s1, var, RuExp([c], -1), acc.math))
						),
						\s1 -> unify_next(s1, mapi(nodes, \i, n -> RuSubIndex(acc.inds[i].start, n.index, acc.inds[i].ends))),
						[]
					);
				}
			} else {
				unify_next(acc.sub, mapi(nodes, \i, n -> RuSubIndex(acc.inds[i].start, n.index, acc.inds[i].ends)));
			}
		} else {
			eitherMap(ruUnifyIndexesStepVar(step, acc.math), \w ->
				eitherMap(
					fold(step.vars, Some(acc.sub), \ac, var -> 
						maybeBind(ac, \s1 -> ruAdd2Subst1(s1, var, RuExp([w], -1), acc.math))
					),
					\s1 -> unify_next(s1, mapi(nodes, \i, n -> RuSubIndex(acc.inds[i].start, n.index, acc.inds[i].ends))),
					[]
				), []
			);
		}
	}
}

ruDoUnifyIndexes(acc : RuUnifyIndexesAcc) -> [RuUnifiyIndexesRet] {
	prod = map(acc.inds, \subind -> concat(getTreeValues(subind.ind.rules), getTreeValues(subind.ind.vars)));
	if (^debugUnifyIndexes) {
		println("prod size: " + i2s(ruSizeCart(prod)));
	}
	ruFoldCart(prod, [], \ac, nodes -> concat(ac, ruDoUnifyIndexNodes(nodes, acc)));
}

ruUnifyIndexes(inds : [RuIndex<?>], sub : Tree<RuVar, RuExp>, math : RuMath) -> [RuUnified<[Set<?>]>] {
	prod = map(inds, \ind -> concat(getTreeValues(ind.rules), getTreeValues(ind.vars)));
	rets = ruFoldCart(prod, [], \acc, nodes -> 
		concat(acc, ruDoUnifyIndexNodes(nodes,
			RuUnifyIndexesAcc(sub, 
				mapi(nodes, \i, n -> RuSubIndex(n, inds[i], n.ends)),
				math
			)
		))
	);
	map(rets, \ret -> 
		RuUnified(ret.sub, mapi(ret.vect, \i, n -> buildSet(^(inds[i].nodes)[n].data)), ret.expr)
	);
}
