import ru_exp;

export {

	RuIndex(
		data  : Maybe<?>,
		rules : Tree<string, RuIndex<?>>,
		vars  : Tree<RuVar, RuIndex<?>>,
		ends  : [RuIndex<?>],
		mutable parent : Maybe<RuIndex<?>>,
	);

	ruMakeIndex() -> RuIndex<?>;

	ruSetIndex(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?>;

	ruIndexSize(ind : RuIndex<?>) -> int;
}

ruMakeIndex() -> RuIndex<?> {
	ruIndexEmpty
}

ruIndexEmpty = RuIndex(None(), makeTree(), makeTree(), [], None());

ruIndexSize(ind : RuIndex<?>) -> int {
	s1 = foldTree(ind.rules, 0, \__, i, acc -> acc + ruIndexSize(i));
	s2 = foldTree(ind.vars, 0, \__, i, acc -> acc + ruIndexSize(i));
	s1 + s2 + 1;
}

ruSetIndex(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?> {
	ruDoAdd2Index(0, index, RuIndexStacks(None(), None()), RuIndexAddEnv(key.nodes, data, conflict)).ind
}

RuIndexAddEnv(
	key : [RuExpNode], 
	data : Maybe<?>,
	conflict : (?, ?) -> ?,
);

RuIndexEndStack(
	parent : Maybe<RuIndexEndStack>,
	i   : int,
	beg : int
);

RuIndexBegStack(
	parent : Maybe<RuIndexBegStack<?>>,
	i    : int,
	node : RuIndex<?>
);

RuIndexStacks(
	ends : Maybe<RuIndexEndStack>,
	begs : Maybe<RuIndexBegStack<?>>
);

RuIndexAddRet(
	ind  : RuIndex<?>,
	begs : Maybe<RuIndexBegStack<?>>
);

ruProcIndexEnd(i : int, n : RuIndex<?>, stacks : RuIndexStacks) -> RuIndexStacks {
	switch (stacks.ends) {
		Some(end):
			if (end.i != i) stacks else {
				ruProcIndexEnd(i, n,
					RuIndexStacks(
						end.parent, 
						Some(RuIndexBegStack(stacks.begs, end.beg, n))
					)
				)
			}
		None(): stacks;
	}
}

ruProcIndexBeg(i : int, n : RuIndex<?>, ret : RuIndexAddRet) -> RuIndexAddRet {
	switch (ret.begs) {
		Some(beg):
			if (beg.i != i) ret else {
				ruProcIndexBeg(i, n,
					RuIndexAddRet(
						RuIndex(ret.ind with ends = concat(ret.ind.ends, [n])),
						beg.parent
					)
				)
			}
		None(): ret;
	}
}

ruDoAdd2Index(i : int, index : RuIndex<?>, stacks : RuIndexStacks<?>, env : RuIndexAddEnv<?>) -> RuIndexAddRet {
	k = env.key[i];
	insert_data = \md1, md2 ->
		eitherMap(md1, \d1 -> eitherMap(md2, \d2 -> Some(env.conflict(d1, d2)), md1), md2);
	update_node = \n, s -> 
		if (i + 1 == length(env.key)) {
			RuIndexAddRet(RuIndex(n with data = insert_data(n.data, env.data)), stacks.begs);
		} else {
			ruProcIndexBeg(i, n, ruDoAdd2Index(i + 1, n, ruProcIndexEnd(i, n, s), env));
		}
	make_ret = \ind, ret -> {
		traverseInOrder(ind.rules, \__, n -> n.parent ::= Some(ind));
		traverseInOrder(ind.vars, \__, n -> n.parent ::= Some(ind));
		RuIndexAddRet(ind, ret.begs);
	}
	switch (k) {
		RuRuleRef(rule, type, __, len): {
			n = lookupTreeDef(index.rules, rule, ruIndexEmpty);
			r = update_node(n, RuIndexStacks(stacks with ends = Some(RuIndexEndStack(stacks.ends, i + len, i))));
			make_ret(RuIndex(index with rules = setTree(index.rules, rule, r.ind)), r);
		}
		RuVar(name, type): {
			n = lookupTreeDef(index.vars, k, ruIndexEmpty);
			r = update_node(n, stacks);
			make_ret(RuIndex(index with vars = setTree(index.vars, k, r.ind)), r);
		}
	}
}
