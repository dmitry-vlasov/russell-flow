import ru_exp;

export {

	RuIndex(
		rules : Tree<string, RuIndexNode<?>>,
		vars  : Tree<string, RuIndexNode<?>>,
	);

	ruMakeIndex() -> RuIndex<?>;

	ruSetIndex(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?>;

	ruIndexSize(ind : RuIndex<?>) -> int;

	RuUnified(
		sub : Tree<RuVar, RuExp>,
		data : ?
	);
	ruUnifyIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [RuUnified<?>];
	ruIndex2s(index : RuIndex<?>, show_data : (?) -> string, math : RuMath) -> string;
	ruIndexRaw2s(index : RuIndex<?>) -> string;

	ruSetIndex1(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?>;
}

RuIndexNode(
	name  : string, // var or rule name
	type  : string, 
	arity : int,    // -1 means that it is a variable, not rule

	mutable ends : Set<RuIndexNode<?>>, // ends of subterms, starting at this node
	lens  : Set<int>, // distances to the beginnings of subterms, starting at this node

	data  : Maybe<?>,
	expr  : Maybe<RuExp>,

	index : RuIndex<?>, // children nodes
	mutable parent : Maybe<RuIndexNode<?>>,
);

ruMakeIndex() -> RuIndex<?> {
	ruIndexEmpty
}

ruIndexEmpty = RuIndex(makeTree(), makeTree());

ruIndexSize(ind : RuIndex<?>) -> int {
	s1 = foldTree(ind.rules, 0, \__, n, acc -> acc + ruIndexSize(n.index));
	s2 = foldTree(ind.vars, 0, \__, n, acc -> acc + ruIndexSize(n.index));
	s1 + s2 + 1;
}

ruSetIndex1(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?> {
	insert_int = \t, i, v -> {
		w = lookupTreeDef(t, i, makeSet());
		setTree(t, i, insertSet(w, v));
	}
	env0 = RuIndexAddEnv1(key, data, conflict, makeTree(), makeTree(), ref makeTree());
	env = foldi(key.nodes, env0, \i, acc, n ->
		switch (n) {
			RuRuleRef(__,__,__, len): 
				RuIndexAddEnv1(acc with 
					lens = insert_int(acc.lens, i + len, len),
					ends = insert_int(acc.ends, i, i + len),
				);
			RuVar(__,__): acc;
		}
	);
	ruDoAdd2Index1(0, index, env);
}

RuIndexAddEnv1(
	key : RuExp, 
	data : Maybe<?>,
	conflict : (?, ?) -> ?,
	lens : Tree<int, Set<int>>,
	ends : Tree<int, Set<int>>,
	nodes : ref Tree<int, RuIndexNode<?>>
);

ruDoAdd2Index1(i : int, index : RuIndex<?>, env : RuIndexAddEnv1<?>) -> RuIndex<?> {
	make_new_node = \n, t, a -> 
		RuIndexNode(n, t, a, makeSet(), makeSet(), None(), None(), ruIndexEmpty, None());
	switch (env.key.nodes[i]) {
		RuRuleRef(name, type, arity, len): {
			n = lookupTreeDef(index.rules, name, make_new_node(name, type, arity));
			m = ruDoAdd2IndexNode1(i, n, env);
			RuIndex(index with rules = setTree(index.rules, name, m));
		}
		RuVar(name, type): {
			n = lookupTreeDef(index.vars, name, make_new_node(name, type, -1));
			m = ruDoAdd2IndexNode1(i, n, env);
			RuIndex(index with vars = setTree(index.vars, name, m));
		}
	}
}

ruDoAdd2IndexNode1(i : int, n : RuIndexNode<?>, env : RuIndexAddEnv1<?>) -> RuIndexNode<?> {
	insert_data = \md1, md2 ->
		eitherMap(md1, \d1 -> eitherMap(md2, \d2 -> Some(env.conflict(d1, d2)), md1), md2);
	n1 = if (i + 1 == length(env.key.nodes)) {
		RuIndexNode(n with data = insert_data(n.data, env.data), expr = Some(env.key));
	} else {
		RuIndexNode(n with index = ruDoAdd2Index1(i + 1, n.index, env));
	}
	n2 = RuIndexNode(n1 with lens = mergeSets(n1.lens, lookupTreeDef(env.lens, i, makeSet())));
	switch (lookupTree(env.ends, i)) {
		Some(ends): iterSet(ends, \j ->
			if (i == j) n2.ends ::= insertSet(n2.ends, n2) else
			switch (lookupTree(^(env.nodes), j)) {
				Some(m): n2.ends ::= insertSet(n2.ends, m);
				None(): {
					println("node not found - error");
					quit(-1);
				}
			}
		);
		None(): { }
	}
	traverseInOrder(n2.index.rules, \__, m -> m.parent ::= Some(n2));
	traverseInOrder(n2.index.vars, \__, m -> m.parent ::= Some(n2));
	env.nodes := setTree(^(env.nodes), i, n2);
	n2
}


























ruSetIndex(key : RuExp, data : Maybe<?>, index : RuIndex<?>, conflict : (?, ?) -> ?) -> RuIndex<?> {
	x = ruDoAdd2Index(0, None(), index, RuIndexStacks(None(), makeTree()), RuIndexAddEnv(key, data, conflict)).ind;
	println("set complete");
	x
}

RuIndexAddEnv(
	key : RuExp, 
	data : Maybe<?>,
	conflict : (?, ?) -> ?,
);

RuIndexEndStack(
	parent : Maybe<RuIndexEndStack>,
	i   : int,
	len : int
);

RuIndexBeg(
	len  : int,
	node : RuIndexNode<?>
);

RuIndexStacks(
	ends : Maybe<RuIndexEndStack>,
	begs : Tree<int, [RuIndexBeg<?>]>
);

RuIndexAddRet(
	ind  : RuIndex<?>,
	node : RuIndexNode<?>,
	begs : Tree<int, [RuIndexBeg<?>]>,
);

ruProcIndexEnd(i : int, n : RuIndexNode<?>, stacks : RuIndexStacks) -> RuIndexStacks {
	switch (stacks.ends) {
		Some(end):
			if (end.i + end.len != i) stacks else {
				println("adding len " + i2s(end.len) + " to " + n.name + ", beg.i=" + i2s(end.i) + ", len=" + i2s(end.len) + ", i=" + i2s(i));
				beg = RuIndexBeg(end.len, RuIndexNode(n with lens = insertSet(n.lens, end.len)));
				ruProcIndexEnd(i, n,
					RuIndexStacks(
						end.parent,
						treePushToArrayValue(stacks.begs, end.i, beg)
					)
				)
			}
		None(): stacks;
	}
}

ruProcIndexBeg(i : int, n : RuIndexNode<?>, ret : RuIndexAddRet) -> RuIndexAddRet {
	r = RuIndexAddRet(ret with 
		node = RuIndexNode(n with 
			index = ret.ind, 
			lens = mergeSets(ret.node.lens, n.lens)
		)
	);
	switch (lookupTree(ret.begs, i)) {
		Some(begs): {
			fold(begs, r, \acc : RuIndexAddRet, beg : RuIndexBeg -> 
				RuIndexAddRet(acc with
					node = RuIndexNode(acc.node with 
						ends = insertSet(acc.node.ends, beg.node),
						lens = mergeSets(acc.node.lens, beg.node.lens),
						index = acc.ind
					)
				)
			)
			
			/*if (beg.i != i) r else {
				println("beg lens: " + i2s(length(beg.node.lens)));
				println("n lens: " + i2s(length(n.lens)));
				println("ret lens: " + i2s(length(ret.node.lens)));
				ruProcIndexBeg(i, n,
					RuIndexAddRet(ret with
						node = RuIndexNode(n with 
							ends = concat(ret.node.ends, [beg.node]),
							lens = concat3(ret.node.lens, n.lens, beg.node.lens),
							index = ret.ind
						),
						begs = beg.parent
					)
				)
			}*/
		}
		None(): r;
	}
}

ruDoAdd2Index(i : int, parent : Maybe<RuIndexNode<?>>, index : RuIndex<?>, stacks : RuIndexStacks<?>, env : RuIndexAddEnv<?>) -> RuIndexAddRet {
	insert_data = \md1, md2 ->
		eitherMap(md1, \d1 -> eitherMap(md2, \d2 -> Some(env.conflict(d1, d2)), md1), md2);
	update_node = \n, s -> {
		r = if (i + 1 == length(env.key.nodes)) {
			m = RuIndexNode(n with data = insert_data(n.data, env.data), expr = Some(env.key));
			r = RuIndexAddRet(m.index, m, ruProcIndexEnd(i, m, s).begs);
			x = ruProcIndexBeg(i, r.node, r);
			//if (i == 0) {
				println("i: " + i2s(i));
				println("x.name: " + x.node.name);
				println("x.lens: " + i2s(sizeSet(x.node.lens)));
			//}
			println("indexx A: " + ruIndexRaw2s(x.ind));
			x
		} else {
			x = ruProcIndexBeg(i, n, ruDoAdd2Index(i + 1, Some(n), n.index, ruProcIndexEnd(i, n, s), env));
			println("indexx B: " + ruIndexRaw2s(x.ind));
			x
		}
		traverseInOrder(r.node.index.rules, \__, m -> m.parent ::= Some(r.node));
		traverseInOrder(r.node.index.vars, \__, m -> m.parent ::= Some(r.node));
		r
	}
	z = switch (env.key.nodes[i]) {
		RuRuleRef(name, type, arity, len): {
			n = lookupTreeDef(index.rules, name, RuIndexNode(name, type, arity, makeSet(), makeSet(), None(), None(), ruIndexEmpty, parent));
			r = update_node(n, RuIndexStacks(stacks with ends = Some(RuIndexEndStack(stacks.ends, i, len))));
			RuIndexAddRet(r with ind = RuIndex(index with rules = setTree(index.rules, name, r.node)));
		}
		RuVar(name, type): {
			n = lookupTreeDef(index.vars, name, RuIndexNode(name, type, -1, makeSet(), makeSet(), None(), None(), ruIndexEmpty, parent));
			r = update_node(n, stacks);
			RuIndexAddRet(r with ind = RuIndex(index with vars = setTree(index.vars, name, r.node)));
		}
	}
	println("indexx C: " + ruIndexRaw2s(z.ind));
	z
}

ruUnifyIndex(e : RuExp, index : RuIndex<?>, math : RuMath) -> [RuUnified<?>] {
	ruDoUnifyIndex(0, index, math, RuUnifyEnv(e, makeTree()))
}

RuUnifyEnv(
	expr : RuExp,
	sub : Tree<RuVar, RuExp>
);

ruIndexBranch(beg : RuIndexNode<?>, end : RuIndexNode<?>, acc : [RuIndexNode<?>]) -> [RuIndexNode<?>] {
	if (beg == end) concat([beg], acc) else {
		ruIndexBranch(beg, either(end.parent, beg), concat([end], acc));
	}
}

ruIndexSubexpr(beg : RuIndexNode<?>, end : RuIndexNode<?>) -> RuExp {
	branch = ruIndexBranch(beg, end, []);
	lens = foldi(branch, makeTree(), \i, acc, n -> 
		foldSet(n.lens, acc, \ac, len -> setTree(acc, i - len, len))
	);
	RuExp(
		foldi(branch, [], \i, acc, n ->
			if (n.arity == -1) {
				concat(acc, [RuVar(n.name, n.type)]);
			} else {
				concat(acc, [RuRuleRef(n.name, n.type, n.arity, lookupTreeDef(lens, i, -1))]);
			}
		)
		, -1
	);
}

ruDoUnifyIndex(i : int, index : RuIndex<?>, math : RuMath, env : RuUnifyEnv) -> [RuUnified<?>] {
	unify_step = \j, var, end, ex ->
		switch (ruAdd2Subst(env.sub, var, ex)) {
			Some(s): 
				ruDoUnifyIndexNode(j, end, math, RuUnifyEnv(env with sub = s));
			None(): [];
		}
	unify_var = \j, var, ex_type, end, e ->
		if (ex_type == var.type) unify_step(j, var, end, e())
		else {
			switch (ruSuperRule(var.type, ex_type, math)) {
				Some(sr): {
					ex = RuExp(concat([RuRuleRef(sr.name, var.type, 1, 1)], e().nodes), -1);
					unify_step(j, var, end, ex);
				}
				None(): []
			}
		}
	if (i == length(env.expr.nodes)) [] else {
		switch (env.expr.nodes[i]) {
			RuRuleRef(name, type, arity, len): {
				r1 = switch (lookupTree(index.rules, name)) {
					Some(n): ruDoUnifyIndexNode(i, n, math, env);
					None(): [];
				}
				r2 = foldTree(index.vars, [], \v, n, acc -> 
					unify_var(i + len, RuVar(n.name, n.type), type, n, 
						\-> RuExp(subrange(env.expr.nodes, i, len + 1), -1)
					)
				);
				concat(r1, r2);
			}
			RuVar(name, type): {
				r1 = foldTree(index.rules, [], \nm, n, acc -> {
					println("nm: " + nm + ", ends: " + i2s(sizeSet(n.ends)));
					foldSet(n.ends, acc, \ac, end ->
						unify_var(i, RuVar(name, type), n.type, n, 
							\-> {
								ex = ruIndexSubexpr(n, end);
								println("ex: " + ru2s(ex, math.rules));
								ex
							}
						)
					)
				});
				r2 = foldTree(index.vars, [], \v, n, acc -> 
					unify_var(i, RuVar(n.name, n.type), type, n, 
						\-> RuExp([RuVar(name, type)], -1)
					)
				);
				concat(r1, r2);
			}
		}
	}
}

ruDoUnifyIndexNode(i : int, node : RuIndexNode<?>, math : RuMath, env : RuUnifyEnv) -> [RuUnified<?>] {
	r = if (i + 1 == length(env.expr.nodes)) {
		switch (node.data) {
			Some(d): {
				switch (node.expr) {
					Some(ex): {
						e1 = ruApplySubst(ex, env.sub);
						e2 = ruApplySubst(env.expr, env.sub);
						if (e1.nodes != e2.nodes) {
							println("wrong unification");
							println("ex: " + ru2s(ex, math.rules));
							println("ex(raw): " + ruExpRPN2s(ex.nodes));
							println("env.expr: " + ru2s(env.expr, math.rules));
							println("e1: " + ru2s(e1, math.rules));
							println("e2: " + ru2s(e2, math.rules));
							println("subst:\n" + ruSubst2s(env.sub, math));
							println("e1(1): " + ru2s(ruApplySubst(ex, env.sub), math.rules));
							println("e1(raw): " + ruExpRPN2s(ruApplySubst(ex, env.sub).nodes));
							quit(-1);
						}
					}
					None(): println("impossible");
				};
				[RuUnified(env.sub, d)];
			}
			None(): [];
		}
	} else [];
	concat(r, ruDoUnifyIndex(i + 1, node.index, math, env))
}

ruIndex2s(index : RuIndex<?>, show_data : (?) -> string, math : RuMath) -> string {
	ruDoIndex2s(index, show_data, None(), "", math)
}

ruDoIndex2s(index : RuIndex<?>, show_data : (?) -> string, beg : Maybe<RuIndexNode<?>>, acc : string, math : RuMath) -> string {
	begin = \n -> switch (beg) {
		Some(b): b;
		None(): n;
	}
	acc1 = foldTree(index.rules, acc, \__, n, ac ->
		ruDoIndexNode2s(n, show_data, begin(n), ac, math)
	);
	foldTree(index.vars, acc1, \__, n, ac ->
		ruDoIndexNode2s(n, show_data, begin(n), ac, math)
	);
}

ruDoIndexNode2s(node : RuIndexNode<?>, show_data : (?) -> string, beg : RuIndexNode<?>, acc : string, math : RuMath) -> string {
	acc1 = switch (node.data) {
		Some(d): acc + ru2s(ruIndexSubexpr(beg, node), math.rules) + " --> " + show_data(d) + "\n";
		None(): acc;
	}
	ruDoIndex2s(node.index, show_data, Some(beg), acc1, math);
}

ruIndexRaw2s(index : RuIndex<?>) -> string {
	ruDoIndexRaw2s(index, [], "")
}

ruDoIndexRaw2s(index : RuIndex<?>, nodes : [RuIndexNode<?>], acc : string) -> string {
	acc1 = foldTree(index.rules, acc, \__, n, ac ->
		ruDoIndexNodeRaw2s(n, concat(nodes, [n]), ac)
	);
	foldTree(index.vars, acc1, \__, n, ac ->
		ruDoIndexNodeRaw2s(n, concat(nodes, [n]), ac)
	);
}

ruDoIndexNodeRaw2s(node : RuIndexNode<?>, nodes : [RuIndexNode<?>], acc : string) -> string {
	acc1 = switch (node.data) {
		Some(d): acc + 
			strGlue(
				map(nodes, \n -> 
					n.name + ":" + n.type + "[" + strGlue(map(set2array(n.lens), i2s), ", ") + "]"
				), 
			" ") + "\n";
		None(): acc;
	}
	ruDoIndexRaw2s(node.index, nodes, acc1);
}
