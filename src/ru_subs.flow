import ru_index;

export {
	ruUnifyCartSubs(subs : [[RuUnified<?>]], math : RuMath) -> [RuUnified<[?]>];
}

RuSubsColumn(
	rows : [RuIndex<int>]
);

RuSubsMatrix(
	cols : [RuSubsColumn]
);

ruMakeSubsMatrix(subs : [[RuUnified<?>]]) -> RuSubsMatrix {
	vars = set2array(fold(subs, makeSet(), \acc, ss ->
		fold(ss, acc, \ac, s ->
			mergeSets(ac, buildSet(getTreeKeys(s.sub)))
		)
	));
	make_cell = \v, ss -> {
		foldi(ss, ruMakeIndex(), \i, ac, s ->
			switch (lookupTree(s.sub, v)) {
				Some(ex): ruSetIndex(ex, i, ac);
				None(): ruSetIndex(RuExp([v], -1), i, ac);
			}
		)
	}
	RuSubsMatrix(
		fold(vars, [], \acc, v ->
			concat(acc, 
				[RuSubsColumn(
					fold(subs, [], \ac, ss ->
						concat(ac, [make_cell(v, ss)])
					)
				)]
			)
		)
	);
}

ruIntersectCols(col1 : [RuUnified<[Set<int>]>], col2 : [RuUnified<[Set<int>]>], math : RuMath) -> [RuUnified<[Set<int>]>] {
	fold(col1, [], \acc, unif1 ->
		fold(col2, acc, \ac, unif2 ->
			eitherMap(ruUnifySubstVect([unif1.sub, unif2.sub], math), 
				\s -> {
					common = mapi(unif1.data, \i, d1 -> intersectSets(d1, unif2.data[i]));
					if (exists(common, isEmptySet)) ac else {
						concat(ac, [RuUnified(s, common)])
					}
				},
				ac
			)
		)
	);
}

ruUnifyCartSubs(subs : [[RuUnified<?>]], math : RuMath) -> [RuUnified<[?]>] {
	matrix = ruMakeSubsMatrix(subs);
	unified = map(matrix.cols, \col -> ruUnifyIndexes(col.rows, makeTree(), math));
	intersected = fold(tail(unified), unified[0], \acc, col -> ruIntersectCols(acc, col, math));
	fold(intersected, [],
		\acc, unif -> {
			prod = map(unif.data, \d -> set2array(d));
			concat(acc, ruMapCart(prod, \v -> RuUnified(unif.sub, mapi(v, \i, n -> subs[i][n].data))))
		}
	);
}

