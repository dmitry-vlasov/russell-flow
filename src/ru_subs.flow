import ru_index;
import ru_stats;

export {
	RuSubData(
		sub : Tree<RuVar, RuExp>,
		data: ?
	);
	ruUnifySubsProd(prod : [[RuSubData<?>]], math : RuMath) -> [RuSubData<[?]>];
	
	RuSubsColumn(
		var : RuVar,
		rows : [RuIndex<int>]
	);

	RuSubsMatrix(
		cols : [RuSubsColumn]
	);

	ruMakeSubsMatrix(subs : [[RuSubData<?>]]) -> RuSubsMatrix;

	ruSubsMatrix2s(matrix : RuSubsMatrix, math : RuMath) -> string;

	debugUnifySubsProd = ref false;
}

ruSubsMatrix2s(matrix : RuSubsMatrix, math : RuMath) -> string {
	n_rows = if (matrix.cols == []) 0 else length(matrix.cols[0].rows);
	ruStringMatrix2s(
		map(matrix.cols, \col -> map(col.rows, \row -> ruIndex2s(row, i2s, math))),
		Some(map(matrix.cols, \col -> ru2s(col.var, math.rules))),
		Some(map(enumFromTo(1, n_rows), \i -> "h_" + i2s(i)))
	);
}

ruMakeSubsMatrix(subs : [[RuSubData<?>]]) -> RuSubsMatrix {
	vars = set2array(fold(subs, makeSet(), \acc, ss ->
		fold(ss, acc, \ac, s ->
			mergeSets(ac, buildSet(getTreeKeys(s.sub)))
		)
	));
	make_cell = \v, ss -> {
		foldi(ss, ruMakeIndex(), \i, ac, s ->
			switch (lookupTree(s.sub, v)) {
				Some(ex): ruSetIndex(ex, i, ac);
				None(): ruSetIndex(RuExp([v], -1), i, ac);
			}
		)
	}
	RuSubsMatrix(
		fold(vars, [], \acc, v ->
			concat(acc, 
				[RuSubsColumn(v,
					fold(subs, [], \ac, ss ->
						concat(ac, [make_cell(v, ss)])
					)
				)]
			)
		)
	);
}

ruIntersectCols(col1 : [RuSubData<[Set<int>]>], col2 : [RuUnified<[Set<int>]>], math : RuMath) -> [RuSubData<[Set<int>]>] {
	fold(col1, [], \acc, unif1 ->
		fold(col2, acc, \ac, unif2 ->
			eitherMap(ruUnifySubs([unif1.sub, unif2.sub], math), 
				\s -> {
						common = mapi(unif1.data, \i, d1 -> intersectSets(d1, unif2.data[i]));
						if (exists(common, isEmptySet)) ac else {
							concat(ac, [RuSubData(s, common)])
						}
				},
				ac
			)
		)
	);
}

ruUnifySubsProd(subs : [[RuSubData<?>]], math : RuMath) -> [RuSubData<[?]>] {
	if (subs == [] || exists(subs, \s -> s == [])) [] else 
	if (length(subs) == 1) map(subs[0], \d -> RuSubData(d.sub, [d.data])) else {
		matrix = ruMakeSubsMatrix(subs);
		if (matrix.cols == []) {
			ruMapCart(subs, \vect -> RuSubData(makeTree(), map(vect, \sd -> sd.data)));
		} else {
			empty = ref false;
			unified = mapi(matrix.cols, \i, col -> {
					if (^debugUnifySubsProd) {
						println("unifying COLUMN " + i2s(i) + ":");
						debugUnifyIndexes := true;
					}
					if (!^empty) {
						size = fold(col.rows, 1, \acc, ind -> acc * ruIndexDataCount(ind));
						descr = strGlue(map(col.rows, \ind -> i2s(ruIndexDataCount(ind))), "x");
						t = timestamp();
						uns = ruUnifyIndexes(col.rows, makeTree(), math);
						time = cast(timestamp() - t : double -> int);
						stats = RuStatsRow("prod " + descr, 
							pairs2tree([Pair("size", size), Pair("time", time), Pair("rets", length(uns))])
						);
						ruAddStats("unif_index_prod", stats);
						
						unif_col = filtermap(uns, \unif -> {
							
								if (^debugUnifySubsProd) {
									println("sub:");
									println(ruIndent(ruSubst2s(unif.sub, math)));
									println("expr");
									println(ruIndent(ru2s(unif.expr, math.rules)));
									println("vect: " + strGlue(map(unif.data, \set -> "{" + strGlue(map(set2array(set), i2s), ", ") + "}"), "x"));
								}
								switch (lookupTree(unif.sub, col.var)) {
									None(): 
										maybeMap(ruAdd2Subst1(unif.sub, col.var, unif.expr, math), \s ->
											RuUnified(s, unif.data, ruApplySubst(unif.expr, s))
										);
									Some(ex):
										maybeBind(ruUnifyExps([unif.expr, ex], unif.sub, math), \un -> 
											maybeMap(ruCompose(unif.sub, un), \s ->
												RuUnified(s, unif.data, ruApplySubst(ex, s))
											)
										);
								}
							}
						);
						if (unif_col == []) {
							empty := true;
						}
						unif_col
					} else {
						[]
					}
				}
			);
			if (^empty) [] else {
				if (^debugUnifySubsProd) {
					println("filtered:");
					iteri(unified, \i, col -> {
						println("COLUMN " + i2s(i));
						iter(col, \unif -> {
							println("sub:");
							println(ruIndent(ruSubst2s(unif.sub, math)));
							println("expr");
							println(ruIndent(ru2s(unif.expr, math.rules)));
							println("vect: " + strGlue(map(unif.data, \set -> "{" + strGlue(map(set2array(set), i2s), ", ") + "}"), "x"));
						})
					});
				}
				size = fold(unified, 1, \acc, un -> acc * length(un));
				descr = strGlue(map(unified, \un -> i2s(length(un))), "x");
				t = timestamp();
				intersected = fold(
					tail(unified), 
					map(unified[0], \unif -> RuSubData(unif.sub, unif.data)), 
					\acc, col -> ruIntersectCols(acc, col, math)
				);
				time = cast(timestamp() - t : double -> int);
				stats = RuStatsRow("prod " + descr, 
					pairs2tree([Pair("size", size), Pair("time", time), Pair("rets", length(intersected))])
				);
				ruAddStats("intersect_index_prod", stats);
			
				if (^debugUnifySubsProd) {
					println("result:");
					iter(intersected, \unif -> {
						println("sub:");
						println(ruIndent(ruSubst2s(unif.sub, math)));
						//println("expr");
						//println(ruIndent(ru2s(unif.expr, math.rules)));
						println("vect: " + strGlue(map(unif.data, \set -> "{" + strGlue(map(set2array(set), i2s), ", ") + "}"), "x"));
					});
				}
				fold(intersected, [],
					\acc, unif -> {
						prod = map(unif.data, \d -> set2array(d));
						concat(acc, ruMapCart(prod, \v -> RuSubData(unif.sub, mapi(v, \i, n -> subs[i][n].data))))
					}
				);
			}
		}
	}
}
