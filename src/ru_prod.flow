import ru_stats;
import prover/ru_prover_util;
import unify/ru_unify_indexes;

export {
	RuSubData(
		sub : Tree<RuVar, RuExp>,
		data: ?
	);
	ruUnifySubsProd(prod : [[RuSubData<?>]], maxExLen : int, timer : () -> bool, math : RuMath) -> [RuSubData<[?]>];
}

RuSubsColumn(
	var : RuVar,
	rows : [RuIndex<int>]
);

RuSubsMatrix(
	cols : [RuSubsColumn]
);

ruMakeSubsMatrix(subs : [[RuSubData<?>]]) -> RuSubsMatrix;

ruSubsMatrix2s(matrix : RuSubsMatrix, math : RuMath) -> string;

debugUnifySubsProd = ref false;

ruSubsMatrix2s(matrix : RuSubsMatrix, math : RuMath) -> string {
	n_rows = if (matrix.cols == []) 0 else length(matrix.cols[0].rows);
	ruStringMatrix2s(
		map(matrix.cols, \col -> map(col.rows, \row -> ruIndex2s(row, i2s, math))),
		Some(map(matrix.cols, \col -> ru2s(col.var, math.rules))),
		Some(map(enumFromTo(1, n_rows), \i -> "h_" + i2s(i)))
	);
}

ruMakeSubsMatrix(subs : [[RuSubData<?>]]) -> RuSubsMatrix {
	vars = set2array(fold(subs, makeSet(), \acc, ss ->
		fold(ss, acc, \ac, s ->
			mergeSets(ac, buildSet(getTreeKeys(s.sub)))
		)
	));
	make_cell = \v, ss -> {
		foldi(ss, ruMakeIndex(), \i, ac, s ->
			switch (lookupTree(s.sub, v)) {
				Some(ex): ruSetIndex(ex, i, ac);
				None(): ruSetIndex(RuExp([v], -1), i, ac);
			}
		)
	}
	RuSubsMatrix(
		fold(vars, [], \acc, v ->
			concat(acc, 
				[RuSubsColumn(v,
					fold(subs, [], \ac, ss ->
						concat(ac, [make_cell(v, ss)])
					)
				)]
			)
		)
	);
}

ruIntersectCols(col1 : [RuSubData<[Set<int>]>], col2 : [RuUnified<[Set<int>]>], math : RuMath) -> [RuSubData<[Set<int>]>] {
	fold(col1, [], \acc, unif1 ->
		fold(col2, acc, \ac, unif2 -> {
				common = mapi(unif1.data, \i, d1 -> intersectSets(d1, unif2.data[i]));
				if (exists(common, isEmptySet)) ac else {
					eitherMap(ruUnifySubs([unif1.sub, unif2.sub], math), 
						\s -> concat(ac, [RuSubData(s, common)]), ac
					)
				}
			}
		)
	);
}

RuSubArrData(
	subs : [Tree<RuVar, RuExp>],
	data : ?
);

ruIntersectCols1(col1 : [RuSubArrData<[Set<int>]>], col2 : [RuUnified<[Set<int>]>], math : RuMath) -> [RuSubArrData<[Set<int>]>] {
	fold(col1, [], \acc, unif1 ->
		fold(col2, acc, \ac, unif2 -> {
				common = mapi(unif1.data, \i, d1 -> intersectSets(d1, unif2.data[i]));
				if (exists(common, isEmptySet)) ac else
				concat(ac, [RuSubArrData(concat(unif1.subs, [unif2.sub]), common)]);
			}
		)
	);
}

ruUnifySubsProd(subs : [[RuSubData<?>]], maxExLen : int, timeLimit : () -> bool, math : RuMath) -> [RuSubData<[?]>] {
	if (subs == [] || exists(subs, \s -> s == [])) [] else 
	if (length(subs) == 1) map(subs[0], \d -> RuSubData(d.sub, [d.data])) else {
		started = timestamp();
		matrix = ruMakeSubsMatrix(subs);
		if (matrix.cols == []) {
			ruMapCart(subs, \vect -> RuSubData(makeTree(), map(vect, \sd -> sd.data)));
		} else {
			empty = ref false;
			unified = mapi(matrix.cols, \i, col -> {
					if (^debugUnifySubsProd) {
						println("unifying COLUMN " + i2s(i) + ":");
						debugUnifyIndexes := true;
					}
					if (!^empty && !timeLimit()) {
						size = fold(col.rows, 1, \acc, ind -> acc * ruIndexDataCount(ind));
						descr = strGlue(map(col.rows, \ind -> i2s(ruIndexDataCount(ind))), "x");
						t = timestamp();
						uns = ruUnifyIndexes(col.rows, makeTree(), math);
						time = cast(timestamp() - t : double -> int);
						stats = RuStatsRow("prod " + descr, 
							pairs2tree([Pair("size", size), Pair("time", time), Pair("rets", length(uns))])
						);
						ruAddStats("unif_index_prod", stats);
						
						unif_col = filtermap(uns, \unif -> {
							
								if (^debugUnifySubsProd) {
									println("sub:");
									println(ruIndent(ruSubst2s(unif.sub, math)));
									println("expr");
									println(ruIndent(ru2s(unif.expr, math.rules)));
									println("vect: " + strGlue(map(unif.data, \set -> "{" + strGlue(map(set2array(set), i2s), ", ") + "}"), "x"));
								}
								switch (lookupTree(unif.sub, col.var)) {
									None(): 
										maybeBind(ruAdd2Subst1(unif.sub, col.var, unif.expr, math), \s ->
											if (ruSubIsLess(s, maxExLen)) {
												Some(RuUnified(s, unif.data, ruApplySubst(unif.expr, s)));
											} else {
												None();
											}
										);
									Some(ex):
										maybeBind(ruUnifyExps([unif.expr, ex], unif.sub, math), \un -> 
											maybeBind(ruCompose(unif.sub, un), \s ->
												if (ruSubIsLess(s, maxExLen)) {
													Some(RuUnified(s, unif.data, ruApplySubst(ex, s)));
												} else {
													None();
												}
											)
										);
								}
							}
						);
						if (unif_col == []) {
							empty := true;
						}
						unif_col
					} else {
						[]
					}
				}
			);
			if (^empty) [] else {
				if (^debugUnifySubsProd) {
					println("filtered:");
					iteri(unified, \i, col -> {
						println("COLUMN " + i2s(i));
						iter(col, \unif -> {
							println("sub:");
							println(ruIndent(ruSubst2s(unif.sub, math)));
							println("expr");
							println(ruIndent(ru2s(unif.expr, math.rules)));
							println("vect: " + strGlue(map(unif.data, \set -> "{" + strGlue(map(set2array(set), i2s), ", ") + "}"), "x"));
						})
					});
				}
				//mergeSort(a : [?], comparisonFn : (?, ?) -> int) -> [?];
				//unified_sorted = mergeSort(unified, \col1, col2 -> length(col1) - length(col2));
				t = timestamp();
				/*inter_pair = fold(
					tail(unified), 
					Pair(map(unified[0], \unif -> RuSubData(unif.sub, unif.data)), []), 
					\acc, col -> {
						ret = ruIntersectCols(acc.first, col, math);
						Pair(ret, concat(acc.second, [length(acc.first) * length(col)]));
					}
				);*/
				
				t1 = timestamp();
				inter_pair = fold(
					tail(unified), 
					Pair(map(unified[0], \unif -> RuSubArrData([unif.sub], unif.data)), []), 
					\acc, col -> {
						if (timeLimit()) acc else {
							ret = ruIntersectCols1(acc.first, col, math);
							Pair(ret, concat(acc.second, [length(acc.first) * length(col)]));
						}
					}
				);
				intersected_1 = inter_pair.first;
				sizes = inter_pair.second;
				
				size1 = fold(sizes, 0, \acc, s -> acc + s);
				descr = strGlue(map(sizes, \s -> i2s(s)), ",");
				
				time1 = cast(timestamp() - t1 : double -> int);
				stats1 = RuStatsRow("prod " + descr, 
					pairs2tree([Pair("size", size1), Pair("time", time1), Pair("rets", length(intersected_1))])
				);
				ruAddStats("intersect_index_prod", stats1);
				
				
				t2 = timestamp();
				intersected = filtermap(intersected_1, \ss -> 
					maybeMap(
						fold(ss.subs, Some(makeTree()), \acc, s2 -> 
							maybeBind(acc, \s1 ->
								maybeBind(ruUnifySubs([s1, s2], math), \s3 ->
									if (ruSubIsLess(s3, maxExLen) && !timeLimit()) {
										Some(s3);
									} else {
										None();
									}
								)
							)
						),
						\s -> RuSubData(s, ss.data)
					)
				);
				size2 = length(intersected_1) * length(unified);
				time2 = cast(timestamp() - t2 : double -> int);
				stats2 = RuStatsRow("unify_subs", 
					pairs2tree([Pair("size", size2), Pair("time", time2), Pair("rets", length(intersected))])
				);
				ruAddStats("unfy_subs_index_prod", stats2);
			
				if (^debugUnifySubsProd) {
					println("result:");
					iter(intersected, \unif -> {
						println("sub:");
						println(ruIndent(ruSubst2s(unif.sub, math)));
						//println("expr");
						//println(ruIndent(ru2s(unif.expr, math.rules)));
						println("vect: " + strGlue(map(unif.data, \set -> "{" + strGlue(map(set2array(set), i2s), ", ") + "}"), "x"));
					});
				}
				fold(intersected, [],
					\acc, unif -> {
						prod = map(unif.data, \d -> set2array(d));
						concat(acc, ruMapCart(prod, \v -> RuSubData(unif.sub, mapi(v, \i, n -> subs[i][n].data))))
					}
				);
			}
		}
	}
}
