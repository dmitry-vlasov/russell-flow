import ru_src;
import ru_conf;
import parse/ru_trie;

export {
	RuTypeEnv(
		type   : RuType,
		trie   : RuTrie<string, RuRuleRef>,
		supers : Tree<string, RuRule>
	);
	ruNoTypeEnv = RuTypeEnv(ruNoType, ruTrieEmpty, makeTree());

	ruAddTerm2RuTrie(term : RuTerm, rule : Maybe<RuRuleRef>, trie : RuTrie<string, RuRuleRef>, conf : RuConf) -> RuTrie<string, RuRuleRef>;
	ruMergeRuTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv;
	ruMakeTypeEnv(type : RuType, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuTypeEnv;

	ruSuperTypeName(super : string, infer : string) -> string;
	ruMakeSuperRule(super : string, infer : string, pos : int) -> RuRule;
}

ruAddTerm2RuTrie(term : RuTerm, rule : Maybe<RuRuleRef>, trie : RuTrie<string, RuRuleRef>, conf : RuConf) -> RuTrie<string, RuRuleRef> {
	term_key = \x -> switch (x) {
		RuConstRef(c):  c;
		RuVar(v, t): t;
	}
	ruAdd2Trie(map(term.expr, term_key), rule, trie, 
		\a1, a2 -> {
			conf.onError("rule term: " + ruTerm2s(term.expr) + " is already used", []);
			a1
		}
	)
}

ruMergeRuTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv {
	RuTypeEnv(
		e1.type,
		ruMergeRuTrie(e1.trie, e2.trie, \a1, a2 -> a1),
		mergeTree(e1.supers, e2.supers)
	)
}

ruSuperTypeName(super : string, infer : string) -> string {
	infer + "-" + super
}

ruMakeSuperRule(super : string, infer : string, pos : int) -> RuRule {
	RuRule(
		ruSuperTypeName(super, infer), 
		makeTree1("x", RuVar("x", infer)), 
		RuTerm(super, [RuVar("x", infer)], pos),
		pos
	);
}

/*
			supers = fold(type.supers, makeTree(), \ac, s ->
				switch (ruLookupType(acc, s)) {
					Some(env): {
						foldTree(env.supers,
							setTree(ac, s, super_rule(s)), 
							\super, __, a ->
								setTree(a, super, super_rule(super))
						)
					}
					None(): {
						acc.conf.onError("unknown super type " + s + " for a type" + infer, [RuPlace(acc.file, type.pos)]);
						ac
					}
				}
			);
			super_types = foldTree(supers, acc.types, 
				\sup_name, sup_rule, ac -> {
					env = lookupTreeDef(ac, sup_name, ruNoTypeEnv);
					setTree(ac, sup_name, env)
				}
			);
			new_types = setTree(super_types, type.name, 
				RuTypeEnv(
					RuType(type.name, type.supers, type.pos), 
					ruAddTerm2RuTrie(
						RuTerm(type.name, [RuVar("x", type.name)], type.pos), 
						None(),
						ruTrieEmpty, acc.conf
					), 
					supers
				)
			);
*/

ruMakeTypeEnv(type : RuType, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuTypeEnv {
	supers = fold(type.supers, makeTree(), \ac, s ->
		switch (lookupTree(types, s)) {
			Some(env): {
				foldTree(env.supers,
					setTree(ac, s, ruMakeSuperRule(s, type.name, type.pos)), 
					\super, __, a ->
						setTree(a, super, ruMakeSuperRule(super, type.name, type.pos))
				)
			}
			None(): {
				conf.onError("unknown super type " + s + " for a type" + type.name, []);
				ac
			}
		}
	);
	RuTypeEnv(
		type,
		ruAddTerm2RuTrie(
			RuTerm(type.name, [RuVar("x", type.name)], type.pos), 
			None(),
			ruTrieEmpty, conf
		),
		supers
	)
}
