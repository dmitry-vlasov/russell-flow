import math/stringmath;
import parse/ru_parse_exp;
import parse/ru_parse;
import ru_verify;
import ru_math;

export {
	ruCollectMath(parsed : Tree<string, RuParsed>, conf : RuConf, to_cache : (RuSource, RuConf) -> void) -> Maybe<RuMath>;
}

ruCollectMath(parsed : Tree<string, RuParsed>, conf0 : RuConf, to_cache : (RuSource, RuConf) -> void) -> Maybe<RuMath> {
	err_count = ref 0;
	conf = ruAddErrCounter(conf0, err_count);
	start = timestamp();
	collected = ruDoCollectMath(parsed, conf, ruMakeMath(conf), to_cache);
	if (conf.verbose > 0) {
		ruPrintln("ru collected: " +i2s(sizeTree(collected.sources)) + " files in " + d2st((timestamp() - start)/ 1000.0, 2) + "s", conf);
	}
	if (^err_count == 0) {
		Some(collected);
	} else {
		None();
	}
}

ruDoCollectMath(left : Tree<string, RuParsed>, conf : RuConf, acc : RuMath, to_cache : (RuSource, RuConf) -> void) -> RuMath {
	parsed_imports = \parsed -> {
		switch (parsed) {
			RuCachedSource(source, __,__): map(source.imports, \imp -> imp.path);
			RuParseSource(imports,__,__): map(imports, \imp -> imp.path);
		}
	}
	parsed_file = \parsed -> {
		switch (parsed) {
			RuCachedSource(source, __,__): source.info.file;
			RuParseSource(__,__, info): info.file;
		}
	}
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(parsed_imports(src), \imp -> !containsKeyTree(left, imp))
		);
		if (ready == []) {
			conf.onError("cyclic import detected", []);
			acc
		} else {
			collected = filtermap(
				ruConcurrent(map(ready, 
					\parsed -> \->
					switch (parsed) {
						RuParseSource(__,__,info): {
							Some(ruCollectParsed(parsed, acc, to_cache));
						}
						RuCachedSource(src, depChanged,__): {
							if (!depChanged()) {
								Some(ruMakeMathFromSource(src, acc.types, conf)); 
							} else { 
								switch (ruVerifySource(src, ruAddSourceAssertions(src, acc))) {
									Some(verified): {
										Some(ruMakeMathFromSource(src, acc.types, conf));
									}
									None(): {
										maybeBind(ruLoadOne(conf, src.info.file, \__,__ -> None()), \l ->
											maybeMap(ruParseOne(l, conf), \s ->
												ruCollectOne(s, ruRemoveSource(src, acc), to_cache)
											)
										);
									}
								}
							}
						}
					}
				)), idfn
			);
			new_acc = fold(collected, acc, \ac, coll -> ruMergeMath(coll, ac));
			new_left = fold(ready, left, \ac, parsed -> removeFromTree(ac, parsed_file(parsed)));
			ruDoCollectMath(new_left, conf, new_acc, to_cache);
		}
	}
}

RuCollectAcc(
	file : string,
	global : RuMath,
	local : RuMath,
	types : Tree<string, RuTypeEnv>,
	conf : RuConf
);

ruCollectOne(parsed : RuParsed, acc : RuMath, to_cache : (RuSource, RuConf) -> void) -> RuMath {
	switch (parsed) {
		RuParseSource(__,__,__): ruCollectParsed(parsed, acc, to_cache);
		RuCachedSource(src, __,__): ruCollectSourceNames(src, acc);
	}
}

ruCollectParsed(src : RuParseSource, acc : RuMath, to_cache : (RuSource, RuConf) -> void) -> RuMath {
	start = timestamp();
	switch (lookupTree(acc.sources, src.info.file)) {
		Some(__): {
			acc.conf.onError("source " + src.info.file + " is already defined", []);
			acc
		}
		None(): {
			imps = map(src.imports, \imp -> RuImport(imp.path, imp.pos));
			acc0 = RuCollectAcc(src.info.file, acc, ruMakeMath(acc.conf), acc.types, acc.conf);
			acc1 = fold(src.decls, acc0, \ac, block -> 
				switch(block) {
					RuParseDecl(): ruCollectSyntax(block, ac);
					RuParseComment(__,__): ac;
				}
			);
			parse_decls : [RuParseDecl] = filtermap(src.decls, \block -> 
				switch(block) {
					RuParseDecl(): Some(block);
					RuParseComment(__,__): None();
				}
			);
			//created_decls = ruConcurrent(map(parse_decls, \decl -> \-> ruCreateAssertion(decl, acc1)));
			created_decls = map(parse_decls, \decl -> ruCreateAssertion(decl, acc1));
			assertions = filtermap(created_decls, idfn);
			acc2 = fold(assertions, acc1, \ac, ass -> 
				RuCollectAcc(ac with
					local = RuMath(ac.local with 
						assertions = setTree(ac.local.assertions, ass.name, ass),
						//names = setTree(ac.local.names, ass.name, src.info.file)
					),
				)
			);
			decls = fold(src.decls, [], \ac, block -> 
				switch (block) {
					RuParseConst(name,__,__,__):               concat(ac, [lookupTreeDef(acc2.local.consts, name, ruNoConst)]);
					RuParseType(name,__,__):                   concat(ac, [lookupTreeDef(acc2.local.types, name, ruNoTypeEnv).type]);
					RuParseRule(name,__,__,__):                concat(ac, [lookupTreeDef(acc2.local.rules, name, ruNoRule)]);
					RuParseAxiom(name,__,__,__,__,__):         concat(ac, [lookupTreeDef(acc2.local.assertions, name, ruNoAxiom)]);
					RuParseTheorem(name,__,__,__,__,__,__,__): concat(ac, [lookupTreeDef(acc2.local.assertions, name, ruNoTheorem)]);
					RuParseDef(name,__,__,__,__,__,__,__):     concat(ac, [lookupTreeDef(acc2.local.assertions, name, ruNoAxiom)]);
					RuParseComment(text, pos):                 concat(ac, [RuComment(text, pos)]);
					RuParseTheory(name, __,__):                ac; // TODO
				}
			);
			if (acc2.conf.verbose > 1) {
				ruPrintln("\tru collected: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s", acc.conf);
			}
			ru_src = RuSource(imps, decls, src.info);
			to_cache(ru_src, acc.conf);
			ruCollectSourceNames(
				ru_src, 
				RuMath(acc2.local with 
					sources = makeTree1(src.info.file, ru_src)
				)
			);
		}
	}
}

ruCollectSyntax(decl : RuParseDecl, acc : RuCollectAcc) -> RuCollectAcc {
	switch (decl) {
		RuParseConst(__,__,__,__): ruCollectConst(decl, acc);
		RuParseType(__,__,__):     ruCollectType(decl, acc);
		RuParseRule(__,__,__,__):  ruCollectRule(decl, acc);
		default: acc;
	}
}

ruCreateAssertion(decl : RuParseDecl, acc : RuCollectAcc) -> Maybe<RuAssertion> {
	switch (decl) {
		RuParseAxiom(__,__,__,__,__,__):         ruCreateAxiom(decl, acc);
		RuParseTheorem(__,__,__,__,__,__,__,__): ruCreateTheorem(decl, acc);
		RuParseDef(__,__,__,__,__,__,__,__):     ruCreateDef(decl, acc);
		default: None();
	}
}

ruCollectConst(const : RuParseConst, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupConst(acc, const.name)) {
		Some(__): {
			acc.conf.onError("constant " + const.name + " is already defined", [RuPlace(acc.file, const.pos)]);
			acc
		}
		None(): {
			RuCollectAcc(acc with
				local = RuMath(acc.local with 
					consts = setTree(acc.local.consts, const.name, RuConst(const.name, const.ascii, const.latex, const.pos)),
				)
			);
		}
	}
}

ruCollectType(type : RuParseType, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupType(acc, type.name)) {
		Some(__): {
			acc.conf.onError("type " + type.name + " is already defined", [RuPlace(acc.file, type.pos)]);
			acc
		}
		None(): {
			infer = type.name;
			supers = fold(type.supers, makeTree(), \ac, s ->
				switch (ruLookupType(acc, s)) {
					Some(env): {
						foldTree(env.supers,
							setTree(ac, s, ruMakeSuperRule(s, infer, type.pos)), 
							\super, __, a ->
								setTree(a, super, ruMakeSuperRule(super, infer, type.pos))
						)
					}
					None(): {
						acc.conf.onError("unknown super type " + s + " for a type" + infer, [RuPlace(acc.file, type.pos)]);
						ac
					}
				}
			);
			super_types = foldTree(supers, acc.types, 
				\sup_name, sup_rule, ac -> {
					env = lookupTreeDef(ac, sup_name, ruNoTypeEnv);
					setTree(ac, sup_name, env)
				}
			);
			new_types = setTree(super_types, type.name, 
				RuTypeEnv(
					RuType(type.name, type.supers, type.pos), 
					ruAddTerm2RuTrie(
						RuTerm(type.name, [RuVar("x", type.name)], type.pos), 
						None(),
						ruTrieEmpty, acc.conf
					), 
					supers
				)
			);
			RuCollectAcc(acc with
				local = RuMath(acc.local with 
					types = new_types,
					rules = foldTree(supers, acc.local.rules, \__, rule, ac -> setTree(ac, rule.name, rule)),
					//names = foldTree(supers, setTree(acc.local.names, type.name, acc.file), \__, rule, ac -> setTree(ac, rule.name, acc.file))
				),
				types = new_types
			)
		}
	}
}

ruCollectRule(rule : RuParseRule, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupRule(acc, rule.name)) {
		Some(__): {
			acc.conf.onError("rule " + rule.name + " is already defined", [RuPlace(acc.file, rule.pos)]);
			acc
		}
		None(): {
			type = rule.term.type;
			vars = fold(rule.vars, makeTree(), \ac, v ->
				switch (ruLookupType(acc, v.type)) {
					Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
					None(): {
						acc.conf.onError("unknown var " + v.name + " type " + v.type, [RuPlace(acc.file, v.pos)]);
						ac
					}
				}
			);
			term = ruMakeTerm(rule.term, vars, acc, ruAddErr2Conf(acc.conf, "\nat rule: " + rule.name));
			new_rule = RuRule(rule.name, vars, term, rule.pos);
			switch (ruLookupType(acc, rule.term.type)) {
				Some(env): {
					new_types = setTree(acc.types, env.type.name,
						RuTypeEnv(env with 
							trie = ruAddTerm2RuTrie(new_rule.term, 
								Some(RuRuleRef(rule.name, rule.term.type, sizeTree(vars), 0)),
								env.trie, acc.conf
							)
						)
					);
					RuCollectAcc(acc with
						local = RuMath(acc.local with 
							rules = setTree(acc.local.rules, rule.name, new_rule),
							types = new_types,
							//names = setTree(acc.local.names, rule.name, acc.file)
						),
						types = new_types
					);
				}
				None(): {
					acc.conf.onError("unknown type " + rule.term.type, [RuPlace(acc.file, rule.term.pos)]);
					quit(0);
					acc;
				}
			}
		}
	}
}

ruMakeTerm(term : RuParseExp, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> RuTerm {
	expr = fold(term.symbs, [], \ac, symb -> {
		switch (ruLookupConst(acc, symb)) {
			Some(s): concat(ac, [RuConstRef(symb)]);
			None(): 
				switch (lookupTree(vars, symb)) {
					Some(v): concat(ac, [RuVar(symb, v.type)]);
					None(): {
						conf.onError("unknown symbol " + symb, [RuPlace(acc.file, term.pos)]);
						ac
					}
				}
			}
		}
	);
	RuTerm(term.type, expr, term.pos);
}

ruCreateAxiom(ax : RuParseAxiom, acc : RuCollectAcc) -> Maybe<RuAxiom> {
	switch (ruLookupAssertion(acc, ax.name)) {
		Some(__): {
			acc.conf.onError("assertion with name " + ax.name + " is already defined", [RuPlace(acc.file, ax.pos)]);
			None();
		}
		None(): {
			err = \-> { acc.conf.onError("error in axiom " + ax.name, [RuPlace(acc.file, ax.pos)]); None(); }
			conf1 = ruAddErr2Conf(acc.conf, "\nat axiom " + ax.name);
			vars = ruCollectVars(ax.vars, acc, conf1);
			disjs = ruCollectDisjs(ax.disjs, vars, acc, conf1);
			hyps = filtermap(ax.hyps, \h -> ruCollectHyp(h, vars, acc, conf1));
			if (length(hyps) != length(ax.hyps)) {
				err();
			} else {
				switch (ruCollectExp(ax.prop, vars, acc, conf1)) {
					Some(prop): {
						Some(RuAxiom(ax.name, vars, disjs, hyps, prop, ax.pos));
					}
					None(): err();
				}
			}
		}
	}
}

ruCollectExp(ex : RuParseExp, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuExp> {
	ruParseExp(ruMakeTerm(ex, vars, acc, conf), acc.types, conf)
}

ruCollectVars(vars : [RuParseVar], acc : RuCollectAcc, conf : RuConf) -> Tree<string, RuVar> {
	fold(vars, makeTree(), \ac, v ->
		switch (ruLookupType(acc, v.type)) {
			Some(tp): setTree(ac, v.name, RuVar(v.name, v.type));
			None(): {
				conf.onError("unknown var " + v.name + " type " + v.type, [RuPlace(acc.file, v.pos)]);
				ac
			}
		}
	)
}

ruCollectMeta(m : RuParseMeta, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Set<string> {
	fold(m.meta, makeSet(), \ac, v ->
		if (containsKeyTree(vars, v)) insertSet(ac, v) else {
			conf.onError("unknown var " + v, [RuPlace(acc.file, m.pos)]);
			ac
		}
	)
}

ruCollectDisjs(disjs : [RuParseDisj], vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Set<RuDisj> {
	fold(disjs, makeSet(), \acc1, disj -> 
		fold(disj.vars, acc1, \acc2, v1 ->
			fold(disj.vars, acc2, \acc3, v2 -> {
					switch (lookupTree(vars, v1)) {
						Some(vr1): {
							switch (lookupTree(vars, v2)) {
								Some(vr2): {
									if (vr1.name < vr2.name) 
										insertSet(acc3, RuDisj(RuVar(vr1.name, vr1.type), RuVar(vr2.name, vr2.type))) 
									else if (vr2.name < vr1.name) 
										insertSet(acc3, RuDisj(RuVar(vr2.name, vr2.type), RuVar(vr1.name, vr1.type))) 
									else acc3 
								}
								None(): {
									conf.onError("unknown var '" + v2 + "' in disjointed set, vars: " + 
									strGlue(map(getTreeValues(vars), \v -> "'" + v.name + "'"), ", "), 
									[RuPlace(acc.file, disj.pos)]); acc3;
								}
							}
						}
						None(): {
							conf.onError("unknown var '" + v1 + "' in disjointed set, vars: " + 
							strGlue(map(getTreeValues(vars), \v -> "'" + v.name + "'"), ", "), 
							[RuPlace(acc.file, disj.pos)]); acc3;
						}
					}
				}
			)
		)
	)
}

ruCollectHyp(hyp : RuParseHyp, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuHyp> {
	maybeMap(
		ruCollectExp(hyp.expr, vars, acc, conf), 
		\expr -> RuHyp(hyp.ind, expr, hyp.pos)
	)
}

ruCreateTheorem(th : RuParseTheorem, acc : RuCollectAcc) -> Maybe<RuTheorem> {
	switch (ruLookupAssertion(acc, th.name)) {
		Some(__): {
			acc.conf.onError("assertion with name " + th.name + " is already defined", [RuPlace(acc.file, th.pos)]);
			None()
		}
		None(): {
			err = \-> { acc.conf.onError("error in theorem " + th.name, [RuPlace(acc.file, th.pos)]); None(); }
			conf1 = ruAddErr2Conf(acc.conf, "\nat theorem " + th.name);
			vars = ruCollectVars(th.vars, acc, conf1);
			disjs = ruCollectDisjs(th.disjs, vars, acc, conf1);
			meta = ruCollectMeta(th.meta, vars, acc, conf1);
			hyps = filtermap(th.hyps, \h -> ruCollectHyp(h, vars, acc, conf1));
			if (length(hyps) != length(th.hyps)) {
				err();
			} else {
				switch (ruCollectExp(th.prop, vars, acc, conf1)) { 
					Some(prop): {
						switch (ruCollectProof(th.proof, vars, acc, conf1)) {
							Some(proof): Some(RuTheorem(th.name, vars, disjs, meta, hyps, prop, proof, th.pos));
							None(): err();
						}
					}
					None(): err();
				}
			}
		}
	}
}

ruCollectProof(proof : RuParseProof, vars : Tree<string, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuProof> {
	proof_vars = ruCollectVars(proof.vars, acc, conf);
	all_vars = mergeTreeCustom(proof_vars, vars, \v, w,__ -> {
		conf.onError("duplicate variable " + v, [RuPlace(acc.file, proof.pos)]);
		w
	});
	proof_disjs = ruCollectDisjs(proof.disjs, all_vars, acc, conf);
	do_ref = \r -> switch (r) {
		RuParseHypRef(i, p): RuHypRef(i, p);
		RuParseStepRef(i, p): RuStepRef(i, p);
	}
	steps = filtermap(proof.steps,
		\s ->
			maybeMap(ruCollectExp(s.expr, all_vars, acc, conf),
				\expr -> RuStep(s.ind, s.assertion, map(s.refs, do_ref), expr, s.pos)
			)
	);
	if (length(steps) != length(proof.steps)) None() else {
		Some(RuProof(proof_vars, proof_disjs, steps, proof.pos));
	}
}

ruCreateDef(df : RuParseDef, acc : RuCollectAcc) -> Maybe<RuDef> {
	switch (ruLookupAssertion(acc, df.name)) {
		Some(__): {
			acc.conf.onError("assertion with name " + df.name + " is already defined", [RuPlace(acc.file, df.pos)]);
			None()
		}
		None(): {
			err = \-> { acc.conf.onError("error in definition " + df.name, [RuPlace(acc.file, df.pos)]); None(); }
			conf1 = ruAddErr2Conf(acc.conf, "\nat definitoin " + df.name);
			vars = ruCollectVars(df.vars, acc, conf1);
			disjs = ruCollectDisjs(df.disjs, vars, acc, conf1);
			prop_ex = fold(df.def.symbs, [], \ac, s ->
				if (s == "defiendum") concat(ac, df.defm.symbs) else
				if (s == "definiens") concat(ac, df.defs.symbs) else
				concat(ac, [s])
			);
			hyps = filtermap(df.hyps, \h -> ruCollectHyp(h, vars, acc, conf1));
			if (length(hyps) != length(df.hyps)) {
				err();
			} else {
				switch (ruCollectExp(RuParseExp(df.def.type, prop_ex, df.def.pos), vars, acc, conf1)) {
					Some(prop): {
						switch (ruCollectExp(df.defm, vars, acc, conf1)) {
							Some(defm): {
								switch (ruCollectExp(df.defs, vars, acc, conf1)) {
									Some(defs): 
										Some(RuDef(df.name, vars, disjs, hyps, defm, defs, prop, df.pos));
									None(): err();
								}
							}
							None(): err();
						}
					}
					None(): err();
				}
			}
		}
	}
}

ruLookupConst(acc : RuCollectAcc, n : string) -> Maybe<RuConst> {
	switch(lookupTree(acc.global.consts, n)) {
		Some(c): Some(c);
		None(): lookupTree(acc.local.consts, n);
	}
}

ruLookupType(acc : RuCollectAcc, n : string) -> Maybe<RuTypeEnv> {
	lookupTree(acc.types, n)
}

ruLookupRule(acc : RuCollectAcc, n : string) -> Maybe<RuRule> {
	switch(lookupTree(acc.global.rules, n)) {
		Some(r): Some(r);
		None(): lookupTree(acc.local.rules, n);
	}
}

ruLookupAssertion(acc : RuCollectAcc, n : string) -> Maybe<RuAssertion> {
	switch(lookupTree(acc.global.assertions, n)) {
		Some(a): Some(a);
		None(): lookupTree(acc.local.assertions, n);
	}
}
