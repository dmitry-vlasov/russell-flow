import ru_util;

export {
	RuStatsRow(
		descr : string,
		data : Tree<string, int>,
	);
	ruAddStats(table_name : string, row : RuStatsRow) -> void;
	ruProcStats(table_name : string, f : ([RuStatsRow]) -> string) -> string;
	ruMaxStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruSumStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruDistribSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
}

store = initConcurrentHashMap();

RuStatTable(
	name : string,
	size : ref int,
	array : native
);

ruEmptyStatTable = RuStatTable("", ref 0, initConcurrentHashMap());

ruAddStats(table_name : string, row : RuStatsRow) -> void {
	if (!containsConcurrentHashMap(store, table_name)) {
		setConcurrentHashMap(store, table_name, RuStatTable(table_name, ref 0, initConcurrentHashMap()));
	}
	table = getConcurrentHashMap(store, table_name, ruEmptyStatTable);
	setConcurrentHashMap(table.array, atomicRefIntAddition(table.size, 1), row);
}

ruProcStats(table_name : string, f : ([RuStatsRow]) -> string) -> string {
	f(valuesConcurrentHashMap(
		getConcurrentHashMap(store, table_name, ruEmptyStatTable).array
	));
}

ruMaxStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		max_row = fold(rows, Pair(RuStatsRow("", makeTree()), 0), \acc, row ->
			switch (lookupTree(row.data, field_name)) {
				Some(val): if (val > acc.second) Pair(row, val) else acc;
				None(): acc;
			}
		).first;
		strGlue(map(tree2pairs(max_row.data), \p -> p.first + "=" + i2s(p.second)), ", ") + (if (max_row.descr == "") "" else ": " + max_row.descr);
	}
}

ruSumStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows ->
		i2s(fold(rows, 0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): acc + val;
					None(): acc;
				}
		))
}

ruDistribSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = ruLogN(key, n);
					switch (lookupTree(row.data, field_val)) {
						Some(val): setTree(acc, k, val + lookupTreeDef(acc, k, 0));
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "^" + i2s(p.first - 1) + " - "+ i2s(n) + "^" + i2s(p.first) + "]: " + i2s(p.second)
			), 
			"\n"
		);
	}
}
