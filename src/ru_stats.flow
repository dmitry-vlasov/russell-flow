import ru_util;

export {
	RuStatsRow(
		descr : string,
		data : Tree<string, int>,
	);
	ruAddStats(table_name : string, row : RuStatsRow) -> void;
	ruProcStats(table_name : string, f : ([RuStatsRow]) -> string) -> string;
	ruMaxStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruSumStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruAvgStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruSigmaStats(field_name : string) -> ([RuStatsRow]) -> string;

	ruDistribLogSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
	ruDistribLogAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
	ruDistribLinSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
	ruDistribLinAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
}

store = initConcurrentHashMap();

RuStatTable(
	name : string,
	size : ref int,
	array : native
);

ruEmptyStatTable = RuStatTable("", ref 0, initConcurrentHashMap());

ruAddStats(table_name : string, row : RuStatsRow) -> void {
	if (!containsConcurrentHashMap(store, table_name)) {
		setConcurrentHashMap(store, table_name, RuStatTable(table_name, ref 0, initConcurrentHashMap()));
	}
	table = getConcurrentHashMap(store, table_name, ruEmptyStatTable);
	setConcurrentHashMap(table.array, atomicRefIntAddition(table.size, 1), row);
}

ruProcStats(table_name : string, f : ([RuStatsRow]) -> string) -> string {
	f(valuesConcurrentHashMap(
		getConcurrentHashMap(store, table_name, ruEmptyStatTable).array
	));
}

ruMaxStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		max_row = fold(rows, Pair(RuStatsRow("", makeTree()), 0), \acc, row ->
			switch (lookupTree(row.data, field_name)) {
				Some(val): if (val > acc.second) Pair(row, val) else acc;
				None(): acc;
			}
		).first;
		strGlue(map(tree2pairs(max_row.data), \p -> p.first + "=" + i2s(p.second)), ", ") + (if (max_row.descr == "") "" else ": " + max_row.descr);
	}
}

ruSumStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows ->
		i2s(fold(rows, 0, \acc, row ->
			switch (lookupTree(row.data, field_name)) {
				Some(val): acc + val;
				None(): acc;
			}
		))
}

ruAvgStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		if (length(rows) == 0) "" else {
			summ = fold(rows, 0.0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): acc + cast(val : int -> double);
					None(): acc;
				}
			);
			avg = summ / cast(length(rows) : int -> double);
			d2s(avg);
		}
	}
}

ruSigmaStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		if (length(rows) == 0) "" else {
			summ = fold(rows, 0.0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): acc + cast(val : int -> double);
					None(): acc;
				}
			);
			avg = summ / cast(length(rows) : int -> double);
			delta = fold(rows, 0.0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): {
						d = cast(val : int -> double) - avg;
						acc + d * d;
					}
					None(): acc;
				}
			);
			d2s(sqrt(delta / cast(length(rows) : int -> double)));
		}
	}
}

ruDistribLogSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = ruLogN(key, n);
					switch (lookupTree(row.data, field_val)) {
						Some(val): setTree(acc, k, val + lookupTreeDef(acc, k, 0));
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "^" + i2s(p.first - 1) + " - "+ i2s(n) + "^" + i2s(p.first) + "]: " + i2s(p.second)
			), 
			"\n"
		);
	}
}

ruDistribLogAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = ruLogN(key, n);
					switch (lookupTree(row.data, field_val)) {
						Some(val): {
							p = lookupTreeDef(acc, k, Pair(0, 0));
							setTree(acc, k, Pair(val + p.first, 1 + p.second));
						}
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "^" + i2s(p.first - 1) + " - "+ i2s(n) + "^" + i2s(p.first) + "]: " + i2s(p.second.first / p.second.second)
			), 
			"\n"
		);
	}
}

ruDistribLinSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = key / n;
					switch (lookupTree(row.data, field_val)) {
						Some(val): setTree(acc, k, val + lookupTreeDef(acc, k, 0));
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "*" + i2s(p.first) + " - "+ i2s(n) + "*" + i2s(p.first + 1) + "]: " + i2s(p.second)
			), 
			"\n"
		);
	}
}

ruDistribLinAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = key / n;
					switch (lookupTree(row.data, field_val)) {
						Some(val): {
							p = lookupTreeDef(acc, k, Pair(0, 0));
							setTree(acc, k, Pair(val + p.first, 1 + p.second));
						}
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "*" + i2s(p.first) + " - "+ i2s(n) + "*" + i2s(p.first + 1) + "]: " + i2s(p.second.first / p.second.second)
			), 
			"\n"
		);
	}
}

