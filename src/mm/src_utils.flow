import mm/src;

export {
	mmApplySubst(expr : MmExp, subst : Tree<int, MmExp>) -> MmExp;
	mmSubst2s(s : Tree<int, MmExp>) -> string;
	mmStack2s(s : List<MmExp>) -> string;
	mm2s(a : MmAny) -> string;
	mmExprVars(e : MmExp) -> Set<int>;
	mmAssertionVars(a : MmAssertion) -> Set<int>;
	mmStripComments(src : MmSource) -> MmSource;
	
	mmStatIsRule(stat : MmStat) -> bool;
	//mmJavaMmVol(any : MmAny) -> double;
}

mmApplySubst(expr : MmExp, subst : Tree<int, MmExp>) -> MmExp {
	applied = ref [];
	iter(expr.symbs, \symb ->
		switch (lookupTree(subst, symb.literal)) {
			Some(e): iter(e.symbs, \s -> refArrayPush(applied, s));
			None(): refArrayPush(applied, symb);
		}
	);
	MmExp(^applied)
}

mm2s(a : MmAny) -> string {
	vars2s = \hs -> {
		str = strGlue(filtermap(hs, \h -> 
			switch (h) {
				MmFloating(lab, type, var): Some(id2s(var));
				default: None();
			}
		), " ");
		if (str == "") "" else "$v " + str + " $.\n\t";
	};
	ind2s = \i -> {
		least = i % 20;
		most = ref [];
		for(i / 20, \k -> (k > 0), \k -> {
			refArrayPush(most, k % 5);
			k / 5
		});
		fold(reverseA(^most), "", \acc, digit -> acc + fromCharCode(digit + 84)) + fromCharCode(least + 65)
	}
	switch (a) {
		MmParseSource(__,toplevel,__): strGlue(map(toplevel, mm2s), "\n") + "\n";
		MmComment(text):  "$( " + text + " $)\n";
		MmImport(file):   "$[ " + id2s(file) + " $]\n";
		MmDisj(vars):     "$d " + strGlue(map(vars, id2s), " ") + " $.";
		MmConst(symbs):   "$c " + strGlue(map(symbs, id2s), " ") + " $.\n";
		MmVars(symbs):     "$v " + strGlue(map(symbs, id2s), " ") + " $.";
		MmEssential(label, expr):       id2s(label) + " $e " + mm2s(expr) + " $.";
		MmFloating(label, type, var):   id2s(label) + " $f " + id2s(type) + " " + id2s(var) + " $.";
		MmAxiomatic(label, expr):       id2s(label) + " $a " + mm2s(expr) + " $.";
		MmProvable(label, expr, proof): id2s(label) + " $p " + mm2s(expr) + mm2s(proof);
		MmBlock(es): "${\n" + "\t" + strGlue(map(es, mm2s), "\n\t") + "\n$}";
		MmNormalProof(labels):  " $= " + strGlue(map(labels, id2s), " ") + " $.";
		MmCompressedProof(labels, steps): " $= ( " + strGlue(map(labels, id2s), " ") + " ) " + strGlue(map(steps, mm2s), "") + " $.";
		MmProofIndex(ind): ind2s(ind); //i2s(ind) + " ";
		MmProofZ(): "Z";
		MmExp(symbs): strGlue(map(symbs, \s -> id2s(s.literal)), " ");
		MmSymb(literal, __): id2s(literal);
		MmAssertion(disj, hyps, inner, stat): 
			"${\n\t" +
				vars2s(concat(hyps, inner)) + 
				(if (disj == []) "" else strGlue(map(disj, mm2s), "\n\t") + "\n\t") +
				(if (hyps == []) "" else strGlue(map(hyps, mm2s), "\n\t") + "\n\t" ) +
				(if (inner == []) "" else strGlue(map(inner, mm2s), "\n\t") + "\n\t" ) +
				mm2s(a.stat) +
			"\n$}\n";
		MmSource(includes, decls, info): 
			concatStrings(map(includes, mm2s)) + "\n" + 
			concatStrings(map(decls, \d -> mm2s(d) + "\n")) + "\n";
	}
}

mmSubst2s(s : Tree<int, MmExp>) -> string {
	foldTree(s, "", \var, expr, str -> str + "\n" + id2s(var) + " --> " + mm2s(expr))
}

mmStack2s(s : List<MmExp>) -> string {
	foldList(s, "", \acc, e -> acc + "\n\t" + mm2s(e)) + "\n";
}

mmExprVars(e : MmExp) -> Set<int> {
	buildSet(filtermap(e.symbs, \s -> if (s.isVar) Some(s.literal) else None()))
}

mmAssertionVars(a : MmAssertion) -> Set<int> {
	fold(a.hyps, makeSet(), \acc, h -> {
			switch (h) {
				MmFloating(__, __, v): insertSet(acc, v);
				default: acc;
			}
		}
	)
}

mmStripComments(src : MmSource) -> MmSource {
	MmSource(src with decls = filter(src.decls, \decl -> 
		switch (decl) {
			MmComment(__): false;
			default: true;
		}
	))
}

mmStatIsRule(stat : MmStat) -> bool {
	stat.expr.symbs[0].literal != s2id("|-");
}

/*
mmJavaMmVol(any : MmAny) -> double {
	ruJavaAlignVol(
		ruJavaObjectHeader() +
		switch (any) {
			MmSource(imps, decls, comms, info): 
				ruJavaArrayVol(imps, ruJavaRuVol) + ruJavaArrayVol(decls, ruJavaRuVol) + ruJavaArrayVol(comms, ruJavaRuVol) + ruJavaFileInfoVol(info);
			RuImport(id, pos):
				ruJavaIntVol() + ruJavaIntVol();
			RuConst(descr, ascii, latex): 
				ruJavaDescrVol(descr) + ruJavaIntVol() + ruJavaIntVol(); 
			RuType(descr, supers): 
				ruJavaDescrVol(descr) + ruJavaArrayVol(supers, \__ -> ruJavaIntVol());
			RuRule(descr, vars, term):
				ruJavaDescrVol(descr) + ruJavaTreeVol(vars, \__->ruJavaIntVol(), ruJavaRuVol) + ruJavaRuVol(term);
			RuAxiom(descr, stat): 
				ruJavaDescrVol(descr) + ruJavaStatementVol(stat);
			RuDef(descr, stat, defm, defs):
				ruJavaDescrVol(descr) + ruJavaStatementVol(stat) + ruJavaRuVol(defm) + ruJavaRuVol(defs);
			RuTheorem(descr, stat, meta, proof): 
				ruJavaDescrVol(descr) + ruJavaStatementVol(stat) + ruJavaSetVol(meta, \__->ruJavaIntVol()) + ruJavaRuVol(proof); 
			RuHyp(ind, expr, pos): 
				ruJavaIntVol() + ruJavaRuVol(expr) + ruJavaIntVol();
			RuProof(vars, disjs, steps, pos): 
				ruJavaTreeVol(vars, \__->ruJavaIntVol(), ruJavaRuVol) + ruJavaSetVol(disjs, ruJavaRuVol) + ruJavaArrayVol(steps, ruJavaRuVol) + ruJavaIntVol();
			RuStep(ind, assertion, refs, expr, pos):
				ruJavaIntVol() + ruJavaIntVol() + ruJavaArrayVol(refs, ruJavaRuVol) + ruJavaRuVol(expr) + ruJavaIntVol();
			RuComment(text, ann, pos): 
				ruJavaStringVol(text) + ruJavaStringVol(json2string(ann)) + ruJavaIntVol();
			RuDisj(v1, v2): 
				ruJavaRuVol(v1) + ruJavaRuVol(v2);
			RuExp(nodes, pos): 
				ruJavaArrayVol(nodes, ruJavaRuVol) + ruJavaIntVol();
			RuHypRef(i, pos): 
				ruJavaIntVol() + ruJavaIntVol();
			RuStepRef(i, pos): 
				ruJavaIntVol() + ruJavaIntVol();
			RuVar(id, type_id): 
				ruJavaIntVol() + ruJavaIntVol();
			RuTerm(type_id, nodes, pos): 
				ruJavaIntVol() + ruJavaArrayVol(nodes, ruJavaRuVol) + ruJavaIntVol();
			RuConstRef(id): 
				ruJavaIntVol();
			RuRuleNode(id, type_id, arity, len): 
				ruJavaIntVol() + ruJavaIntVol() + ruJavaIntVol() + ruJavaIntVol();
		}
	);
}
*/