import ru/parse/src;
import mm/src;
import base/html;

export {
	MmSymbDef(
		symb  : int, 
		html  : string,
		alt   : MmSymbAltDef,
		latex : string,
	);
	MmSymbAltDef(
		full : string, // i.e. "&uarr;<SUB>&#x1D45A;</SUB>
		html : Maybe<[HtmlElement]>,
		unicode : string // unicode representation of the symbol
	);

	mmGatherSymbolDefs(srcs : Tree<int, MmParseSource>) -> Tree<int, MmSymbDef>;
	mmSymbolDef2s(def : MmSymbDef) -> string;
	mmSymbolDefs2s(defs : Tree<int, MmSymbDef>) -> string;
	mmSynbDefs2SymbTable(defs : Tree<int, MmSymbDef>) -> Tree<int, RuParseConst>;
	mmCompareSymbolTables(tab1 : Tree<int, RuParseConst>, tab2 : Tree<int, RuParseConst>) -> string;

	mmSymbTable() -> Tree<int, RuParseConst>;
	mmSetSymbolTable(table : Tree<int, RuParseConst>) -> void;
	mmSymbTable2s(tab : Tree<int, RuParseConst>, full : bool) -> string;
}

/*
	htmldef "(" as "<IMG SRC='lp.gif' WIDTH=5 HEIGHT=19 ALT=' (' TITLE='('>";
	althtmldef "(" as "(";
	latexdef "(" as "(";

	htmldef "A." as "<IMG SRC='forall.gif' WIDTH=10 HEIGHT=19 ALT=' A.' TITLE='A.'>";
	althtmldef "A." as '&forall;';  / * "#8704; * /
	latexdef "A." as "\forall";

	htmldef "T." as " <IMG SRC='top.gif' WIDTH=11 HEIGHT=19 ALT='T.' TITLE='T.'> ";
	althtmldef "T." as '&#x22A4;';
	latexdef "T." as "\top";

	althtmldef "'''" as '&#39&#39&#39';
	&uarr;<SUB>&#x1D45A;</SUB>
	althtmldef "~<_*" as ' &#8828;<SUP>*</SUP> ';
	althtmldef "Fin1a" as "Fin<SUP>Ia</SUP>";
	althtmldef "N." as '<I><B>N</B></I>';
	althtmldef "seqz" as 'seq<SUB><FONT FACE=sans-serif>&#8484;</FONT></SUB>';
	
*/

mmSymbolDef2s(def : MmSymbDef) -> string {
	"symb: '" + id2s(def.symb) + "'\n" + 
	(if (def.latex != "") "\tlatex: '" + def.latex + "'\n" else "") +
	(if (def.alt.full != "") "\talt:\n" + strIndent(mmSymbAltDef2s(def.alt)) + "\n" else "");
}

mmSymbAltDef2s(alt : MmSymbAltDef) -> string {
	if (alt.full == "") "" else {
		"full: " + alt.full + "\n" + 
		"html: " + eitherMap(alt.html, html2s, "NONE") + "\n" +
		"unicode: " + alt.unicode + "\n";
	}
}

mmSymbolDefs2s(defs : Tree<int, MmSymbDef>) -> string {
	superglue(getTreeValues(defs), mmSymbolDef2s, "\n");
}

mmGatherSymbolDefs(srcs : Tree<int, MmParseSource>) -> Tree<int, MmSymbDef> {
	vars = mmGatherAllVars(srcs);
	fold(getTreeValues(srcs), makeTree(), \acc, src -> 
		fold(src.toplevel, acc, \ac, elem -> 
			switch (elem) {
				MmComment(text): {
					i = strIndexOf(text, "$t");
					if (i == -1) ac else {
						uncommented = mmRemoveDefComments(text, 0, makeList());
						mmGatherTextSymbDefs(uncommented, i, vars, ac);
					}
				}
				default: ac;
			}
		)
	);
}

mmGatherAllVars(srcs : Tree<int, MmParseSource>) -> Set<string> {
	fold(getTreeValues(srcs), makeSet(), \acc, src -> 
		fold(src.toplevel, acc, mmGatherAllElemVars)
	);
}

mmGatherAllElemVars(acc : Set<string>, elem : MmElement) -> Set<string> {
	switch (elem) {
		MmVars(vars): mergeSets(acc, buildSet(map(vars, id2s)));
		MmBlock(elems): fold(elems, acc, mmGatherAllElemVars)
		default: acc;
	}
}

mmRemoveDefComments(text : string, pos : int, acc : List<string>) -> string {
	open = ruFindSubstring(text, pos, "/*");
	if (open == -1) {
		// No comments are left
		concatStrings(list2array(acc));
	} else {
		close = ruFindSubstring(text, open + 2, "*/");
		if (close == -1) {
			// unclosed comment. Just skip it.
			concatStrings(list2array(acc));
		} else {
			uncommented = substring(text, pos, open - pos);
			mmRemoveDefComments(text, close + 2, Cons(uncommented, acc));
		}
	}
}

mmGatherTextSymbDefs(txt : string, pos : int, vars : Set<string>, acc : Tree<int, MmSymbDef>) -> Tree<int, MmSymbDef> {
	keywords = ["htmldef", "althtmldef", "latexdef"];
	escapes = "'\"";
	p = ruFindOneOfSubstrings(txt, pos, keywords);
	if (p.first == -1) acc else {
		pos1 = p.second + strlen(keywords[p.first]);
		pos2 = ruFindSubstringEscaped(txt, pos1, ";", escapes);
		if (pos2 == -1) {
			ruCrash(" wrong typesetting def - doesn't end with ';' \n" + substring(txt, pos1, strlen(txt) - pos1));
			acc;
		} else {
			body = substring(txt, pos1, pos2 - pos1);
			//println("BODY: " + body);
			if (!strContains(body, " as ") && !strContains(body, " as\n")) {
				// Bad situation. 
				ruCrash("BODY NOT CONTAINS as: " + body);
				mmGatherTextSymbDefs(txt, pos2 + 1, vars, acc);
			} else {
				els = if (strContains(body, " as ")) strSplit(body, " as ") else strSplit(body, " as\n");
				symb1 = ruUnwrapQuotations(trim2(els[0], " \n\t\r"));
				if (symb1 == "") {
					// Bad situation. 
					ruCrash("Bad definition: " + body);
					mmGatherTextSymbDefs(txt, pos2 + 1, vars, acc);
				} else {
					symb = s2id(symb1);
					def1 = ruJoinMultDef(trim2(els[1], " \n\t\r"));
					def = trim2(ruUnwrapQuotations(def1), " \n\r\t");
					symb_def_old = lookupTreeDef(acc, symb, MmSymbDef(symb, "", MmSymbAltDef("", None(), ""), ""));
					symb_def_new = if (p.first == 0) {
						MmSymbDef(symb_def_old with html = def);
					} else if (p.first == 1) {
						html = parseHtml(def);
						if (isNone(html)) {
							println("Symbol definition:\n" + strIndent(def) + "\nis not parsed (sic!)");
						}
						unicode = switch (html) {
							Some(elems): {
								uni = mmSymbolHtml2unicode(elems);
								if (containsSet(vars, uni) || uni == "") symb1 else uni;
							}
							None(): "";
						}
						MmSymbDef(symb_def_old with 
							alt = MmSymbAltDef(def, html, unicode)
						);
					} else {
						MmSymbDef(symb_def_old with latex = def);
					}
					mmGatherTextSymbDefs(txt, pos2 + 1, vars, setTree(acc, symb, symb_def_new));
				}
			}
		}
	}
}

/*
  To parse definitions like this:

	althtmldef "-1-1-onto->" as '&ndash;<FONT SIZE=-2 '
		+ 'FACE=sans-serif>1-1</FONT>-<FONT SIZE=-2 '
		+ 'FACE=sans-serif>onto</FONT>&rarr;';

  we need to glue such multi-string definitions into a one string.
*/

mm_mult_def_parser : ref Maybe<[PegOp]> = ref None();

mmMultDefParser() -> [PegOp] {
	onlyOnce(mm_mult_def_parser, \ -> 
		compilePegGrammar("
mult_def = def:d defs+:ds { makeDefs(:d, :ds) };
def = def0 | def1;
def0 = ws '\\'' (!'\\'' any)+ $d '\\'' ws { $d };
def1 = ws \"\\\"\" (!\"\\\"\" any)+ $d \"\\\"\" ws { $d };
defs = '+' ws def:d { :d };

ws = (' ' | '\\t' | '\\n' | '\\r')*;
any = '\\u0000'-'\\uFFFF';
"
		)
	);
}

ruJoinMultDef(def : string) -> string {
	triple = parsic3(mmMultDefParser(), def, 
		SemanticActions(mergeTree(defaultPegActions.t, makeTree1(
			"makeDefs", \s -> concat([s[0]], s[1]))
		)), []
	);
	if (triple.third != "") def else concatStrings(triple.first);
}

ruUnwrapQuotations(str : string) -> string {
	if (startsWith(str, "'") && endsWith(str, "'")) {
		trim2(str, "'");
	} else if (startsWith(str, "\"") && endsWith(str, "\"")) {
		trim2(str, "\"");
	} else {
		str;
	}
}

mmSymbolHtml2unicode(html : [HtmlElement]) -> string {
	concatStrings(map(html, mmSymbolHtmlElement2unicode));
}

// htmlEntity2UnicodeId(entity: HtmlEntity) -> int

mmSymbolHtmlElement2unicode(elem : HtmlElement) -> string {
	switch (elem) {
		HtmlTag(title, attribs, body):
			mmSymbolHtml2unicode(body);
		HtmlText(text):
			strReplaces(text, [" ", "", "\n", "", "\r", "", "\t", ""]);
		HtmlEntity(): {
			code = htmlEntity2UnicodeId(elem);
			if (code != -1) fromCharCode(code) else {
				ruCrash("Unknown html entity: '" + htmlElement2s(elem) + "'");
				"";
			}
		}
	}
}

mmSynbDefs2SymbTable(defs : Tree<int, MmSymbDef>) -> Tree<int, RuParseConst> {
	all_defs = getTreeValues(defs);
	fold(getTreeValues(defs), makeTree(), \acc, def -> {
		if (def.alt.unicode == "") {
			ruCrash("def.alt.unicode == '':\n" + mmSymbolDef2s(def));
			acc;
		} else {
			// Try to correct ambiguities
			symb = lookupTreeDef(mm_symb_ambiguities, id2s(def.symb), def.alt.unicode);
			id = s2id(symb);
			if (id == def.symb && def.latex == "") acc else {
				setTree(acc, def.symb, RuParseConst(
					id, [], 
					if (id == def.symb) -1 else def.symb,
					def.latex, 
					-1
				));
			}
		}
	});
}

mmCompareSymbolTables(tab1 : Tree<int, RuParseConst>, tab2 : Tree<int, RuParseConst>) -> string {
	keys_1 = buildSet(getTreeKeys(tab1));
	keys_2 = buildSet(getTreeKeys(tab2));
	no_const = RuParseConst(-1, [], -1, "", -1);
	common_keys = intersectSets(keys_1, keys_2);
	"common keys:\n" + 
		strIndent(concatStrings(map(set2array(common_keys), \k -> {
			c1 = lookupTreeDef(tab1, k, no_const);
			c2 = lookupTreeDef(tab2, k, no_const);
			id2s(k) + " " + id2s(c1.id) + (if (c1.id == c2.id) "" else " != " + id2s(c2.id)) + "\n";
		}))) + "\n"
	"keys from tab1 missed in tab2 :\n" + 
		strIndent(concatStrings(map(set2array(differenceSets(keys_1, common_keys)), \k -> {
			c1 = lookupTreeDef(tab1, k, no_const);
			id2s(k) + " " + id2s(c1.id) + "\n";
		}))) + "\n"
	"keys from tab2 missed in tab1 :\n" + 
		strIndent(concatStrings(map(set2array(differenceSets(keys_2, common_keys)), \k -> {
			c2 = lookupTreeDef(tab2, k, no_const);
			id2s(k) + " " + id2s(c2.id) + "\n";
		}))) + "\n";
}

mmSymbTable2s(tab : Tree<int, RuParseConst>, full : bool) -> string {
	if (full) {
		superglue(getTreeValues(tab), ruParse2s, "\n");	
	} else {
		consts = filter(getTreeValues(tab), \c -> c.id != c.ascii);
		const2s = \c -> {
			"\t" + 
			id2s(c.id) + 
			(if (c.ascii == -1) "" else ", ascii: " + id2s(c.ascii)) + 
			(if (c.latex == "") "" else ", latex: " + c.latex)
		}
		superglue(consts, const2s, "\n");
	}
}

mmSetSymbolTable(table : Tree<int, RuParseConst>) -> void {
	// Add a constant for |- 
	vdash = mmMakeParseConst("|-", "‚ä¢", "\\vdash");
	table1 = setTree(table, vdash.ascii, vdash);
	table2 = fold(getTreeValues(table1), makeTree(), \acc, const -> {
		key = if (const.ascii == -1) const.id else const.ascii;
		if (containsKeyTree(acc, key)) {
			ruCrash("non unique ascii - key: " + id2s(key));
		}
		setTree(acc, key, const.id)
	});
	reversed = reverseTreeArray(table2);
	duplicate_keys = filter(tree2pairs(reversed), \p -> 
		length(p.second) != 1
	);
	if (length(duplicate_keys) > 0) {
		ruCrash("duplicate keys in symbol table:\n" + 
			strIndent(superglue(duplicate_keys, \p -> 
				"symbol: '" + id2s(p.first) + "' has ASCII pre-images: \n" + strIndent(superglue(p.second, id2s, "\n")) + "\n", "\n"
			)) + "\n" +
			"supplement the 'mm_symb_ambiguities' table in file mm/symbols with appropriate resolutions are recompile the russell"
		);
	}
	mmSymbTable_ref := Some(table1);
}

// Hand written table for resovling ambiguities in symbols,
// when althtmldef-defined symbols for different ascii-symbols coincide. 
mm_symb_ambiguities = pairs2tree([
	Pair("].", "]."),
	Pair("]", "]"),

	Pair(".,", ".,"),
	Pair(",,", ",,"), /* , -> .,    ,, */
	
	Pair("[.", "[."),
	Pair("[b", "[b"), /* [ ->  [.   [b */
	
	Pair("./", "./"),
	Pair("/.", "/."),
	Pair("/b", "/b"), /* / ->  ./    /.   /b */
	
	Pair("_lcm", "_lcm"),
	Pair("lcmOLD", "lcmOLD"),
	Pair("_lcmOLD", "_lcmOLD"), /* lcm ->  _lcm    lcmOLD   _lcmOLD */
	
	Pair("->", "‚Üí"),
	Pair("->..", "‚Üí.."), /*  ‚Üí ->  ->   ->.. */

	Pair("\\/", "‚à®"),
	Pair(".\\/", ".‚à®"),  /* ‚à® ->  \/  .\/  */
	
	Pair("/\\", "‚àß"),
	Pair("./\\", ".‚àß"),  /* ‚àß ->  /\  ./\  */

	Pair("F.", "F."),
	Pair("._|_", ".‚ä•"),
	Pair("_|_", "‚ä•"),   /* ‚ä• ->  F.   ._|_  _|_ */
	
	Pair("F/", "‚Ñ≤"),
	Pair("F/_", "‚Ñ≤_"),  /* ‚Ñ≤ ->  F/  F/_  */
	
	Pair(".<_", ".‚â§"),
	Pair("<_", "‚â§"),   /* ‚â§ ->   .<_  <_ */
	
	Pair(".-", ".‚àí"),
	Pair("-", "‚àí"),  /*  ‚àí ->  .-  	-  */
	
	Pair(".X.", ".√ó."),
	Pair("X.", "√ó."),  /*  √ó ->  .X.   X.  */
	
	Pair(".^", ".‚Üë"),
	Pair("^", "‚Üë"),   /*  ‚Üë ->   .^   	^   */
	
	Pair(".||", ".‚à•"),
	Pair("||", "‚à•"),  /*  ‚à• ->   .||   	||  */
	
	Pair(".*", ".‚àó"),
	Pair("*", "‚àó"),   /*   ‚àó ->  .*   *   */
	
	Pair(".x.", ".x."),
	Pair("x.", "x."),  /*  ¬∑ ->  .x.   x.  */
	
	Pair(".(x)", ".‚äó"),
	Pair("(x)", "‚äó"), /*  ‚äó ->  .(x)    (x) */
	
	Pair("u.", "‚à™"),
	Pair("U.", "‚à™."),
	Pair("U_", "‚à™_"), /*  ‚à™ ->  u.   U.   U_  */
	
	Pair("i^i", "‚à©"),
	Pair("|^|", "‚à©."),
	Pair("|^|_", "‚à©_"), /* ‚à© ->  i^i  |^|  |^|_  */
	
	Pair("/_\\", "‚ñ≥"),
	Pair("_/_\\", "_‚ñ≥"), /*  ‚ñ≥ ->  /_\   _/_\  */
	
	Pair("iota", "‚Ñ©"),
	Pair("iota_", "‚Ñ©_"), /*  ‚Ñ© ->  iota   iota_ */
	
	Pair("R1", "ùëÖ1"),
	Pair("R1_", "ùëÖ1_"),  /*  ùëÖ1 ->  R1   R1_ */
	
	Pair("+oo", "+‚àû"),
	Pair("pinfty", "+‚àû."), /* +‚àû ->  +oo   pinfty */

	Pair("-oo", "-‚àû"),
	Pair("minfty", "-‚àû."), /* -‚àû ->  -oo   minfty */
	
	Pair("ZZ", "‚Ñ§"),
	Pair("_ZZ", "_‚Ñ§"),  /* ‚Ñ§ ->  ZZ  _ZZ */

	Pair("_pi", "œÄ"),
	Pair("_piOLD", "œÄOLD"),
	Pair("ppi", "pœÄ"), /* œÄ ->  _pi   _piOLD  ppi */
	
	Pair("odZ", "od‚Ñ§"),
	Pair("odZOLD", "od‚Ñ§OLD"), /* od‚Ñ§ ->  odZ   odZOLD */
	
	Pair("\"s", "‚Äús"),
	Pair("\"sOLD", "‚ÄúsOLD"), /* ‚Äús ->  "s   "sOLD */
	
	Pair("Xs.", "√ós"),
	Pair("sX", "s√ó"),  /*  √ós ->  Xs.   sX */
	
	Pair("~=r", "‚âÉùëü"),
	Pair("~=R", "‚âÉR"), /*  ‚âÉùëü ->  ~=r   ~=R */
	
	Pair("L^1", "ùêø1"),
	Pair("L1_", "ùêø_1"), /*  ùêø1 ->  L^1  L1_ */
	
	Pair("vH", "v‚Ñã"),
	Pair("\\/H", "‚à®‚Ñã"), /* ‚à®‚Ñã ->  vH   \/H */

	Pair("Se", "Se"),
	Pair("_Se", "_Se"), /* Se ->  Se  _Se */
	
	Pair("0", "0"),
	Pair(".0.", ".0."), /*  0 ->  .0.  0  */
	
	Pair("1", "1"),
	Pair(".1.", ".1."),  /*  1 ->  .1.  1 */
	
	Pair("+", "+"),
	Pair(".+", ".+"), /*  + ->  .+   +  */
	
	Pair("<", "<"),
	Pair(".<", ".<"), /*  < ->   .<    <  */
	
	Pair("limsup", "limsup"),
	Pair("limsupOLD", "limsupOLD"), /*  limsup ->  limsup  limsupOLD */
	
	Pair("Ramsey", "Ramsey"),
	Pair("RamseyOLD", "RamseyOLD"), /*  Ramsey ->  Ramsey  RamseyOLD */
	
	Pair("Moore", "Moore"),
	Pair("Moore_", "Moore_"),  /*  Moore ->   Moore     Moore_ */
	
	Pair("od", "od"),
	Pair("odOLD", "odOLD"), /*  od ->  od   odOLD  */
	
	Pair("gEx", "gEx"),
	Pair("gExOLD", "gExOLD"),  /*  gEx ->  gEx   gExOLD */
	
	Pair("pGrp", "pGrp"),
	Pair("pGrpOLD", "pGrpOLD"), /*  pGrp ->   pGrp    pGrpOLD */
	
	Pair("Cn", "Cn"),
	Pair("C^n", "C^n"), /* Cn ->  Cn   C^n */

	Pair("normOp", "normOp"),
	Pair("normOpOLDOLD", "normOpOLDOLD"), /*  normOp ->   normOp  normOpOLDOLD */
	
	Pair("NGHom", "NGHom"),
	Pair("NGHomOLD", "NGHomOLD"), /*  NGHom ->   NGHom  NGHomOLD */
	
	Pair("vol*", "vol*"),
	Pair("vol*OLD", "vol*OLD"), /* vol* ->  vol*  vol*OLD  */
	
	Pair("idlGen1p", "idlGen1p"),
	Pair("idlGen1pOLD", "idlGen1pOLD"), /* idlGen1p ->  idlGen1p  idlGen1pOLD */
	
	Pair("toOMeas", "toOMeas"),
	Pair("toOMeasOLD", "toOMeasOLD"), /*  toOMeas ->   toOMeas   toOMeasOLD */
	
	Pair("PellFund", "PellFund"),
	Pair("PellFundOLD", "PellFundOLD"), /* PellFund ->  PellFund  PellFundOLD */
	
	Pair("degAA", "degAA"),
	Pair("degAAOLD", "degAAOLD"), /*  degAA ->  degAA	degAAOLD */
	
	Pair("jps", "jps"),
	Pair("jsi", "jsi"), /* jps ->  jps  jsi */
]);

mmSymbTable_ref : ref Maybe<Tree<int, RuParseConst>> = ref None();

mmSymbTable() -> Tree<int, RuParseConst> {
	onlyOnce(mmSymbTable_ref, mmInitSymbTable);
}

mmMakeParseConst(ascii : string, utf : string, latex : string) -> RuParseConst {
	RuParseConst(s2id(utf), [], s2id(ascii), latex, -1);
}

// Obsolete, hand-written symbol correspondence table
mmInitSymbTable() -> Tree<int, RuParseConst> {
	values2tree([
		mmMakeParseConst("|-", "‚ä¢", "\\vdash"),
		mmMakeParseConst("->", "‚Üí", "\\rightarrow"),
		mmMakeParseConst("-.", "¬¨", "\\lnot"),
		mmMakeParseConst("<->", "‚Üî", "\\leftrightarrow"),
		mmMakeParseConst("\\/", "‚à®", "\\lor"),
		mmMakeParseConst("/\\", "‚àß", "\\land"),
		mmMakeParseConst("-/\\", "‚äº", "\\bar{\\wedge}"),
		mmMakeParseConst("A.", "‚àÄ", "\\forall"),
		mmMakeParseConst("E.", "‚àÉ", "\\exists"),
		mmMakeParseConst("e.", "‚àà", "\\in"),
		mmMakeParseConst("E!", "‚àÉ!", "\\exists{!}"),
		mmMakeParseConst("E*", "‚àÉ*", "\\exists^{\\ast}"),
		mmMakeParseConst("{", "{", "\\{"),
		mmMakeParseConst("}", "}", "\\}"),
		mmMakeParseConst("=/=", "‚â†", "\\ne"),
		mmMakeParseConst("e/", "‚àâ", "\\notin"),
		//mmMakeParseConst("_V", "ÔøΩÔøΩÔøΩ", "\\rm{V}"),
		mmMakeParseConst("[_", "[_", "["),
		mmMakeParseConst("]_", "]_", "]"),
		mmMakeParseConst("C_", "‚äÜ", "\\subseteq"),
		mmMakeParseConst("C.", "‚äÇ", "\\subset"),
		mmMakeParseConst("\\", "‚àñ", "\\setminus"),
		mmMakeParseConst("u.", "‚à™", "\\cup"),
		mmMakeParseConst("i^i", "‚à©", "\\cap"),
		mmMakeParseConst("(/)", "‚àÖ", "\\emptyset"),
		mmMakeParseConst("~P", "Pow", "\\cal{P}"),
		mmMakeParseConst("<.", "‚å©", "\\langle"),
		mmMakeParseConst(">.", "‚å™", "\\rangle"),
		mmMakeParseConst("U.", "‚ãÉ", "\\bigcup"),
		mmMakeParseConst("|^|", "‚ãÇ", "\\bigcap"),
		mmMakeParseConst("U_", "‚ãÉ_", "\\bigcup"),
		mmMakeParseConst("|^|_", "‚ãÇ_", "\\bigcap"),
		//mmMakeParseConst("_E", "ÔøΩÔøΩÔøΩ", "\\epsilon"),
		mmMakeParseConst("_E", "_E", "\\epsilon"),
		mmMakeParseConst("_I", "_I", "\\rm{Id}"),
		mmMakeParseConst("om", "œâ", "\\omega"),
		mmMakeParseConst("X.", "√ó", "\\times"),
		mmMakeParseConst("`'", "‚Åª¬π", "{}^{-1}"),
		mmMakeParseConst("|`", "‚Üæ", "\\upharpoonright"),
		mmMakeParseConst("\"", "\"", "``"),
		mmMakeParseConst("o.", "‚àò", "\\circ"),
		mmMakeParseConst("-->", "‚ü∂", "\\longrightarrow"),
		mmMakeParseConst("-1-1->", "‚Ü£", "\\rightarrowtail"),
		mmMakeParseConst("-onto->", "‚Ü†", "\\twoheadrightarrow"),
		mmMakeParseConst("-1-1-onto->", "‚§ñ", "\\rightarrowtail\\twoheadrightarrow"),
		mmMakeParseConst("X_", "√ó_", "\\times"),
		mmMakeParseConst("|->", "‚Ü¶", "\\mapsto"),
		mmMakeParseConst("^m", "‚Üëm", "\\uparrow_m"),
		mmMakeParseConst("^pm", "‚Üëpm", "\\uparrow_{pm}"),
		mmMakeParseConst("+o", "+‚Çí", "+_o"),
		mmMakeParseConst(".o", "‚àô‚Çí", "\\cdot_o"),
		mmMakeParseConst("^o", "‚Üë‚Çí", "\\uparrow_o"),
		mmMakeParseConst("1o", "1‚Çí", "1_o"),
		mmMakeParseConst("2o", "2‚Çí", "2_o"),
		mmMakeParseConst("/.", "/.", "\\diagup"),
		mmMakeParseConst("~~", "‚âà", "\\approx"),
		mmMakeParseConst("~<_", "‚âº", "\\preccurlyeq"),
		mmMakeParseConst("~<", "‚â∫", "\\prec"),
		mmMakeParseConst("aleph", "‚Ñµ", "\\aleph"),
		//mmMakeParseConst("+c", "+ÔøΩÔøΩÔøΩ", "+_c"),
		mmMakeParseConst("+c", "+c", "+_c"),
		mmMakeParseConst("R1", "R‚ÇÅ", "R_1"),
		mmMakeParseConst(".N", "‚àôN", "\\cdot_{\\cal{N}}"),
		mmMakeParseConst("<N", "<N", "<_{\\cal{N}}"),
		mmMakeParseConst("+pQ", "+pQ", "+_{p\\cal{Q}}"),
		mmMakeParseConst(".pQ", "‚àôpQ", "\\cdot_{p\\cal{Q}}"),
		mmMakeParseConst("Q.", "Q.", "\\cal{Q}"),
		mmMakeParseConst(".Q", "‚àôQ", "\\cdot_{\\cal{Q}}"),
		mmMakeParseConst("P.", "Pos", "\\rm{Pos}"),
		mmMakeParseConst("1P", "1Pos", "1_{\\rm{Pos}}"),
		mmMakeParseConst("+P.", "+Pos", "+_{\\rm{Pos}}"),
		mmMakeParseConst(".P.", "‚àôPos", "\\cdot_{\\rm{Pos}}"),
		mmMakeParseConst("<P", "<Pos", "<_{\\rm{Pos}}"),
		mmMakeParseConst("+pR", "+pR", "+_{p\\cal{R}}"),
		mmMakeParseConst(".pR", "‚àôpR", "\\cdot_{p\\cal{R}}"),
		mmMakeParseConst("-1R", "-1R", "-1_{p\\cal{R}}"),
		mmMakeParseConst(".R", "‚àôR", "\\cdot_{p\\cal{R}}"),
		mmMakeParseConst("<R", "<R", "<_{p\\cal{R}}"),
		mmMakeParseConst("<RR", "<‚Ñù", "<_{\\mathbb{R}}"),
		mmMakeParseConst("CC", "‚ÑÇ", "\\mathbb{C}"),
		mmMakeParseConst("RR", "‚Ñù", "\\mathbb{R}"),
		mmMakeParseConst("x.", "‚àô", "\\cdot"),
		mmMakeParseConst("+oo", "+‚àû", "+\\infty"),
		mmMakeParseConst("-oo", "-‚àû", "-\\infty"),
		mmMakeParseConst("RR*", "‚Ñù*", "\\mathbb{R}*"),
		mmMakeParseConst("<_", "‚â§", "\\le"),
		mmMakeParseConst("NN", "‚Ñï", "\\mathbb{N}"),
		mmMakeParseConst("NN0", "‚Ñï‚ÇÄ", "\\mathbb{N}_0"),
		mmMakeParseConst("ZZ", "‚Ñ§", "\\mathbb{Z}"),
		mmMakeParseConst("QQ", "‚Ñö", "\\mathbb{Q}"),
		mmMakeParseConst("RR+", "‚Ñù‚Å∫", "\\mathbb{R}^+"),
		mmMakeParseConst("sqr", "‚àö", "\\surd"),
		mmMakeParseConst("Re", "‚Ñú", "\\Re"),
		mmMakeParseConst("Im", "‚Ñë", "\\Im"),
		mmMakeParseConst("|_", "‚åä", "\\lfloor"),
		mmMakeParseConst("==", "‚â°", "\\equiv"),
		mmMakeParseConst("seq1", "seq‚ÇÅ", "\\rm{seq}_1"),
		mmMakeParseConst("ZZ>=", "‚Ñ§‚â•", "\\mathbb{Z}_\\ge"),
		mmMakeParseConst("seq0", "seq‚ÇÄ", "\\rm{seq}_0"),
		mmMakeParseConst("^", "‚Üë", "\\uparrow"),
		mmMakeParseConst("~~>", "‚áù", "\\rightsquigarrow"),
		mmMakeParseConst("...", "...", "\\ldots"),
		mmMakeParseConst("sum_", "‚àë", "\\sigma"),
		mmMakeParseConst("_e", "‚Ñá", "\\rm{e}"),
		mmMakeParseConst("pi", "œÄ", "\\pi"),
		mmMakeParseConst("-cn->", "‚Äícn‚Üí", "\\longrightarrow_{\\rm{cn}}"),
		mmMakeParseConst("~~>m", "‚áùm", "\\rightsquigarrow_{\\rm{m}}"),
		mmMakeParseConst("Id", "Id", "\\rm{Id}"),
		mmMakeParseConst("^d", "‚Üëg", "\\uparrow_g"),
		mmMakeParseConst(".s", "‚àôs", "\\cdot_s"),
		mmMakeParseConst(".i", "‚àôi", "\\cdot_i"),
		mmMakeParseConst("~~>v", "‚áùv", "\\rightsquigarrow_{\\rm{v}}"),
		mmMakeParseConst("_|_", "‚ä•", "\\perp"),
		mmMakeParseConst("vH", "vH", "\\vee_\\mathfrak{H}"),
		mmMakeParseConst("\\/H", "\\/H", "\\bigvee_\\mathfrak{H}"),
		mmMakeParseConst("<_op", "‚â§op", "\\le_{\\rm{op}}"),
		mmMakeParseConst("Lambda", "Œõ", "\\Lambda"),
		mmMakeParseConst("<o", "‚ãñ", "\\lessdot"),
		mmMakeParseConst("1stc", "1stœâ", "1^{\\rm{st}}\\omega"),
		mmMakeParseConst("2ndc", "2ndœâ", "2^{\\rm{nd}}\\omega"),
		mmMakeParseConst("prod_", "‚àè", "\\Pi"),
		mmMakeParseConst("(+)", "‚äï", "\\oplus"),
		mmMakeParseConst("~~>t", "‚áùt", "\\rightsquigarrow_{\\rm{t}}"),
		mmMakeParseConst("=~ph", "=~œÜ", "\\mbox{$=$\\~{}ph}"),
		mmMakeParseConst("->..", "‚áí", "\\Longrightarrow"),
	], \c -> c.ascii);
}
