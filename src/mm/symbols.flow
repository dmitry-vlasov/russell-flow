import ru/parse/src;
import mm/src;
import base/html;

export {
	MmSymbDef(
		symb  : int, 
		html  : string,
		alt   : MmSymbAltDef,
		latex : string,
	);
	MmSymbAltDef(
		full : string, // i.e. "&uarr;<SUB>&#x1D45A;</SUB>
		html : Maybe<[HtmlElement]>,
		unicode : string // unicode representation of the symbol
	);

	mmGatherSymbolDefs(srcs : Tree<int, MmParseSource>) -> Tree<int, MmSymbDef>;
	mmSymbolDef2s(def : MmSymbDef) -> string;
	mmSymbolDefs2s(defs : Tree<int, MmSymbDef>) -> string;
	mmSynbDefs2SymbTable(defs : Tree<int, MmSymbDef>) -> Tree<int, RuParseConst>;
	mmCompareSymbolTables(tab1 : Tree<int, RuParseConst>, tab2 : Tree<int, RuParseConst>) -> string;

	mmSymbTable() -> Tree<int, RuParseConst>;
	mmSetSymbolTable(table : Tree<int, RuParseConst>) -> void;
	mmSymbTable2s(tab : Tree<int, RuParseConst>, full : bool) -> string;
}

/*
	htmldef "(" as "<IMG SRC='lp.gif' WIDTH=5 HEIGHT=19 ALT=' (' TITLE='('>";
	althtmldef "(" as "(";
	latexdef "(" as "(";

	htmldef "A." as "<IMG SRC='forall.gif' WIDTH=10 HEIGHT=19 ALT=' A.' TITLE='A.'>";
	althtmldef "A." as '&forall;';  / * "#8704; * /
	latexdef "A." as "\forall";

	htmldef "T." as " <IMG SRC='top.gif' WIDTH=11 HEIGHT=19 ALT='T.' TITLE='T.'> ";
	althtmldef "T." as '&#x22A4;';
	latexdef "T." as "\top";

	althtmldef "'''" as '&#39&#39&#39';
	&uarr;<SUB>&#x1D45A;</SUB>
	althtmldef "~<_*" as ' &#8828;<SUP>*</SUP> ';
	althtmldef "Fin1a" as "Fin<SUP>Ia</SUP>";
	althtmldef "N." as '<I><B>N</B></I>';
	althtmldef "seqz" as 'seq<SUB><FONT FACE=sans-serif>&#8484;</FONT></SUB>';
	
*/

mmSymbolDef2s(def : MmSymbDef) -> string {
	"symb: '" + id2s(def.symb) + "'\n" + 
	(if (def.latex != "") "\tlatex: '" + def.latex + "'\n" else "") +
	(if (def.alt.full != "") "\talt:\n" + strIndent(mmSymbAltDef2s(def.alt)) + "\n" else "");
}

mmSymbAltDef2s(alt : MmSymbAltDef) -> string {
	if (alt.full == "") "" else {
		"full: " + alt.full + "\n" + 
		"html: " + eitherMap(alt.html, html2s, "NONE") + "\n" +
		"unicode: " + alt.unicode + "\n";
	}
}

mmSymbolDefs2s(defs : Tree<int, MmSymbDef>) -> string {
	superglue(getTreeValues(defs), mmSymbolDef2s, "\n");
}

mmGatherSymbolDefs(srcs : Tree<int, MmParseSource>) -> Tree<int, MmSymbDef> {
	vars = mmGatherAllVars(srcs);
	fold(getTreeValues(srcs), makeTree(), \acc, src -> 
		fold(src.toplevel, acc, \ac, elem -> 
			switch (elem) {
				MmComment(text): {
					i = strIndexOf(text, "$t");
					if (i == -1) ac else {
						uncommented = mmRemoveDefComments(text, 0, makeList());
						mmGatherTextSymbDefs(uncommented, i, vars, ac);
					}
				}
				default: ac;
			}
		)
	);
}

mmGatherAllVars(srcs : Tree<int, MmParseSource>) -> Set<string> {
	fold(getTreeValues(srcs), makeSet(), \acc, src -> 
		fold(src.toplevel, acc, mmGatherAllElemVars)
	);
}

mmGatherAllElemVars(acc : Set<string>, elem : MmElement) -> Set<string> {
	switch (elem) {
		MmVars(vars): mergeSets(acc, buildSet(map(vars, id2s)));
		MmBlock(elems): fold(elems, acc, mmGatherAllElemVars)
		default: acc;
	}
}

mmRemoveDefComments(text : string, pos : int, acc : List<string>) -> string {
	open = ruFindSubstring(text, pos, "/*");
	if (open == -1) {
		// No comments are left
		concatStrings(list2array(acc));
	} else {
		close = ruFindSubstring(text, open + 2, "*/");
		if (close == -1) {
			// unclosed comment. Just skip it.
			concatStrings(list2array(acc));
		} else {
			uncommented = substring(text, pos, open - pos);
			mmRemoveDefComments(text, close + 2, Cons(uncommented, acc));
		}
	}
}

mmGatherTextSymbDefs(txt : string, pos : int, vars : Set<string>, acc : Tree<int, MmSymbDef>) -> Tree<int, MmSymbDef> {
	keywords = ["htmldef", "althtmldef", "latexdef"];
	escapes = "'\"";
	p = ruFindOneOfSubstrings(txt, pos, keywords);
	if (p.first == -1) acc else {
		pos1 = p.second + strlen(keywords[p.first]);
		pos2 = ruFindSubstringEscaped(txt, pos1, ";", escapes);
		if (pos2 == -1) {
			ruCrash(" wrong typesetting def - doesn't end with ';' \n" + substring(txt, pos1, strlen(txt) - pos1));
			acc;
		} else {
			body = substring(txt, pos1, pos2 - pos1);
			//println("BODY: " + body);
			if (!strContains(body, " as ") && !strContains(body, " as\n")) {
				// Bad situation. 
				ruCrash("BODY NOT CONTAINS as: " + body);
				mmGatherTextSymbDefs(txt, pos2 + 1, vars, acc);
			} else {
				els = if (strContains(body, " as ")) strSplit(body, " as ") else strSplit(body, " as\n");
				symb1 = ruUnwrapQuotations(trim2(els[0], " \n\t\r"));
				if (symb1 == "") {
					// Bad situation. 
					ruCrash("Bad definition: " + body);
					mmGatherTextSymbDefs(txt, pos2 + 1, vars, acc);
				} else {
					symb = s2id(symb1);
					def1 = ruJoinMultDef(trim2(els[1], " \n\t\r"));
					def = trim2(ruUnwrapQuotations(def1), " \n\r\t");
					symb_def_old = lookupTreeDef(acc, symb, MmSymbDef(symb, "", MmSymbAltDef("", None(), ""), ""));
					symb_def_new = if (p.first == 0) {
						MmSymbDef(symb_def_old with html = def);
					} else if (p.first == 1) {
						html = parseHtml(def);
						if (isNone(html)) {
							println("Symbol definition:\n" + strIndent(def) + "\nis not parsed (sic!)");
						}
						unicode = switch (html) {
							Some(elems): {
								uni = mmSymbolHtml2unicode(elems);
								if (containsSet(vars, uni) || uni == "") symb1 else uni;
							}
							None(): "";
						}
						MmSymbDef(symb_def_old with 
							alt = MmSymbAltDef(def, html, unicode)
						);
					} else {
						MmSymbDef(symb_def_old with latex = def);
					}
					mmGatherTextSymbDefs(txt, pos2 + 1, vars, setTree(acc, symb, symb_def_new));
				}
			}
		}
	}
}

/*
  To parse definitions like this:

	althtmldef "-1-1-onto->" as '&ndash;<FONT SIZE=-2 '
		+ 'FACE=sans-serif>1-1</FONT>-<FONT SIZE=-2 '
		+ 'FACE=sans-serif>onto</FONT>&rarr;';

  we need to glue such multi-string definitions into a one string.
*/

mm_mult_def_parser : ref Maybe<[PegOp]> = ref None();

mmMultDefParser() -> [PegOp] {
	onlyOnce(mm_mult_def_parser, \ -> 
		compilePegGrammar("
mult_def = def:d defs+:ds { makeDefs(:d, :ds) };
def = def0 | def1;
def0 = ws '\\'' (!'\\'' any)+ $d '\\'' ws { $d };
def1 = ws \"\\\"\" (!\"\\\"\" any)+ $d \"\\\"\" ws { $d };
defs = '+' ws def:d { :d };

ws = (' ' | '\\t' | '\\n' | '\\r')*;
any = '\\u0000'-'\\uFFFF';
"
		)
	);
}

ruJoinMultDef(def : string) -> string {
	triple = parsic3(mmMultDefParser(), def, 
		SemanticActions(mergeTree(defaultPegActions.t, makeTree1(
			"makeDefs", \s -> concat([s[0]], s[1]))
		)), []
	);
	if (triple.third != "") def else concatStrings(triple.first);
}

ruUnwrapQuotations(str : string) -> string {
	if (startsWith(str, "'") && endsWith(str, "'")) {
		trim2(str, "'");
	} else if (startsWith(str, "\"") && endsWith(str, "\"")) {
		trim2(str, "\"");
	} else {
		str;
	}
}

mmSymbolHtml2unicode(html : [HtmlElement]) -> string {
	concatStrings(map(html, mmSymbolHtmlElement2unicode));
}

// htmlEntity2UnicodeId(entity: HtmlEntity) -> int

mmSymbolHtmlElement2unicode(elem : HtmlElement) -> string {
	switch (elem) {
		HtmlTag(title, attribs, body):
			mmSymbolHtml2unicode(body);
		HtmlText(text):
			strReplaces(text, [" ", "", "\n", "", "\r", "", "\t", ""]);
		HtmlEntity(): {
			code = htmlEntity2UnicodeId(elem);
			if (code != -1) fromCharCode(code) else {
				ruCrash("Unknown html entity: '" + htmlElement2s(elem) + "'");
				"";
			}
		}
	}
}

mmSynbDefs2SymbTable(defs : Tree<int, MmSymbDef>) -> Tree<int, RuParseConst> {
	all_defs = getTreeValues(defs);
	fold(getTreeValues(defs), makeTree(), \acc, def -> {
		if (def.alt.unicode == "") {
			ruCrash("def.alt.unicode == '':\n" + mmSymbolDef2s(def));
			acc;
		} else {
			// Try to correct ambiguities
			symb = lookupTreeDef(mm_symb_ambiguities, id2s(def.symb), def.alt.unicode);
			id = s2id(symb);
			if (id == def.symb && def.latex == "") acc else {
				setTree(acc, def.symb, RuParseConst(
					id, [], 
					if (id == def.symb) -1 else def.symb,
					def.latex, 
					-1
				));
			}
		}
	});
}

mmCompareSymbolTables(tab1 : Tree<int, RuParseConst>, tab2 : Tree<int, RuParseConst>) -> string {
	keys_1 = buildSet(getTreeKeys(tab1));
	keys_2 = buildSet(getTreeKeys(tab2));
	no_const = RuParseConst(-1, [], -1, "", -1);
	common_keys = intersectSets(keys_1, keys_2);
	"common keys:\n" + 
		strIndent(concatStrings(map(set2array(common_keys), \k -> {
			c1 = lookupTreeDef(tab1, k, no_const);
			c2 = lookupTreeDef(tab2, k, no_const);
			id2s(k) + " " + id2s(c1.id) + (if (c1.id == c2.id) "" else " != " + id2s(c2.id)) + "\n";
		}))) + "\n"
	"keys from tab1 missed in tab2 :\n" + 
		strIndent(concatStrings(map(set2array(differenceSets(keys_1, common_keys)), \k -> {
			c1 = lookupTreeDef(tab1, k, no_const);
			id2s(k) + " " + id2s(c1.id) + "\n";
		}))) + "\n"
	"keys from tab2 missed in tab1 :\n" + 
		strIndent(concatStrings(map(set2array(differenceSets(keys_2, common_keys)), \k -> {
			c2 = lookupTreeDef(tab2, k, no_const);
			id2s(k) + " " + id2s(c2.id) + "\n";
		}))) + "\n";
}

mmSymbTable2s(tab : Tree<int, RuParseConst>, full : bool) -> string {
	if (full) {
		superglue(getTreeValues(tab), ruParse2s, "\n");	
	} else {
		consts = filter(getTreeValues(tab), \c -> c.id != c.ascii);
		const2s = \c -> {
			"\t" + 
			id2s(c.id) + 
			(if (c.ascii == -1) "" else ", ascii: " + id2s(c.ascii)) + 
			(if (c.latex == "") "" else ", latex: " + c.latex)
		}
		superglue(consts, const2s, "\n");
	}
}

mmSetSymbolTable(table : Tree<int, RuParseConst>) -> void {
	// Add a constant for |- 
	vdash = mmMakeParseConst("|-", "⊢", "\\vdash");
	table1 = setTree(table, vdash.ascii, vdash);
	table2 = fold(getTreeValues(table1), makeTree(), \acc, const -> {
		key = if (const.ascii == -1) const.id else const.ascii;
		if (containsKeyTree(acc, key)) {
			ruCrash("non unique ascii - key: " + id2s(key));
		}
		setTree(acc, key, const.id)
	});
	reversed = reverseTreeArray(table2);
	duplicate_keys = filter(tree2pairs(reversed), \p -> 
		length(p.second) != 1
	);
	if (length(duplicate_keys) > 0) {
		ruCrash("duplicate keys in symbol table:\n" + 
			strIndent(superglue(duplicate_keys, \p -> 
				"symbol: '" + id2s(p.first) + "' has ASCII pre-images: \n" + strIndent(superglue(p.second, id2s, "\n")) + "\n", "\n"
			)) + "\n" +
			"supplement the 'mm_symb_ambiguities' table in file mm/symbols with appropriate resolutions are recompile the russell"
		);
	}
	mmSymbTable_ref := Some(table1);
}

// Hand written table for resovling ambiguities in symbols,
// when althtmldef-defined symbols for different ascii-symbols coincide. 
mm_symb_ambiguities = pairs2tree([
	Pair("].", "]."),
	Pair("]", "]"),

	Pair(".,", ".,"),
	Pair(",,", ",,"), /* , -> .,    ,, */
	
	Pair("[.", "[."),
	Pair("[b", "[b"), /* [ ->  [.   [b */
	
	Pair("./", "./"),
	Pair("/.", "/."),
	Pair("/b", "/b"), /* / ->  ./    /.   /b */
	
	Pair("_lcm", "_lcm"),
	Pair("lcmOLD", "lcmOLD"),
	Pair("_lcmOLD", "_lcmOLD"), /* lcm ->  _lcm    lcmOLD   _lcmOLD */
	
	Pair("->", "→"),
	Pair("->..", "→.."), /*  → ->  ->   ->.. */

	Pair("\\/", "∨"),
	Pair(".\\/", ".∨"),  /* ∨ ->  \/  .\/  */
	
	Pair("/\\", "∧"),
	Pair("./\\", ".∧"),  /* ∧ ->  /\  ./\  */

	Pair("F.", "F."),
	Pair("._|_", ".⊥"),
	Pair("_|_", "⊥"),   /* ⊥ ->  F.   ._|_  _|_ */
	
	Pair("F/", "Ⅎ"),
	Pair("F/_", "Ⅎ_"),  /* Ⅎ ->  F/  F/_  */
	
	Pair(".<_", ".≤"),
	Pair("<_", "≤"),   /* ≤ ->   .<_  <_ */
	
	Pair(".-", ".−"),
	Pair("-", "−"),  /*  − ->  .-  	-  */
	
	Pair(".X.", ".×."),
	Pair("X.", "×."),  /*  × ->  .X.   X.  */
	
	Pair(".^", ".↑"),
	Pair("^", "↑"),   /*  ↑ ->   .^   	^   */
	
	Pair(".||", ".∥"),
	Pair("||", "∥"),  /*  ∥ ->   .||   	||  */
	
	Pair(".*", ".∗"),
	Pair("*", "∗"),   /*   ∗ ->  .*   *   */
	
	Pair(".x.", ".x."),
	Pair("x.", "x."),  /*  · ->  .x.   x.  */
	
	Pair(".(x)", ".⊗"),
	Pair("(x)", "⊗"), /*  ⊗ ->  .(x)    (x) */
	
	Pair("u.", "∪"),
	Pair("U.", "∪."),
	Pair("U_", "∪_"), /*  ∪ ->  u.   U.   U_  */
	
	Pair("i^i", "∩"),
	Pair("|^|", "∩."),
	Pair("|^|_", "∩_"), /* ∩ ->  i^i  |^|  |^|_  */
	
	Pair("/_\\", "△"),
	Pair("_/_\\", "_△"), /*  △ ->  /_\   _/_\  */
	
	Pair("iota", "℩"),
	Pair("iota_", "℩_"), /*  ℩ ->  iota   iota_ */
	
	Pair("R1", "𝑅1"),
	Pair("R1_", "𝑅1_"),  /*  𝑅1 ->  R1   R1_ */
	
	Pair("+oo", "+∞"),
	Pair("pinfty", "+∞."), /* +∞ ->  +oo   pinfty */

	Pair("-oo", "-∞"),
	Pair("minfty", "-∞."), /* -∞ ->  -oo   minfty */
	
	Pair("ZZ", "ℤ"),
	Pair("_ZZ", "_ℤ"),  /* ℤ ->  ZZ  _ZZ */

	Pair("_pi", "π"),
	Pair("_piOLD", "πOLD"),
	Pair("ppi", "pπ"), /* π ->  _pi   _piOLD  ppi */
	
	Pair("odZ", "odℤ"),
	Pair("odZOLD", "odℤOLD"), /* odℤ ->  odZ   odZOLD */
	
	Pair("\"s", "“s"),
	Pair("\"sOLD", "“sOLD"), /* “s ->  "s   "sOLD */
	
	Pair("Xs.", "×s"),
	Pair("sX", "s×"),  /*  ×s ->  Xs.   sX */
	
	Pair("~=r", "≃𝑟"),
	Pair("~=R", "≃R"), /*  ≃𝑟 ->  ~=r   ~=R */
	
	Pair("L^1", "𝐿1"),
	Pair("L1_", "𝐿_1"), /*  𝐿1 ->  L^1  L1_ */
	
	Pair("vH", "vℋ"),
	Pair("\\/H", "∨ℋ"), /* ∨ℋ ->  vH   \/H */

	Pair("Se", "Se"),
	Pair("_Se", "_Se"), /* Se ->  Se  _Se */
	
	Pair("0", "0"),
	Pair(".0.", ".0."), /*  0 ->  .0.  0  */
	
	Pair("1", "1"),
	Pair(".1.", ".1."),  /*  1 ->  .1.  1 */
	
	Pair("+", "+"),
	Pair(".+", ".+"), /*  + ->  .+   +  */
	
	Pair("<", "<"),
	Pair(".<", ".<"), /*  < ->   .<    <  */
	
	Pair("limsup", "limsup"),
	Pair("limsupOLD", "limsupOLD"), /*  limsup ->  limsup  limsupOLD */
	
	Pair("Ramsey", "Ramsey"),
	Pair("RamseyOLD", "RamseyOLD"), /*  Ramsey ->  Ramsey  RamseyOLD */
	
	Pair("Moore", "Moore"),
	Pair("Moore_", "Moore_"),  /*  Moore ->   Moore     Moore_ */
	
	Pair("od", "od"),
	Pair("odOLD", "odOLD"), /*  od ->  od   odOLD  */
	
	Pair("gEx", "gEx"),
	Pair("gExOLD", "gExOLD"),  /*  gEx ->  gEx   gExOLD */
	
	Pair("pGrp", "pGrp"),
	Pair("pGrpOLD", "pGrpOLD"), /*  pGrp ->   pGrp    pGrpOLD */
	
	Pair("Cn", "Cn"),
	Pair("C^n", "C^n"), /* Cn ->  Cn   C^n */

	Pair("normOp", "normOp"),
	Pair("normOpOLDOLD", "normOpOLDOLD"), /*  normOp ->   normOp  normOpOLDOLD */
	
	Pair("NGHom", "NGHom"),
	Pair("NGHomOLD", "NGHomOLD"), /*  NGHom ->   NGHom  NGHomOLD */
	
	Pair("vol*", "vol*"),
	Pair("vol*OLD", "vol*OLD"), /* vol* ->  vol*  vol*OLD  */
	
	Pair("idlGen1p", "idlGen1p"),
	Pair("idlGen1pOLD", "idlGen1pOLD"), /* idlGen1p ->  idlGen1p  idlGen1pOLD */
	
	Pair("toOMeas", "toOMeas"),
	Pair("toOMeasOLD", "toOMeasOLD"), /*  toOMeas ->   toOMeas   toOMeasOLD */
	
	Pair("PellFund", "PellFund"),
	Pair("PellFundOLD", "PellFundOLD"), /* PellFund ->  PellFund  PellFundOLD */
	
	Pair("degAA", "degAA"),
	Pair("degAAOLD", "degAAOLD"), /*  degAA ->  degAA	degAAOLD */
	
	Pair("jps", "jps"),
	Pair("jsi", "jsi"), /* jps ->  jps  jsi */
]);

mmSymbTable_ref : ref Maybe<Tree<int, RuParseConst>> = ref None();

mmSymbTable() -> Tree<int, RuParseConst> {
	onlyOnce(mmSymbTable_ref, mmInitSymbTable);
}

mmMakeParseConst(ascii : string, utf : string, latex : string) -> RuParseConst {
	RuParseConst(s2id(utf), [], s2id(ascii), latex, -1);
}

// Obsolete, hand-written symbol correspondence table
mmInitSymbTable() -> Tree<int, RuParseConst> {
	values2tree([
		mmMakeParseConst("|-", "⊢", "\\vdash"),
		mmMakeParseConst("->", "→", "\\rightarrow"),
		mmMakeParseConst("-.", "¬", "\\lnot"),
		mmMakeParseConst("<->", "↔", "\\leftrightarrow"),
		mmMakeParseConst("\\/", "∨", "\\lor"),
		mmMakeParseConst("/\\", "∧", "\\land"),
		mmMakeParseConst("-/\\", "⊼", "\\bar{\\wedge}"),
		mmMakeParseConst("A.", "∀", "\\forall"),
		mmMakeParseConst("E.", "∃", "\\exists"),
		mmMakeParseConst("e.", "∈", "\\in"),
		mmMakeParseConst("E!", "∃!", "\\exists{!}"),
		mmMakeParseConst("E*", "∃*", "\\exists^{\\ast}"),
		mmMakeParseConst("{", "{", "\\{"),
		mmMakeParseConst("}", "}", "\\}"),
		mmMakeParseConst("=/=", "≠", "\\ne"),
		mmMakeParseConst("e/", "∉", "\\notin"),
		//mmMakeParseConst("_V", "���", "\\rm{V}"),
		mmMakeParseConst("[_", "[_", "["),
		mmMakeParseConst("]_", "]_", "]"),
		mmMakeParseConst("C_", "⊆", "\\subseteq"),
		mmMakeParseConst("C.", "⊂", "\\subset"),
		mmMakeParseConst("\\", "∖", "\\setminus"),
		mmMakeParseConst("u.", "∪", "\\cup"),
		mmMakeParseConst("i^i", "∩", "\\cap"),
		mmMakeParseConst("(/)", "∅", "\\emptyset"),
		mmMakeParseConst("~P", "Pow", "\\cal{P}"),
		mmMakeParseConst("<.", "〈", "\\langle"),
		mmMakeParseConst(">.", "〉", "\\rangle"),
		mmMakeParseConst("U.", "⋃", "\\bigcup"),
		mmMakeParseConst("|^|", "⋂", "\\bigcap"),
		mmMakeParseConst("U_", "⋃_", "\\bigcup"),
		mmMakeParseConst("|^|_", "⋂_", "\\bigcap"),
		//mmMakeParseConst("_E", "���", "\\epsilon"),
		mmMakeParseConst("_E", "_E", "\\epsilon"),
		mmMakeParseConst("_I", "_I", "\\rm{Id}"),
		mmMakeParseConst("om", "ω", "\\omega"),
		mmMakeParseConst("X.", "×", "\\times"),
		mmMakeParseConst("`'", "⁻¹", "{}^{-1}"),
		mmMakeParseConst("|`", "↾", "\\upharpoonright"),
		mmMakeParseConst("\"", "\"", "``"),
		mmMakeParseConst("o.", "∘", "\\circ"),
		mmMakeParseConst("-->", "⟶", "\\longrightarrow"),
		mmMakeParseConst("-1-1->", "↣", "\\rightarrowtail"),
		mmMakeParseConst("-onto->", "↠", "\\twoheadrightarrow"),
		mmMakeParseConst("-1-1-onto->", "⤖", "\\rightarrowtail\\twoheadrightarrow"),
		mmMakeParseConst("X_", "×_", "\\times"),
		mmMakeParseConst("|->", "↦", "\\mapsto"),
		mmMakeParseConst("^m", "↑m", "\\uparrow_m"),
		mmMakeParseConst("^pm", "↑pm", "\\uparrow_{pm}"),
		mmMakeParseConst("+o", "+ₒ", "+_o"),
		mmMakeParseConst(".o", "∙ₒ", "\\cdot_o"),
		mmMakeParseConst("^o", "↑ₒ", "\\uparrow_o"),
		mmMakeParseConst("1o", "1ₒ", "1_o"),
		mmMakeParseConst("2o", "2ₒ", "2_o"),
		mmMakeParseConst("/.", "/.", "\\diagup"),
		mmMakeParseConst("~~", "≈", "\\approx"),
		mmMakeParseConst("~<_", "≼", "\\preccurlyeq"),
		mmMakeParseConst("~<", "≺", "\\prec"),
		mmMakeParseConst("aleph", "ℵ", "\\aleph"),
		//mmMakeParseConst("+c", "+���", "+_c"),
		mmMakeParseConst("+c", "+c", "+_c"),
		mmMakeParseConst("R1", "R₁", "R_1"),
		mmMakeParseConst(".N", "∙N", "\\cdot_{\\cal{N}}"),
		mmMakeParseConst("<N", "<N", "<_{\\cal{N}}"),
		mmMakeParseConst("+pQ", "+pQ", "+_{p\\cal{Q}}"),
		mmMakeParseConst(".pQ", "∙pQ", "\\cdot_{p\\cal{Q}}"),
		mmMakeParseConst("Q.", "Q.", "\\cal{Q}"),
		mmMakeParseConst(".Q", "∙Q", "\\cdot_{\\cal{Q}}"),
		mmMakeParseConst("P.", "Pos", "\\rm{Pos}"),
		mmMakeParseConst("1P", "1Pos", "1_{\\rm{Pos}}"),
		mmMakeParseConst("+P.", "+Pos", "+_{\\rm{Pos}}"),
		mmMakeParseConst(".P.", "∙Pos", "\\cdot_{\\rm{Pos}}"),
		mmMakeParseConst("<P", "<Pos", "<_{\\rm{Pos}}"),
		mmMakeParseConst("+pR", "+pR", "+_{p\\cal{R}}"),
		mmMakeParseConst(".pR", "∙pR", "\\cdot_{p\\cal{R}}"),
		mmMakeParseConst("-1R", "-1R", "-1_{p\\cal{R}}"),
		mmMakeParseConst(".R", "∙R", "\\cdot_{p\\cal{R}}"),
		mmMakeParseConst("<R", "<R", "<_{p\\cal{R}}"),
		mmMakeParseConst("<RR", "<ℝ", "<_{\\mathbb{R}}"),
		mmMakeParseConst("CC", "ℂ", "\\mathbb{C}"),
		mmMakeParseConst("RR", "ℝ", "\\mathbb{R}"),
		mmMakeParseConst("x.", "∙", "\\cdot"),
		mmMakeParseConst("+oo", "+∞", "+\\infty"),
		mmMakeParseConst("-oo", "-∞", "-\\infty"),
		mmMakeParseConst("RR*", "ℝ*", "\\mathbb{R}*"),
		mmMakeParseConst("<_", "≤", "\\le"),
		mmMakeParseConst("NN", "ℕ", "\\mathbb{N}"),
		mmMakeParseConst("NN0", "ℕ₀", "\\mathbb{N}_0"),
		mmMakeParseConst("ZZ", "ℤ", "\\mathbb{Z}"),
		mmMakeParseConst("QQ", "ℚ", "\\mathbb{Q}"),
		mmMakeParseConst("RR+", "ℝ⁺", "\\mathbb{R}^+"),
		mmMakeParseConst("sqr", "√", "\\surd"),
		mmMakeParseConst("Re", "ℜ", "\\Re"),
		mmMakeParseConst("Im", "ℑ", "\\Im"),
		mmMakeParseConst("|_", "⌊", "\\lfloor"),
		mmMakeParseConst("==", "≡", "\\equiv"),
		mmMakeParseConst("seq1", "seq₁", "\\rm{seq}_1"),
		mmMakeParseConst("ZZ>=", "ℤ≥", "\\mathbb{Z}_\\ge"),
		mmMakeParseConst("seq0", "seq₀", "\\rm{seq}_0"),
		mmMakeParseConst("^", "↑", "\\uparrow"),
		mmMakeParseConst("~~>", "⇝", "\\rightsquigarrow"),
		mmMakeParseConst("...", "...", "\\ldots"),
		mmMakeParseConst("sum_", "∑", "\\sigma"),
		mmMakeParseConst("_e", "ℇ", "\\rm{e}"),
		mmMakeParseConst("pi", "π", "\\pi"),
		mmMakeParseConst("-cn->", "‒cn→", "\\longrightarrow_{\\rm{cn}}"),
		mmMakeParseConst("~~>m", "⇝m", "\\rightsquigarrow_{\\rm{m}}"),
		mmMakeParseConst("Id", "Id", "\\rm{Id}"),
		mmMakeParseConst("^d", "↑g", "\\uparrow_g"),
		mmMakeParseConst(".s", "∙s", "\\cdot_s"),
		mmMakeParseConst(".i", "∙i", "\\cdot_i"),
		mmMakeParseConst("~~>v", "⇝v", "\\rightsquigarrow_{\\rm{v}}"),
		mmMakeParseConst("_|_", "⊥", "\\perp"),
		mmMakeParseConst("vH", "vH", "\\vee_\\mathfrak{H}"),
		mmMakeParseConst("\\/H", "\\/H", "\\bigvee_\\mathfrak{H}"),
		mmMakeParseConst("<_op", "≤op", "\\le_{\\rm{op}}"),
		mmMakeParseConst("Lambda", "Λ", "\\Lambda"),
		mmMakeParseConst("<o", "⋖", "\\lessdot"),
		mmMakeParseConst("1stc", "1stω", "1^{\\rm{st}}\\omega"),
		mmMakeParseConst("2ndc", "2ndω", "2^{\\rm{nd}}\\omega"),
		mmMakeParseConst("prod_", "∏", "\\Pi"),
		mmMakeParseConst("(+)", "⊕", "\\oplus"),
		mmMakeParseConst("~~>t", "⇝t", "\\rightsquigarrow_{\\rm{t}}"),
		mmMakeParseConst("=~ph", "=~φ", "\\mbox{$=$\\~{}ph}"),
		mmMakeParseConst("->..", "⇒", "\\Longrightarrow"),
	], \c -> c.ascii);
}
