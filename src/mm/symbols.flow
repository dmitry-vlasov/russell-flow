import ru/parse/src;
import mm/src;
import base/html;
import base/db;
import base/id_consts;

export {
	MmSymbDef(
		symb  : int, 
		html  : string,
		alt   : MmSymbAltDef,
		latex : string,
	);
	MmSymbAltDef(
		full : string, // i.e. "&uarr;<SUB>&#x1D45A;</SUB>
		html : Maybe<[HtmlElement]>,
		unicode : string // unicode representation of the symbol
	);

	mmMakeSymbolTable(srcs : Tree<int, MmParseSource>, env : RuEnv) -> void;
	mmSymbTable() -> Tree<int, RuParseConst>;
}

mmMakeSymbolTable(srcs : Tree<int, MmParseSource>, env : RuEnv) -> void {
	defs = mmGatherSymbolDefs(srcs, env);
	table = mmSynbDefs2SymbTable(defs, env);
	mmCheckSymbDefsAmbiguities(table, env);
	mmSymbTable_ref := Some(table);
}

/*
	htmldef "(" as "<IMG SRC='lp.gif' WIDTH=5 HEIGHT=19 ALT=' (' TITLE='('>";
	althtmldef "(" as "(";
	latexdef "(" as "(";

	htmldef "A." as "<IMG SRC='forall.gif' WIDTH=10 HEIGHT=19 ALT=' A.' TITLE='A.'>";
	althtmldef "A." as '&forall;';  / * "#8704; * /
	latexdef "A." as "\forall";

	htmldef "T." as " <IMG SRC='top.gif' WIDTH=11 HEIGHT=19 ALT='T.' TITLE='T.'> ";
	althtmldef "T." as '&#x22A4;';
	latexdef "T." as "\top";

	althtmldef "'''" as '&#39&#39&#39';
	&uarr;<SUB>&#x1D45A;</SUB>
	althtmldef "~<_*" as ' &#8828;<SUP>*</SUP> ';
	althtmldef "Fin1a" as "Fin<SUP>Ia</SUP>";
	althtmldef "N." as '<I><B>N</B></I>';
	althtmldef "seqz" as 'seq<SUB><FONT FACE=sans-serif>&#8484;</FONT></SUB>';
	
*/

mmSymbolDef2s(def : MmSymbDef) -> string {
	"symb: '" + id2s(def.symb) + "'\n" + 
	(if (def.latex != "") "\tlatex: '" + def.latex + "'\n" else "") +
	(if (def.alt.full != "") "\talt:\n" + strIndent(mmSymbAltDef2s(def.alt)) + "\n" else "");
}

mmSymbAltDef2s(alt : MmSymbAltDef) -> string {
	if (alt.full == "") "" else {
		"full: " + alt.full + "\n" + 
		"html: " + eitherMap(alt.html, html2s, "NONE") + "\n" +
		"unicode: " + alt.unicode + "\n";
	}
}

mmSymbolDefs2s(defs : Tree<int, MmSymbDef>) -> string {
	superglue(getTreeValues(defs), mmSymbolDef2s, "\n");
}

mmGatherSymbolDefs(srcs : Tree<int, MmParseSource>, env : RuEnv) -> Tree<int, MmSymbDef> {
	vars = mmGatherAllVars(srcs);
	//("|-", "⊢", "\\vdash")
	turnstile = ruIdTurnstile();
	turnstile_def = MmSymbDef(turnstile, "&#8866;", MmSymbAltDef("&#8866;", Some([HtmlDecEntity("8866")]), "⊢"), "\\vdash");
	fold(getTreeValues(srcs), 
		makeTree1(turnstile, turnstile_def), \acc, src -> 
		fold(src.toplevel, acc, \ac, elem -> 
			switch (elem) {
				MmComment(text): {
					i = strIndexOf(text, "$t");
					if (i == -1) ac else {
						uncommented = mmRemoveDefComments(text, 0, makeList());
						mmGatherTextSymbDefs(uncommented, i, vars, ac, env);
					}
				}
				default: ac;
			}
		)
	);
}

mmGatherAllVars(srcs : Tree<int, MmParseSource>) -> Set<string> {
	fold(getTreeValues(srcs), makeSet(), \acc, src -> 
		fold(src.toplevel, acc, mmGatherAllElemVars)
	);
}

mmGatherAllElemVars(acc : Set<string>, elem : MmElement) -> Set<string> {
	switch (elem) {
		MmVars(vars): mergeSets(acc, buildSet(map(vars, id2s)));
		MmBlock(elems): fold(elems, acc, mmGatherAllElemVars)
		default: acc;
	}
}

mmRemoveDefComments(text : string, pos : int, acc : List<string>) -> string {
	open = ruFindSubstring(text, pos, "/*");
	if (open == -1) {
		// No comments are left
		concatStrings(list2array(acc));
	} else {
		close = ruFindSubstring(text, open + 2, "*/");
		if (close == -1) {
			// unclosed comment. Just skip it.
			concatStrings(list2array(acc));
		} else {
			uncommented = substring(text, pos, open - pos);
			mmRemoveDefComments(text, close + 2, Cons(uncommented, acc));
		}
	}
}

mmGatherTextSymbDefs(txt : string, pos : int, vars : Set<string>, acc : Tree<int, MmSymbDef>, env : RuEnv) -> Tree<int, MmSymbDef> {
	keywords = ["htmldef", "althtmldef", "latexdef"];
	escapes = "'\"";
	p = ruFindOneOfSubstrings(txt, pos, keywords);
	if (p.first == -1) acc else {
		pos1 = p.second + strlen(keywords[p.first]);
		pos2 = ruFindSubstringEscaped(txt, pos1, ";", escapes);
		if (pos2 == -1) {
			env.out.onError(" wrong typesetting def - doesn't end with ';' \n" + substring(txt, pos1, strlen(txt) - pos1), []);
			acc;
		} else {
			body = substring(txt, pos1, pos2 - pos1);
			if (!strContains(body, " as ") && !strContains(body, " as\n")) {
				// Bad situation. 
				env.out.onError("Bad definition: (not contains ' as ' or ' as\\n' )" + body, []);
				mmGatherTextSymbDefs(txt, pos2 + 1, vars, acc, env);
			} else {
				els = if (strContains(body, " as ")) strSplit(body, " as ") else strSplit(body, " as\n");
				symb1 = ruUnwrapQuotations(trim2(els[0], " \n\t\r"));
				if (symb1 == "") {
					// Bad situation. 
					env.out.onError("Bad definition: " + body, []);
					mmGatherTextSymbDefs(txt, pos2 + 1, vars, acc, env);
				} else {
					symb = s2id(symb1);
					def1 = ruJoinMultDef(trim2(els[1], " \n\t\r"));
					def = trim2(ruUnwrapQuotations(def1), " \n\r\t");
					symb_def_old = lookupTreeDef(acc, symb, MmSymbDef(symb, "", MmSymbAltDef("", None(), ""), ""));
					symb_def_new = if (p.first == 0) {
						MmSymbDef(symb_def_old with html = def);
					} else if (p.first == 1) {
						html = parseHtml(def);
						if (isNone(html)) {
							env.out.onError("Symbol definition:\n" + strIndent(def) + "\nis not parsed", []);
						}
						unicode = switch (html) {
							Some(elems): {
								uni = mmSymbolHtml2unicode(elems, env);
								if (containsSet(vars, uni) || uni == "") symb1 else uni;
							}
							None(): "";
						}
						MmSymbDef(symb_def_old with 
							alt = MmSymbAltDef(def, html, unicode)
						);
					} else {
						MmSymbDef(symb_def_old with latex = def);
					}
					mmGatherTextSymbDefs(txt, pos2 + 1, vars, setTree(acc, symb, symb_def_new), env);
				}
			}
		}
	}
}

/*
  To parse definitions like this:

	althtmldef "-1-1-onto->" as '&ndash;<FONT SIZE=-2 '
		+ 'FACE=sans-serif>1-1</FONT>-<FONT SIZE=-2 '
		+ 'FACE=sans-serif>onto</FONT>&rarr;';

  we need to glue such multi-string definitions into a one string.
*/

mm_mult_def_parser : ref Maybe<[PegOp]> = ref None();

mmMultDefParser() -> [PegOp] {
	onlyOnce(mm_mult_def_parser, \ -> 
		compilePegGrammar("
mult_def = def:d defs+:ds { makeDefs(:d, :ds) };
def = def0 | def1;
def0 = ws '\\'' (!'\\'' any)+ $d '\\'' ws { $d };
def1 = ws \"\\\"\" (!\"\\\"\" any)+ $d \"\\\"\" ws { $d };
defs = '+' ws def:d { :d };
ws = (' ' | '\\t' | '\\n' | '\\r')*;
any = '\\u0000'-'\\uFFFF';
"
		)
	);
}

ruJoinMultDef(def : string) -> string {
	triple = parsic3(mmMultDefParser(), def, 
		SemanticActions(mergeTree(defaultPegActions.t, makeTree1(
			"makeDefs", \s -> concat([s[0]], s[1]))
		)), []
	);
	if (triple.third != "") def else concatStrings(triple.first);
}

ruUnwrapQuotations(str : string) -> string {
	if (startsWith(str, "'") && endsWith(str, "'")) {
		trim2(str, "'");
	} else if (startsWith(str, "\"") && endsWith(str, "\"")) {
		trim2(str, "\"");
	} else {
		str;
	}
}

mmSymbolHtml2unicode(html : [HtmlElement], env : RuEnv) -> string {
	concatStrings(map(html, \elem -> mmSymbolHtmlElement2unicode(elem, env)));
}

mmSymbolHtmlElement2unicode(elem : HtmlElement, env : RuEnv) -> string {
	switch (elem) {
		HtmlTag(title, attribs, body):
			mmSymbolHtml2unicode(body, env);
		HtmlText(text):
			strReplaces(text, [" ", "", "\n", "", "\r", "", "\t", ""]);
		HtmlEntity(): {
			code = htmlEntity2UnicodeId(elem);
			if (code != -1) fromCharCode(code) else {
				env.out.onError(
					"Unknown html entity: '" + htmlElement2s(elem) + "'\n" + 
					"Add approptiate correspondence to 'html2unicode' table in db/common.json file"
					, []
				);
				"";
			}
		}
	}
}

mmSynbDefs2SymbTable(defs : Tree<int, MmSymbDef>, env : RuEnv) -> Tree<int, RuParseConst> {
	all_defs = getTreeValues(defs);
	fold(getTreeValues(defs), makeTree(), \acc, def -> {
		if (def.alt.unicode == "") {
			ruCrash("def.alt.unicode == '':\n" + mmSymbolDef2s(def));
			acc;
		} else {
			// Try to correct ambiguities
			symb = lookupTreeDef(mmSymbAmbiguities(env), id2s(def.symb), def.alt.unicode);
			id = s2id(symb);
			if (id == def.symb && def.latex == "") acc else {
				setTree(acc, def.symb, RuParseConst(
					id, [], 
					if (id == def.symb) -1 else def.symb,
					def.latex, 
					-1
				));
			}
		}
	});
}

mmSymbTable2s(tab : Tree<int, RuParseConst>, full : bool) -> string {
	if (full) {
		superglue(getTreeValues(tab), ruParse2s, "\n");	
	} else {
		consts = filter(getTreeValues(tab), \c -> c.id != c.ascii);
		const2s = \c -> {
			"\t" + 
			id2s(c.id) + 
			(if (c.ascii == -1) "" else ", ascii: " + id2s(c.ascii)) + 
			(if (c.latex == "") "" else ", latex: " + c.latex)
		}
		superglue(consts, const2s, "\n");
	}
}

mmCheckSymbDefsAmbiguities(table : Tree<int, RuParseConst>, env : RuEnv) -> void {
	table2 = fold(getTreeValues(table), makeTree(), \acc, const -> {
		key = if (const.ascii == -1) const.id else const.ascii;
		if (containsKeyTree(acc, key)) {
			ruCrash("non unique ascii - key: " + id2s(key));
		}
		setTree(acc, key, const.id)
	});
	reversed = reverseTreeArray(table2);
	duplicate_keys = filter(tree2pairs(reversed), \p -> 
		length(p.second) != 1
	);
	if (length(duplicate_keys) > 0) {
		env.out.onError("duplicate keys in symbol table:\n" + 
			strIndent(superglue(duplicate_keys, \p -> 
				"symbol: '" + id2s(p.first) + "' has ASCII pre-images: \n" + strIndent(superglue(p.second, id2s, "\n")) + "\n", "\n"
			)) + "\n" +
			"update the 'symb_ambiguities' table in file 'set.json' with appropriate resolutions", []
		);
	}
}

/*
mmSetSymbolTable(table : Tree<int, RuParseConst>, env : RuEnv) -> void {
	// Add a constant for |- 
	//vdash = mmMakeParseConst("|-", "⊢", "\\vdash");
	//table1 = setTree(table, vdash.ascii, vdash);
	table2 = fold(getTreeValues(table), makeTree(), \acc, const -> {
		key = if (const.ascii == -1) const.id else const.ascii;
		if (containsKeyTree(acc, key)) {
			ruCrash("non unique ascii - key: " + id2s(key));
		}
		setTree(acc, key, const.id)
	});
	reversed = reverseTreeArray(table2);
	duplicate_keys = filter(tree2pairs(reversed), \p -> 
		length(p.second) != 1
	);
	if (length(duplicate_keys) > 0) {
		ruCrash("duplicate keys in symbol table:\n" + 
			strIndent(superglue(duplicate_keys, \p -> 
				"symbol: '" + id2s(p.first) + "' has ASCII pre-images: \n" + strIndent(superglue(p.second, id2s, "\n")) + "\n", "\n"
			)) + "\n" +
			"supplement the 'mm_symb_ambiguities' table in file mm/symbols with appropriate resolutions are recompile the russell"
		);
	}
	mmSymbTable_ref := Some(table);
}
*/
// Hand written table for resovling ambiguities in symbols,
// when althtmldef-defined symbols for different ascii-symbols coincide. 
mm_symb_ambiguities : ref Maybe<Tree<string, string>> = ref None();

mmSymbAmbiguities(env : RuEnv) -> Tree<string, string> {
	onlyOnce(mm_symb_ambiguities, \ -> mmInitSymbAmbiguities(env));
}

mmInitSymbAmbiguities(env : RuEnv) -> Tree<string, string> {
	json_table = ruGetDbItem("set", ["symb_ambiguities"]);
	table = map(getJsonObjectValue(json_table, []), \p -> 
		Pair(p.first, getJsonStringValue(p.second, ""))
	);
	pairs2tree(table);
}

mmSymbTable_ref : ref Maybe<Tree<int, RuParseConst>> = ref None();


mmSymbTable() -> Tree<int, RuParseConst> {
	switch (^mmSymbTable_ref) {
		Some(table): table;
		None(): {
			mmSymbTable_ref := Some(makeTree());
			mmSymbTable();
		}
	}
}
/*
mmMakeParseConst(ascii : string, utf : string, latex : string) -> RuParseConst {
	RuParseConst(s2id(utf), [], s2id(ascii), latex, -1);
}

// Obsolete, hand-written symbol correspondence table
mmInitSymbTable() -> Tree<int, RuParseConst> {
	values2tree([
		mmMakeParseConst("|-", "⊢", "\\vdash"),
		mmMakeParseConst("->", "→", "\\rightarrow"),
		mmMakeParseConst("-.", "¬", "\\lnot"),
		mmMakeParseConst("<->", "↔", "\\leftrightarrow"),
		mmMakeParseConst("\\/", "∨", "\\lor"),
		mmMakeParseConst("/\\", "∧", "\\land"),
		mmMakeParseConst("-/\\", "⊼", "\\bar{\\wedge}"),
		mmMakeParseConst("A.", "∀", "\\forall"),
		mmMakeParseConst("E.", "∃", "\\exists"),
		mmMakeParseConst("e.", "∈", "\\in"),
		mmMakeParseConst("E!", "∃!", "\\exists{!}"),
		mmMakeParseConst("E*", "∃*", "\\exists^{\\ast}"),
		mmMakeParseConst("{", "{", "\\{"),
		mmMakeParseConst("}", "}", "\\}"),
		mmMakeParseConst("=/=", "≠", "\\ne"),
		mmMakeParseConst("e/", "∉", "\\notin"),
		//mmMakeParseConst("_V", "���", "\\rm{V}"),
		mmMakeParseConst("[_", "[_", "["),
		mmMakeParseConst("]_", "]_", "]"),
		mmMakeParseConst("C_", "⊆", "\\subseteq"),
		mmMakeParseConst("C.", "⊂", "\\subset"),
		mmMakeParseConst("\\", "∖", "\\setminus"),
		mmMakeParseConst("u.", "∪", "\\cup"),
		mmMakeParseConst("i^i", "∩", "\\cap"),
		mmMakeParseConst("(/)", "∅", "\\emptyset"),
		mmMakeParseConst("~P", "Pow", "\\cal{P}"),
		mmMakeParseConst("<.", "〈", "\\langle"),
		mmMakeParseConst(">.", "〉", "\\rangle"),
		mmMakeParseConst("U.", "⋃", "\\bigcup"),
		mmMakeParseConst("|^|", "⋂", "\\bigcap"),
		mmMakeParseConst("U_", "⋃_", "\\bigcup"),
		mmMakeParseConst("|^|_", "⋂_", "\\bigcap"),
		//mmMakeParseConst("_E", "���", "\\epsilon"),
		mmMakeParseConst("_E", "_E", "\\epsilon"),
		mmMakeParseConst("_I", "_I", "\\rm{Id}"),
		mmMakeParseConst("om", "ω", "\\omega"),
		mmMakeParseConst("X.", "×", "\\times"),
		mmMakeParseConst("`'", "⁻¹", "{}^{-1}"),
		mmMakeParseConst("|`", "↾", "\\upharpoonright"),
		mmMakeParseConst("\"", "\"", "``"),
		mmMakeParseConst("o.", "∘", "\\circ"),
		mmMakeParseConst("-->", "⟶", "\\longrightarrow"),
		mmMakeParseConst("-1-1->", "↣", "\\rightarrowtail"),
		mmMakeParseConst("-onto->", "↠", "\\twoheadrightarrow"),
		mmMakeParseConst("-1-1-onto->", "⤖", "\\rightarrowtail\\twoheadrightarrow"),
		mmMakeParseConst("X_", "×_", "\\times"),
		mmMakeParseConst("|->", "↦", "\\mapsto"),
		mmMakeParseConst("^m", "↑m", "\\uparrow_m"),
		mmMakeParseConst("^pm", "↑pm", "\\uparrow_{pm}"),
		mmMakeParseConst("+o", "+ₒ", "+_o"),
		mmMakeParseConst(".o", "∙ₒ", "\\cdot_o"),
		mmMakeParseConst("^o", "↑ₒ", "\\uparrow_o"),
		mmMakeParseConst("1o", "1ₒ", "1_o"),
		mmMakeParseConst("2o", "2ₒ", "2_o"),
		mmMakeParseConst("/.", "/.", "\\diagup"),
		mmMakeParseConst("~~", "≈", "\\approx"),
		mmMakeParseConst("~<_", "≼", "\\preccurlyeq"),
		mmMakeParseConst("~<", "≺", "\\prec"),
		mmMakeParseConst("aleph", "ℵ", "\\aleph"),
		//mmMakeParseConst("+c", "+���", "+_c"),
		mmMakeParseConst("+c", "+c", "+_c"),
		mmMakeParseConst("R1", "R₁", "R_1"),
		mmMakeParseConst(".N", "∙N", "\\cdot_{\\cal{N}}"),
		mmMakeParseConst("<N", "<N", "<_{\\cal{N}}"),
		mmMakeParseConst("+pQ", "+pQ", "+_{p\\cal{Q}}"),
		mmMakeParseConst(".pQ", "∙pQ", "\\cdot_{p\\cal{Q}}"),
		mmMakeParseConst("Q.", "Q.", "\\cal{Q}"),
		mmMakeParseConst(".Q", "∙Q", "\\cdot_{\\cal{Q}}"),
		mmMakeParseConst("P.", "Pos", "\\rm{Pos}"),
		mmMakeParseConst("1P", "1Pos", "1_{\\rm{Pos}}"),
		mmMakeParseConst("+P.", "+Pos", "+_{\\rm{Pos}}"),
		mmMakeParseConst(".P.", "∙Pos", "\\cdot_{\\rm{Pos}}"),
		mmMakeParseConst("<P", "<Pos", "<_{\\rm{Pos}}"),
		mmMakeParseConst("+pR", "+pR", "+_{p\\cal{R}}"),
		mmMakeParseConst(".pR", "∙pR", "\\cdot_{p\\cal{R}}"),
		mmMakeParseConst("-1R", "-1R", "-1_{p\\cal{R}}"),
		mmMakeParseConst(".R", "∙R", "\\cdot_{p\\cal{R}}"),
		mmMakeParseConst("<R", "<R", "<_{p\\cal{R}}"),
		mmMakeParseConst("<RR", "<ℝ", "<_{\\mathbb{R}}"),
		mmMakeParseConst("CC", "ℂ", "\\mathbb{C}"),
		mmMakeParseConst("RR", "ℝ", "\\mathbb{R}"),
		mmMakeParseConst("x.", "∙", "\\cdot"),
		mmMakeParseConst("+oo", "+∞", "+\\infty"),
		mmMakeParseConst("-oo", "-∞", "-\\infty"),
		mmMakeParseConst("RR*", "ℝ*", "\\mathbb{R}*"),
		mmMakeParseConst("<_", "≤", "\\le"),
		mmMakeParseConst("NN", "ℕ", "\\mathbb{N}"),
		mmMakeParseConst("NN0", "ℕ₀", "\\mathbb{N}_0"),
		mmMakeParseConst("ZZ", "ℤ", "\\mathbb{Z}"),
		mmMakeParseConst("QQ", "ℚ", "\\mathbb{Q}"),
		mmMakeParseConst("RR+", "ℝ⁺", "\\mathbb{R}^+"),
		mmMakeParseConst("sqr", "√", "\\surd"),
		mmMakeParseConst("Re", "ℜ", "\\Re"),
		mmMakeParseConst("Im", "ℑ", "\\Im"),
		mmMakeParseConst("|_", "⌊", "\\lfloor"),
		mmMakeParseConst("==", "≡", "\\equiv"),
		mmMakeParseConst("seq1", "seq₁", "\\rm{seq}_1"),
		mmMakeParseConst("ZZ>=", "ℤ≥", "\\mathbb{Z}_\\ge"),
		mmMakeParseConst("seq0", "seq₀", "\\rm{seq}_0"),
		mmMakeParseConst("^", "↑", "\\uparrow"),
		mmMakeParseConst("~~>", "⇝", "\\rightsquigarrow"),
		mmMakeParseConst("...", "...", "\\ldots"),
		mmMakeParseConst("sum_", "∑", "\\sigma"),
		mmMakeParseConst("_e", "ℇ", "\\rm{e}"),
		mmMakeParseConst("pi", "π", "\\pi"),
		mmMakeParseConst("-cn->", "‒cn→", "\\longrightarrow_{\\rm{cn}}"),
		mmMakeParseConst("~~>m", "⇝m", "\\rightsquigarrow_{\\rm{m}}"),
		mmMakeParseConst("Id", "Id", "\\rm{Id}"),
		mmMakeParseConst("^d", "↑g", "\\uparrow_g"),
		mmMakeParseConst(".s", "∙s", "\\cdot_s"),
		mmMakeParseConst(".i", "∙i", "\\cdot_i"),
		mmMakeParseConst("~~>v", "⇝v", "\\rightsquigarrow_{\\rm{v}}"),
		mmMakeParseConst("_|_", "⊥", "\\perp"),
		mmMakeParseConst("vH", "vH", "\\vee_\\mathfrak{H}"),
		mmMakeParseConst("\\/H", "\\/H", "\\bigvee_\\mathfrak{H}"),
		mmMakeParseConst("<_op", "≤op", "\\le_{\\rm{op}}"),
		mmMakeParseConst("Lambda", "Λ", "\\Lambda"),
		mmMakeParseConst("<o", "⋖", "\\lessdot"),
		mmMakeParseConst("1stc", "1stω", "1^{\\rm{st}}\\omega"),
		mmMakeParseConst("2ndc", "2ndω", "2^{\\rm{nd}}\\omega"),
		mmMakeParseConst("prod_", "∏", "\\Pi"),
		mmMakeParseConst("(+)", "⊕", "\\oplus"),
		mmMakeParseConst("~~>t", "⇝t", "\\rightsquigarrow_{\\rm{t}}"),
		mmMakeParseConst("=~ph", "=~φ", "\\mbox{$=$\\~{}ph}"),
		mmMakeParseConst("->..", "⇒", "\\Longrightarrow"),
	], \c -> c.ascii);
}
*/