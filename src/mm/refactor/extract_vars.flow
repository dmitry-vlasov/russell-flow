import mm/src;
import comm;

export {
	mmSourcesExtractVars(sources : Tree<int, MmSource>) -> Tree<int, MmParseSource>;
	mmCommExtractVars : RuComm;
}

mmCommExtractVars = RuComm(
	RuCommInfo("extract-vars-mm", "misc", "extract common vars", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		task = unit.task;
		state = unit.state;
		sources = state.mm;
		conf = state.conf;
		all_vars = mmAllVars(sources);
		env.out.onMessage("mm vars:\n" +
			concatStrings(map(all_vars, \v -> "\t" + id2s(v.var) + " : " + id2s(v.type) + "\n"))
		);
		Some(state);
	}
);

mmSourcesExtractVars(sources : Tree<int, MmSource>) -> Tree<int, MmParseSource> {
	makeTree();
}

mmAllVars(sources : Tree<int, MmSource>) -> [MmFloating] {
	strip_name = \hyp -> MmFloating(hyp with label = hyp.var);
	filter_floatings = \hyps -> {
		filtermap(hyps, \hyp -> 
			switch (hyp) {
				MmFloating(__,__,__): Some(hyp);
				default: None();
			}
		)
	}
	all_vars = foldTree(sources, makeSet(), \__,src, acc ->
		fold(src.decls, acc, \ac, decl -> 
			switch (decl) {
				MmAssertion(__,hyps, inner,__): {
					fold(filter_floatings(inner),
						fold(filter_floatings(hyps), ac, \a, hyp -> 
							insertSet(a, strip_name(hyp))
						),
						\a, hyp -> insertSet(a, strip_name(hyp))
					)
				}
				default: ac;
			}
		)
	);
	sortCustom(set2array(all_vars), \v -> id2s(v.label), true);
}