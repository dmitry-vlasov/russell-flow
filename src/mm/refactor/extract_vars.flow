import base/path;
import mm/src;
import mm/proof_tree;
import comm;

export {
	mmSourcesExtractVars(sources : Tree<int, MmSource>, env : RuEnv) -> Tree<int, MmSource>;
	mmCommExtractVars : RuComm;
}

mmCommExtractVars = RuComm(
	RuCommInfo("extract-vars-mm", "misc", "extract common vars", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		task = unit.task;
		state = unit.state;
		sources = state.mm;
		conf = state.conf;
		extracted = mmSourcesExtractVars(sources, env);
		Some(RuState(state with mm = extracted));
	}
);

mmSourcesExtractVars(sources : Tree<int, MmSource>, env : RuEnv) -> Tree<int, MmSource> {
	assertions = mmAssertions(sources);
	vars = mmAllVars(sources);
	vars_map = foldi(vars, makeTree(), \i, acc, var ->
		setTree(acc, var.label, i)
	);
	perms = mmMakeVarsPermutations(assertions, vars_map, env);
	env.out.onMessage("mm vars:\n" +
		concatStrings(map(vars, \v -> "\t" + id2s(v.var) + " : " + id2s(v.type) + "\n"))
	);
	structs = mmSources2structs(sources);
	permuted = mapTree(sources, \src -> 
		mmApplyPermutation2Source(src, perms, structs, env)
	);
	mmAddVars(vars, permuted, env);
}

mmMakeVarsPermutations(assertions : [MmAssertion], vars_map : Tree<int, int>, env : RuEnv) -> Tree<int, [int]> {
	fold(assertions, makeTree(), \acc, ass -> {
		all_hyps = concat(ass.hyps, ass.inner);
		flows = mmAssertionFlos(all_hyps);
		pair = fold(all_hyps, Pair([], 0), \ac, hyp -> {
			switch (hyp) {
				MmFloating(lab, type, var): {
					Pair(
						concat(ac.first, [lookupTreeDef(vars_map, var, -1)]),
						ac.second
					);
				}
				MmEssential(__, __): {
					Pair(
						concat(ac.first, [ac.second + length(flows)]),
						ac.second + 1
					);
				}
			}
		});
		setTree(acc, ass.stat.label, pair.first);
	});
}

mmApplyPermutation2Source(src : MmSource, perms : Tree<int, [int]>, structs : MmStructs, env : RuEnv) -> MmSource {
	MmSource(src with 
		decls = map(src.decls, \decl ->
			switch (decl) {
				MmAssertion(__,__,__,__): 
					mmApplyPermutation2Assertion(decl, perms, structs, env);
				default: 
					decl;
			}
		)
	);
}


mmApplyPermutation2Assertion(ass : MmAssertion, perms : Tree<int, [int]>, structs : MmStructs, env : RuEnv) -> MmAssertion {
	MmAssertion(ass with
		hyps = mmAssertionHyps(ass.hyps),
		stat = switch (ass.stat) {
			MmAxiomatic(__,__): ass.stat;
			MmProvable(__,__,proof): {
				switch (proof) {
					MmNormalProof(labs): {
						switch (mmTheorem2MmProofTree(ass, ass.stat, structs, env)) {
							Some(proof_tree): {
								permuted_tree = mmApplyPermutation2ProofTree(proof_tree, perms, env);
								permuted_labs = mmProofTree2NormalProof(permuted_tree, env);
								MmProvable(ass.stat with proof = MmNormalProof(permuted_labs));
							}
							None(): {
								env.out.onError("Couldn't transform an RPN proof to tree", []);
								ass.stat;
							}
						}
					}
					MmCompressedProof(__,__): {
						env.out.onError("Compressed proofs are not allowed at applying a permutations to assertion hyps", []);
						ass.stat;
					}
				}
			}
		}
	);
}

mmApplyPermutation2ProofTree(proof : MmProofTree, perms : Tree<int, [int]>, env : RuEnv) -> MmProofTree {
	switch (proof) {
		MmProofTreeHyp(h): proof;
		MmProofTreeStep(lab, hyps): {
			perm = lookupTreeDef(perms, lab, []);
			MmProofTreeStep(lab, mapi(hyps, \i,__ -> hyps[perm[i]]));
		}
	}
}

mmAddVars(vars : [MmFloating], sources : Tree<int, MmSource>, env : RuEnv) -> Tree<int, MmSource> {
	leaf_srcs = filter(getTreeValues(sources), \src -> src.imports == []);
	common_dir = ruPath2s(ruCommonDir(map(leaf_srcs, \src -> ruSplitPath(src.info.path))));
	path = common_dir + "vars.mm";
	module = ruTrimPath(path, env.conf, ".mm");
	module_id = s2id(module);
	vars_src = MmSource(
		[], 
		vars, 
		RuFileInfo(module_id, module, path, 0.0, ruIdsVersion())
	);
	fold(leaf_srcs, setTree(sources, module_id, vars_src), \acc, src ->
		setTree(acc, src.info.id, 
			MmSource([MmImport(module_id)], src.decls, src.info)
		)
	);
}

mmAllVars(sources : Tree<int, MmSource>) -> [MmFloating] {
	strip_name = \hyp -> MmFloating(hyp with label = hyp.var);
	filter_floatings = \hyps -> {
		filtermap(hyps, \hyp -> 
			switch (hyp) {
				MmFloating(__,__,__): Some(hyp);
				default: None();
			}
		)
	}
	all_vars = foldTree(sources, makeSet(), \__,src, acc ->
		fold(src.decls, acc, \ac, decl -> 
			switch (decl) {
				MmAssertion(__,hyps, inner,__): {
					fold(filter_floatings(inner),
						fold(filter_floatings(hyps), ac, \a, hyp -> 
							insertSet(a, strip_name(hyp))
						),
						\a, hyp -> insertSet(a, strip_name(hyp))
					)
				}
				default: ac;
			}
		)
	);
	sortCustom(set2array(all_vars), \v -> id2s(v.label), true);
}