import mm/src_utils;

export {
	MmRuProofTree ::= MmRuProofTreeStep, MmRuProofTreeHyp, MmRuProofTreeNone;
		MmRuProofTreeStep(name  : int, expr  : MmExp, refs : [MmRuProofTree]);
		MmRuProofTreeHyp(ind : int, expr  : MmExp);
		MmRuProofTreeNone();

	mmTheorem2MmRuProofTree(ass : MmAssertion, stat : MmProvable, structs : MmStructs, env : RuEnv) -> Maybe<MmRuProofTree>;
	mmProofTree2NormalProof(proof : MmRuProofTree, env : RuEnv) -> [int];
}

Mm2RuExecAcc(
	stack : Maybe<MmRuStack>,
	subst : Tree<int, MmExp>,
	refs : [MmRuProofTree]
);

MmRuStack(
	parent : Maybe<MmRuStack>,
	expr   : MmExp,
	proof  : MmRuProofTree,
);

mm2ruPickFromStack(s : Maybe<MmRuStack>, mmHyps : [MmHyp]) -> Mm2RuExecAcc {
	fold(mmHyps, Mm2RuExecAcc(s, makeTree(), []),
		\acc, hyp -> {
			eitherMap(acc.stack,
				\stack -> {
					switch (hyp) {
						MmEssential(__, expr):
							Mm2RuExecAcc(stack.parent, acc.subst, concat([stack.proof], acc.refs));
						MmFloating(__, type, var):
							Mm2RuExecAcc(stack.parent, setTree(acc.subst, var, MmExp(tail(stack.expr.symbs))), acc.refs);
					}
				},
				acc
			)
		}
	)
}

mm2ruExecRPNstep(lab : int, stack : Maybe<MmRuStack>, th_hyps : [MmHyp], labeled : Tree<int, MmLabeled>, env : RuEnv) -> Maybe<MmRuStack> {
	switch (lookupTreeDef(labeled, lab, mmNoAssertion)) {
		MmAssertion(disj, hyps, inner, stat): {
			acc = mm2ruPickFromStack(stack, reverseA(hyps));
			applied = mmApplySubst(stat.expr, acc.subst);
			Some(MmRuStack(acc.stack, applied, 
				if (mmStatIsRule(stat)) MmRuProofTreeNone() else MmRuProofTreeStep(lab, applied, acc.refs)
			));
		}
		MmEssential(l, expr): {
			i = findiDef(th_hyps, \h -> l == h.label, -1);
			switch (th_hyps[i]) {
				MmEssential(__, ex):
					Some(MmRuStack(stack, expr, MmRuProofTreeHyp(i, ex)));
				default:
					Some(MmRuStack(stack, expr, MmRuProofTreeNone()));
			}
		}
		MmFloating(__, type, var):
			Some(MmRuStack(stack, MmExp([MmSymb(type, false), MmSymb(var, true)]), MmRuProofTreeNone()));
	}
}

mmTheorem2MmRuProofTree(ass : MmAssertion, stat : MmProvable, structs : MmStructs, env : RuEnv) -> Maybe<MmRuProofTree> {
	switch (stat.proof) {
		MmNormalProof(labels): {
			th_hyps = mmAssertionHyps(ass.hyps);
			maybeMap(
				fold(labels, None(), \s, lab -> mm2ruExecRPNstep(lab, s, th_hyps, structs.labeled, env)),
				\stack -> stack.proof
			);
		}
		MmCompressedProof(__,__): {
			env.out.onError("Compressed proof is met while translating Metamath to Russell. Decompress first.", []);
			None();
		}
	}
}


mmProofTree2NormalProof(proof : MmRuProofTree, env : RuEnv) -> [int] {
	switch (proof) {
		MmRuProofTreeStep(name, expr, refs): {
			[];
		}
		MmRuProofTreeHyp(ind, expr): {
			[];
		}
		MmRuProofTreeNone(): {
			[];
		}
	}
}