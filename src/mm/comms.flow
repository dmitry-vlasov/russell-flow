import mm/parse/comms;
import mm/refactor/comms;
import mm/mm2ru;
import mm/verify;

export {
	mmCommands = concat3(
		mmIoCommands, 
		mmRefactorCommands,
		[
			ruCommMm2Ru, 
			ruCommMmCompressProofs,
			ruCommMmDecompressProofs
		]
	);
}

ruCommMmCompressProofs = RuComm(
	"mm-compress-proofs", "misc", "compress Metamath proofs", "", [],
	mmRunMmCompressProofs
);

ruCommMmDecompressProofs = RuComm(
	"mm-decompress-proofs", "misc", "decompress Metamath proofs", "", [],
	mmRunMmDecompressProofs
);


mmRunMmCompressProofs(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.mmMath;
	conf = env.conf;
	arities = fold(mmOrderSources(math), makeTree(), \acc, src ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__,hyps, __, stat): 
					setTree(ac, stat.label, length(hyps));
				default: ac;
			}
		)
	);
	Some(RuState(env with 
		mmMath = mmMathRelabel(MmMath(math with 
			sources = mapTree(math.sources, \src -> 
				MmSource(src with 
					//decls = ruConcurrent(map(src.decls, 
					decls = ruSequential(map(src.decls, 
						\decl -> \ -> mmCompressDeclCheck(decl, math, conf, arities)
					))
				)
			)
		))
	));
}

mmRunMmDecompressProofs(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.mmMath;
	conf = env.conf;
	arities = fold(mmOrderSources(math), makeTree(), \acc, src ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__,hyps, __, stat): 
					setTree(ac, stat.label, length(hyps));
				default: ac;
			}
		)
	);
	Some(RuState(env with 
		mmMath = mmMathRelabel(MmMath(math with 
			sources = mapTree(math.sources, \src -> 
				MmSource(src with 
					decls = ruConcurrent(map(src.decls, 
						\decl -> \ -> mmDecompressDecl(decl, arities)
					))
				)
			)
		))
	));
}

ruCommMm2Ru = RuComm(
	"mm-to-ru", "translate", "translate Metamath to Russell", "file",
	[
		RuCommArg("file", false, "input file", ""),
		RuCommArg("fix-left-recursion", true, "fix left recursive grammar rules", "1")
	],
	mmRunMm2Ru
);

mmRunMm2Ru(task : ScTask, env : RuState) -> Maybe<RuState> {
	fix_left_recursion = lookupTreeDef(task.args, "fix-left-recursion", "1");
	maybeMap(mm2ru(env.mmMath, env.conf),
		\math -> {
			new_math = if (fix_left_recursion == "0") {
				math 
			} else {
				if (env.conf.verbose > 0) {
					env.conf.onMessage("ru left-recursive rules are fixed");
				}
				ruFixLeftRecursion(math);
			}
			RuState(env with ruMath = new_math)
		}
	);
}