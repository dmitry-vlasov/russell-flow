import mm/parse/comms;
import mm/refactor/comms;
import mm/mm2ru;
import mm/verify;

export {
	mmCommands = concat3(
		mmIoCommands, 
		mmRefactorCommands,
		[
			mmCommMm2Ru, 
			mmCommMmCompressProofs,
			mmCommMmDecompressProofs,
			mmCommVerifyMm
		]
	);
}

mmCommMmCompressProofs = RuComm(
	"mm-compress-proofs", "misc", "compress Metamath proofs", "", [],
	mmRunMmCompressProofs
);

mmCommMmDecompressProofs = RuComm(
	"mm-decompress-proofs", "misc", "decompress Metamath proofs", "", [],
	mmRunMmDecompressProofs
);

mmRunMmCompressProofs(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.mmMath;
	conf = env.conf;
	start = ruTime();
	arities = fold(mmOrderSources(math), makeTree(), \acc, src ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__,hyps, __, stat): 
					setTree(ac, stat.label, length(hyps));
				default: ac;
			}
		)
	);
	counter = ref 0;
	new_math = mmMathRelabel(MmMath(math with 
		sources = mapTree(math.sources, \src -> 
			MmSource(src with 
				decls = ruConcurrent(map(src.decls, 
				//decls = ruSequential(map(src.decls, 
					\decl -> \ -> {
						ret : MmDecl = mmCompressDecl(decl, math, conf, arities);
						if (ret != decl) { atomicRefIntAddition(counter, 1); { } }
						/*dec = mmDecompressDecl(ret, arities);
						if (decl != dec) {
							conf.onMessage("PROOFS DIFFER");
							conf.onMessage("original:\n" + mm2s(decl));
							conf.onMessage("compressed:\n" + mm2s(ret));
							conf.onMessage("decompressed:\n" + mm2s(dec));
							if (!mmVerifyDecl(dec, math, conf)) {
								quit(0);
							}
						} else {
							switch (decl) {
								MmAssertion(__,__,__, stat): {
									//conf.onMessage("PROOF " + id2s(stat.label) + " IS OK");
									//if (stat.label == s2id("quartlem2")) {
									//	conf.onMessage("PROOFS quartlem2");
									//	conf.onMessage("original:\n" + mm2s(decl));
									//	conf.onMessage("compressed:\n" + mm2s(ret));
									//	conf.onMessage("decompressed:\n" + mm2s(dec));
									//}
								}
								default: { }
							}
						}*/
						ret;
					}
				))
			)
		)
	));
	if (conf.verbose > 0) {
		conf.onMessage("mm compressed " + i2s(^counter) + " proofs in " + ruTime2s(ruTime() - start));
	}
	Some(RuState(env with mmMath = new_math));
}

mmRunMmDecompressProofs(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.mmMath;
	conf = env.conf;
	start = ruTime();
	arities = fold(mmOrderSources(math), makeTree(), \acc, src ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__,hyps, __, stat): 
					setTree(ac, stat.label, length(hyps));
				default: ac;
			}
		)
	);
	counter = ref 0;
	new_math = mmMathRelabel(MmMath(math with 
			sources = mapTree(math.sources, \src -> 
				MmSource(src with 
					decls = ruConcurrent(map(src.decls, 
					//decls = ruSequential(map(src.decls,
						\decl -> \ -> {
							ret : MmDecl = mmDecompressDecl(decl, arities);
							if (ret != decl) { atomicRefIntAddition(counter, 1); {} }
							/*dec = mmCompressDeclCheck(ret, math, conf, arities);
							if (decl != dec) {
								conf.onMessage("PROOFS DIFFER");
								conf.onMessage("original:\n" + mm2s(decl));
								conf.onMessage("decompressed:\n" + mm2s(ret));
								conf.onMessage("recompressed:\n" + mm2s(dec));
								quit(0);
							}*/
							ret;
						}
					))
				)
			)
		));
	if (conf.verbose > 0) {
		conf.onMessage("mm decompressed " + i2s(^counter) + " proofs in " + ruTime2s(ruTime() - start));
	}
	Some(RuState(env with mmMath = new_math));
}

mmCommMm2Ru = RuComm(
	"mm-to-ru", "translate", "translate Metamath to Russell", "file",
	[
		RuCommArg("file", false, "input file", ""),
		RuCommArg("fix-left-recursion", true, "fix left recursive grammar rules", "1")
	],
	mmRunMm2Ru
);

mmRunMm2Ru(task : ScTask, env : RuState) -> Maybe<RuState> {
	fix_left_recursion = lookupTreeDef(task.args, "fix-left-recursion", "1");
	maybeMap(mm2ru(env.mmMath, env.conf),
		\math -> {
			new_math = if (fix_left_recursion == "0") {
				math 
			} else {
				if (env.conf.verbose > 0) {
					env.conf.onMessage("ru left-recursive rules are fixed");
				}
				ruFixLeftRecursion(math);
			}
			RuState(env with ruMath = new_math)
		}
	);
}