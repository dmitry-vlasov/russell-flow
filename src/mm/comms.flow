import mm/parse/comms;
import mm/refactor/comms;
import mm/mm2ru;
import mm/verify;

export {
	mmCommands = concat3(
		mmIoCommands, 
		mmRefactorCommands,
		[
			mmCommMm2Ru, 
			mmCommMmCompressProofs,
			mmCommMmDecompressProofs,
			mmCommVerifyMm
		]
	);
}

mmCommMmCompressProofs = RuComm(
	RuCommDescr("mm-compress-proofs", "misc", "compress Metamath proofs", "", false, [], []),
	mmRunMmCompressProofs
);

mmCommMmDecompressProofs = RuComm(
	RuCommDescr("mm-decompress-proofs", "misc", "decompress Metamath proofs", "", false, [], []),
	mmRunMmDecompressProofs
);

mmRunMmCompressProofs(task : ScTask, env : RuState) -> Maybe<RuState> {
	sources = env.mm;
	conf = env.conf;
	timer = ruMakeTimer();
	arities = fold(mmOrderSources(sources), makeTree(), \acc, src ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__,hyps, __, stat): 
					setTree(ac, stat.label, length(hyps));
				default: ac;
			}
		)
	);
	structs = mmSources2structs(sources);
	counter = ref 0;
	compressed = mapTree(sources, \src -> 
		MmSource(src with 
			decls = ruConcurrent(map(src.decls, 
			//decls = ruSequential(map(src.decls, 
				\decl -> \ -> {
					ret : MmDecl = mmCompressDecl(decl, sources, structs, conf, arities);
					if (ret != decl) { atomicRefIntAddition(counter, 1); { } }
					/*dec = mmDecompressDecl(ret, arities);
					if (decl != dec) {
						conf.onMessage("PROOFS DIFFER");
						conf.onMessage("original:\n" + mm2s(decl));
						conf.onMessage("compressed:\n" + mm2s(ret));
						conf.onMessage("decompressed:\n" + mm2s(dec));
						if (!mmVerifyDecl(dec, math, conf)) {
							quit(0);
						}
					} else {
						switch (decl) {
							MmAssertion(__,__,__, stat): {
								//conf.onMessage("PROOF " + id2s(stat.label) + " IS OK");
								//if (stat.label == s2id("quartlem2")) {
								//	conf.onMessage("PROOFS quartlem2");
								//	conf.onMessage("original:\n" + mm2s(decl));
								//	conf.onMessage("compressed:\n" + mm2s(ret));
								//	conf.onMessage("decompressed:\n" + mm2s(dec));
								//}
							}
							default: { }
						}
					}*/
					ret;
				}
			))
		)
	);
	if (ruVerbose(conf) > 0) {
		conf.onMessage("mm compressed " + i2s(^counter) + " proofs in " + ruTimePassed2s(timer));
	}
	Some(RuState(env with mm = compressed));
}

mmRunMmDecompressProofs(task : ScTask, env : RuState) -> Maybe<RuState> {
	sources = env.mm;
	conf = env.conf;
	timer = ruMakeTimer();
	arities = fold(mmOrderSources(sources), makeTree(), \acc, src ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__,hyps, __, stat): 
					setTree(ac, stat.label, length(hyps));
				default: ac;
			}
		)
	);
	counter = ref 0;
	decompressed = mapTree(sources, \src -> 
		MmSource(src with 
			decls = ruConcurrent(map(src.decls, 
			//decls = ruSequential(map(src.decls,
				\decl -> \ -> {
					ret : MmDecl = mmDecompressDecl(decl, arities);
					if (ret != decl) { atomicRefIntAddition(counter, 1); {} }
					/*dec = mmCompressDeclCheck(ret, math, conf, arities);
					if (decl != dec) {
						conf.onMessage("PROOFS DIFFER");
						conf.onMessage("original:\n" + mm2s(decl));
						conf.onMessage("decompressed:\n" + mm2s(ret));
						conf.onMessage("recompressed:\n" + mm2s(dec));
						quit(0);
					}*/
					ret;
				}
			))
		)
	);
	if (ruVerbose(conf) > 0) {
		conf.onMessage("mm decompressed " + i2s(^counter) + " proofs in " + ruTimePassed2s(timer));
	}
	Some(RuState(env with mm = decompressed));
}

mmCommMm2Ru = RuComm(
	RuCommDescr(
		"mm-to-ru", "translate", "translate Metamath to Russell", "file", true,
		[
			RuCommArg("file", false, "input file", ""),
			RuCommArg("fix-left-recursion", true, "fix left recursive grammar rules", "1")
		], []
	),
	mmRunMm2Ru
);

mmRunMm2Ru(task : ScTask, env : RuState) -> Maybe<RuState> {
	fix_left_recursion = lookupTreeDef(task.args, "fix-left-recursion", "1");
	conf = env.conf;
	maybeMap(mm2ru(env.mm, conf),
		\math -> {
			new_math = if (fix_left_recursion == "0") {
				math 
			} else {
				if (ruVerbose(conf) > 0) {
					conf.onMessage("ru left-recursive rules are fixed");
				}
				ruFixLeftRecursion(math);
			}
			RuState(env with ru = new_math.sources)
		}
	);
}