import mm/math;

export {
	mmMath2SingleSource(math : MmMath, file : string, conf : RuConf) -> MmSource;
	mmFindLeafSources(math : MmMath) -> [MmSource];
	mmMathAssertions(math : MmMath) -> [MmAssertion];
	mmMathAxiomatic(math : MmMath) -> [MmAssertion];
	mmMathProvable(math : MmMath) -> [MmAssertion];
	mmMathStats(math : MmMath) -> string;
	mmMathRelabel(math : MmMath) -> MmMath;
	mmOrderSources(math : MmMath) -> [MmSource];
}

mmFindLeafSources(math : MmMath) -> [MmSource] {
	filter(getTreeValues(math.sources), \src -> src.imports == [])
}

mmMath2SingleSource(math : MmMath, file : string, conf : RuConf) -> MmSource {
	MmSource([],
		concatA(foldTree(math.sources, Pair([[]], makeSet()), \__,src, acc ->
			mmMathCollectSource(src, math, acc)
		).first),
		ruMakeFileInfo(file, conf)
	);
}

mmMathCollectSource(src : MmSource, math : MmMath, acc : Pair<[[MmDecl]], Set<int>>) -> Pair<[[MmDecl]], Set<int>> {
	if (containsSet(acc.second, src.info.id)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.id)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.module)) {
					Some(inc_src): mmMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, [src.decls]), acc1.second)
	}
}

mmMathAssertions(math : MmMath) -> [MmAssertion] {
	filtermap(getTreeValues(math.labeled), \lab ->
		switch (lab) {
			MmAssertion(__,__,__,__): Some(lab);
			default: None();
		}
	);
}

mmMathAxiomatic(math : MmMath) -> [MmAssertion] {
	filter(mmMathAssertions(math), \ass ->
		switch (ass.stat) {
			MmAxiomatic(__,__): true;
			default: false;
		}
	);
}

mmMathProvable(math : MmMath) -> [MmAssertion] {
	filter(mmMathAssertions(math), \ass ->
		switch (ass.stat) {
			MmProvable(__,__,__): true;
			default: false;
		}
	);
}

mmMathStats(math : MmMath) -> string {
	strGlue([
		"sources:     " + i2s(sizeTree(math.sources)),
		"consts:      " + i2s(sizeSet(math.consts)),
		"labeled:     " + i2s(sizeTree(math.labeled)),
		"assertions:  " + i2s(length(mmMathAssertions(math))),
		"  axiomatic: " + i2s(length(mmMathAxiomatic(math))),
		"  provable:  " + i2s(length(mmMathProvable(math))),
	], "\n")
}

mmMathRelabel(math : MmMath) -> MmMath {
	add_hyps = \ac, hs -> fold(hs, ac, \a, h : MmHyp -> setTree(a, h.label, h));
	labeled = foldTree(math.sources, makeTree(), \__,src, acc ->
		fold(src.decls, acc, \ac, decl : MmDecl -> 
			switch (decl) {
				MmAssertion(__,hyps, inner, stat): 
					add_hyps(add_hyps(setTree(ac, stat.label, decl), inner), hyps);
				default: ac;
			}
		)
	);
	MmMath(math with labeled = labeled;)
}

mmOrderSources(math : MmMath) -> [MmSource] {
	mmDoOrderSources(getTreeValues(math.sources), [], makeSet());
}

mmDoOrderSources(srcs : [MmSource], acc : [MmSource], visited: Set<int>) -> [MmSource] {
	new_level = filter(srcs, \src -> forall(src.imports, \imp -> containsSet(visited, imp.module)));
	level_names = buildSet(map(new_level, \src -> src.info.id));
	if (new_level == []) {
		if (length(srcs) == 0) acc else {
			println("Cycilc imports detected:\n" + strIndent(strGlue(map(srcs, \src -> id2s(src.info.id)), "\n")));
			[]
		};
	} else {
		new_srcs = filter(srcs, \src -> !containsSet(level_names, src.info.id));
		mmDoOrderSources(new_srcs, concat(acc, new_level), mergeSets(visited, level_names));
	}
}