import mm/verify;

export {
	mmDecompressProof(proof : MmProof, hyps : [MmHyp], arities : Tree<int, int>) -> MmNormalProof;
	mmDecompressAssertion(ass : MmAssertion, arities : Tree<int, int>) -> MmAssertion;
	mmDecompressDecl(decl : MmDecl, arities : Tree<int, int>) -> MmDecl;

	mmCompressDecl(decl : MmDecl, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmDecl;
	mmCompressAssertion(ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmAssertion;
	mmCompressProof(labels : [int], ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmCompressedProof;
}

mmDecompressDecl(decl : MmDecl, arities : Tree<int, int>) -> MmDecl {
	switch (decl) {
		MmAssertion(__,__,__,__): mmDecompressAssertion(decl, arities);
		default: decl;
	}
}

mmDecompressAssertion(ass : MmAssertion, arities : Tree<int, int>) -> MmAssertion {
	switch (ass.stat) {
		MmAxiomatic(__,__): ass;
		MmProvable(l, ex, proof): 
			MmAssertion(ass with 
				stat = MmProvable(l, ex, mmDecompressProof(proof, ass.hyps, arities))
			);
	}
}

MmDecompressAcc(
	decompressed : [int],
	subexprs : [[int]]
);

mmDecompressProof(proof : MmProof, hyps : [MmHyp], arities : Tree<int, int>) -> MmNormalProof {
	switch (proof) {
		MmNormalProof(__): proof;
		MmCompressedProof(labels, steps): {
			len_cache = ref makeTree();
			MmNormalProof(fold(steps, MmDecompressAcc([],[]), \acc, s ->
				switch (s) {
					MmProofIndex(i): {
						if (i < length(hyps)) {
							MmDecompressAcc(acc with decompressed = concat(acc.decompressed, [hyps[i].label]));
						} else {
							j = i - length(hyps);
							if (j < length(labels)) {
								MmDecompressAcc(acc with decompressed = concat(acc.decompressed , [labels[j]]));
							} else {
								k = j - length(labels);
								MmDecompressAcc(acc with decompressed = concat(acc.decompressed , acc.subexprs[k]));
							}
						}
					}
					MmProofZ(): {
						len = mmSubexprLength(length(acc.decompressed) - 1, acc.decompressed, arities, len_cache);
						subexpr = subrange(acc.decompressed, length(acc.decompressed) - len, len);
						MmDecompressAcc(acc with subexprs = concat(acc.subexprs, [subexpr]));
					}
				}
			).decompressed);
		}
	}
}

mmSubexprLength(i : int, labels : [int], arities : Tree<int, int>, len_cache : ref Tree<int, int>) -> int {
	switch (lookupTree(^len_cache, i)) {
		Some(len): len;
		None(): {
			len = switch (lookupTree(arities, labels[i])) {
				Some(arity): mmSubexprArgsLength(i - 1, 1, arity, labels, arities, len_cache);
				None(): 1;
			}
			len_cache := setTree(^len_cache, i, len);
			len;
		}
	}
}

mmSubexprArgsLength(i : int, acc : int, arg : int, labels : [int], arities : Tree<int, int>, len_cache : ref Tree<int, int>) -> int {
	if (arg == 0) acc else {
		arg_len = mmSubexprLength(i, labels, arities, len_cache);
		mmSubexprArgsLength(i - arg_len, acc + arg_len, arg - 1, labels, arities, len_cache)
	}
}


MmCompressStackItem(
	expr : MmExp,
	len : int
);

noCompressStackItem = MmCompressStackItem(MmExp([]), -1);

MmExecutionAcc1(
	stack : List<MmCompressStackItem>,
	essentials : List<MmExpPair>,
	subst : Tree<int, MmExp>,
	len : int
);


mmPickFromStack1(stack : List<MmCompressStackItem>, hyps : [MmHyp], conf : RuConf) -> MmExecutionAcc1 {
	fold(hyps, MmExecutionAcc1(stack, makeList(), makeTree(), 0), \acc, hyp -> {
		item = headList(acc.stack, noCompressStackItem);
		switch (hyp) {
			MmEssential(__, expr):
				MmExecutionAcc1(
					tailList(acc.stack), 
					Cons(MmExpPair(item.expr, expr), acc.essentials), 
					acc.subst,
					acc.len + item.len
				);
			MmFloating(__, type, var): {
				MmExecutionAcc1(
					tailList(acc.stack),
					acc.essentials,
					setTree(acc.subst, var, MmExp(tail(item.expr.symbs))),
					acc.len + item.len
				);
			}
		}
	});
}

// Do not check, just perform a single step
mmExecuteRPNstep(label : int, stack : List<MmCompressStackItem>, entities : Tree<int, MmLabeled>, theorem : MmAssertion, conf : RuConf) -> List<MmCompressStackItem> {
	switch (lookupTreeDef(entities, label, mmNoAssertion)) {
		MmAssertion(disj, hyps, inner, statement): {
			exec_acc = mmPickFromStack1(stack, reverseA(hyps), conf);
			Cons(
				MmCompressStackItem(
					mmApplySubst(statement.expr, exec_acc.subst),
					exec_acc.len + 1
				), 
				exec_acc.stack
			);
		}
		MmEssential(__, expr): {
			Cons(
				MmCompressStackItem(expr, 1), 
				stack
			);
		}
		MmFloating(__, type, var): {
			Cons(
				MmCompressStackItem(MmExp([MmSymb(type, false), MmSymb(var, true)]), 1), 
				stack
			);
		}
	}
}

MmProofExprFeatures(
	occurrences : [int],
	length : int
);

mmProofExprsFeatures(proof : [int], ass : MmAssertion, math : MmMath, conf : RuConf) -> Tree<MmExp, MmProofExprFeatures> {
	foldi(proof, Pair(makeList(), makeTree()),
		\i, acc, label -> {
			stack = mmExecuteRPNstep(label, acc.first, math.labeled, ass, conf);
			top = headList(stack, noCompressStackItem);
			features = lookupTreeDef(acc.second, top.expr, MmProofExprFeatures([], top.len));
			Pair(
				stack, 
				setTree(acc.second, top.expr, 
					MmProofExprFeatures(features with occurrences = concat(features.occurrences, [i]))
				)
			);
		}
	).second;
}


/*mmCountExprsInProof(proof : [int], ass : MmAssertion, math : MmMath, conf : RuConf) -> Tree<MmExp, int> {
	fold(proof, Pair(makeList(), makeTree()),
		\acc, label -> {
			stack = mmExecuteRPNstep(label, acc.first, math.labeled, ass, conf);
			ex = headList(stack, noCompressStackItem).expr;
			Pair(stack, setTree(acc.second, ex, lookupTreeDef(acc.second, ex, 0) + 1));
		}
	).second;
}*/

MmProofCompressionAcc(
	stack : List<MmCompressStackItem>,
	compressed : [MmCompressedStep],
	steps : Tree<MmExp, int>
);

mmCompressDecl(decl : MmDecl, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmDecl {
	switch (decl) {
		MmAssertion(__,__,__,__): mmCompressAssertion(decl, math, conf, arities);
		default: decl;
	}
}

mmCompressAssertion(ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmAssertion {
	switch (ass.stat) {
		MmAxiomatic(__,__): ass;
		MmProvable(thm, expr, proof): {
			switch (proof) {
				MmCompressedProof(__,__): ass;
				MmNormalProof(labels): {
					MmAssertion(ass with
						stat = MmProvable(thm, expr,  mmCompressProof(labels, ass, math, conf, arities))
					);
				}
			}
		}
	}
}

mmCompressProof(labels : [int], ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmCompressedProof {
	stack_top = \st -> switch (st) { 
		Cons(e, __): e; 
		EmptyList(): MmExp([]); 
	}
	labs = concat(
		map(ass.inner, \inn -> inn.label), 
		filter(uniq(labels), \lab -> !(exists(ass.hyps, \hyp -> hyp.label == lab) || exists(ass.inner, \inn -> inn.label == lab)))
	);
	arity0 = length(ass.hyps);
	arity1 = length(ass.inner);
	arity2 = length(labs);
	labs_map = foldi(labs, makeTree(), \i, acc, lab -> setTree(acc, lab, i));
	exps_features = mmProofExprsFeatures(labels, ass, math, conf);
	compressed = foldi(labels, MmProofCompressionAcc(makeList(), [], makeTree()),
		\i, acc, label -> {
		stack = mmExecuteRPNstep(label, acc.stack, math.labeled, ass, conf);
		ex = headList(stack, noCompressStackItem).expr;
		switch (findi(ass.hyps, \hyp -> hyp.label == label)) {
			Some(k): {
				MmProofCompressionAcc(stack, 
					concat(acc.compressed, [MmProofIndex(k)]),
					acc.steps
				);
			}
			None(): {
				switch (findi(ass.inner, \inn -> inn.label == label)) {
					Some(k): {
						MmProofCompressionAcc(stack, 
							concat(acc.compressed, [MmProofIndex(arity0 + k)]),
							acc.steps
						);
					}
					None(): {
						switch (lookupTree(labs_map, label)) {
							Some(k): {
								switch (lookupTree(acc.steps, ex)) {
									Some(n): {
										len = mmSubexprArgsLength1(
											length(acc.compressed) - 1, 
											0, 
											lookupTreeDef(arities, label, -1), 
											labs, acc.compressed, arities, arity0, arity1, arity2
										);
										MmProofCompressionAcc(
											stack, 
											concat(take(acc.compressed, length(acc.compressed) - len), [MmProofIndex(n)]), 
											acc.steps
										);
									}
									None(): {
										if (length(lookupTreeDef(exps_features, ex, MmProofExprFeatures([], 0)).occurrences) == 1) {
											MmProofCompressionAcc(stack, 
												concat(acc.compressed, [MmProofIndex(arity0 + k)]),
												acc.steps
											);
										} else {
											MmProofCompressionAcc(stack, 
												concat(acc.compressed, [MmProofIndex(arity0 + k), MmProofZ()]),
												setTree(acc.steps, ex, sizeTree(acc.steps) + arity0 + arity2)
											);
										}
									}
								}
							}
							None(): {
								println("MUST NOT HAPPEN (A), unknown label: " + id2s(label));
								quit(0);
								acc;
							}
						}
					}
				}
			}
		}
	}).compressed;
	MmCompressedProof(labs, compressed);
}

mmSubexprLength1(i : int, labs : [int], steps : [MmCompressedStep], arities : Tree<int, int>, arity0 : int, arity1 : int, arity2 : int) -> int {
	switch (steps[i]) {
		MmProofIndex(k): {
			if (k < arity0 + arity1 || k >= arity0 + arity2) 1 else {
				switch (lookupTree(arities, labs[k - arity0])) {
					Some(arity): mmSubexprArgsLength1(i - 1, 1, arity, labs, steps, arities, arity0, arity1, arity2);
					None(): { println("MUST NOT HAPPEN (B): " + id2s(labs[k - arity0])); quit(0); 1; }
				}
			}
		}
		MmProofZ(): 1;
	}
}

mmSubexprArgsLength1(i : int, acc : int, arg : int, labs : [int], steps : [MmCompressedStep], arities : Tree<int, int>, arity0 : int, arity1 : int, arity2 : int) -> int {
	if (arg == 0) acc else {
		arg_len = mmSubexprLength1(i, labs, steps, arities, arity0, arity1, arity2);
		mmSubexprArgsLength1(i - arg_len, acc + arg_len, arg - 1, labs, steps, arities, arity0, arity1, arity2)
	}
}
