import mm/verify;

export {
	mmDecompressProof(proof : MmProof, hyps : [MmHyp], arities : Tree<int, int>) -> MmNormalProof;
	mmDecompressAssertion(ass : MmAssertion, arities : Tree<int, int>) -> MmAssertion;
	mmDecompressDecl(decl : MmDecl, arities : Tree<int, int>) -> MmDecl;

	mmCompressDecl(decl : MmDecl, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmDecl;
	mmCompressAssertion(ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmAssertion;
	mmCompressProof(labels : [int], ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmCompressedProof;
}

mmDecompressDecl(decl : MmDecl, arities : Tree<int, int>) -> MmDecl {
	switch (decl) {
		MmAssertion(__,__,__,__): mmDecompressAssertion(decl, arities);
		default: decl;
	}
}

mmDecompressAssertion(ass : MmAssertion, arities : Tree<int, int>) -> MmAssertion {
	switch (ass.stat) {
		MmAxiomatic(__,__): ass;
		MmProvable(l, ex, proof): 
			MmAssertion(ass with 
				stat = MmProvable(l, ex, mmDecompressProof(proof, ass.hyps, arities))
			);
	}
}

MmStepLen(
	step : int,
	len : int // length of corresponding subproof in decompressed proof
);

MmDecompressAcc(
	decompressed : [MmStepLen],
	subexprs : [[MmStepLen]]
);

mmDecompressProof(proof : MmProof, hyps : [MmHyp], arities : Tree<int, int>) -> MmNormalProof {
	switch (proof) {
		MmNormalProof(__): proof;
		MmCompressedProof(labels, steps): {
			decompressed = fold(steps, MmDecompressAcc([], []), \acc, i ->
				if (i >= 0) {
					if (i < length(hyps)) {
						MmDecompressAcc(acc with 
							decompressed = concat(acc.decompressed, 
								[MmStepLen(hyps[i].label, 1)]
							)
						);
					} else {
						j = i - length(hyps);
						if (j < length(labels)) {
							arity = lookupTreeDef(arities, labels[j], -1);
							if (arity == -1) {
								// Case of inner floating variable declaration
								MmDecompressAcc(acc with 
									decompressed = concat(acc.decompressed, 
										[MmStepLen(labels[j], 1)]
									)
								);
							} else {
								MmDecompressAcc(acc with 
									decompressed = concat(acc.decompressed, 
										[MmStepLen(
											labels[j], 
											mmCalcSubproofLen(
												length(acc.decompressed) - 1, 
												arity, 1, acc.decompressed
											)
										)]
									)
								);
							}
						} else {
							k = j - length(labels);
							subexpr = acc.subexprs[k];
							MmDecompressAcc(acc with 
								decompressed = concat(acc.decompressed, subexpr)
							);
						}
					}
				} else {
					len = lastElement(acc.decompressed, MmStepLen(0, 0)).len;
					subexpr = subrange(acc.decompressed, length(acc.decompressed) - len, len);
					MmDecompressAcc(acc with subexprs = concat(acc.subexprs, [subexpr]));
				}
			).decompressed;
			MmNormalProof(map(decompressed, \s -> s.step));
		}
	}
}

mmCalcSubproofLen(i : int, arity : int, acc : int, steps : [MmStepLen]) -> int {
	if (arity == 0) acc else {
		arg_len = steps[i].len;
		mmCalcSubproofLen(i - arg_len, arity - 1, acc + arg_len, steps);
	}
}


MmExecutionAcc1(
	stack : List<MmExp>,
	essentials : List<MmExpPair>,
	subst : Tree<int, MmExp>
);

mmPickFromStack1(stack : List<MmExp>, hyps : [MmHyp], conf : RuConf) -> MmExecutionAcc1 {
	fold(hyps, MmExecutionAcc1(stack, makeList(), makeTree()), \acc, hyp -> {
		e = headList(acc.stack, MmExp([]));
		switch (hyp) {
			MmEssential(__, expr):
				MmExecutionAcc1(
					tailList(acc.stack), 
					Cons(MmExpPair(e, expr), acc.essentials), 
					acc.subst
				);
			MmFloating(__, type, var): {
				MmExecutionAcc1(
					tailList(acc.stack),
					acc.essentials,
					setTree(acc.subst, var, MmExp(tail(e.symbs)))
				);
			}
		}
	});
}

// Do not check, just perform a single step
mmExecuteRPNstep(label : int, stack : List<MmExp>, entities : Tree<int, MmLabeled>, theorem : MmAssertion, conf : RuConf) -> List<MmExp> {
	switch (lookupTreeDef(entities, label, mmNoAssertion)) {
		MmAssertion(disj, hyps, inner, statement): {
			exec_acc = mmPickFromStack1(stack, reverseA(hyps), conf);
			Cons(mmApplySubst(statement.expr, exec_acc.subst), exec_acc.stack);
		}
		MmEssential(__, expr): {
			Cons(expr, stack);
		}
		MmFloating(__, type, var): {
			Cons(MmExp([MmSymb(type, false), MmSymb(var, true)]), stack);
		}
	}
}

mmCountExprsInProof(proof : [int], ass : MmAssertion, math : MmMath, conf : RuConf) -> Tree<MmExp, int> {
	fold(proof, Pair(makeList(), makeTree()),
		\acc, label -> {
			stack = mmExecuteRPNstep(label, acc.first, math.labeled, ass, conf);
			ex = headList(stack, MmExp([]));
			Pair(stack, setTree(acc.second, ex, lookupTreeDef(acc.second, ex, 0) + 1));
		}
	).second;
}

mmCompressDecl(decl : MmDecl, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmDecl {
	switch (decl) {
		MmAssertion(__,__,__,__): mmCompressAssertion(decl, math, conf, arities);
		default: decl;
	}
}

mmCompressAssertion(ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmAssertion {
	switch (ass.stat) {
		MmAxiomatic(__,__): ass;
		MmProvable(thm, expr, proof): {
			switch (proof) {
				MmCompressedProof(__,__): ass;
				MmNormalProof(labels): {
					MmAssertion(ass with
						stat = MmProvable(thm, expr,  mmCompressProof(labels, ass, math, conf, arities))
					);
				}
			}
		}
	}
}

MmProofCompressionAcc(
	stack : List<MmExp>,
	compressed : [MmStepLen],
	steps : Tree<MmExp, int>
);

mmCompressProof(labels : [int], ass : MmAssertion, math : MmMath, conf : RuConf, arities : Tree<int, int>) -> MmCompressedProof {
	level = s2i(lookupTreeDef(conf.opts, "mm-compress-level", "1"));
	labs = concat(
		map(ass.inner, \inn -> inn.label), 
		filter(uniq(labels), \lab -> !(exists(ass.hyps, \hyp -> hyp.label == lab) || exists(ass.inner, \inn -> inn.label == lab)))
	);
	hyps_map = foldi(concat(ass.hyps, ass.inner), makeTree(), \i, acc, hyp -> setTree(acc, hyp.label, i));
	labs_map = foldi(labs, makeTree(), \i, acc, lab -> setTree(acc, lab, length(ass.hyps) + i));
	N = length(ass.hyps) + sizeTree(labs_map);
	
	exps_counts = if (level == 0) makeTree() else mmCountExprsInProof(labels, ass, math, conf);
	calc_acc = \bad_steps -> 
		foldi(labels, MmProofCompressionAcc(makeList(), [], makeTree()), \i, acc, label -> {
			stack = mmExecuteRPNstep(label, acc.stack, math.labeled, ass, conf);
			ex = headList(stack, MmExp([]));
			switch (lookupTree(hyps_map, label)) {
				Some(k): {
					MmProofCompressionAcc(stack, 
						concat(acc.compressed, [MmStepLen(k, 1)]),
						acc.steps
					);
				}
				None(): {
					switch (lookupTree(labs_map, label)) {
						Some(k): {
							switch (lookupTree(acc.steps, ex)) {
								Some(n): {
									arity = lookupTreeDef(arities, label, -1);
									len = mmCalcSubproofLen(
										length(acc.compressed) - 1, 
										arity, 0, acc.compressed
									);
									MmProofCompressionAcc(
										stack, 
										concat(take(acc.compressed, length(acc.compressed) - len), [MmStepLen(n, 1)]), 
										acc.steps
									);
								}
								None(): {
									arity = lookupTreeDef(arities, label, -1);
									len = mmCalcSubproofLen(
										length(acc.compressed) - 1, 
										arity, 0, acc.compressed
									);
									if (lookupTreeDef(exps_counts, ex, 0) <= 1 || containsSet(bad_steps, ex)) {
										if (containsSet(bad_steps, ex)) {
											println("BAD STEP: " + mm2s(ex));
										}
										MmProofCompressionAcc(stack, 
											concat(acc.compressed, [MmStepLen(k, len)]),
											acc.steps
										);
									} else {
										MmProofCompressionAcc(stack, 
											concat(acc.compressed, [MmStepLen(k, len), MmStepLen(-1, 1)]),
											setTree(acc.steps, ex, sizeTree(acc.steps) + N)
										);
									}
								}
							}
						}
						None(): { println("MUST NOT HAPPEN (A), unknown label: " + id2s(label)); quit(0); acc; }
					}
				}
			}
		});
	acc1 = calc_acc(makeSet());
	steps_inds = buildSet(getTreeValues(acc1.steps));
	unused_inds = differenceSets(steps_inds, buildSet(map(acc1.compressed, \s -> s.step)));
	unused_exps = foldTree(acc1.steps, makeSet(), \ex, i, acc ->
		if (containsSet(unused_inds, i)) insertSet(acc, ex) else acc
	);
	if (sizeSet(unused_inds) > 0) {
		println("unused inds: [" + strGlue(map(set2array(unused_inds), i2s), ", ") + "] in " + id2s(ass.stat.label));
		println("hyps: " + i2s(length(ass.hyps)) + ", inner: " + i2s(length(ass.inner)) + ", labs: " + i2s(length(labs)) + ", N=" + i2s(N));
	}
	acc2 = calc_acc(unused_exps);
	steps_inds2 = buildSet(getTreeValues(acc2.steps));
	unused_inds2 = differenceSets(steps_inds2, buildSet(map(acc2.compressed, \s -> s.step)));
	if (sizeSet(unused_inds2) > 0) {
		println("unused inds2: " + i2s(sizeSet(unused_inds2)) + " in " + id2s(ass.stat.label));
		quit(0);
	}
	MmCompressedProof(labs, map(acc2.compressed, \s -> s.step));
}
