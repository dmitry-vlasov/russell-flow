import mm/parse/load;
import mm/parse/collect;
import mm/to_ru;
import mm/verify;

import command;

export {
	mmIoCommands : [RuComm] = [
		mmCommRead,
		mmCommWrite
	];
	mmRunRead(task : ScTask, env : RuState) -> Maybe<RuState>;
	mmRunWrite(task : ScTask, env : RuState) -> Maybe<RuState>;
}

mmCommRead = RuComm(
	"read-mm", "io", "read a Metamath file", "file",
	[RuCommArg("file", false, "input file", "")],
	mmRunRead
);

mmRunRead(task : ScTask, env : RuState) -> Maybe<RuState> {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".mm")) {
		env.conf.onError("Wrong extension of a file '" + file + "' , must be *.mm", []);
		None();
	} else {
		path = resolveRelativePath(file);
		module = ruTrimPath(path, env.conf, getFileExt(file));
		mm = maybeBind(mmLoad(env.conf, s2id(module)), \loaded ->
			maybeBind(mmParse(getTreeValues(loaded), env.conf), \parsed ->
				maybeBind(mmCollectMath(parsed, env.conf), \collected ->
					mmVerifyMath(collected, env.conf)
				)
			)
		);
		maybeMap(mm, \math -> RuState(env with mmMath = math));
	}
}

mmCommWrite = RuComm(
	"write-mm", "io", "write a Metamath file to a filesystem", "target",
	[
		RuCommArg("target", true, "write the mm file or 'all' (default)", "all"), 
		RuCommArg("monolithic", true, "include all dependencies into a target file", ""),
		RuCommArg("strip-comments", true, "self evident", ""),
		RuCommArg("test-write", true, "perform a test writing - do not save files", ""),
	],
	mmRunWrite
);

mmRunWrite(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.mmMath;
	conf = env.conf;
	test = lookupTreeDef(task.args, "test-write", "");
	write_mm = \src0 : MmSource -> {
		path = src0.info.path;
		if (test != "1") {
			dir = ruDirName(path);
			if (dir != "") {
				err = ensureDirectoryExists(dir);
				if (err != "") {
					conf.onError("failed to create directory: '" + dir + "', error: '" + err + "'", [RuPlace(src0.info.module, -1)]);
				}
			}
		}
		if (env.conf.verbose > 1) {
			conf.onMessage("\tmm writing : '" + path + "'");
		}
		src = if (lookupTreeDef(task.args, "strip-comments", "") == "1") mmStripComments(src0) else src0;
		if (test != "1") {
			if (!setFileContent(path, mm2s(src))) {
				conf.onError("error while writing '" + path + "'", [RuPlace(src.info.module, -1)]);
			}
		}
	}
	write_module = \module -> {
		switch (lookupTree(math.sources, module)) {
			Some(src): {
				monolith =lookupTreeDef(task.args, "monolithic", "");
				if (monolith == "") {
					write_mm(src);
				} else {
					if (monolith != "1") {
						write_mm(mmMath2SingleSource(env.mmMath, monolith, env.conf));
					} else {
						write_mm(mmMath2SingleSource(env.mmMath, src.info.path, env.conf));
					}
				}
			}
			None(): conf.onMessage("unknown module: '" + id2s(module) + "'");
		}
	}
	if (sizeTree(math.sources) == 0) {
		conf.onError("There are no Metamath sources at all.", []);
	} else {
		target = lookupTreeDef(task.args, "target", "");
		target_id = s2id(target);
		if (target == "all") {
			start = timestamp();
			iter(getTreeValues(math.sources), write_mm);
			time = (timestamp() - start);
			if (conf.verbose > 0 && time > 100.0) {
				conf.onMessage("mm written " + i2s(sizeTree(math.sources)) + " files in " + d2st(time/ 1000.0, 2) + "s");
			}
		} else if (containsKeyTree(math.sources, target_id)) {
			write_module(target_id);
		} else {
			module = ruTrimPath(target, conf, ".mm");
			if (containsKeyTree(math.sources, target_id)) {
				write_module(s2id(module));
			} else {
				conf.onError("Metamath source '" + target + "' is not found", []);
			}
		}
	}
	Some(env);
}
