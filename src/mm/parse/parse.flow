import ru/parse/load;
import mm/parse/file;
import mm/parse/ast;
import mm/src;

import lingo/pegcode/driver;

export {
	mmParse(loaded : [RuRawSource], conf : RuConf) -> Maybe<Tree<int, MmParseSource>>;
}

mmParse(loaded : [RuRawSource], conf0 : RuConf) -> Maybe<Tree<int, MmParseSource>> {
	err_count = ref 0;
	conf = ruAddErrCounter(conf0, err_count);
	start = ruTime();
	parsed = fold(
		filtermap(ruConcurrent(map(loaded, \l -> \-> mmParseSource(l, conf))), idfn),
		makeTree(),
		\acc, src -> setTree(acc, src.info.id, src)
	);
	if (ruVerbose(conf) > 0) {
		conf.onMessage("mm parsed " +i2s(sizeTree(parsed)) + " files in: " + ruTime2s(ruTime() - start));
	}
	if (^err_count == 0) {
		Some(parsed);
	} else {
		None();
	}
}

mmParseSource(loaded : RuRawSource, conf : RuConf) -> Maybe<MmParseSource> {
	start = ruTime();
	pr1 = parse_mm_source(loaded.src);
	st = pr1.first;
	err = pr1.second;
	if (st.end != strlen(loaded.src)) {
		conf.onError(
			"Syntax error:\n" + 
				"\t" + ruExpectError2s(err) + "\n" +
			"source:\n" +
				strIndent(ruHighlightErrorPos(loaded.src, st.end)), 
			[RuPlace(loaded.info.path, st.end)]
		);
		None()
	} else {
		parsed = mmMakeSrc(loaded, st, conf);
		if (ruVerbose(conf) > 1) {
			conf.onMessage("\tmm parsed: '" + loaded.info.module + "' in " + ruTime2s(ruTime() - start));
		}
		Some(parsed);
	}
}

mmMakeSrc(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmParseSource {
	synt_trees = get_mm_source_mm_element_s(st);
	toplevel = map(synt_trees,
		\elem -> {
			if (elem.rule == st_mm_rcomment) {
				mmMakeComment(loaded, elem, conf);
			} else if (elem.rule == st_mm_include) {
				mmMakeInclude(loaded, elem, conf);
			} else if (elem.rule == st_mm_const) {
				mmMakeConst(loaded, elem, conf);
			} else if (elem.rule == st_mm_vars) {
				mmMakeVars(loaded, elem, conf);
			} else if (elem.rule == st_mm_disj) {
				mmMakeDisj(loaded, elem, conf);
			} else if (elem.rule == st_mm_floating) {
				mmMakeFloating(loaded, elem, conf);
			} else if (elem.rule == st_mm_essential) {
				mmMakeEssential(loaded, elem, conf);
			} else if (elem.rule == st_mm_axiomatic) {
				mmMakeAxiomatic(loaded, elem, conf);
			} else if (elem.rule == st_mm_provable) {
				mmMakeProvable(loaded, elem, conf);
			} else if (elem.rule == st_mm_block) {
				mmMakeBlock(loaded, elem, conf);
			} else {
				// Shouldn't happen
				MmComment("");
			}
		}
	);
	imports = filtermap(synt_trees, \elem ->
		if (elem.rule != st_mm_include) None() else {
			Some(mmMakeInclude(loaded, elem, conf));
		} 
	);
	MmParseSource(imports, toplevel, loaded.info);
}

mmMakeComment(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmComment {
	text = grabSTText(get_mm_source_mm_comment_text(st), loaded.src);
	if (startsWith(ltrim(text), "Begin $[") || startsWith(ltrim(text), "End $[") || startsWith(ltrim(text), "Skip $[")) {
		MmComment("ignore " + text);
	} else {
		MmComment(text);
	}
}

mmMakeInclude(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmImport { 
	path = ruTrimPath(grabSTText(get_mm_source_mm_path(st), loaded.src), conf, ".mm");
	MmImport(s2id(path));
}

mmMakeConst(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmConst {
	MmConst(mmMakeSymbs(loaded, st, conf));
}

mmMakeVars(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmVars {
	MmVars(mmMakeSymbs(loaded, st, conf));
}

mmMakeDisj(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmDisj {
	MmDisj(mmMakeSymbs(loaded, st, conf));
}

mmMakeFloating(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmFloating {
	MmFloating(
		mmMakeLabel(loaded, get_mm_source_mm_label_sp(st), conf),
		mmMakeSymb(loaded, get_mm_source_mm_type(st), conf),
		mmMakeSymb(loaded, get_mm_source_mm_var(st), conf)
	);
}

mmMakeEssential(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmEssential {
	MmEssential(
		mmMakeLabel(loaded, get_mm_source_mm_label_sp(st), conf),
		mmMakeExpr(loaded, get_mm_source_mm_expr(st), conf)
	);
}

mmMakeAxiomatic(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmAxiomatic {
	MmAxiomatic(
		mmMakeLabel(loaded, get_mm_source_mm_label_sp(st), conf),
		mmMakeExpr(loaded, get_mm_source_mm_expr(st), conf)
	);
}

mmMakeProvable(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmProvable {
	MmProvable(
		mmMakeLabel(loaded, get_mm_source_mm_label_sp(st), conf),
		mmMakeExpr(loaded, get_mm_source_mm_expr(st), conf),
		mmMakeProof(loaded, get_mm_source_mm_proof(st), conf)
	);
}

mmMakeProof(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmProof {
	if (st.rule == st_mm_normal_proof) {
		MmNormalProof(mmMakeLabels(loaded, st, conf));
	} else {
		MmCompressedProof(
			mmMakeLabels(loaded, st, conf), 
			mmMakeSteps(loaded, get_mm_source_mm_step_s(st), conf)
		);
	}
}

mmMakeSteps(loaded : RuRawSource, st : [SyntaxTree], conf : RuConf) -> [int] {
	map(st, \s -> 
		if (s.rule == st_mm_index) {
			least = trim2(grabSTText(get_mm_source_mm_least_significant_digit(s), loaded.src), " \t\n\r");
			most = map(get_mm_source_mm_most_significant_digit_s(s), \d -> trim2(grabSTText(d, loaded.src), " \t\n\r"));
			ruDecompressInd(least, most);
		} else {
			-1;
		}
	)
}

mmMakeSymb(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> int {
	s2id(grabSTText(get_mm_source_mm_symb(st), loaded.src));
}

mmMakeSymbs(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> [int] {
	map(get_mm_source_mm_symb_sp_s(st), \w_sp -> 
		s2id(grabSTText(get_mm_source_mm_symb(w_sp), loaded.src))
	);
}

mmMakeExpr(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmExp {
	MmExp(map(get_mm_source_mm_symb_sp_s(st), \w_sp -> 
		MmSymb(s2id(grabSTText(get_mm_source_mm_symb(w_sp), loaded.src)), false)
	));
}

mmMakeLabel(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> int {
	s2id(grabSTText(get_mm_source_mm_label(st), loaded.src));
}

mmMakeLabels(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> [int] {
	map(get_mm_source_mm_label_sp_s(st), \l_sp -> 
		s2id(grabSTText(get_mm_source_mm_label(l_sp), loaded.src))
	);
}

mmMakeBlock(loaded : RuRawSource, st : SyntaxTree, conf : RuConf) -> MmBlock {
	MmBlock(map(get_mm_source_mm_element_s(st), \elem -> 
		if (elem.rule == st_mm_rcomment) {
			mmMakeComment(loaded, elem, conf);
		} else if (elem.rule == st_mm_include) {
			mmMakeInclude(loaded, elem, conf);
		} else if (elem.rule == st_mm_const) {
			mmMakeConst(loaded, elem, conf);
		} else if (elem.rule == st_mm_vars) {
			mmMakeVars(loaded, elem, conf);
		} else if (elem.rule == st_mm_disj) {
			mmMakeDisj(loaded, elem, conf);
		} else if (elem.rule == st_mm_floating) {
			mmMakeFloating(loaded, elem, conf);
		} else if (elem.rule == st_mm_essential) {
			mmMakeEssential(loaded, elem, conf);
		} else if (elem.rule == st_mm_axiomatic) {
			mmMakeAxiomatic(loaded, elem, conf);
		} else if (elem.rule == st_mm_provable) {
			mmMakeProvable(loaded, elem, conf);
		} else if (elem.rule == st_mm_block) {
			mmMakeBlock(loaded, elem, conf);
		} else {
			// should never happen
			ruCrash("unexpected MM syntax element");
			MmComment("");
		}
	));
}
