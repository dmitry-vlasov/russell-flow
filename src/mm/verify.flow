import mm/src_utils;
import command;

export {
	MmExpPair(
		fromStack : MmExp,
		fromHyp   : MmExp
	);
	mmCommVerifyMm : RuComm;
}

mmCommVerifyMm = RuComm(
	RuCommDescr(
		"mm-verify", "misc", "verify Metamath", "file", true, 
		[
			RuCommArg("file", true, "input file", ""),
			RuCommArg("stack-trace", true, "comma separated list of theorems, at which print a stack trace during verification", ""),
		], []
	),
	mmRunVerifyMm
);

mmRunVerifyMm(task : ScTask, env : RuState) -> Maybe<RuState> {
	sources = env.mm;
	conf = env.conf;
	stack_trace = map(filter(strSplit(lookupTreeDef(task.args, "stack-trace", ""), ","), isNotSpace), s2id);
	if (mmVerifyMath(sources, conf, stack_trace)) Some(env) else None();
}

mmVerifyMath(sources : Tree<int, MmSource>, conf0 : RuConf, stack_trace : [int]) -> bool {
	err_count = ref 0;
	conf = ruAddErrCounter(conf0, err_count);
	timer = ruMakeTimer();
	structs = mmSources2structs(sources); 
	verified = all(map(getTreeValues(sources), \s -> mmVerifySource(s, structs, conf, stack_trace)));
	if (ruVerbose(conf) > 0) {
		conf.onMessage("mm verified: " +i2s(sizeTree(sources)) + " files in " + ruTimePassed2s(timer));
	}
	^err_count == 0;
}

mmVerifySource(src : MmSource, structs : MmStructs, conf : RuConf, stack_trace : [int]) -> bool {
	timer = ruMakeTimer();
	ret = all(ruConcurrent(map(src.decls, \decl -> 
		\-> mmVerifyDecl(decl, structs, conf, stack_trace)
	)));
	if (ruVerbose(conf) > 1) {
		conf.onMessage("\tmm verified: '" + src.info.module + "' in " + ruTimePassed2s(timer));
	}
	ret;
}

mmVerifyDecl(decl : MmDecl, structs : MmStructs, conf : RuConf, stack_trace : [int]) -> bool {
	switch (decl) {
		MmAssertion(__,__,__,stat): 
			switch (stat) {
				MmProvable(__,__,__): mmVerifyAssertion(decl, structs, conf, stack_trace);
				default: true;
			}
		default: true;
	}
}

MmExecutionAcc(
	stack : List<MmExp>,
	essentials : List<MmExpPair>,
	subst : Tree<int, MmExp>
);

mmPickFromStack(stack : List<MmExp>, hyps : [MmHyp], conf : RuConf) -> Maybe<MmExecutionAcc> {
	fold(hyps, Some(MmExecutionAcc(stack, makeList(), makeTree())),
		\macc, hyp -> {
			maybeBind(macc,
				\acc -> {
					if (isEmptyList(acc.stack)) {
						conf.onError("empty stack in the middle of proof", []);
						None();
					} else {
						e = headList(acc.stack, MmExp([]));
						switch (hyp) {
							MmEssential(__, expr):
								Some(MmExecutionAcc(
									tailList(acc.stack), 
									Cons(MmExpPair(e, expr), acc.essentials), 
									acc.subst
								));
							MmFloating(__, type, var): {
								if (length(e.symbs) == 0) {
									conf.onError("empty expression on stack", []);
									None();
								} else {
									e_type = e.symbs[0].literal;
									if (e_type != type) {
										conf.onError("wrong type of expression on stack: " + id2s(e_type) + " != " + id2s(type), []);
										None()
									} else {
										e_expr = MmExp(tail(e.symbs));
										Some(MmExecutionAcc(
											tailList(acc.stack),
											acc.essentials,
											setTree(acc.subst, var, e_expr)
										));
									}
								}
							}
						}
					}
				}
			)
		}
	)
}

mmCheckSubstitution(subst : Tree<int, MmExp>, disj : [MmDisj], theorem : MmAssertion, conf : RuConf) -> bool {
	forall(disj, \dis -> {
			mapped = fold(dis.vars, [], 
				\acc, v -> switch(lookupTree(subst, v)) {
					Some(e): concat(acc, [e]);
					None(): acc;
				}
			);
			getVars = \e : MmExp -> fold(e.symbs, makeSet(), \acc, symb -> if (symb.isVar) insertSet(acc, symb.literal) else acc);
			foldi(mapped, true, \i, acc1, e1 -> 
				foldi(mapped, acc1, \j, acc2, e2 -> 
					if (j <= i || !acc2) acc2 else {
						vars1 = getVars(e1);
						vars2 = getVars(e2);
						if (!isEmptySet(intersectSets(vars1, vars2))) {
							conf.onError("expressions " + mm2s(e1) + " and " + mm2s(e2) + " have common vars - disjointed restrictions violation", []);
							false;
						} else {
							foldSet(vars1, true, \ac1, v1 ->
								foldSet(vars2, ac1, \ac2, v2 -> {
										ret = exists(theorem.disjs,
											\d -> contains(d.vars, v1) && contains(d.vars, v2)
										);
										if (!ret) {
											conf.onError("variables " + id2s(v1) + " and " + id2s(v2) + " are not inherently disjointed in theorem " + id2s(theorem.stat.label), []);
										}
										ret
									}
								)
							)
						}
					}
				)
			)
		}
	)
}

mmVerifyRPNstep(label : int, mstack : Maybe<List<MmExp>>, entities : Tree<int, MmLabeled>, theorem : MmAssertion, conf : RuConf) -> Maybe<List<MmExp>> {
	maybeBind(mstack, 
		\stack -> {
			switch (lookupTree(entities, label)) {
				Some(labeled): {
					switch (labeled) {
						MmAssertion(disj, hyps, inner, statement): {
							maybeBind(mmPickFromStack(stack, reverseA(hyps), conf),
								\acc -> {
									if (forall(list2array(acc.essentials), \pair -> {
											applied = mmApplySubst(pair.fromHyp, acc.subst);
											if (applied != pair.fromStack) {
												conf.onError("applied expression differs from stack value: " + mm2s(applied) + " != " + mm2s(pair.fromStack), []);
												false;
											} else {
												true;
											}
										}
									)) {
										applied = mmApplySubst(statement.expr, acc.subst);
										if (mmCheckSubstitution(acc.subst, disj, theorem, conf)) {
											Some(Cons(applied, acc.stack));
										} else {
											None();
										}
									} else {
										None();
									}
								}
							)
						}
						MmEssential(__, expr): Some(Cons(expr, stack));
						MmFloating(__, type, var): Some(Cons(MmExp([MmSymb(type, false), MmSymb(var, true)]), stack));
					}
				}
				None(): {
					conf.onError("unknown label: " + id2s(label), []);
					None();
				}
			}
		}
	)
}

mmVerifyAssertion(assertion : MmAssertion, structs : MmStructs, conf : RuConf, stack_trace : [int]) -> bool {
	ret = switch(assertion.stat) {
		MmAxiomatic(__,__): true;
		MmProvable(th_label, expr, proof): {
			trace = contains(stack_trace, th_label);
			if (trace) {
				conf.onMessage("Tracing verification stack of " + id2s(th_label));
			}
			switch (proof) {
				MmNormalProof(labels): {
					maybe_stack = fold(labels, Some(makeList()),
						\stack, label -> {
							if (trace) {
								conf.onMessage(id2s(label) + ":");
							}
							new_stack = mmVerifyRPNstep(label, stack, structs.labeled, assertion, conf);
							if (trace) {
								switch (new_stack) {
									Some(s): {
										conf.onMessage(
											strIndent(strGlue(map(list2array(s), mm2s), "\n")) + "\n"
										);
									}
									None(): conf.onMessage("\t<EMPTY STACK>\n");
								}
							}
							new_stack;
						}
					);
					eitherMap(maybe_stack,
						\stack -> {
							if (!isEmptyList(tailList(stack))) {
								conf.onError("non-empty stack at the end of proof", []);
								false;
							} else if (expr != headList(stack, MmExp([]))) {
								head = headList(stack, MmExp([]));
								conf.onError("expression on the top of the stack differs from provable expression: " + mm2s(expr) + " != " + mm2s(head), []);
								false;
							} else {
								true;
							}
						},
						false
					)
				}
				MmCompressedProof(__,__): {
					conf.onError("Decompress proofs before verification", []);
					quit(0);
					false;
				}
			}
		}
	};
	if (!ret) {
		conf.onError("proof of " + id2s(assertion.stat.label) + " is wrong", []);
	} else {
		if (ruVerbose(conf) > 2) {
			switch(assertion.stat) {
				MmProvable(__,__,__): conf.onMessage("theorem " + id2s(assertion.stat.label) + " is verified");
				default: {}
			}
		}
	}
	ret
}
