import ru_cache;
import ru_math;
import ru_log;

export {
	ruProcessInfo(math : RuMath) -> void;
}

ruProcessInfo(math : RuMath) -> void {
	if (ruOptIsTrue("outline", math.conf)) {
		ruInfoOutline(math);
	}  else {
		if (ruSomeOptsAreSet(["decl", "uses", "hover", "rename"], math.conf)) {
			if (!ruInfoTask(math, "decl", ruInfoDecl)) {
				if (!ruInfoTask(math, "hover", ruInfoHover)) {
					ruInfoTask(math, "uses", ruInfoUses);
					{}
				}
			}
		}
	}
}

ruInfoTask(math : RuMath, task_name : string, task_job : (string, RuMath) -> void) -> bool {
	opt = ruOpt(task_name, math.conf);
	if (opt == "") false else {
		line = s2i(ruOptDef("line", "-1", math.conf));
		col = s2i(ruOptDef("col", "-1", math.conf));
		name = if (opt != "1") opt else {
			if (line != -1 && col != -1) {
				ruNameByLineCol(line, col, getFileContent(math.conf.path));
			} else {
				ruPrintln("Provide line=<int> and col=<in> arguments", math.conf);
				""
			}
		}
		if (name != "") {
			task_job(name, math);
		}
		true;
	}
}

ruInfoDecl(name : string, math : RuMath) -> void {
	maybeApply(ruCachedDecl(name), \d ->
		maybeApply(ruFromCache(d.src, math.conf), \src -> {
			i = ruIndexOfDecl(name, src);
			end = if (i + 1 < length(src.decls)) {
				src.decls[i + 1].pos;
			} else {
				strlen(ruFileSource(src.info.file));
			}
			range = RuRange(d.decl.pos, end);
			ruPrintln(ruRange2s(src.info, range, "declaration of " + name), math.conf);
		}
	));
}

ruInfoHover(name : string, math : RuMath) -> void {
	maybeApply(ruCachedDecl(name), \d -> 
		ruPrintln(ruTrimAll(ruDecl2s(d.decl, math.rules)), math.conf)
	);
}

ruInfoOutline(math : RuMath) -> void {
	maybeApply(ruFromCache(math.conf.file, math.conf), \src -> {
		code = ruFileSource(src.info.file);
		iter(src.decls, \decl -> {
			switch (decl) {
				RuDecl(): {
					maybeApply(ruNameRangeByPos(ruDeclPos(decl), code),
						\range -> 
							ruPrintln(ruRange2s(src.info, range, ruDeclKind(decl) + " " + ruDeclName(decl)), math.conf)
					);
				}
				default: { }
			}
		});
	});
}

ruInfoUses(name : string, math : RuMath) -> void {
	maybeApply(ruCachedDecl(name), \decl ->
		maybeApply(ruFromCache(decl.src, math.conf), \src ->
			iter(ruSourcesCache(), \s -> { 
				iter(s.decls, \d ->
					switch (d) {
						RuTheorem(__,__,__,__,__,__,proof,__):
							iter(proof.steps, \step ->
								if (step.assertion == name) {
									code = ruFileSource(s.info.file);
									maybeApply(ruNameRangeByPos(step.pos, code),
										\range -> 
											ruPrintln(ruRange2s(src.info, range, "uses " + name), math.conf)
									);
								}
							);
						default: { }
					}
				);
			})
		)
	);
}
