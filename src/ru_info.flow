import ru_cache;
import ru_conf;
import ru_log;

export {
	ruProcessInfo(conf : RuConf) -> void;
}

ruProcessInfo(conf : RuConf) -> void {
	if (ruOptIsTrue("outline", conf)) {
		ruInfoOutline(conf);
	} else if (ruOptIsTrue("consts-info", conf)) {
		ruInfoConsts(conf);
	} else if (ruOptIsSet("math-info", conf)) {
		ruInfoMath(ruOpt("math-info", conf), conf);
	} else {
		if (ruSomeOptsAreSet(["decl", "uses", "hover", "rename", "find"], conf)) {
			if (!ruInfoTask(conf, "decl", ruInfoDecl)) {
				if (!ruInfoTask(conf, "hover", ruInfoHover)) {
					if (!ruInfoTask(conf, "uses", ruInfoUses)) {
						name = ruOpt("find", conf);
						if (name != "") {
							ruInfoDecl(name, conf);
						}
					}
				}
			}
		}
	}
}

ruInfoTask(conf : RuConf, task_name : string, task_job : (string, RuConf) -> void) -> bool {
	opt = ruOpt(task_name, conf);
	if (opt == "") false else {
		line = s2i(ruOptDef("line", "-1", conf));
		col = s2i(ruOptDef("col", "-1", conf));
		name = if (opt != "1") opt else {
			if (line != -1 && col != -1) {
				ruNameByLineCol(line, col, getFileContent(conf.path));
			} else {
				ruPrintln("Provide line=<int> and col=<in> arguments", conf);
				""
			}
		}
		if (name != "") {
			task_job(name, conf);
		}
		true;
	}
}

ruInfoDecl(name : string, conf : RuConf) -> void {
	ruDebugLog("ruInfoDecl entered: " + name, conf);
	maybeApply(ruCachedDecl(name), \d ->
		maybeApply(ruFromCache(d.info.file, conf), \cached -> 
			ruPrintln(ruRange2s(cached.source.info.path, ruDeclRange(d.decl, cached.source), "declaration of " + name), conf)
		)
	);
}

ruInfoHover(name : string, conf : RuConf) -> void {
	ruPrintln(ruCachedDecl2s(name, conf), conf);
}

ruInfoOutline(conf : RuConf) -> void {
	maybeApply(ruFromCache(conf.file, conf), \cached -> {
		src = cached.source;
		code = ruFileSource(src.info.path);
		resolver = makeLineResolver(code);
		iter(src.imports, \imp -> 
			maybeApply(ruNameRangeByPos(imp.pos, code), \range ->
				ruPrintln(ruRangeWithResolver2s(src.info.path, range, "import " + imp.path, resolver), conf)
			)
		);
		iter(src.decls, \decl -> {
			switch (decl) {
				RuDecl(): {
					maybeApply(ruNameRangeByPos(ruDeclPos(decl), code),
						\range -> 
							ruPrintln(ruRangeWithResolver2s(src.info.path, range, ruDeclKind(decl) + " " + ruDeclName(decl), resolver), conf)
					);
				}
				default: { }
			}
		});
	});
}

ruInfoUses(name : string, conf : RuConf) -> void {
	maybeApply(ruCachedDecl(name), \decl ->
		maybeApply(ruFromCache(decl.info.file, conf), \cached ->
			iter(ruSourcesCache(), \s -> { 
				iter(s.decls, \d ->
					switch (d) {
						RuTheorem(__,__,__,__,__,__,proof,__):
							iter(proof.steps, \step ->
								if (step.assertion == name) {
									code = ruFileSource(s.info.path);
									maybeApply(ruNameRangeByPos(step.pos, code),
										\range -> 
											ruPrintln(ruRange2s(cached.source.info.path, range, "uses " + name), conf)
									);
								}
							);
						default: { }
					}
				);
			})
		)
	);
}

ruInfoConsts(conf : RuConf) -> void {
	const2s = \const -> const.name + " " + const.latex + " " + const.ascii;
	iter(
		filtermap(ruCachedDecls(), \cached -> {
			decl = cached.decl;
			switch (decl) {
				RuConst(name,__,__,__):Some(Pair(decl, cached.info.path));
				default: None();
			}
		}),
		\pair -> {
			path = pair.second;
			const = pair.first;
			code = ruFileSource(path);
			//ruDebugLog("const: " + const.ascii + ", path: " + path + 
			//	", range: " + (if (isNone(ruNameRangeByPos(const.pos, code))) "NONE" else "SOME" ), conf);
			maybeApply(ruNameRangeByPos(const.pos, code),
				\range -> 
					ruPrintln(ruRange2s(path, range, "const " + const2s(const)), conf)
			)
		}
	)
}

ruInfoMath(kind : string, conf : RuConf) -> void {
	info = JsonArray(filtermap(
		filter(ruCachedDecls(), \cached ->
			switch (cached.decl) {
				RuConst(name,__,__,__):               kind == "consts";
				RuType(name,__,__):                   kind == "types";
				RuRule(name,__,__,__):                kind == "rules";
				RuAxiom(name,__,__,__,__,__):         kind == "axioms";
				RuDef(name,__,__,__,__,__,__,__):     kind == "defs";
				RuTheorem(name,__,__,__,__,__,__,__): kind == "theorems";
			}
		),
		\cached -> {
			path = cached.info.path;
			decl = cached.decl;
			name = ruDeclName(decl);
			code = ruFileSource(path);
			maybeMap(ruNameRangeByPos(ruDeclPos(decl), code),
				\range ->
					JsonObject([
						Pair("location", lspLocation2Json(ruRange2LspLocation(range, path))),
						Pair("name", JsonString(name)),
						Pair("tooltip", JsonString(ruCachedDecl2s(name, conf)))
					])
			)
		}
	));
	ruPrintln(json2string(info), conf)
}
