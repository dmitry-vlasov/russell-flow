import lingo/linecolumn;
import math/stringmath;
import formats/json/json;
import ru_conf;
import ru_println;

export {
	ruMakeJob(dir : string, params : [[string]]) -> RuJob;
	ruMakeConf(dir_ : string, params : [[string]]) -> RuConf;
	ruJob2Json(job : RuJob) -> Json;
	ruJson2Job(json : Json) -> Maybe<RuJob>;
}

ruMergeOpts(opts1 : Tree<string, string>, opts2 : Tree<string, string>) -> Tree<string, string> {
	mergeTreeCustom(opts1, opts2, \opt, val1, val2 -> if (val1 == "") val2 else val1 + "," + val2);
}

ruImportRoots(opts : Tree<string, string>) -> [string] {
	switch (lookupTree(opts, "import-roots")) {
		Some(roots): {
			filtermap(strSplit(roots, ","), \imp -> {
				imp_dir = rtrim2(strReplace(imp, "\\", "/"), "/") + "/";
				if (!isDirectory(imp_dir)) {
					None();
				} else {
					Some(strReplace(resolveRelativePath(imp_dir), "\\", "/"));
				}
			});
		}
		None(): [];
	}
}

ruMakeConf(dir_ : string, params : [[string]]) -> RuConf {
	dir = rtrim2(strReplace(resolveRelativePath(dir_), "\\", "/"), "/");
	conf_dir = ruFindConfDir(dir);
	opts = ruMergeOpts(
		ruReadConfFileFromDir(conf_dir), 
		fold(params, makeTree(), \acc, p -> setTree(acc, p[0], p[1]))
	);
	conf = RuConf(
		ruImportRoots(opts), 
		lookupTreeDef(opts, "working-dir", ""), 
		s2i(lookupTreeDef(opts, "verbose", "0")), 
		opts, 
		s2i(getThreadId()), 
		nop2
	);
	RuConf(conf with
		onError = \err, places -> 
			ruPrintln("Error: " + err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")), conf)
	);
}

ruMakeTask(params : [[string]], conf : RuConf) -> Maybe<RuTask> {
	if (length(params) == 0) {
		conf.onError("empty task", []);
		None();
	} else if (params[0][0] != "do") {
		conf.onError("empty task", []);
		None();
	} else {
		Some(RuTask(params[0][1], 
			fold(tail(params), makeTree(), \acc, p -> 
				if (length(p) == 0) acc else 
				if (length(p) == 1) setTree(acc, p[0], "") else
				setTree(acc, p[0], p[1])
			)
		));
	}
}

ruMakeJob(dir : string, params : [[string]]) -> RuJob {
	splitted = split(params, \opt -> opt[0] == ";");
	conf = ruMakeConf(dir, splitted[0]);
	RuJob(conf, filtermap(tail(splitted), \ps -> ruMakeTask(ps, conf)));
}

ruFindConfDir(dir : string) -> string {
	path = dir + "/russell.conf";
	if (fileExists(path)) dir else 
	if (dir == "/" || dir == "") "" else {
		ruFindConfDir(ruDirName(dir));
	}
}

ruReadConfFileFromDir(dir : string) -> Tree<string, string> {
	path = dir + "/russell.conf";
	if (!fileExists(path)) makeTree() else {
		config = getFileContent(path);
		lines = strSplit(config, "\n");
		fold(lines, makeTree(), \acc, l -> {
			// Skip comment lines in russell.conf
			if (!startsWith(ltrim2(l, " \t"), "#") && !startsWith(ltrim2(l, " \t"), "//")) {
				opts = strSplit(l, "=");
				if (length(opts) == 1) {
					opt = trim2(opts[0], " \t\r");
					setTree(acc, opt, "");
				} else if (length(opts) == 2) {
					opt = trim2(opts[0], " \t\r");
					val = trim2(opts[1], " \t\r");
					setTree(acc, opt, val)
				} else acc;
			} else acc;
		});
	}
}

ruConf2Json(conf : RuConf) -> Json {
	JsonObject([
		Pair("importRoots", JsonArray(map(conf.importRoots, \root -> JsonString(root)))),
		Pair("workingDir", JsonString(conf.workingDir)),
		Pair("verbose", JsonString(i2s(conf.verbose))),
		Pair("opts", JsonArray(map(tree2pairs(conf.opts), 
			\opt -> JsonObject([
				Pair("key", JsonString(opt.first)),
				Pair("value", JsonString(opt.second))
			])
		))),
		Pair("threadId", JsonString(i2s(conf.threadId))),
	]);
}

ruTask2Json(task : RuTask) -> Json {
	JsonObject([
		Pair("command", JsonString(task.command)),
		Pair("args", JsonArray(map(tree2pairs(task.args), 
			\arg -> JsonObject([
				Pair("key", JsonString(arg.first)),
				Pair("value", JsonString(arg.second))
			])
		)))
	]);
}

ruJob2Json(job : RuJob) -> Json {
	JsonObject([
		Pair("conf", ruConf2Json(job.conf)),
		Pair("tasks", JsonArray(map(job.tasks, ruTask2Json)))
 	]);
}

ruJson2Conf(json : Json) -> Maybe<RuConf> {
	if (exists(["importRoots", "workingDir", "verbose", "opts"], \field -> !jsonObjectHasField(json, field))) None() else {
		conf = RuConf(
			map(getJsonArrayField(json, "importRoots"), \root -> getJsonStringValue(root, "")),
			getJsonStringField(json, "workingDir", ""),
			s2i(getJsonStringField(json, "verbose", "")),
			pairs2tree(map(getJsonArrayField(json, "opts"), 
				\opt -> Pair(getJsonStringField(opt, "key", ""), getJsonStringField(opt, "value", ""))
			)),
			s2i(getThreadId()), 
			nop2
		);
		Some(RuConf(conf with
			onError = \err, places -> 
				ruPrintln("Error: " + err + (if (places == []) "" else "\n" + strGlue(map(places, ruPlace2s), "\n")), conf)
		));
	}
}

ruJson2Task(json : Json) -> Maybe<RuTask> {
	if (exists(["command", "args"], \field -> !jsonObjectHasField(json, field))) None() else {
		Some(RuTask(
			getJsonStringField(json, "command", ""),
			pairs2tree(map(getJsonArrayField(json, "args"), 
				\opt -> Pair(getJsonStringField(opt, "key", ""), getJsonStringField(opt, "value", ""))
			))
		));
	}
}

ruJson2Job(json : Json) -> Maybe<RuJob> {
	if (exists(["conf", "tasks"], \field -> !jsonObjectHasField(json, field))) None() else {
		maybeMap(
			ruJson2Conf(getJsonObjectField(json, "conf")), 
			\conf -> RuJob(
				conf,
				filtermap(getJsonArrayField(json, "args"), ruJson2Task)
			)
		);
	}
}
