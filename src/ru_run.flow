import lingo/linecolumn;
import math/stringmath;
import net/http;
import text/serialize;
import formats/lsp;

import parse/mm_load;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import parse/mm_parse;
import parse/mm_collect_math;
import ru_usage;
import ru_verify;
import ru_2_mm;
import mm_2_ru;
import mm_verify;
import ru_split;
import ru_imports;
import ru_refactor;
import ru_shorten;
import ru_info;
import ru_command;
import ru_conf_utils;
import prover/ru_prover_prove;
import prover/ru_prover_reprove;

export {
	ruRun(job : RuJob, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onRunComplete : (int) -> void) -> void;
}

ruRun(job : RuJob, onRunComplete : (int) -> void) -> void {
	if (lookupTreeDef(job.conf.opts, "local", "") == "1") {
		ruRunLocal(job, onRunComplete);
	} else {
		ruRunRemote(
			job, 
			\msg -> ruPrintln(msg, job.conf), 
			\msg -> ruPrintln(msg, job.conf), 
			onRunComplete, 
			\code -> {
				//ruPrintln("DEBUG trying local run: " + i2s(code), conf);
				ruRunLocal(job, onRunComplete)
			}
		)
	}
}

ruRunRemote(job : RuJob, onData: (flow) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + lookupTreeDef(job.conf.opts, "server-url", "localhost") + 
		":" + lookupTreeDef(job.conf.opts, "server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remoteConf = RuConf(job.conf with opts =
		setTree(
			switch (lookupTree(job.conf.opts, "output-dir")) {
				Some(__): job.conf.opts;
				None():   setTree(job.conf.opts, "output-dir", cwd);
			},
			"working-dir",
			lookupTreeDef(job.conf.opts, "working-dir", cwd)
		)
	);
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(RuJob(job with conf = remoteConf)))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				//ruPrintln("DEBUG: " + data, conf);
				onServerError(status);
			}
		},
		false
	)
}

ru_commands : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommands() -> Tree<string, RuComm> {
	init_commands = \-> {
		commands_list = [
			[
				RuComm(
					"verify", "", "verify entity",
					[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
					ruCommVerify
				),
				RuComm("math-stats", "", "show math statistics", [],
					\conf, task, env -> { ruPrintln("stats:\n" + ruMathStats(env.ruMath) + "\n", conf);	env; }
				),
			],
			ruIoCommands(),
			ruRefactorCommands(),
			ruProverCommands(),
			ruTranslateCommands(),
			ruInfoCommands(),
			ruFileSyncCommands()
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands, init_commands);
}

ru_env = ref RuEnv(
	RuMath(makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), makeTree()),
	MmMath(makeTree(), makeTree(), makeSet())
);

ruRunLocal(job : RuJob, onRunComplete : (int) -> void) -> void {
	ru_env := fold(job.tasks, ^ru_env, \acc, task -> 
		switch (lookupTree(ruCommands(), task.command)) {
			Some(command): {
				if (ruCheckTaskArgs(task, command, job.conf)) {
					command.run(job.conf, task, acc);
				} else {
					acc;
				}
			}
			None(): {
				ruPrintln("Unknown command: " + task.command, job.conf);
				acc;
			}
		}
	);
	onRunComplete(0);
}

ruCheckTaskArgs(task : RuTask, command : RuComm, conf : RuConf) -> bool {
	forall(command.args, \arg ->
		if (arg.optional || containsKeyTree(task.args, arg.name)) true else {
			ruPrintln("Obligatory argument " + arg.name + " of the command " + task.command + " is missing", conf);
			false;
		}
	)
}

ruPrepareSources(math : RuMath, conf : RuConf) -> [RuWriteSource] {
	ruRoot0 = rtrim2(lookupTreeDef(conf.opts, "ru-root", ""), "/");
	ruRoot = if (ruRoot0 == "1") "." else ruRoot0 + "/";
	map(getTreeValues(math.sources), 
		\src : RuSource -> {
			RuWriteSource(
				ru2s(src, math.rules),
				ruUpdateFileInfo(RuFileInfo(src.info with path = ruRoot + src.info.file + ".ru"))
			);
		}
	)
}

ruFileSyncCommands() -> [RuComm] {[
	RuComm(
		"update-cache", "file-sync", "read cached sources",
		[RuCommArg("file", false, "input file", "")],
		\conf, task, env -> { ruLoadToCache(lookupTreeDef(task.args, "file", ""), conf); env; }
	),
	RuComm(
		"file-source", "file-sync", "load an updated file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("text", false, "updated source", "")],
		\conf, task, env -> { ruSetFileSource(lookupTreeDef(task.args, "file", ""), lookupTreeDef(task.args, "text", "")); env; }
	),
	RuComm(
		"file-change", "file-sync", "apply changes to a file source",
		[RuCommArg("change-json", false, "change in JSON format", "")],
		\conf, task, env -> {
			json = lookupTreeDef(task.args, "change-json", "");
			switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
				Some(params): {
					path = ruCorrectUriPath(params.textDocument.uri.path);
					contents = ruFileSource(path);
					changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
					ruSetFileSource(path, changed);
				}
				None(): {
					ruPrintln("file-change: An option 'change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams", conf);
				}
			}
			env;
		}
	),
	RuComm(
		"file-saved", "file-sync", "file was saved",
		[RuCommArg("file", false, "input file", "")],
		\conf, task, env -> { ruLoadFileSource(lookupTreeDef(task.args, "file", "")); env; }
	)
]}

ruRefactorCommands() -> [RuComm] {[
	RuComm(
		"shorten-proofs", "refactor", "try to make proofs shorter",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommShortenProofs
	),
	RuComm(
		"remove-duplicate-steps", "refactor", "self evident",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommRemoveMathDuplicateSteps
	),
	RuComm(
		"remove-unused-steps", "refactor", "self evident",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommRemoveMathUnusedSteps
	),
]}

ruProverCommands() -> [RuComm] {[
	RuComm(
		"reprove", "prover", "reprove entities",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommReprove
	),
]}

ruIoCommands() -> [RuComm] {[
	RuComm(
		"read-ru", "io", "read a Russell file",
		[RuCommArg("file", false, "input file", "")],
		ruCommRead
	),
	RuComm(
		"read-mm", "io", "read a Metamath file",
		[RuCommArg("file", false, "input file", "")],
		mmCommRead
	),
	RuComm(
		"write-mm", "io", "write a Metamath file to a filesystem",
		[RuCommArg("file", false, "input file", ""), RuCommArg("strip-comments", true, "self evident", "")],
		\conf, task, env -> {
			file = lookupTreeDef(task.args, "file", "");
			if (!endsWith(file, ".mm")) {
				conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
			} else {
				src0 = mmMath2SingleSource(env.mmMath, ruRemoveExt(file, ".mm"));
				src1 = if (lookupTreeDef(task.args, "strip-comments", "") == "") src0 else mmStripComments(src0);
				if (!setFileContent(src1.info.path, mm2s(src1))) {
					ruPrintln("failed to save file: " + src1.info.path, conf);
				}
			}
			env;
		}
	),
	RuComm(
		"write-ru", "io", "write a Russell file to a filesystem",
		[
			RuCommArg("file", true, "input file", ""), 
			RuCommArg("all", true, "write all files", ""), 
			RuCommArg("all-to-one", true, "write all files to a one", "")
		],
		\conf, task, env -> {
			math = env.ruMath;
			if (lookupTreeDef(task.args, "file", "") != "") {
				file0 = lookupTreeDef(task.args, "file", "");
				if (!endsWith(file0, ".ru")) {
					conf.onError("Wrong file extension " + file0 + ", mus be *.ru", []);
				} else {
					file = ruTrimPath(file0, conf, ".ru");
					switch (lookupTree(math.sources, file)) {
						Some(src): ruWriteSource(src, math.rules);
						None(): ruPrintln("source: " + file + " is not found", conf);
					}
				}
			} else if (lookupTreeDef(task.args, "all", "") == "1") {
				ruWriteSources(ruPrepareSources(env.ruMath, conf), conf);
			} else if (lookupTreeDef(task.args, "all-to-one", "") != "") {
				file = lookupTreeDef(task.args, "all-to-one", "");
				if (!endsWith(file, ".ru")) {
					conf.onError("Wrong file extension " + file + ", mus be *.ru", []);
				} else {
					ruWriteSource(ruMath2SingleSource(math, ruRemoveExt(file, ".ru")), math.rules);
				}
			}
			env;
		}
	),
	RuComm(
		"split-math", "misc", "split a single file into a filesystem",
		[RuCommArg("file", false, "input file", "")],
		\conf, task, env -> RuEnv(env with ruMath = ruSplitMath(env.ruMath, conf, lookupTreeDef(task.args, "file", "")))
	),
	RuComm(
		"fix-left-recursion", "misc", "make all grammar rules non-left-recursive",
		[RuCommArg("file", false, "input file", "")],
		\conf, task, env -> RuEnv(env with ruMath = ruFixLeftRecursiveRules(env.ruMath, conf))
	),
	RuComm(
		"optimize-imports", "misc", "optimize imports",
		[RuCommArg("file", false, "input file", "")],
		\conf, task, env -> RuEnv(env with ruMath = ruOptimizeImports(env.ruMath, conf))
	),
]}

ruParseMath(conf : RuConf, file : string) -> Maybe<Tree<string, RuParsed>> {
	maybeBind(ruLoadAll(conf, file, ruFromCache), \loaded ->
		ruParseAll(getTreeValues(loaded), conf)
	)
}

ruLoadMath1(parsed : Tree<string, RuParsed>, conf : RuConf) -> Maybe<RuMath> {
	maybeBind(ruCollectMath(parsed, conf, ruToCache), \math -> ruVerifyMath(math, conf));
}

ruLoadMath(conf : RuConf, file : string) -> Maybe<RuMath> {
	maybeBind(ruParseMath(conf, file), \parsed -> ruLoadMath1(parsed, conf))
}

ruCommRead(conf : RuConf, task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".ru")) {
		conf.onError("Wrong file extension: " + file + ", must be *.ru", []);
		env;
	} else {
		eitherMap(ruLoadMath(conf, changeFileExt(file, "")), \math -> RuEnv(env with ruMath = math), env);
	}
}

mmLoadMath(conf : RuConf, file : string) -> Maybe<MmMath> {
	maybeBind(mmLoad(conf, file), \loaded ->
		maybeBind(mmParse(getTreeValues(loaded), conf), \parsed ->
			maybeBind(mmCollectMath(parsed, conf), \collected ->
				mmVerifyMath(collected, conf)
			)
		)
	)
}

mmCommRead(conf : RuConf, task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".mm")) {
		conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
		env;
	} else {
		eitherMap(mmLoadMath(conf, changeFileExt(file, "")), \math -> RuEnv(env with mmMath = math), env);
	}
}

ruTranslateCommands() -> [RuComm] {[
	RuComm(
		"ru-to-mm", "translate", "translate Russell to Metamath", [],
		\conf, task, env -> RuEnv(env with mmMath = ru2mm(env.ruMath, conf))
	),
	RuComm(
		"mm-to-ru", "translate", "translate Metamath to Russell",
		[RuCommArg("file", false, "input file", "")],
		\conf, task, env -> eitherMap(ruLoadMath1(mm2ru(env.mmMath, conf), conf), \math -> RuEnv(env with ruMath = math), env)
	),
]}

