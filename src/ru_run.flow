import lingo/linecolumn;
import math/stringmath;
import net/http;
import text/serialize;
import formats/lsp;

import parse/mm_load;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import parse/mm_parse;
import parse/mm_collect_math;
import ru_usage;
import ru_verify;
import ru_2_mm;
import mm_2_ru;
import mm_verify;
import ru_split;
import ru_imports;
import ru_refactor;
import ru_shorten;
import ru_info;
import ru_command;
import prover/ru_prover_prove;
import prover/ru_prover_reprove;

export {
	ruRun(job : RuJob, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onRunComplete : (int) -> void) -> void;
}

ruRun(job : RuJob, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(job, onRunComplete);
	} else {
		ruRunRemote(
			job,
			\msg -> ruPrintln(msg), 
			\msg -> ruPrintln(msg), 
			onRunComplete, 
			\code -> {
				//ruPrintln("DEBUG trying local run: " + i2s(code), conf);
				ruRunLocal(job, onRunComplete)
			}
		)
	}
}

ruRunRemote(job : RuJob, onData: (flow) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	/*cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remoteConf = RuConf(job.conf with opts =
		setTree(
			switch (lookupTree(job.conf.opts, "output-dir")) {
				Some(__): job.conf.opts;
				None():   setTree(job.conf.opts, "output-dir", cwd);
			},
			"working-dir",
			lookupTreeDef(job.conf.opts, "working-dir", cwd)
		)
	);*/
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(job))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				//ruPrintln("DEBUG: " + data, conf);
				onServerError(status);
			}
		},
		false
	)
}

ru_commands : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommands() -> Tree<string, RuComm> {
	init_commands = \-> {
		commands_list = [
			[
				RuComm(
					"help", "", "help on some topics", [RuCommArg("category", true, "category of help", "")],
					ruCommHelp
				),
				RuComm(
					"verify", "", "verify entity",
					[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
					ruCommVerify
				),
				RuComm("math-stats", "", "show math statistics", [],
					\task, env -> { 
						ruPrintln("Mathematics statistics:");
						ruPrintln("-----------------------");
						ruPrintln(ruMathStats(env.ruMath));
						env; 
					}
				),
				RuComm("mem-stats", "", "show memory usage statistics", [],
					\task, env -> { 
						ruPrintln(
							"Used: " + ruMemory2s(usedMemory()) + " " + 
							"Free: " + ruMemory2s(freeMemory()) + " " + 
							"Total: " + ruMemory2s(totalMemory())
						);
						env; 
					}
				),
				RuComm("update-conf", "", "update configuration", [], ruCommUpdateConf),
				RuComm("show-conf", "", "show current configuration key-value pairs", [], ruCommShowConf),
				RuComm("load-conf", "", "load configuration from given directory", [RuCommArg("dir", false, "directory with config file", "")], ruCommLoadConf),
				RuComm("clear-conf", "", "clear configuration", [], ruCommClearConf),
			],
			ruIoCommands(),
			ruRefactorCommands(),
			ruProverCommands(),
			ruTranslateCommands(),
			ruInfoCommands(),
			ruFileSyncCommands()
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands, init_commands);
}

ruCommHelp(task : RuTask, env : RuEnv) -> RuEnv {
	category = lookupTreeDef(task.args, "category", "");
	filtered = if (category == "") getTreeValues(ruCommands()) else 
		filter(getTreeValues(ruCommands()), \comm -> comm.category == category);
	// Syntax of a command line task:
	//   do=<command> <arg_1>=<val_1> ... <arg_n>=<val_n>
	//
	// Syntax of a command line:
	//   <opt_1>=<val_1> ... <opt_k>=<val_k> ; <task_1> ; ... ; <task_m>
	ruPrintln("usage: '<task_1> ; ... ; <task_m>' where");
	ruPrintln("task is: '<command> <arg_1>=<val_1> ... <arg_n>=<val_n>'");
	ruPrintln(ruComms2s(filtered));
	env;
}

ruCommUpdateConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with conf = ruMergeConfs(env.conf, ruTree2Conf(task.args)));
}

ruCommShowConf(task : RuTask, env : RuEnv) -> RuEnv {
	ruPrintln("Configuration:");
	traverseInOrder(ruConf2Tree(env.conf), \key, val -> ruPrintln("\t" + key + "=" + val));
	env;
}

ruCommLoadConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with 
		conf = ruMergeConfs(
			env.conf, 
			ruMakeConf(lookupTreeDef(task.args, "dir", ""), [])
		)
	);
}

ruCommClearConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with conf = ruTree2Conf(makeTree()));
}

ru_env = ref RuEnv(ruEmptyMath, mmEmptyMath, ruMakeConf(".", []));

ruRunLocal(job : RuJob, onRunComplete : (int) -> void) -> void {
	ru_env := fold(job.tasks, ^ru_env, \acc, t -> {
		task = ruPrepareTask(t, acc.conf);
		switch (lookupTree(ruCommands(), task.command)) {
			Some(command): {
				if (ruCheckTaskArgs(task, command, acc.conf)) {
					command.run(task, acc);
				} else {
					acc;
				}
			}
			None(): {
				ruPrintln("Unknown command: '" + task.command + "'");
				acc;
			}
		}
	});
	onRunComplete(0);
}

ruPrepareTask(task : RuTask, conf : RuConf) -> RuTask {
	switch (lookupTree(task.args, "file")) {
		Some(file): {
			module = ruTrimPath(file, conf, getFileExt(file));
			RuTask(task with args = setTree(task.args, "module", module));
		}
		None(): {
			switch (lookupTree(conf.opts, "root-file")) {
				Some(file): {
					module = ruTrimPath(file, conf, getFileExt(file));
					RuTask(task with 
						args = setTree(setTree(task.args, "file", file), "module", module)
					);
				}
				None(): task;
			}
		}
	}
}

ruCheckTaskArgs(task : RuTask, command : RuComm, conf : RuConf) -> bool {
	forall(command.args, \arg ->
		if (arg.optional || containsKeyTree(task.args, arg.name)) true else {
			ruPrintln("Obligatory argument '" + arg.name + "' of the command '" + task.command + "' is missing");
			false;
		}
	)
}

ruPrepareSources(math : RuMath, conf : RuConf) -> [RuWriteSource] {
	ruRoot0 = rtrim2(lookupTreeDef(conf.opts, "ru-root", ""), "/");
	ruRoot = if (ruRoot0 == "1") "." else ruRoot0 + "/";
	map(getTreeValues(math.sources), 
		\src : RuSource -> {
			RuWriteSource(
				ru2s(src, math.rules),
				ruUpdateFileInfo(RuFileInfo(src.info with path = ruRoot + src.info.module + ".ru"))
			);
		}
	)
}

ruFileSyncCommands() -> [RuComm] {[
	RuComm(
		"load-cache", "file-sync", "read cached sources",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> { ruLoadToCache(lookupTreeDef(task.args, "file", ""), env.conf); env; }
	),
	RuComm(
		"save-cache", "file-sync", "save cached sources",
		[RuCommArg("file", true, "input file", "")],
		\task, env -> { 
			file = lookupTreeDef(task.args, "file", "");
			if (file == "") {
				ruSaveCache(env.conf); 
			} else {
				ruSaveCacheFile(file, env.conf); 
			}
			env; 
		}
	),
	RuComm(
		"file-source", "file-sync", "load an updated file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("text", false, "updated source", "")],
		\task, env -> { ruSetFileSource(lookupTreeDef(task.args, "file", ""), lookupTreeDef(task.args, "text", "")); env; }
	),
	RuComm(
		"file-changed", "file-sync", "apply changes to a file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("change", false, "change in JSON format", "")],
		\task, env -> {
			json = lookupTreeDef(task.args, "change-json", "");
			switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
				Some(params): {
					path = ruCorrectUriPath(params.textDocument.uri.path);
					contents = ruFileSource(path);
					changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
					ruSetFileSource(path, changed);
				}
				None(): {
					ruPrintln("file-change: An option 'change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams");
				}
			}
			env;
		}
	),
	RuComm(
		"file-saved", "file-sync", "file was saved",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> { ruLoadFileSource(lookupTreeDef(task.args, "file", "")); env; }
	)
]}

ruRefactorCommands() -> [RuComm] {[
	RuComm(
		"shorten-proofs", "refactor", "try to make proofs shorter",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommShortenProofs
	),
	RuComm(
		"remove-duplicate-steps", "refactor", "self evident",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommRemoveMathDuplicateSteps
	),
	RuComm(
		"remove-unused-steps", "refactor", "self evident",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommRemoveMathUnusedSteps
	),
]}

ruProverCommands() -> [RuComm] {[
	RuComm(
		"reprove", "prover", "reprove entities",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommReprove
	),
]}

ruIoCommands() -> [RuComm] {[
	RuComm(
		"read", "io", "read a Russell file",
		[RuCommArg("file", false, "input file", "")],
		ruCommRead
	),
	RuComm(
		"read-ru", "io", "read a Russell file",
		[RuCommArg("file", false, "input file", "")],
		ruCommReadRu
	),
	RuComm(
		"read-mm", "io", "read a Metamath file",
		[RuCommArg("file", false, "input file", "")],
		ruCommReadMm
	),
	RuComm(
		"write-mm", "io", "write a Metamath file to a filesystem",
		[RuCommArg("file", false, "input file", ""), RuCommArg("strip-comments", true, "self evident", "")],
		\task, env -> {
			file = lookupTreeDef(task.args, "file", "");
			if (!endsWith(file, ".mm")) {
				env.conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
			} else {
				src0 = mmMath2SingleSource(env.mmMath, ruRemoveExt(file, ".mm"));
				src1 = if (lookupTreeDef(task.args, "strip-comments", "") == "") src0 else mmStripComments(src0);
				if (!setFileContent(src1.info.path, mm2s(src1))) {
					ruPrintln("failed to save file: " + src1.info.path);
				}
			}
			env;
		}
	),
	RuComm(
		"write-ru", "io", "write a Russell file to a filesystem",
		[
			RuCommArg("file", true, "input file", ""), 
			RuCommArg("all", true, "write all files", ""), 
			RuCommArg("all-to-one", true, "write all files to a one", "")
		],
		\task, env -> {
			math = env.ruMath;
			if (lookupTreeDef(task.args, "file", "") != "") {
				file = lookupTreeDef(task.args, "file", "");
				if (!endsWith(file, ".ru")) {
					env.conf.onError("Wrong file extension " + file + ", mus be *.ru", []);
				} else {
					module = ruTrimPath(file, env.conf, ".ru");
					switch (lookupTree(math.sources, module)) {
						Some(src): ruWriteSource(src, math.rules);
						None(): ruPrintln("source: " + file + " is not found");
					}
				}
			} else if (lookupTreeDef(task.args, "all", "") == "1") {
				ruWriteSources(ruPrepareSources(env.ruMath, env.conf), env.conf);
			} else if (lookupTreeDef(task.args, "all-to-one", "") != "") {
				file = lookupTreeDef(task.args, "all-to-one", "");
				if (!endsWith(file, ".ru")) {
					env.conf.onError("Wrong file extension " + file + ", mus be *.ru", []);
				} else {
					ruWriteSource(ruMath2SingleSource(math, ruRemoveExt(file, ".ru")), math.rules);
				}
			}
			env;
		}
	),
	RuComm(
		"split-math", "misc", "split a single file into a filesystem",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> {
			file = lookupTreeDef(task.args, "file", "");
			module = ruTrimPath(file, env.conf, ".ru");
			RuEnv(env with ruMath = ruSplitMath(env.ruMath, env.conf, module));
		}
	),
	RuComm(
		"fix-left-recursion", "misc", "make all grammar rules non-left-recursive",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> RuEnv(env with ruMath = ruFixLeftRecursiveRules(env.ruMath, env.conf))
	),
	RuComm(
		"optimize-imports", "misc", "optimize imports",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> RuEnv(env with ruMath = ruOptimizeImports(env.ruMath, env.conf))
	),
]}

ruCommReadRu(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".ru")) {
		env.conf.onError("Wrong file extension: " + file + ", must be *.ru", []);
		env;
	} else {
		module = ruTrimPath(file, env.conf, getFileExt(file));
		ru = maybeBind(
			maybeBind(ruLoadAll(env.conf, module, ruFromCache), \loaded ->
				ruParseAll(getTreeValues(loaded), env.conf)
			), 
			\parsed -> ruCollectMath(parsed, env.conf, ruToCache)
		);
		eitherMap(ru, \math -> RuEnv(env with ruMath = math), env);
	}
}

ruCommReadMm(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".mm")) {
		env.conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
		env;
	} else {
		module = ruTrimPath(file, env.conf, getFileExt(file));
		mm = maybeBind(mmLoad(env.conf, module), \loaded ->
			maybeBind(mmParse(getTreeValues(loaded), env.conf), \parsed ->
				maybeBind(mmCollectMath(parsed, env.conf), \collected ->
					mmVerifyMath(collected, env.conf)
				)
			)
		);
		eitherMap(mm, \math -> RuEnv(env with mmMath = math), env);
	}
}

ruCommRead(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruCommReadRu(task, env);
	} else if (endsWith(file, ".mm")) {
		ruCommReadMm(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		env;
	}
}

ruTranslateCommands() -> [RuComm] {[
	RuComm(
		"ru-to-mm", "translate", "translate Russell to Metamath", [],
		\task, env -> RuEnv(env with mmMath = ru2mm(env.ruMath, env.conf))
	),
	RuComm(
		"mm-to-ru", "translate", "translate Metamath to Russell",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> eitherMap(ruCollectMath(mm2ru(env.mmMath, env.conf), env.conf, ruToCache), \math -> RuEnv(env with ruMath = math), env)
	),
]}
