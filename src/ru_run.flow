import ru_usage;
import ru_verify;
import ru_io;
import ru_refactor;
import ru_shorten;
import ru_info;
import ru_command;
import ru_write;
import prover/ru_prover_prove;
import prover/ru_prover_reprove;
import prover/ru_prover_generalize;

export {
	ruRun(job : RuJob, onRunComplete : (int) -> void) -> void;
	ruRunLocal(job : RuJob, onRunComplete : (int) -> void) -> void;
}

ruRun(job : RuJob, onRunComplete : (int) -> void) -> void {
	if (getUrlParameterBoolDef("local", false)) {
		ruRunLocal(job, onRunComplete);
	} else {
		ruRunRemote(
			job,
			\msg -> ruPrintln(msg), 
			\msg -> ruPrintln(msg), 
			onRunComplete, 
			\code -> ruRunLocal(job, onRunComplete)
		)
	}
}

ruRunRemote(job : RuJob, onData: (flow) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = 
		"http://" + getUrlParameterDef("server-url", "localhost") + 
		":" + getUrlParameterDef("server-port", "20001");
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remote_job = RuJob(concat([RuTask("update-conf", makeTree1("working-dir", cwd))], job.tasks));
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruJob2Json(remote_job))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				onServerError(status);
			}
		},
		false
	)
}

ru_commands : ref Maybe<Tree<string, RuComm>> = ref None();

ruCommands() -> Tree<string, RuComm> {
	init_commands = \-> {
		commands_list = [
			[
				RuComm(
					"help", "", "help on some topics", [RuCommArg("category", true, "category of help", "")],
					ruCommHelp
				),
				RuComm(
					"verify", "", "verify entity",
					[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
					ruCommVerify
				),
				RuComm("math-stats", "", "show math statistics", [],
					\task, env -> { 
						ruPrintln("Mathematics statistics:");
						ruPrintln("-----------------------");
						ruPrintln(ruMathStats(env.ruMath));
						env; 
					}
				),
				RuComm("mem-stats", "", "show memory usage statistics", [],
					\task, env -> { 
						start = timestamp();
						n = s2i(lookupTreeDef(task.args, "delay", "0"));
						m = s2i(lookupTreeDef(task.args, "count", "0"));
						for(0, \a -> a < m, \a -> {
							for(0, \b -> b < n, \b -> b + 1);
							a + 1
						});
						ruPrintln(
							"Used: " + ruMemory2s(usedMemory()) + " " + 
							"Free: " + ruMemory2s(freeMemory()) + " " + 
							"Total: " + ruMemory2s(totalMemory()) + " in " + 
							d2st((timestamp() - start) / 1000.0, 2)
						);
						env; 
					}
				),
				RuComm("cache-stats", "", "show cache statistics", [RuCommArg("full", true, "show cached names", "")], 
					\task, env -> {
						ruPrintln(ruCacheInfo(lookupTreeDef(task.args, "full", "") == "1"));
						env;
					}
				),
				RuComm("update-conf", "", "update configuration", [], ruCommUpdateConf),
				RuComm("show-conf", "", "show current configuration key-value pairs", [], ruCommShowConf),
				RuComm("load-conf", "", "load configuration from given directory", [RuCommArg("dir", false, "directory with config file", "")], ruCommLoadConf),
				RuComm("clear-conf", "", "clear configuration", [], ruCommClearConf),
			],
			ruIoCommands(),
			ruRefactorCommands(),
			ruProverCommands(),
			ruTranslateCommands(),
			ruInfoCommands(),
			ruFileSyncCommands()
		];
		fold(concatA(commands_list), makeTree(), \acc, comm -> setTree(acc, comm.name, comm));
    }
    onlyOnce(ru_commands, init_commands);
}

ruCommHelp(task : RuTask, env : RuEnv) -> RuEnv {
	category = lookupTreeDef(task.args, "category", "");
	filtered = if (category == "") getTreeValues(ruCommands()) else 
		filter(getTreeValues(ruCommands()), \comm -> comm.category == category);
	ruPrintln("usage: '<task_1> ; ... ; <task_m>' where");
	ruPrintln("task is: '<command> <arg_1>=<val_1> ... <arg_n>=<val_n>'");
	ruPrintln(ruComms2s(filtered));
	env;
}

ruCommUpdateConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with conf = ruMergeConfs(env.conf, ruTree2Conf(task.args)));
}

ruCommShowConf(task : RuTask, env : RuEnv) -> RuEnv {
	ruPrintln("Configuration:");
	traverseInOrder(ruConf2Tree(env.conf), \key, val -> ruPrintln("\t" + key + "=" + val));
	env;
}

ruCommLoadConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with 
		conf = ruMergeConfs(
			env.conf, 
			ruMakeConf(lookupTreeDef(task.args, "dir", ""), [])
		)
	);
}

ruCommClearConf(task : RuTask, env : RuEnv) -> RuEnv {
	RuEnv(env with conf = ruTree2Conf(makeTree()));
}

ru_env = ref RuEnv(ruEmptyMath, mmEmptyMath, ruMakeConf(".", []));

ruRunLocal(job : RuJob, onRunComplete : (int) -> void) -> void {
	ru_env := fold(job.tasks, ^ru_env, \acc, t -> {
		task = ruPrepareTask(t, acc.conf);
		switch (lookupTree(ruCommands(), task.command)) {
			Some(command): {
				if (ruCheckTaskArgs(task, command, acc.conf)) {
					command.run(task, acc);
				} else {
					acc;
				}
			}
			None(): {
				ruPrintln("Unknown command: '" + task.command + "'");
				acc;
			}
		}
	});
	onRunComplete(0);
}

ruPrepareTask(task : RuTask, conf : RuConf) -> RuTask {
	switch (lookupTree(task.args, "file")) {
		Some(file): {
			module = ruTrimPath(file, conf, getFileExt(file));
			RuTask(task with args = setTree(task.args, "module", module));
		}
		None(): {
			switch (lookupTree(conf.opts, "root-file")) {
				Some(file): {
					module = ruTrimPath(file, conf, getFileExt(file));
					RuTask(task with 
						args = setTree(setTree(task.args, "file", file), "module", module)
					);
				}
				None(): task;
			}
		}
	}
}

ruCheckTaskArgs(task : RuTask, command : RuComm, conf : RuConf) -> bool {
	forall(command.args, \arg ->
		if (arg.optional || containsKeyTree(task.args, arg.name)) true else {
			ruPrintln("Obligatory argument '" + arg.name + "' of the command '" + task.command + "' is missing");
			false;
		}
	)
}

ruFileSyncCommands() -> [RuComm] {[
	RuComm(
		"load-cache", "file-sync", "read cached sources",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> { ruLoadToCache(lookupTreeDef(task.args, "file", ""), env.conf); env; }
	),
	RuComm(
		"save-cache", "file-sync", "save cached sources",
		[RuCommArg("file", true, "input file", "")],
		\task, env -> { 
			file = lookupTreeDef(task.args, "file", "");
			if (file == "") {
				ruSaveCache(env.conf); 
			} else {
				ruSaveCacheFile(file, env.conf); 
			}
			env; 
		}
	),
	RuComm(
		"file-source", "file-sync", "load an updated file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("text", false, "updated source", "")],
		\task, env -> { ruSetFileSource(lookupTreeDef(task.args, "file", ""), lookupTreeDef(task.args, "text", "")); env; }
	),
	RuComm(
		"file-changed", "file-sync", "apply changes to a file source",
		[RuCommArg("file", false, "input file", ""),  RuCommArg("change", false, "change in JSON format", "")],
		\task, env -> {
			json = lookupTreeDef(task.args, "change-json", "");
			switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
				Some(params): {
					path = ruCorrectUriPath(params.textDocument.uri.path);
					contents = ruFileSource(path);
					changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
					ruSetFileSource(path, changed);
				}
				None(): {
					ruPrintln("file-change: An option 'change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams");
				}
			}
			env;
		}
	),
	RuComm(
		"file-saved", "file-sync", "file was saved",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> { ruLoadFileSource(lookupTreeDef(task.args, "file", "")); env; }
	)
]}

ruRefactorCommands() -> [RuComm] {[
	RuComm(
		"shorten-proofs", "refactor", "try to make proofs shorter",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommShortenProofs
	),
	RuComm(
		"remove-duplicate-steps", "refactor", "self evident",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommRemoveMathDuplicateSteps
	),
	RuComm(
		"remove-unused-steps", "refactor", "self evident",
		[RuCommArg("target", false, "the target: a theorem, file or all", "")],
		ruCommRemoveMathUnusedSteps
	),
]}

ruProverCommands() -> [RuComm] {[
	RuComm(
		"reprove", "prover", "reprove entities",
		[
			RuCommArg("file", false, "input file", ""),
			RuCommArg("target", false, "the target: a theorem, file or all", "")
		],
		ruCommReprove
	),
	RuComm(
		"generalize", "prover", "generalize entities",
		[
			RuCommArg("file", false, "input file", ""),
			RuCommArg("target", false, "the target: a theorem, file or all", "")
		],
		ruCommGeneralize
	),
]}
