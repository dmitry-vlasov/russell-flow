import lingo/linecolumn;
import math/stringmath;
import net/http;
import text/serialize;
import formats/lsp;

import parse/mm_load;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import parse/mm_parse;
import parse/mm_collect_math;
import ru_usage;
import ru_verify;
import ru_2_mm;
import mm_2_ru;
import mm_verify;
import ru_split;
import ru_imports;
import ru_refactor;
import ru_shorten;
import ru_info;
import prover/ru_prover_prove;
import prover/ru_prover_reprove;

export {
	ruRun(conf : RuConf, onRunComplete : (int) -> void) -> void;
	ruRunLocal(conf : RuConf, onRunComplete : (int) -> void) -> void;
}

ruRun(conf : RuConf, onRunComplete : (int) -> void) -> void {
	if (ruOptIsTrue("local", conf)) {
		ruRunLocal(conf, onRunComplete);
	} else {
		ruRunRemote(
			conf, 
			\msg -> ruPrintln(msg, conf), 
			\msg -> ruPrintln(msg, conf), 
			onRunComplete, 
			\code -> {
				//ruPrintln("DEBUG trying local run: " + i2s(code), conf);
				ruRunLocal(conf, onRunComplete)
			}
		)
	}
}

ruRunRemote(conf : RuConf, onData: (flow) -> void, onError : (string) -> void, onRunComplete : (int) -> void, onServerError : (int) -> void) -> void {
	serverUrl = "http://" + ruOptDef("server-url", "localhost", conf) + ":" + ruOptDef("server-port", "20001", conf);
	cwd = strReplace(resolveRelativePath("."), "\\", "/");
	remoteConf = RuConf(conf with opts =
		setTree(
			setTree(
				switch (lookupTree(conf.opts, "output-dir")) {
					Some(__): conf.opts;
					None():   setTree(conf.opts, "output-dir", cwd);
				},
				"file",
				conf.file
			),
			"working-dir",
			lookupTreeDef(conf.opts, "working-dir", cwd)
		)
	);
	httpCustomRequest(
		serverUrl,
		GET(), [], RequestPayload(json2string(ruConf2Json(remoteConf))),
		\status, data, headers -> {
			code = status - 200;
			if (code == 0) {
				onData(data);
				onRunComplete(0);
			} else if (0 < code && code < 64) {
				onError("Compilation error " + i2s(code) + "\n" + data);
				onRunComplete(code);
			} else {
				//ruPrintln("DEBUG: " + data, conf);
				onServerError(status);
			}
		},
		false
	)
}

ruRunLocal(conf : RuConf, onRunComplete : (int) -> void) -> void {
	ruMakeCacheDir(conf);
	if (conf.ext == ".ru") {
		if (ruSomeOptsAreSet([
				"decl", "uses", "hover", "rename", "outline", "find", "consts-info", "math-info"], conf)) {
			ruProcessInfo(conf);
			onRunComplete(0);
		} if (ruOptIsSet("command", conf)) {
			ruProcessCommand(conf);
			onRunComplete(0);
		} else if (ruSomeOptsAreSet(["update-cache", "did-open", "did-change", "did-save"], conf)) {
			ruProcessConf(conf);
			onRunComplete(0);
		} else if (conf.file == "") {
			// No tasks
			onRunComplete(0); 
		} else {
			switch (ruLoadMath(conf)) {
				Some(math): {
					ruProcessMath(math);
					onRunComplete(0);
				}
				None(): {
					ruPrintln("could not load config for: '" + conf.ext + "', file: " + conf.file + ", path: " + conf.path, conf);
					onRunComplete(1);
				}
			}
		}
	} else if (conf.ext == ".mm") {
		if (conf.file == "") {
			// No tasks
			onRunComplete(0); 
		} else {
			switch (mmLoadMath(conf)) {
				Some(math): {
					mmProcessMath(math);
					onRunComplete(0);
				}
				None(): {
					ruPrintln("could not load config for: '" + conf.ext + "', file: " + conf.file + ", path: " + conf.path, conf);
					onRunComplete(1);
				}
			}
		}
	} else {
		ruPrintln("file extension should be *.ru or *.mm, while given is: '" + conf.ext + "', file: " + conf.file + ", path: " + conf.path, conf);
		onRunComplete(1);
	}
}

ruOperateMath(comm : RuCommand, math : RuMath) -> RuMath {
	if (comm.name == "verify") {
		ruCommandVerify(math);
	} else if (comm.name == "remove-duplicate-steps") {
		ruCommandRemoveMathDuplicateSteps(math);
	} else if (comm.name == "remove-unused-steps") {
		ruCommandRemoveMathUnusedSteps(math);
	} else if (comm.name == "remove-unused-hyps") {
		ruCommandRemoveMathUnusedHyps(math);
	} else if (comm.name == "shorten-proofs") {
		ruCommandShortenProofs(math);
	} else if (comm.name == "reprove") {
		ruCommandReproveTask(math);
	} else if (comm.name == "stats") {
		ruPrintln("stats:\n" + ruMathStats(math) + "\n", math.conf);
		math;
	} else if (comm.name == "expr-len-stats") {
		ruCommandExpressionLenStats(math);
		math;
	} else if (comm.name == "proof-stats") {
		ruCommandProofsStats(math);
		math;
	}else if (comm.name == "write") {
		target = lookupTreeDef(math.conf.opts, "default", "");
		if (target == "all" || target == "1" || target == "") {
			ruWriteSources(ruPrepareSources(math), math.conf);
		} else {
			file = ruTrimPath(target, math.conf, ".ru");
			switch (lookupTree(math.sources, file)) {
				Some(src): ruWriteSource(src, math.rules);
				None():    ruPrintln("source: " + file + " is not found", math.conf);
			}
		}
		math;
	} else if (comm.name == "write-single") {
		target = lookupTreeDef(math.conf.opts, "default", "");
		if (target != "") {
			file = ruRemoveExt(target, ".ru");
			ruWriteSource(ruMath2SingleSource(math, file), math.rules);
		}
		math;
	} else {
		ruPrintln("unknown command: " + comm.name, math.conf);
		math
	}
}

ruPrepareSources(math : RuMath) -> [RuWriteSource] {
	ruRoot0 = rtrim2(lookupTreeDef(math.conf.opts, "ru-root", ""), "/");
	ruRoot = if (ruRoot0 == "1") "." else ruRoot0 + "/";
	map(getTreeValues(math.sources), 
		\src : RuSource -> {
			RuWriteSource(
				ru2s(src, math.rules),
				ruUpdateFileInfo(RuFileInfo(src.info with path = ruRoot + src.info.file + ".ru"))
			);
		}
	)
}

ruProcessConf(conf : RuConf) -> void {
	//ruDebugLog("processing conf: " + ruOptsDescr(conf.opts), conf);
	if (ruOptIsSet("update-cache", conf)) {
		ruLoadToCache(conf.path, conf);
	}
	if (ruOptIsSet("did-open", conf)) {
		source_path = ruOpt("did-open", conf);
		source_text = ruOpt("did-open-text", conf);
		if (source_text != "" && source_path != "") {
			ruSetFileSource(source_path, source_text);
		} else {
			ruPrintln("did-open: Options 'did-open-text' must be provided", conf);
		}
	}
	if (ruOptIsSet("did-change", conf)) {
		json = ruOpt("did-change-json", conf);
		switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
			Some(params): {
				path = ruCorrectUriPath(params.textDocument.uri.path);
				contents = ruFileSource(path);
				changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
				ruSetFileSource(path, changed);
			}
			None(): {
				ruPrintln("did-change: An option 'did-change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams", conf);
			}
		}
	}
	if (ruOptIsSet("did-save", conf)) {
		path = ruOpt("did-save", conf);
		ruLoadFileSource(path);
	}
}

ruProcessMath(math0 : RuMath) -> void {
	math1 = ruIf(ruOptIsTrue("ru-imports", math0.conf), math0, ruOptimizeMathImports);
	math = fold(ruConf2Commands(math1.conf), math1, \acc, comm -> 
		ruOperateMath(comm, RuMath(acc with conf = comm.conf))
	);
	if (ruOptIsTrue("ru-2-mm", math.conf)) {
		mmProcessMath(ruMath2mm(RuMath(math with conf = ruRemoveOpt("ru-2-mm", math.conf))));
	}
	
	if (ruOptIsTrue("ru-write-all", math.conf)) {
		ruWriteSources(ruPrepareSources(math), math.conf);
	}
	if (ruOptIsSet("ru", math.conf)) {
		ruWriteSource(ruMath2SingleSource(math, ruRemoveExt(ruOpt("ru", math.conf), ".ru")), math.rules);
	}
	if (ruOptIsSet("ru-write", math.conf)) {
		file = ruTrimPath(ruOpt("ru-write", math.conf), math.conf, ".ru");
		switch (lookupTree(math.sources, file)) {
			Some(src): ruWriteSource(src, math.rules);
			None(): ruPrintln("source: " + file + " is not found", math.conf);
		}
	}
	if (ruOptIsSet("verify", math.conf)) {
		ruCommandVerify(math);
		{}
	}
	if (ruOptIsSet("shorten-proofs", math.conf)) {
		ruCommandShortenProofs(RuMath(math with
			conf = RuConf(math.conf with 
				opts = setTree(math.conf.opts, "default", ruOpt("shorten-proofs", math.conf))
			)
		)); {}
	}
	if (ruOptIsSet("ru-assertion", math.conf)) {
		name = ruOpt("ru-assertion", math.conf);
		switch (lookupTree(math.assertions, name)) {
			Some(ass): ruPrintln(ru2s(ass, math.rules), math.conf);
			None(): ruPrintln("assertion: " + name + " is not found", math.conf);
		}
	}
	if (ruOptIsTrue("ru-stats", math.conf)) {
		ruPrintln("ru stats:\n" + ruMathStats(math) + "\n", math.conf);
	}
}

mmProcessMath(math : MmMath) -> void {
	if (ruOptIsSet("mm", math.conf)) {
		src = mmMath2SingleSource(math, ruRemoveExt(ruOpt("mm", math.conf), ".mm"));
		txt = mm2s(ruIf(ruOptIsTrue("strip-comments", math.conf), src, mmStripComments));
		if (!setFileContent(src.info.path, txt)) {
			ruPrintln("failed to save file: " + src.info.path, math.conf);
		}
	}
	if (ruOptIsTrue("mm-2-ru", math.conf)) {
		maybeApply(ruLoadMath1(mmMath2ru(math), math.conf), \verified ->
			ruProcessMath(
				ruIf(ruOptIsTrue("mm-split", math.conf), 
					ruIf(ruOptIsSet("mm-fix", math.conf), 
						RuMath(verified with conf = ruRemoveOpt("mm-2-ru", verified.conf)), 
						ruFixLeftRecursiveRules
					), 
					ruSplitMath
				)
			)
		);
	}
	if (ruOptIsSet("mm-assertion", math.conf)) {
		name = ruOpt("mm-assertion", math.conf);
		switch (lookupTree(math.labeled, name)) {
			Some(ass): ruPrintln(mm2s(ass), math.conf);
			None(): ruPrintln("assertion: " + name + " is not found", math.conf);
		}
	}
	if (ruOptIsTrue("mm-stats", math.conf)) {
		ruPrintln("mm stats:\n" + mmMathStats(math) + "\n", math.conf);
	}
}

ruParseMath(conf : RuConf) -> Maybe<Tree<string, RuParsed>> {
	maybeBind(ruLoadAll(conf, conf.file, ruFromCache), \loaded ->
		ruParseAll(getTreeValues(loaded), conf)
	)
}

ruLoadMath1(parsed : Tree<string, RuParsed>, conf : RuConf) -> Maybe<RuMath> {
	maybeMap(maybeBind(ruCollectMath(parsed, conf, ruToCache), ruVerifyMath), 
		\math -> ruIf(ruOptIsTrue("ru-imports", conf), math, ruOptimizeMathImports)
	)
}

ruLoadMath(conf : RuConf) -> Maybe<RuMath> {
	maybeBind(ruParseMath(conf), \parsed -> ruLoadMath1(parsed, conf))
}

mmLoadMath(conf : RuConf) -> Maybe<MmMath> {
	maybeBind(mmLoad(conf, conf.file), \loaded ->
		maybeBind(mmParse(getTreeValues(loaded), conf), \parsed ->
			maybeBind(mmCollectMath(parsed, conf), \collected ->
				mmVerifyMath(collected)
			)
		)
	)
}

// ruInfoTheoremAxioms() -> void

ruProcessCommand(conf : RuConf) -> void {
	comm = ruOpt("command", conf);
	args = ruOpt("args", conf);
	if (comm == "theorem-axioms") {
		ruDebugLog("theorem-axioms invoked", conf);
		ruInfoTheoremAxioms(conf);
	}
}