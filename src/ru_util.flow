import fs/filesystem;
import net/url_parameter;
import sys/concurrent;

export {
	ruDirName(path : string) -> string;
	ruRemoveExt(file : string, ext : string) -> string;
	ruIndent(str : string) -> string;
	ruIndent2(str : string) -> string;
	ruIndent3(str : string) -> string;
	
	ruIf(cond : bool, val : ?, f : (?) -> ?) -> ?;
	ruReplaceArray(a : [?], i : int, v : ?) -> [?];
	ruConcurrent(jobs : [() -> ?]) -> [?];

	// Cartesian product iterator
	ruInitCart(prod : [[?]]) -> [int];
	ruNextCart(v : [int], prod : [[?]]) -> Maybe<[int]>;
	ruSizeCart(prod : [[?]]) -> int;
	ruProd2s(prod : [[?]]) -> string;
	ruMapCart(prod : [[?]], f : ([?]) -> ??) -> [??];
	ruIterCart(prod : [[?]], f : ([?]) -> void) -> void;
}

ruIndent(str : string) -> string {
	strGlue(map(strSplit(str, "\n"), \s -> "\t" + s), "\n")
}

ruIndent2(str : string) -> string {
	ruIndent(ruIndent(str))
}

ruIndent3(str : string) -> string {
	ruIndent(ruIndent2(str))
}

ruDirName(path : string) -> string {
	path1 = strReplace(path, "\\", "/");
	if (!strContains(path1, "/")) "" else {
		strLeft(path1, strLastIndexOf(path1, "/"));
	}
}

ruRemoveExt(file : string, ext : string) -> string {
	if (endsWith(file, ext)) strsubsmart(file, 0, -strlen(ext)) else file
}

ruIf(cond : bool, val : ?, f : (?) -> ?) -> ? {
	if (cond) f(val) else val
}

ruConcurrent(jobs : [() -> ?]) -> [?] {
	concurrent(true, jobs)
	//sequential(true, jobs)
}

ruReplaceArray(a : [?], i : int, v : ?) -> [?] {
	concat3(subrange(a, 0, i), [v], subrange(a, i + 1, length(a)));
}

ruInitCart(prod : [[?]]) -> [int] {
	map(prod, \__ -> 0);
}

ruNextCart(v : [int], prod : [[?]]) -> Maybe<[int]> {
	keep = ref false;
	next = mapi(v, \i, n -> {
		if (^keep) n else 
		if (n + 1 < length(prod[i])) {
			keep := true;
			n + 1;
		} else 0
	});
	if (^keep) Some(next) else None();
}

ruSizeCart(prod : [[?]]) -> int {
	fold (prod, 1, \acc, p -> acc * length(p));
}

ruProd2s(prod : [[?]]) -> string {
	"dims=[" + strGlue(map(prod, \p -> i2s(length(p))), ", ") + "]"
}

ruMapCart(prod : [[?]], f : ([?]) -> ??) -> [??] {
	if (ruSizeCart(prod) == 0) [] else
	ruDoMapCart(prod, ruInitCart(prod), [], f)
}

ruDoMapCart(prod : [[?]], v : [int], acc : [??], f : ([?]) -> ??) -> [??] {
	d = mapi(v, \i, n -> prod[i][n]);
	new_acc = concat(acc, [f(d)]);
	switch (ruNextCart(v, prod)) {
		Some(next): ruDoMapCart(prod, next, new_acc, f);
		None(): new_acc;
	}
}

ruIterCart(prod : [[?]], f : ([?]) -> void) -> void {
	if (ruSizeCart(prod) > 0) {
		ruDoIterCart(prod, ruInitCart(prod), f)
	}
}

ruDoIterCart(prod : [[?]], v : [int], f : ([?]) -> void) -> void {
	f(mapi(v, \i, n -> prod[i][n]));
	switch (ruNextCart(v, prod)) {
		Some(next): ruDoIterCart(prod, next, f);
		None(): {};
	}
}


/*
RuTask(
	id : string,
	job  : () -> ??,
	fork : (?) -> ?,
	join : (?, ??) -> ?,
);

RuTaskFactory(
	produce : (?) -> [RuTask<?, ??>],
	complete : (?) -> bool
);

ruConcurrentTasks(factory : RuTaskFactory, init : ref ?) -> ? {
		ruDoConcurrentTasks(factory, init, initConcurrentHashMap(), ref makeSet());
		^init
	}
	ruConcurrent2(jobs : [() -> ?]) -> [?] {
		if (length(jobs) == 0) [] else
		if (length(jobs) == 1) [jobs[0]()] else 
		if (length(jobs) <= availableProcessors()) concurrent(true, jobs) else {
			jobs_map = initConcurrentHashMap();
			results = initConcurrentHashMap();
			iteri(jobs, \i, job -> setConcurrentHashMap(jobs_map, i, RuJobStatus(i, job)));
			ruDoConcurrentJobs(length(jobs), jobs_map, ref 0, ref 0, results);
			getTreeValues(fold(valuesConcurrentHashMap(results), makeTree(), \acc, res : RuJobResult<?> -> setTree(acc, res.ind, res.data)));
		}
	}

RuJobStatus(
	ind : int,
	job : () -> ?
);

RuJobResult(
	ind : int,
	data : ?
);

ruDoConcurrentJobs(njobs : int, jobs : native, started : ref int, finished : ref int, results : native) -> void {
	if (^finished < njobs) {
		free_cpus = availableProcessors() - (^started - ^finished);
		if (free_cpus > 0) {
			ready = take(valuesConcurrentHashMap(jobs), free_cpus);
			iter(ready, \job -> {
				atomicRefIntAddition(started, 1);
				removeConcurrentHashMap(jobs, job.ind);
				concurrentAsyncCallback(
					\__, cb -> cb(job.job()),
					\r -> {
						setConcurrentHashMap(results, job.ind, RuJobResult(job.ind, r));
						atomicRefIntAddition(finished, 1);
						{}
					}
				)
			});
		}
		//threadSleep(100); TODO
		ruDoConcurrentJobs(njobs, jobs, started, finished, results);
	}
}


ruDoConcurrentTasks(factory : RuTaskFactory, acc : ref ?, results : native, running : ref Set<string>) -> void {
	if (!factory.complete(^acc)) {
		tasks = factory.produce(^acc);
		iter(tasks, \task -> {
			acc := task.fork(^acc);
			running := insertSet(^running, task.id);
			concurrentAsyncCallback(
				\__, cb -> cb(task.job()),
				\w -> setConcurrentHashMap(results, task.id, \a -> task.join(a, w))
			)
		});
		iter(set2array(^running), \id ->
			if (containsConcurrentHashMap(results, id)) {
				acc := getConcurrentHashMap(results, id, idfn)(^acc);
				running := removeSet(^running, id);
			}
		);
		// threadSleep(100); TODO
		ruDoConcurrentTasks(factory, acc, results, running);
	}
}
*/
