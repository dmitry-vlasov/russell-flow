import fs/filesystem;
import net/url_parameter;
import sys/concurrent;
import math/stringmath;
import text/blueprint;
import lingo/linecolumn;

export {
	ruDirName(path : string) -> string;
	ruRemoveExt(file : string, ext : string) -> string;
	ruIndent(str : string) -> string;
	ruIndent2(str : string) -> string;
	ruIndent3(str : string) -> string;
	
	ruIf(cond : bool, val : ?, f : (?) -> ?) -> ?;
	ruReplaceArray(a : [?], i : int, v : ?) -> [?];
	ruConcurrent(jobs : [() -> ?]) -> [?];

	// Cartesian product iterator
	ruInitCart(prod : [[?]]) -> [int];
	ruNextCart(v : [int], prod : [[?]]) -> Maybe<[int]>;
	ruSizeCart(prod : [[?]]) -> int;
	ruProd2s(prod : [[?]]) -> string;
	ruMapCart(prod : [[?]], f : ([?]) -> ??) -> [??];
	ruIterCart(prod : [[?]], f : ([?]) -> void) -> void;
	ruFoldCart(prod : [[?]], init : ??, f : (??, [?]) -> ??) -> ??;
	ruFiltermapCart(prod : [[?]], f : ([?]) -> Maybe<??>) -> [??];

	// matrix[col][row] : string
	ruStringMatrix2s(matrix : [[string]], colHeaders : Maybe<[string]>, rowHeadres : Maybe<[string]>) -> string;
	ruPrint(s : string) -> void;

	ruLogN(n : int, N : int) -> int;
	ruExpN(n : int, N : int) -> int;

	ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void;

	RuRange(start : int, end : int);
	ruNameByLineCol(line : int, col : int, src : string) -> string ;
	ruNameByPos(pos : int, src : string) -> string;
	ruRangeByPos(pos : int, src : string) -> Maybe<RuRange>;
	ruIsIdChar(s : string) -> bool;
}

ruPrint(s : string) -> void {
	//println(s + fromCharCode(8));
	println(s);
	println(fromCharCode(27) + "[D ");
}

ruIndent(str : string) -> string {
	strGlue(map(strSplit(str, "\n"), \s -> "\t" + s), "\n")
}

ruIndent2(str : string) -> string {
	ruIndent(ruIndent(str))
}

ruIndent3(str : string) -> string {
	ruIndent(ruIndent2(str))
}

ruDirName(path : string) -> string {
	path1 = strReplace(path, "\\", "/");
	if (!strContains(path1, "/")) "" else {
		strLeft(path1, strLastIndexOf(path1, "/"));
	}
}

ruRemoveExt(file : string, ext : string) -> string {
	if (endsWith(file, ext)) strsubsmart(file, 0, -strlen(ext)) else file
}

ruIf(cond : bool, val : ?, f : (?) -> ?) -> ? {
	if (cond) f(val) else val
}

ruConcurrent(jobs : [() -> ?]) -> [?] {
	concurrent(true, jobs)
	//sequential(true, jobs)
}

ruReplaceArray(a : [?], i : int, v : ?) -> [?] {
	concat3(subrange(a, 0, i), [v], subrange(a, i + 1, length(a)));
}

ruInitCart(prod : [[?]]) -> [int] {
	map(prod, \__ -> 0);
}

ruNextCart(v : [int], prod : [[?]]) -> Maybe<[int]> {
	keep = ref false;
	next = mapi(v, \i, n -> {
		if (^keep) n else 
		if (n + 1 < length(prod[i])) {
			keep := true;
			n + 1;
		} else 0
	});
	if (^keep) Some(next) else None();
}

ruSizeCart(prod : [[?]]) -> int {
	fold (prod, 1, \acc, p -> acc * length(p));
}

ruProd2s(prod : [[?]]) -> string {
	strGlue(map(prod, \p -> i2s(length(p))), "x")
}

ruMapCart(prod : [[?]], f : ([?]) -> ??) -> [??] {
	if (ruSizeCart(prod) == 0) [] else {
		arr = ref [];
		ruDoMapCart(prod, ruInitCart(prod), arr, f);
		^arr;
	}
}

ruDoMapCart(prod : [[?]], v : [int], arr : ref [??], f : ([?]) -> ??) -> void {
	d = mapi(v, \i, n -> prod[i][n]);
	refArrayPush(arr, f(d));
	switch (ruNextCart(v, prod)) {
		Some(next): ruDoMapCart(prod, next, arr, f);
		None(): {};
	}
}

ruIterCart(prod : [[?]], f : ([?]) -> void) -> void {
	if (ruSizeCart(prod) > 0) {
		ruDoIterCart(prod, ruInitCart(prod), f)
	}
}

ruDoIterCart(prod : [[?]], v : [int], f : ([?]) -> void) -> void {
	f(mapi(v, \i, n -> prod[i][n]));
	switch (ruNextCart(v, prod)) {
		Some(next): ruDoIterCart(prod, next, f);
		None(): {};
	}
}

ruFoldCart(prod : [[?]], init : ??, f : (??, [?]) -> ??) -> ?? {
	if (ruSizeCart(prod) == 0) init else
	ruDoFoldCart(prod, ruInitCart(prod), init, f)
}

ruDoFoldCart(prod : [[?]], v : [int], val : ??, f : (??, [?]) -> ??) -> ?? {
	d = mapi(v, \i, n -> prod[i][n]);
	new_val = f(val, d);
	switch (ruNextCart(v, prod)) {
		Some(next): ruDoFoldCart(prod, next, new_val, f);
		None(): new_val;
	}
}

ruFiltermapCart(prod : [[?]], f : ([?]) -> Maybe<??>) -> [??] {
	if (ruSizeCart(prod) == 0) [] else {
		arr = ref [];
		ruDoFiltermapCart(prod, ruInitCart(prod), arr, f);
		^arr;
	}
}

ruDoFiltermapCart(prod : [[?]], v : [int], arr : ref [??], f : ([?]) -> Maybe<??>) -> void {
	d = mapi(v, \i, n -> prod[i][n]);
	maybeApply(f(d), \val -> refArrayPush(arr, val));
	switch (ruNextCart(v, prod)) {
		Some(next): ruDoFiltermapCart(prod, next, arr, f);
		None(): { };
	}
}

RuStringDims(length : int, height : int);

ruStringDims(s : string) -> RuStringDims {
	lines = strSplit(s, "\n");
	RuStringDims(
		fold(tail(lines), strlen(lines[0]), \acc, line -> max(acc, strlen(line))),
		length(lines)
	);
}

ruFillCell(s : string, dims : RuStringDims) -> [string] {
	s_lines = strSplit(s, "\n");
	map(enumFromTo(0, dims.height - 1), \i ->
		if (i < length(s_lines)) {
			line = " " + s_lines[i];
			if (strlen(line) < dims.length) {
				rpad(line, " ", dims.length);
			} else {
				substring(line, 0, dims.length);
			}
		} else {
			strRepeat(" ", dims.length);
		}
	);
}

ruCompleteMatrix(m : [[string]]) -> [[string]] {
	max_rows = fold(m, 0, \acc, col -> max(acc, length(col)));
	fold(m, [], \acc, col ->
		concat(acc, [concat(col, arrayRepeat("", max_rows - length(col)))])
	);
}

ruStringMatrix2s(m : [[string]], colHeaders : Maybe<[string]>, rowHeadres : Maybe<[string]>) -> string {
	if (m == []) "" else {
		m1 = eitherMap(colHeaders, \hs -> mapi(m, \i, col -> concat([hs[i]], col)), m);
		m2 = eitherMap(rowHeadres, \hs -> concat(if (isNone(colHeaders)) [hs] else [concat([""], hs)], m1), m1);
		matr = ruCompleteMatrix(m2);
		n_rows = length(matr[0]);
		dims = map(matr, \col -> map(col, \row -> ruStringDims(row)));
		cols = map(dims, \col -> fold(col, 0, \ac, row -> max(ac, row.length + 2)));
		rows = map(enumFromTo(0, n_rows - 1), \i -> fold(dims, 0, \ac, col -> max(ac, col[i].height)));
		cells = mapi(matr, \i, col -> mapi(col, \j, row -> ruFillCell(row, RuStringDims(cols[i], rows[j]))));
		leng = fold(cols, 0, \acc, col -> acc + col);
		strGlue(
			map(enumFromTo(0, n_rows - 1),
				\i -> strGlue(
					map(enumFromTo(0, rows[i] - 1),
						\j -> strGlue(mapi(cols, \k,__ -> cells[k][i][j]), "|")
					),
					"\n"
				)
			),
			"\n" + strRepeat("-", leng) + "\n"
		)
	}
}

ruLogN(n : int, N : int) -> int {
	if (n < 0) ruLogN(-n, N) else 
	if (n < N) 1 else {
		1 + ruLogN(n / N, N);
	}
}

ruExpN(n : int, N : int) -> int {
	if (n < 0) ruExpN(-n, N) else 
	if (n == 0) 1 else {
		N * ruExpN(n - 1, N);
	}
}

ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void {
	message_with_limestamp = "[" + time2string(timestamp()) + "] " + message;
	log_file = if (fileExists(log_name)) getFileContent(log_name) else "";
	log_lines = strSplit(log_file, "\n");
	log_lines_cut = if (length(log_lines) > log_size) tailFrom(log_lines, log_size / 8) else log_lines;
	updated_log_lines = concat(log_lines_cut, [message_with_limestamp]);
	updated_log_file = strGlue(updated_log_lines, "\n");
	setFileContent(log_name, updated_log_file);
	{}
}

ruNameByLineCol(line : int, col : int, src : string) -> string {
	resolver = makeLineResolver(src);
	ruNameByPos(findLineIndex(resolver, line, col), src);
}

ruNameByPos(pos : int, src : string) -> string {
	eitherMap(ruRangeByPos(pos, src), \range -> substring(src, range.start, range.end - range.start + 1), "");
}

ruRangeByPos(pos : int, src : string) -> Maybe<RuRange> {
	if (pos < 0 || pos >= strlen(src) || !ruIsIdChar(getCharAt(src, pos))) None() else {
		start = for(pos, 
			\i -> if (i <= 0) false else ruIsIdChar(getCharAt(src, i - 1)), 
			\i -> i - 1
		);
		end = for(pos, 
			\i -> if (i + 1 >= strlen(src)) false else ruIsIdChar(getCharAt(src, i + 1)), 
			\i -> i + 1
		);
		if (isDigit(getCharAt(src, start))) None() else Some(RuRange(start, end));
	}
}

ruIsIdChar(s : string) -> bool {
	// id_char = 'a'-'z' | 'A'-'Z' | '0'-'9' | '_' | '.' | '-' | '\'';
	s == "_" || s == "." || s == "-" || s =="'" || isLetter(s) || isDigit(s);
}

/*
RuTask(
	id : string,
	job  : () -> ??,
	fork : (?) -> ?,
	join : (?, ??) -> ?,
);

RuTaskFactory(
	produce : (?) -> [RuTask<?, ??>],
	complete : (?) -> bool
);

ruConcurrentTasks(factory : RuTaskFactory, init : ref ?) -> ? {
		ruDoConcurrentTasks(factory, init, initConcurrentHashMap(), ref makeSet());
		^init
	}
	ruConcurrent2(jobs : [() -> ?]) -> [?] {
		if (length(jobs) == 0) [] else
		if (length(jobs) == 1) [jobs[0]()] else 
		if (length(jobs) <= availableProcessors()) concurrent(true, jobs) else {
			jobs_map = initConcurrentHashMap();
			results = initConcurrentHashMap();
			iteri(jobs, \i, job -> setConcurrentHashMap(jobs_map, i, RuJobStatus(i, job)));
			ruDoConcurrentJobs(length(jobs), jobs_map, ref 0, ref 0, results);
			getTreeValues(fold(valuesConcurrentHashMap(results), makeTree(), \acc, res : RuJobResult<?> -> setTree(acc, res.ind, res.data)));
		}
	}

RuJobStatus(
	ind : int,
	job : () -> ?
);

RuJobResult(
	ind : int,
	data : ?
);

ruDoConcurrentJobs(njobs : int, jobs : native, started : ref int, finished : ref int, results : native) -> void {
	if (^finished < njobs) {
		free_cpus = availableProcessors() - (^started - ^finished);
		if (free_cpus > 0) {
			ready = take(valuesConcurrentHashMap(jobs), free_cpus);
			iter(ready, \job -> {
				atomicRefIntAddition(started, 1);
				removeConcurrentHashMap(jobs, job.ind);
				concurrentAsyncCallback(
					\__, cb -> cb(job.job()),
					\r -> {
						setConcurrentHashMap(results, job.ind, RuJobResult(job.ind, r));
						atomicRefIntAddition(finished, 1);
						{}
					}
				)
			});
		}
		//threadSleep(100); TODO
		ruDoConcurrentJobs(njobs, jobs, started, finished, results);
	}
}


ruDoConcurrentTasks(factory : RuTaskFactory, acc : ref ?, results : native, running : ref Set<string>) -> void {
	if (!factory.complete(^acc)) {
		tasks = factory.produce(^acc);
		iter(tasks, \task -> {
			acc := task.fork(^acc);
			running := insertSet(^running, task.id);
			concurrentAsyncCallback(
				\__, cb -> cb(task.job()),
				\w -> setConcurrentHashMap(results, task.id, \a -> task.join(a, w))
			)
		});
		iter(set2array(^running), \id ->
			if (containsConcurrentHashMap(results, id)) {
				acc := getConcurrentHashMap(results, id, idfn)(^acc);
				running := removeSet(^running, id);
			}
		);
		// threadSleep(100); TODO
		ruDoConcurrentTasks(factory, acc, results, running);
	}
}
*/
