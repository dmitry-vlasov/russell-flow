import ds/cart_prod;
import ds/trie;
import fs/filesystem;
import net/url_parameter;
import sys/concurrent;
import sys/system;
import sys/target;
import math/stringmath;
import text/blueprint;
import lingo/linecolumn;
import formats/lsp;

export {
	ruDirName(path : string) -> string;
	// Returns current working directory with slashes (/) and no slash at the end
	ruCurrentWorkingDir() -> string;
	ruRemoveExt(file : string, ext : string) -> string;
	ruIndent(str : string) -> string;
	ruIndent2(str : string) -> string;
	ruIndent3(str : string) -> string;
	ruTrimAll(str : string) -> string;
	
	ruIf(cond : bool, val : ?, f : (?) -> ?) -> ?;
	ruConcurrent(jobs : [() -> ?]) -> [?];
	ruConcurrent1(jobs : [() -> ?]) -> [?];
	ruProd2s(prod : CartProd) -> string;

	// matrix[col][row] : string
	ruStringMatrix2s(matrix : [[string]], colHeaders : Maybe<[string]>, rowHeadres : Maybe<[string]>) -> string;

	ruiLogN(n : int, N : int) -> int;
	ruiExpN(n : int, N : int) -> int;

	rudLogN(n : double, N : int) -> int;
	rudExpN(n : double, N : int) -> int;

	ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void;

	RuRange(start : int, end : int);
	RuLocation(path : string, range : RuRange);

	ruNameByLineCol(line : int, col : int, src : string) -> string ;
	ruNameByPos(pos : int, src : string) -> string;
	ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange>;

	// Recursively deletes a directory. Returns an array of error messages
	ruDeleteDir(dir : string) -> [string];
	ruCopyFile(file : string, dir : string) -> bool;

	ruSetsIntersect(s1 : Set<?>, s2 : Set<?>) -> bool;
	ruExistsi(a : [?], fn : (int, ?) -> bool) -> bool;

	/*
	When URI parser parses something like: 
		file:///c:/Users/dmitr/area9/flow9/tools/flowc
	it outputs path as: 
		/c:/Users/dmitr/area9/flow9/tools/flowc
	which is wrong in windows, first slash must be removed.
	*/
	ruCorrectUriPath(path : string) -> string;

	// Do a replacement "\n" to "\\n" and so on
	ruServerEscapeString(str : string) -> string;
	ruCutLongString(str : string) -> string;
	ruDebugLog1(message : string) -> void;
}

ruCurrentWorkingDir() -> string {
	rtrim2(strReplace(resolveRelativePath("."), "\\", "/"), "/");
}

ruIndent(str : string) -> string {
	strGlue(map(strSplit(str, "\n"), \s -> "\t" + s), "\n")
}

ruIndent2(str : string) -> string {
	ruIndent(ruIndent(str))
}

ruIndent3(str : string) -> string {
	ruIndent(ruIndent2(str))
}

ruTrimAll(str : string) -> string {
	ltrim2(rtrim2(str, "_\n\t\r"), " \n\t\r");
}

ruDirName(path : string) -> string {
	path1 = strReplace(path, "\\", "/");
	if (!strContains(path1, "/")) "" else {
		strLeft(path1, strLastIndexOf(path1, "/"));
	}
}

ruRemoveExt(file : string, ext0 : string) -> string {
	ext = if (startsWith(ext0, ".")) ext0 else "." + ext0;
	if (endsWith(file, ext)) strsubsmart(file, 0, -strlen(ext)) else file;
}

ruIf(cond : bool, val : ?, f : (?) -> ?) -> ? {
	if (cond) f(val) else val
}

ruConcurrent(jobs : [() -> ?]) -> [?] {
	concurrent(true, jobs)
	//sequential(true, jobs)
}

ruConcurrent1(jobs : [() -> ?]) -> [?] {
	concatA(
		map(
			splitByNumber(jobs, availableProcessors()),
			ruConcurrent
		)
	)
	//sequential(true, jobs)
}

ruProd2s(prod : CartProd) -> string {
	strGlue(map(prod.sets, \s -> i2s(length(s))), "x");
}

RuStringDims(length : int, height : int);

ruStringDims(s : string) -> RuStringDims {
	lines = strSplit(s, "\n");
	RuStringDims(
		fold(tail(lines), strlen(lines[0]), \acc, line -> max(acc, strlen(line))),
		length(lines)
	);
}

ruFillCell(s : string, dims : RuStringDims) -> [string] {
	s_lines = strSplit(s, "\n");
	map(enumFromTo(0, dims.height - 1), \i ->
		if (i < length(s_lines)) {
			line = " " + s_lines[i];
			if (strlen(line) < dims.length) {
				rpad(line, " ", dims.length);
			} else {
				substring(line, 0, dims.length);
			}
		} else {
			strRepeat(" ", dims.length);
		}
	);
}

ruCompleteMatrix(m : [[string]]) -> [[string]] {
	max_rows = fold(m, 0, \acc, col -> max(acc, length(col)));
	fold(m, [], \acc, col ->
		concat(acc, [concat(col, arrayRepeat("", max_rows - length(col)))])
	);
}

ruStringMatrix2s(m : [[string]], colHeaders : Maybe<[string]>, rowHeadres : Maybe<[string]>) -> string {
	if (m == []) "" else {
		m1 = eitherMap(colHeaders, \hs -> mapi(m, \i, col -> concat([hs[i]], col)), m);
		m2 = eitherMap(rowHeadres, \hs -> concat(if (isNone(colHeaders)) [hs] else [concat([""], hs)], m1), m1);
		matr = ruCompleteMatrix(m2);
		n_rows = length(matr[0]);
		dims = map(matr, \col -> map(col, \row -> ruStringDims(row)));
		cols = map(dims, \col -> fold(col, 0, \ac, row -> max(ac, row.length + 2)));
		rows = map(enumFromTo(0, n_rows - 1), \i -> fold(dims, 0, \ac, col -> max(ac, col[i].height)));
		cells = mapi(matr, \i, col -> mapi(col, \j, row -> ruFillCell(row, RuStringDims(cols[i], rows[j]))));
		leng = fold(cols, 0, \acc, col -> acc + col);
		strGlue(
			map(enumFromTo(0, n_rows - 1),
				\i -> strGlue(
					map(enumFromTo(0, rows[i] - 1),
						\j -> strGlue(mapi(cols, \k,__ -> cells[k][i][j]), "|")
					),
					"\n"
				)
			),
			"\n" + strRepeat("-", leng) + "\n"
		)
	}
}

ruiLogN(n : int, N : int) -> int {
	if (n < 0) ruiLogN(-n, N) else 
	if (n < N) 1 else {
		1 + ruiLogN(n / N, N);
	}
}

ruiExpN(n : int, N : int) -> int {
	if (n < 0) ruiExpN(-n, N) else 
	if (n == 0) 1 else {
		N * ruiExpN(n - 1, N);
	}
}

rudLogN(n : double, N : int) -> int {
	if (n < 0.0) rudLogN(-n, N) else 
	if (n < i2d(N)) 1 else {
		1 + rudLogN(n / i2d(N), N);
	}
}

rudExpN(n : double, N : int) -> int {
	if (n < 0.0) rudExpN(-n, N) else 
	if (n == 0.0) 1 else {
		N * rudExpN(n - 1.0, N);
	}
}


ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void {
	message_with_limestamp = "[" + time2string(timestamp()) + "] " + message;
	log_file = if (fileExists(log_name)) getFileContent(log_name) else "";
	log_lines = strSplit(log_file, "\n");
	log_lines_cut = if (length(log_lines) > log_size) tailFrom(log_lines, log_size / 8) else log_lines;
	updated_log_lines = concat(log_lines_cut, [message_with_limestamp]);
	updated_log_file = strGlue(updated_log_lines, "\n");
	setFileContent(log_name, updated_log_file);
	{}
}

ruNameByLineCol(line : int, col : int, src : string) -> string {
	resolver = makeLineResolver(src);
	ruNameByPos(findLineIndex(resolver, line, col), src);
}

ruNameByPos(pos : int, src : string) -> string {
	eitherMap(ruNameRangeByPos(pos, src), \range -> substring(src, range.start, range.end - range.start + 1), "");
}

ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange> {
	is_name_char = \s -> s != "(" && s != ":" && s != ")" && s !="," && s != "=" && isNotSpace(s);
	if (pos < 0 || pos >= strlen(src) || !isNotSpace(getCharAt(src, pos))) None() else {
		start = for(pos, 
			\i -> if (i <= 0) false else is_name_char(getCharAt(src, i - 1)), 
			\i -> i - 1
		);
		end = for(pos, 
			\i -> if (i + 1 >= strlen(src)) false else is_name_char(getCharAt(src, i + 1)), 
			\i -> i + 1
		);
		Some(RuRange(start, end));
	}
}

ruDeleteDir(dir : string) -> [string] {
	msgs = fold(readDirectory(dir), [], \acc, x ->
		if (isDirectory(x)) {
			concat(acc, ruDeleteDir(x));
		} else {
			msg = deleteFile(x);
			if (msg == "") acc else {
				concat(acc, [msg]);
			}
		}
	);
	msg = deleteDirectory(dir);
	if (msg == "") msgs else {
		concat(msgs, [msg]);
	}
}

ruCopyFile(file1 : string, file2 : string) -> bool {
	setFileContent(file2, getFileContent(file1));
}

ruSetsIntersect(s1 : Set<?>, s2 : Set<?>) -> bool {
	if (sizeSet(s2) < sizeSet(s1)) {
		ruSetsIntersect(s2, s1);
	} else {
		existsSet(s1, \v -> containsSet(s2, v));
	}
}

ruExistsi(a : [?], fn : (int, ?) -> bool) -> bool {
	iteriUntil(a, fn) != length(a);
}

// Do a replacement "\n" to "\\n" and so on
ruServerEscapeString(str : string) -> string {
	strReplaces(str, ["\n", "\\n", "\r", "\\r", "\t", "\\t"]);
}

ruCutLongString(str : string) -> string {
	if (strlen(str) < 4096) str else {
		strLeft(ruServerEscapeString(str), 2048) + " ... " + strRight(ruServerEscapeString(str), strlen(str) - 2048);
	}
}

ruDebugLog1(message : string) -> void {
	log_file = "./russell_debug1.log";
	log_dir = ruDirName(log_file);
	if (log_dir != "") {
		err = ensureDirectoryExists(log_dir);
		if (err != "") {
			println(err);
		} else {
			ruWriteLogMessage(message, log_file, 256);
		}
	}
}






showDiffFiles(str1 : string, str2 : string) -> string {
	strGlue(mapi(
		diffFiles(str1, str2), \i, diff ->
			"diff " + i2s(i + 1) + ":\n" + showDiff(diff)
		), "\n====================\n"
	);
}

FcDiffPart(start : int, end : int, text : string);
FcDiff(left : FcDiffPart, right : FcDiffPart);

showDiffPart(part : FcDiffPart) -> string {
	"start=" + i2s(part.start) + ", end=" + i2s(part.end) + ", len=" + i2s(part.end - part.start) + " " 
	+ ", text:\n--------------\n" + part.text + "\n--------------\n\n";
}

showDiff(diff : FcDiff) -> string {
	"LEFT: " + showDiffPart(diff.left) + "RIGHT: " + showDiffPart(diff.right);
}

diffFiles(str1 : string, str2 : string) -> [FcDiff] {
	lines1 = strSplit(str1, "\n");
	lines2 = strSplit(str2, "\n");
	trie1 = foldi(lines1, makeTrie(), \i, acc, line -> addTrie(acc, line, concat(lookupTrieDef(acc, line, []), [i])));
	trie2 = foldi(lines2, makeTrie(), \i, acc, line -> addTrie(acc, line, concat(lookupTrieDef(acc, line, []), [i])));
	for(Triple([], 0,0), 
		\t -> {
			i1 = t.second;
			i2 = t.third;
			!(i1 == length(lines1) && i2 == length(lines2))
		},
		\t -> {
			acc = t.first;
			i1 = t.second;
			i2 = t.third;
			p1 = diffFilesHelper(i1 + 1, i2 + 1, lines1, length(lines2), trie2);
			p2 = diffFilesHelper(i2 + 1, i1 + 1, lines2, length(lines1), trie1);
			if (p1.second != -1) {
				s1 = p1.first - i1 + p1.second - i2;
				s2 = p2.first - i2 + p2.second - i1;
				if (s1 <= s2) {
					between1 = strGlue(subrange(lines1, i1 + 1, p1.first - i1 - 1), "\n");
					between2 = strGlue(subrange(lines2, i2 + 1, p1.second - i2 - 1), "\n");
					Triple(
						if (between1 == "" && between2 == "") acc else {
							concat(acc, [
								FcDiff(
									FcDiffPart(i1 + 1, p1.first, between1), 
									FcDiffPart(i2 + 1, p1.second, between2)
								)
							])
						},
						p1.first, 
						p1.second
					);
				} else {
					between1 = strGlue(subrange(lines1, i1 + 1, p2.second - i1 - 1), "\n");
					between2 = strGlue(subrange(lines2, i2 + 1, p2.first - i2 - 1), "\n");
					Triple(
						if (between1 == "" && between2 == "") acc else {
							concat(acc, [
								FcDiff(
									FcDiffPart(i1 + 1, p2.second, between1), 
									FcDiffPart(i2 + 1, p2.first, between2)
								)
							]);
						},
						p2.second, 
						p2.first
					);
				}
			} else {
				between1 = strGlue(subrange(lines1, i1 + 1, length(lines1) - i1 - 1), "\n");
				between2 = strGlue(subrange(lines2, i2 + 1, length(lines2) - i2 - 1), "\n");
				Triple(
					concat(acc, [
						FcDiff(
							FcDiffPart(i1 + 1, length(lines1) - 1, between1), 
							FcDiffPart(i2 + 1, length(lines2) - 1, between2)
						)
					]), 
					length(lines1), 
					length(lines2)
				);
			}
		}
	).first
}

diffFilesHelper(i : int, j : int, arr : [string], len : int, trie : Trie<[int]>) -> Pair<int, int> {
	if (i == length(arr)) {
		if (j == len) Pair(i, j) else Pair(i, -1);
	} else {
		switch (lookupTrie(trie, arr[i])) {
			Some(js_): {
				switch (find(js_, \j1 -> j <= j1)) {
					Some(j1): Pair(i, j1);
					None(): Pair(i, -1);
				}
			}
			None(): diffFilesHelper(i + 1, j, arr, len, trie);
		}
	}
}

/*
 When URI parser parses something like: 
	file:///c:/Users/dmitr/area9/flow9/tools/flowc
 it outputs path as: 
	/c:/Users/dmitr/area9/flow9/tools/flowc
 which is wrong in windows, first slash must be removed.
*/
ruCorrectUriPath(path : string) -> string {
	if (!startsWith(path, "/") || !hasTargetName("windows")) path else {
		path1 = strRight(path, 1);
		// Detect c:, d:, etc.
		if (isLetter(getCharAt(path1, 0)) && getCharAt(path1, 1) == ":") {
			path1
		} else {
			// keep original path 
			path
		}
	}
}


/*
RuTask(
	id : string,
	job  : () -> ??,
	fork : (?) -> ?,
	join : (?, ??) -> ?,
);

RuTaskFactory(
	produce : (?) -> [RuTask<?, ??>],
	complete : (?) -> bool
);

ruConcurrentTasks(factory : RuTaskFactory, init : ref ?) -> ? {
		ruDoConcurrentTasks(factory, init, initConcurrentHashMap(), ref makeSet());
		^init
	}
	ruConcurrent2(jobs : [() -> ?]) -> [?] {
		if (length(jobs) == 0) [] else
		if (length(jobs) == 1) [jobs[0]()] else 
		if (length(jobs) <= availableProcessors()) concurrent(true, jobs) else {
			jobs_map = initConcurrentHashMap();
			results = initConcurrentHashMap();
			iteri(jobs, \i, job -> setConcurrentHashMap(jobs_map, i, RuJobStatus(i, job)));
			ruDoConcurrentJobs(length(jobs), jobs_map, ref 0, ref 0, results);
			getTreeValues(fold(valuesConcurrentHashMap(results), makeTree(), \acc, res : RuJobResult<?> -> setTree(acc, res.ind, res.data)));
		}
	}

RuJobStatus(
	ind : int,
	job : () -> ?
);

RuJobResult(
	ind : int,
	data : ?
);

ruDoConcurrentJobs(njobs : int, jobs : native, started : ref int, finished : ref int, results : native) -> void {
	if (^finished < njobs) {
		free_cpus = availableProcessors() - (^started - ^finished);
		if (free_cpus > 0) {
			ready = take(valuesConcurrentHashMap(jobs), free_cpus);
			iter(ready, \job -> {
				atomicRefIntAddition(started, 1);
				removeConcurrentHashMap(jobs, job.ind);
				concurrentAsyncCallback(
					\__, cb -> cb(job.job()),
					\r -> {
						setConcurrentHashMap(results, job.ind, RuJobResult(job.ind, r));
						atomicRefIntAddition(finished, 1);
						{}
					}
				)
			});
		}
		//threadSleep(100); TODO
		ruDoConcurrentJobs(njobs, jobs, started, finished, results);
	}
}


ruDoConcurrentTasks(factory : RuTaskFactory, acc : ref ?, results : native, running : ref Set<string>) -> void {
	if (!factory.complete(^acc)) {
		tasks = factory.produce(^acc);
		iter(tasks, \task -> {
			acc := task.fork(^acc);
			running := insertSet(^running, task.id);
			concurrentAsyncCallback(
				\__, cb -> cb(task.job()),
				\w -> setConcurrentHashMap(results, task.id, \a -> task.join(a, w))
			)
		});
		iter(set2array(^running), \id ->
			if (containsConcurrentHashMap(results, id)) {
				acc := getConcurrentHashMap(results, id, idfn)(^acc);
				running := removeSet(^running, id);
			}
		);
		// threadSleep(100); TODO
		ruDoConcurrentTasks(factory, acc, results, running);
	}
}
*/
