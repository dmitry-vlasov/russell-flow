import mm/commands;

import ru/parse/commands;
import ru/to_mm;
import ru/refactor/split_math;
import ru/refactor/optimize_imports;

export {
	ruIoCommands1() -> [RuComm];
	ruCommReadAny(task : RuTask, env : RuEnv) -> RuEnv;
	ruTranslateCommands() -> [RuComm];
}

ruIoCommands1() -> [RuComm] {
	concatA([
		mmCommands(), 
		ruIoCommands(),
		[
			RuComm(
				"read", "io", "read a Russell file",
				[RuCommArg("file", false, "input file", "")],
				ruCommReadAny
			),
			RuComm(
				"split-math", "misc", "split a single file into a filesystem",
				[RuCommArg("file", false, "input file", "")],
				\task, env -> {
					file = lookupTreeDef(task.args, "file", "");
					module = ruTrimPath(file, env.conf, ".ru");
					RuEnv(env with ruMath = ruSplitMath(env.ruMath, env.conf, module));
				}
			),
			RuComm(
				"fix-left-recursion", "misc", "make all grammar rules non-left-recursive",
				[RuCommArg("file", false, "input file", "")],
				\task, env -> RuEnv(env with ruMath = ruFixLeftRecursiveRules(env.ruMath, env.conf))
			),
			RuComm(
				"optimize-imports", "misc", "optimize imports", [],
				\task, env -> RuEnv(env with ruMath = ruOptimizeImports(env.ruMath, env.conf))
			)
		]
	]);
}

ruCommReadAny(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruCommRead(task, env);
	} else if (endsWith(file, ".mm")) {
		mmCommRead(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		env;
	}
}

ruTranslateCommands() -> [RuComm] {[
	RuComm(
		"ru-to-mm", "translate", "translate Russell to Metamath", [],
		\task, env -> RuEnv(env with mmMath = ru2mm(env.ruMath, env.conf))
	)
]}
