import ru_math;

export {
	ruRemoveTheoremDuplicateSteps(theorem : RuTheorem, conf : RuConf) -> Maybe<RuTheorem>;
	ruRemoveTheoremUnusedSteps(theorem : RuTheorem, conf : RuConf) -> Maybe<RuTheorem>;

	ruCommandRemoveMathDuplicateSteps(math : RuMath) -> RuMath;
	ruCommandRemoveMathUnusedSteps(math : RuMath) -> RuMath;
	ruCommandRemoveMathUnusedHyps(math : RuMath) -> RuMath;
}

RuDuplicateStepsAcc(
	steps : [RuStep],
	exprMap : Tree<[RuExpNode], int>,
	stepMap : Tree<int, int>
);

ruRemoveTheoremDuplicateSteps(theorem : RuTheorem, conf : RuConf) -> Maybe<RuTheorem> {
	proof = theorem.proof;
	dup_steps_inds = ref [];
	new_steps = foldi(proof.steps, RuDuplicateStepsAcc([], makeTree(), makeTree()), \i, acc, step -> {
		new_step = RuStep(step with 
			ind = length(acc.steps),
			refs = map(step.refs, \r ->
				switch (r) {
					RuStepRef(j, pos): RuStepRef(lookupTreeDef(acc.stepMap, j, -1), pos);
					default: r;
				}
			)
		);
		switch (lookupTree(acc.exprMap, step.expr.nodes)) {
			Some(j): {
				refArrayPush(dup_steps_inds, i);
				RuDuplicateStepsAcc(acc with stepMap = setTree(acc.stepMap, i, j));
			}
			None(): {
				RuDuplicateStepsAcc(
					concat(acc.steps, [new_step]),
					setTree(acc.exprMap, step.expr.nodes, i),
					setTree(acc.stepMap, i, length(acc.steps))
				)
			}
		}
	}).steps;
	if (length(new_steps) == length(proof.steps)) None() else {
		if (conf.verbose > 1) {
			println("\ttheorem " + theorem.name + " has " + i2s(length(proof.steps) - length(new_steps)) + " duplicate steps: " + strGlue(map(^dup_steps_inds, \i -> i2s(i + 1)), ", "));
		}
		Some(RuTheorem(theorem with proof = ruUpdateProofVars(RuProof(proof with steps = new_steps))));
	}
}

ruRemoveTheoremUnusedSteps(theorem : RuTheorem, conf : RuConf) -> Maybe<RuTheorem> {
	proof = theorem.proof;
	used_steps = ruFindUsedSteps(lastElement(proof.steps, ruNoStep), theorem.proof, makeSet());
	if (sizeSet(used_steps) == length(proof.steps)) None() else {
		new_steps = foldi(proof.steps, Pair([], makeTree()), \i, acc, step -> {
			if (!containsSet(used_steps, i)) acc else {
				new_step = RuStep(step with 
					ind = length(acc.first),
					refs = map(step.refs, \r ->
						switch (r) {
							RuStepRef(j, pos): RuStepRef(lookupTreeDef(acc.second, j, -1), pos);
							default: r;
						}
					)
				);
				Pair(
					concat(acc.first, [new_step]),
					setTree(acc.second, i, length(acc.first))
				)
			}
		}).first;
		if (conf.verbose > 1) {
			unused = differenceSets(buildSet(enumFromTo(0, length(proof.steps) - 1)), used_steps);
			println("\ttheorem " + theorem.name + " has " + i2s(length(proof.steps) - length(new_steps)) + " unused steps: " +
			strGlue(map(set2array(unused), \i -> i2s(i + 1)), ", "));
		}
		Some(RuTheorem(theorem with proof = ruUpdateProofVars(RuProof(proof with steps = new_steps))));
	}
}

ruFindUsedSteps(step : RuStep, proof : RuProof, acc : Set<int>) -> Set<int> {
	fold(step.refs, insertSet(acc, step.ind), \ac, r ->
		switch (r) {
			RuStepRef(i, __): ruFindUsedSteps(proof.steps[i], proof, ac);
			default: ac;
		}
	)
}

ruRemoveTheoremUnusedHyps(theorem : RuTheorem, conf : RuConf) -> Maybe<Pair<RuTheorem, [bool]>> {
	proof = theorem.proof;
	used_hyps = ruFindUsedHyps(lastElement(proof.steps, ruNoStep), theorem.proof, makeSet());
	if (sizeSet(used_hyps) == length(theorem.hyps)) None() else {
		p = foldi(theorem.hyps, Pair([], makeTree()), \i, acc, hyp ->
			if (!containsSet(used_hyps, i)) acc else {
				new_hyp = RuHyp(length(acc.first), hyp.expr, hyp.pos);
				Pair(
					concat(acc.first, [new_hyp]),
					setTree(acc.second, i, length(acc.first))
				);
			}
		);
		mapping = mapi(theorem.hyps, \i,__ -> containsSet(used_hyps, i));
		new_steps = map(proof.steps, \step ->
			RuStep(step with refs = map(step.refs, \r ->
					switch (r) {
						RuHypRef(i, pos): RuHypRef(lookupTreeDef(p.second, i, -1), pos);
						default: r;
					}
				)
			)
		);
		if (conf.verbose > 1) {
			unused = differenceSets(buildSet(enumFromTo(0, length(theorem.hyps) - 1)), used_hyps);
			println("\ttheorem " + theorem.name + " has " + i2s(length(theorem.hyps) - length(p.first)) + " unused hyps: " + 
			strGlue(map(set2array(unused), \i -> i2s(i + 1)), ", "));
		}
		Some(Pair(
			ruUpdateTheoremVars(RuTheorem(theorem with 
				hyps = p.first, 
				proof = RuProof(proof with steps = new_steps)
			)),
			mapping
		));
	}
}

ruFindUsedHyps(step : RuStep, proof : RuProof, acc : Set<int>) -> Set<int> {
	fold(step.refs, acc, \ac, r ->
		switch (r) {
			RuStepRef(i, __): ruFindUsedHyps(proof.steps[i], proof, ac);
			RuHypRef(i, __): insertSet(ac, i);
		}
	)
}

ruCommandRemoveMathDuplicateSteps(math : RuMath) -> RuMath {
	start = timestamp();
	reduced = filtermap(ruConcurrent(
		map(getTreeValues(ruMathTheorems(math)), 
			\th -> \ -> ruRemoveTheoremDuplicateSteps(th, math.conf)
		)
	), idfn);
	ret = fold(reduced, math, \acc, th -> ruReplaceTheorem(th, acc));
	if (math.conf.verbose > 0) {
		println("found " + i2s(length(reduced)) + " theorems with duplicate steps in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	ret;
}

ruCommandRemoveMathUnusedSteps(math : RuMath) -> RuMath {
	start = timestamp();
	reduced = filtermap(ruConcurrent(
		map(getTreeValues(ruMathTheorems(math)), 
			\th -> \ -> ruRemoveTheoremUnusedSteps(th, math.conf)
		)
	), idfn);
	ret = fold(reduced, math, \acc, th -> ruReplaceTheorem(th, acc));
	if (math.conf.verbose > 0) {
		println("found " + i2s(length(reduced)) + " theorems with unused steps in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	ret;
}

ruCommandRemoveMathUnusedHyps(math : RuMath) -> RuMath {
	start = timestamp();
	reduced = filtermap(ruConcurrent(
		map(getTreeValues(ruMathTheorems(math)), 
			\th -> \ -> ruRemoveTheoremUnusedHyps(th, math.conf)
		)
	), idfn);
	if (reduced == []) math else {
		name2thms = ruName2ReferringTheorems(math);
		ret = fold(
			reduced,
			fold(reduced, math, \acc, p -> ruReplaceTheorem(p.first, acc)),
			\acc, p ->
				foldSet(lookupTreeDef(name2thms, p.first.name, makeSet()), acc, \ac, n -> {	
						th = lookupTreeDef(ac.assertions, n, ruNoAxiom);
						ruReplaceTheorem(
							ruRemoveTheoremRedundantHyps(
								cast(th : RuAssertion -> RuTheorem), 
								p.first.name, p.second, ac
							), 
							ac
						);
					}
				)
		);
		if (math.conf.verbose > 0) {
			println("found " + i2s(length(reduced)) + " theorems with unused hyps in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
		}
		ret;
	}
}

ruName2ReferringTheorems(math : RuMath) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, th, acc ->
		switch (th) {
			RuTheorem(__,__,__,__,__,__,proof,__): 
				fold(proof.steps, acc, \ac, step ->
					setTree(ac, step.assertion, 
						insertSet(lookupTreeDef(ac, step.assertion, makeSet()), th.name)
					)
				);
			default: acc;
		}
	);
}

ruRemoveTheoremRedundantHyps(theorem : RuTheorem, name : string, keep_hyp : [bool], math : RuMath) -> RuTheorem {
	proof = theorem.proof;
	new_steps = map(proof.steps, \step ->
		if (step.assertion != name) step else
		RuStep(step with 
			refs = foldi(step.refs, [], \i, acc, r ->
				if (keep_hyp[i]) concat(acc, [r]) else acc
			)
		)
	);
	ruUpdateTheoremVars(RuTheorem(theorem with 
		proof = RuProof(proof with steps = new_steps)
	));
}
