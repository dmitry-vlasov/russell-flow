import ru_math;

export {
	ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp;
	ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string;
	ruSubstRPN2s(s : Tree<RuVar, RuExp>) -> string;
	ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp) -> Maybe<Tree<RuVar, RuExp>>;
	ruAdd2Subst1(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool;
	ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>>;

	ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruBiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruUnsafeCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Tree<RuVar, RuExp>;

	ruSubsAreEq(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> bool;
	ruSubsAreSim(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
}

ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	conflict = ref false;
	s0 = mergeTreeCustom(s1, s2, \__, e1, e2 -> if (e1.nodes == e2.nodes) e1 else { conflict := true; e1 });
	if (^conflict) None() else Some(s0);
}

ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExp2s(p.second, math.rules)) 
	, "\n")
}

ruSubstRPN2s(s : Tree<RuVar, RuExp>) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExpRPN2s(p.second.nodes)) 
	, "\n")
}

ruAdd2Subst1(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	if (e.nodes[0].type == v.type) ruAdd2Subst(s, v, e) else 
	maybeBind(ruSuperRule(e.nodes[0].type, v.type, math), \super ->
		ruAdd2Subst(s, v, RuExp(concat([RuRuleRef(super.name, v.type, 1, 1)], e.nodes), e.pos))
	)
}

ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e0 : RuExp) -> Maybe<Tree<RuVar, RuExp>> {
	e = ruApplySubst(e0, s);
	if (e.nodes == [v]) Some(s) else {
		e_vars = ruExp2Vars(e.nodes);
		if (containsSet(e_vars, v)) None() else {
			switch (lookupTree(s, v)) {
				Some(e1): if (e.nodes == e1.nodes) Some(s) else None();
				None(): {
					p = foldSet(e_vars, Pair(true, None()), \acc, e_v ->
						if (!acc.first) acc else {
							switch (lookupTree(s, e_v)) {
								Some(e2): {
									e2_vars = ruExp2Vars(e2.nodes);
									if (!containsSet(e2_vars, e_v)) acc else {
										Pair(e2.nodes == [v] && e.nodes == [e_v], Some(e_v));
									}
								}
								None(): acc;
							}
						}
					);
					if (!p.first) None() else {
						switch (p.second) {
							Some(w): Some(removeFromTree(s, w));
							None():  {
								theta = makeTree1(v, e);
								Some(setTree(mapTree(s, \x -> ruApplySubst(x, theta)), v, e));
							}
						}
					}
				}
			}
		}
	}
}

ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s1, Some(makeTree()), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2Subst(s, v1, ruApplySubst(e1, s2)))
	);
}

ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s2, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1, v2)) Some(s) else ruAdd2Subst(s, v2, e2))
	);
}

ruBiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	maybeBind(ruSemiCompose(s2, s1), \s -> ruCompose(s1, s))
}

ruUnsafeCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Tree<RuVar, RuExp> {
	foldTree(s2, 
		foldTree(s1, makeTree(), \v1, e1, acc -> setTree(acc, v1, ruApplySubst(e1, s2))), 
		\v2, e2, acc -> if (containsKeyTree(acc, v2)) acc else setTree(acc, v2, e2)
	);
}

ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	add2s = \i, p : Pair<Tree<RuVar, RuExp>, int>, v, ex ->
		switch (lookupTree(p.first, v)) {
			Some(e1): if (ex.nodes == e1.nodes) Some(Pair(p.first, p.second + i)) else None();
			None(): Some(Pair(setTree(p.first, v, ex), p.second + i));
		}
	addVar = \i, t1, t2, n1, p, ec -> 
		if (t1 == t2) {
			add2s(i, p, n1, ec());
		} else {
			maybeBind(ruSuperRule(t2, t1, math), \super ->
				add2s(i, p, n1, RuExp(concat([RuRuleRef(super.name, t1, 1, 1)], ec().nodes), e.pos))
			)
		}
	maybeMap(fold(pattern.nodes, Some(Pair(makeTree(), 0)), \acc, n1 ->
		maybeBind(acc, \p ->
			switch (n1) {
				RuRuleRef(r1,__,__,__): {
					switch (e.nodes[p.second]) {
						RuRuleRef(r2,__,__,__): 
							if (r1 != r2) None() else Some(Pair(p.first, p.second + 1));
						RuVar(__,__): None();
					}
				}
				RuVar(v1, t1): {
					n2 = e.nodes[p.second];
					switch (n2) {
						RuRuleRef(r2, t2, __, len):
							addVar(len + 1, t1, t2, n1, p, \-> RuExp(subrange(e.nodes, p.second, len + 1), e.pos));
						RuVar(v2, t2):
							addVar(1, t1, t2, n1, p, \-> RuExp([n2], e.pos));
					}
				}
			}
		)
	), \p -> p.first);
}

RuApplyStack(
	parent : Maybe<RuApplyStack>,
	len : int
);

ruApplyComputeLen(arity : int, stack_len : Pair<RuApplyStack, int>) -> Pair<RuApplyStack, int> {
	if (arity == 0) stack_len else {
		switch (stack_len.first.parent) {
			Some(p): 
				ruApplyComputeLen(
					arity - 1, 
					Pair(p, stack_len.first.len + stack_len.second)
				);
			None(): {
				println("empty stack pop at ruApplyComputeLen");
				quit(0);
				stack_len;
			}
		}
	}
}

RuApplyAcc(
	nodes : [RuExpNode],
	stack : RuApplyStack
);

ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp {
	RuExp(reverseA(foldr(e.nodes, RuApplyAcc([], RuApplyStack(None(), 0)), 
		\acc, n -> {
			switch (n) {
				RuRuleRef(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						concat(acc.nodes, [RuRuleRef(r, t, a, st_len.second)]),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(v, t): {
					switch (lookupTree(s, n)) {
						Some(x):
							RuApplyAcc(
								concat(acc.nodes, reverseA(x.nodes)),
								RuApplyStack(Some(acc.stack), length(x.nodes))
							);
						None(): 
							RuApplyAcc(
								concat(acc.nodes, [n]),
								RuApplyStack(Some(acc.stack), 1)
							);
					}
				}
			}
		}).nodes)
		, e.pos
	)
}

ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool {
	forall(getTreeValues(s), ruIsVar)
}

ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>> {
	if (length(e.nodes) != length(pattern.nodes)) None() else {
		foldi(e.nodes, Some(makeTree()), \i, acc, v1 ->
			maybeBind(acc, \s -> {
				switch (v1) {
					RuRuleRef(r1,__,__,__): {
						switch (pattern.nodes[i]) {
							RuRuleRef(r2,__,__,__): if (r1 != r2) None() else Some(s);
							RuVar(__,__): None();
						}
					}
					RuVar(__, __): {
						v2 = pattern.nodes[i];
						switch (v2) {
							RuRuleRef(r2,__,__,__): None();
							RuVar(__,__):
								if (v1.type != v2.type) None() else {
									switch (lookupTree(s, v2)) {
										Some(w1): if (v1 == w1) Some(s) else None();
										None(): Some(setTree(s, v2, v1));
									}
								}
						}
					}
				}
			})
		)
	}
}

ruSubsAreEq(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> bool {
	if (sizeTree(s1) != sizeTree(s2)) false else {
		forall(tree2pairs(s1), \p ->
			switch (lookupTree(s2, p.first)) {
				Some(e2): p.second.nodes == e2.nodes;
				None(): false;
			}
		);
	}
}

ruSubsAreSim(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	if (sizeTree(s1) != sizeTree(s2)) None() else {
		theta = foldTree(s1, makeTree(), \v1, e1, acc ->
			switch (lookupTree(s2, v1)) {
				Some(__): acc;
				None(): {
					if (length(e1.nodes) != 1) acc else {
						v2 = e1.nodes[0];
						switch (v2) {
							RuVar(__,__): setTree(acc, v2, RuExp([v1], -1));
							default: acc;
						}
					}
				}
			}
		);
		maybeBind(ruCompose(s1, theta), \s -> if (ruSubsAreEq(s2, s)) Some(theta) else None());
	}
}
