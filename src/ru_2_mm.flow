import ru_verify;
import mm_src;

export {
	ruMath2mm(math : RuMath) -> MmMath;
}

ruMath2mm(math : RuMath) -> MmMath {
	start = timestamp();
	srcs = mapTree(math.sources, \src -> ruSource2mm(src, math));
	add_hyps = \acc, hs -> fold(hs, acc, \ac, h : MmHyp -> setTree(ac, h.label, h));
	labeled_consts = foldTree(srcs, Pair(makeTree(), makeSet()), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__, hyps, inner, stat):
					Pair(
						add_hyps(add_hyps(setTree(ac.first, stat.label, decl), hyps), inner),
						ac.second
					);
				MmConst(symbs): {
					Pair(ac.first, mergeSets(ac.second, buildSet(symbs)))
				}
				default: ac;
			}
		)
	);
	ret = ruAddTurnstile(math, MmMath(srcs, labeled_consts.first, labeled_consts.second, math.conf));
	if (math.conf.verbose > 0) {
		println("ru translated in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

ruAddTurnstile(ru_math : RuMath, mm_math : MmMath) -> MmMath {
	leaf_srcs = mmFindLeafSources(mm_math);
	common_dir = ruPath2s(ruCommonDir(map(leaf_srcs, \src -> ruSplitPath(src.info.path))));
	turnstile = ruMakeTurnstile(ru_math);
	turnstile_path = common_dir + "turnstile.mm";
	turnstile_file = ruTrimPath(turnstile_path, ru_math.conf, ".mm");
	turnstile_src = MmSource(
		[], 
		[MmConst([turnstile])], 
		ruMakeFileInfo(turnstile_file, turnstile_path)
	);
	acc1 = MmMath(mm_math with sources = setTree(mm_math.sources, turnstile_file, turnstile_src));
	fold(leaf_srcs, acc1, \acc, src ->
		MmMath(acc with 
			sources = setTree(acc.sources, src.info.file, 
				MmSource([MmInclude(turnstile_file)], src.decls, src.info)
			)
		)
	)
}

ruFindLeafSources(math : RuMath) -> [RuSource] {
	filter(getTreeValues(math.sources), \src -> src.imports == [])
}

ruMakeTurnstile(math : RuMath) -> string {
	ascii_consts = buildSet(map(getTreeValues(math.consts), \c -> c.ascii));
	ruDoMakeTurnstile("|-", ascii_consts)
}

ruDoMakeTurnstile(turnstile : string, consts : Set<string>) -> string {
	
	if (!containsSet(consts, turnstile)) turnstile else {
		ruDoMakeTurnstile("|" + turnstile, consts)
	}
}

ruSource2mm(src : RuSource, math : RuMath) -> MmSource {
	turnstile = ruMakeTurnstile(math);
	start = timestamp();
	ret = MmSource(
		map(src.imports, \imp -> MmInclude(imp.path)),
		concatA(ruConcurrent(map(src.decls, \decl -> \ -> ruDecl2mm(decl, turnstile, math)))),
		ruMakeFileInfo(src.info.file, src.info.file + ".mm")
	);
	if (math.conf.verbose > 1) {
		println("\tru translated: " + src.info.file + " in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

ruVar2mm(th : string, var : string) -> string {
	// Mm labels must be: "Only letters, digits, "_", "-", and "." are allowed in labels."
	// Replace all characters not falling into these classes with those, who fall. 
	var1 = fold(
		map(s2a(var), \i -> 
			if (i == 45 || i == 46 || i == 95) i else
			if (48 <= i  && i <= 57) i else 
			if (65 <= i  && i <= 90) i else
			if (97 <= i  && i <= 122) i else {
				if (i < 48) i + 32 else
				if (i < 65) i + 23 else 
				if (i < 97) i + 7 else i - 4
			}
		),
		"",
		\ac, i -> ac + fromCharCode(i)
	);
	th + "_" + var1
}

ruDecl2mm(decl : RuBlock, turnstile : string, math : RuMath) -> [MmDecl] {
	const2mm = \c -> if (c.ascii != "") c.ascii else c.name;
	term2mm = \t -> map(t.expr, 
		\s -> switch (s) {
			RuVar(v, __): 
				MmSymb(v, true);
			RuConstRef(c):
				MmSymb(const2mm(lookupTreeDef(math.consts, c, ruNoConst)), false);
		}
	);
	tvars2mm = \n, t -> fold(t.expr, [],
		\acc, s -> switch (s) {
			RuVar(var, type): 
				concat(acc, [MmFloating(ruVar2mm(n, var), type, var)]);
			RuConstRef(c):
				acc;
		}
	);
	expr2mm = \ex -> MmExp(concat([MmSymb(turnstile, false)], term2mm(ruExp2Term(ex, math.rules))));
	disj2mm = \disjs -> map(ruDisjs2Array(disjs), \ds -> MmDisj(map(set2array(ds), \d -> d.name)));
	vars2mm = \n, vs -> map(getTreeValues(vs), \v -> MmFloating(ruVar2mm(n, v.name), v.type, v.name));
	hyps2mm = \n, hs -> mapi(hs, \i, h -> MmEssential(n + "_" + i2s(i), expr2mm(h.expr)));
	comm2mm = \t -> {
		t0 = trim2(t, " \t\n\r");
		t1 = if (startsWith(t0, "/*") || startsWith(t0, "//")) strRight(t0, 2) else t0;
		if (endsWith(t1, "*/")) strLeft(t1, strlen(t1) - 2) else t1;
	}
	switch (decl) {
		RuComment(text,__): [MmComment(comm2mm(text))];
		RuConst(symb, ascii,__, __): [MmConst([const2mm(decl)])];
		RuType(name,__,__): {
			tenv = lookupTreeDef(math.types, name, ruNoTypeEnv);
			concat(
				[MmConst([name])], 
				concatA(map(getTreeValues(tenv.supers), \r -> ruDecl2mm(r, turnstile,math)))
			);
		}
		RuRule(name, vars, term, __):
			[MmAssertion(
				[], 
				tvars2mm(name, term), [],
				MmAxiomatic(name, MmExp(concat([MmSymb(term.type, false)], term2mm(term))))
			)];
		RuAxiom(name, vars, disjs, hyps, prop, __):
			[MmAssertion(
				disj2mm(disjs),
				concat(vars2mm(name, vars), hyps2mm(name, hyps)), [],
				MmAxiomatic(name, expr2mm(prop))
			)];
		RuTheorem(name, vars, disjs, meta, hyps, prop, proof, __):
			[MmAssertion(
				disj2mm(mergeSets(disjs, proof.disjs)),
				concat(vars2mm(name, vars), hyps2mm(name, hyps)),
				vars2mm(name, proof.vars),
				MmProvable(name, expr2mm(prop), MmNormalProof(ruProof2mm(lastElement(proof.steps, ruNoStep), decl, math)))
			)];
		RuDef(name, vars, disjs, hyps, defm, defs, prop, pos):
			[MmAssertion(
				disj2mm(disjs),
				concat(vars2mm(name, vars), hyps2mm(name, hyps)), [],
				MmAxiomatic(name, expr2mm(prop))
			)];
	}
}

ruProofExp2mm(i : int, nodes : [RuExpNode], name : string) -> Pair<[string], int> {
	switch (nodes[i]) {
		RuRuleRef(rule, __, arity, len): {
			args = fold(enumFromTo(1, arity), Pair([], i + 1), \acc, __ -> {
				arg = ruProofExp2mm(acc.second, nodes, name);
				Pair(concat(acc.first, arg.first), arg.second);
			});
			Pair(concat(args.first, [rule]), args.second);
		}
		RuVar(var, type): Pair([ruVar2mm(name, var)], i + 1);
	}
}

ruProof2mm(step : RuStep, th : RuTheorem, math : RuMath) -> [string] {
	switch (ruMatchStep(step, th, math)) {
		Some(p): {
			subs = fold(getTreeValues(p.first.vars), [], \acc, v ->
				switch (lookupTree(p.second, RuVar(v.name, v.type))) {
					None(): acc;
					Some(ex): concat(acc, ruProofExp2mm(0, ex.nodes, th.name).first);
				}
			)
			refs = fold(step.refs, [], \acc, ref ->
				switch (ref) {
					RuHypRef(ind,__): concat(acc, [th.name + "_" + i2s(ind)]);
					RuStepRef(ind,__): concat(acc, ruProof2mm(th.proof.steps[ind], th, math));
				}
			);
			concat3(subs, refs, [p.first.name]);
		}
		None(): [];
	}
}
