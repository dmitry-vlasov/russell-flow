import lingo/pegcode/driver;
import lingo/pegcode/parsic;
import base/db;

export {
	HtmlElement ::= HtmlTag, HtmlText, HtmlEntity;
		HtmlTag(
			title: string,
			attribs: [HtmlAttrib],
			body: [HtmlElement]
		);
		HtmlAttrib(key: string, val: string);
		HtmlText(text: string);
		HtmlEntity ::= HtmlDecEntity, HtmlHexEntity, HtmlCodeEntity;
			HtmlDecEntity(dec: string);   // like &#8828,  dec = 8828
			HtmlHexEntity(hex: string);   // like &#x22A4; hex = 22A4
			HtmlCodeEntity(code: string); // like &forall; code = forall

	parseHtml(text: string) -> Maybe<[HtmlElement]>;
	html2s(html : [HtmlElement]) -> string;
	htmlElement2s(elem : HtmlElement) -> string;

	// Decodes pairs like: igrave -> 236, (&igrave -> &#236).
	htmlEntity2UnicodeId(entity: HtmlEntity) -> int;
}

html_parser : ref Maybe<[PegOp]> = ref None();

htmlParser() -> [PegOp] {
	onlyOnce(html_parser, \ -> 
		compilePegGrammar("#include base/html.lingo")
	);
}

parseHtml(text: string) -> Maybe<[HtmlElement]> {
	triple = parsic3(htmlParser(), text, SemanticActions(
		mergeTree(defaultPegActions.t, pairs2tree([
			Pair("makeHtmlSingleTag", \s -> HtmlTag(s[0], s[1], [])),
			Pair("makeHtmlBodyTag", \s -> HtmlTag(s[0], s[1], s[2]))
		]))),
		[]
	);
	if (triple.third == "") Some(triple.first) else None();
}

html2s(html : [HtmlElement]) -> string {
	concatStrings(map(html, htmlElement2s));
}

htmlElement2s(elem : HtmlElement) -> string {
	switch (elem) {
		HtmlTag(title, attribs, body): {
			attribs_s = concatStrings(map(attribs, \attr -> attr.key + "='" + attr.val + "' "));
			if (body == []) {
				"<" + title + (if (length(attribs) == 0) "" else " ") + attribs_s + "/>";
			} else {
				"<" + title + (if (length(attribs) == 0) "" else " ") + attribs_s + ">" + html2s(body) + "</" + title + ">";
			}
		}
		HtmlText(text): text;
		HtmlDecEntity(dec): "&#" + dec + ";";  // like &#8828
		HtmlHexEntity(hex): "&#x" + hex + ";"; // like &#x22A4;
		HtmlCodeEntity(code): "&" + code + ";" // like &forall;
	}
}

isHexDigits(s) {
	isHexDigits0(s, 0, strlen(s))
}

isHexDigits0(s : string, index : int, len : int) -> bool {
	if (index < len) isHexDigit(getCharAt(s, index)) && isHexDigits0(s, index+1, len) else len > 0;
}

htmlEntity2UnicodeId(entity: HtmlEntity) -> int {
	switch (entity) {
		HtmlDecEntity(dec):  
			// like &#8828
			if (isDigits(dec)) s2i(dec) else -1;
		HtmlHexEntity(hex):
			// like &#x22A4;
			if (isHexDigits(hex)) parseHex(hex) else -1;
		HtmlCodeEntity(html_code): {
			table = onlyOnce(html2code_table, make_html2code_table);
			uni_code = lookupTreeDef(table, html_code, "");
			if (uni_code != "") s2i(uni_code) else -1;
		}
	}
}

html2code_table : ref Maybe<Tree<string, string>> = ref None();

make_html2code_table() -> Tree<string, string> {
	json_table = ruGetDbItem("common", ["html2unicode"]);
	table = map(getJsonObjectValue(json_table, []), \p -> 
		Pair(p.first, getJsonStringValue(p.second, ""))
	);
	pairs2tree(table);
}
