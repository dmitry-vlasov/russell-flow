import lingo/pegcode/driver;
import lingo/pegcode/parsic;

export {
	HtmlElement ::= HtmlTag, HtmlText, HtmlEntity;
		HtmlTag(
			title: string,
			attribs: [HtmlAttrib],
			body: [HtmlElement]
		);
		HtmlAttrib(key: string, val: string);
		HtmlText(text: string);
		HtmlEntity ::= HtmlDecEntity, HtmlHexEntity, HtmlCodeEntity;
			HtmlDecEntity(dec: string);   // like &#8828
			HtmlHexEntity(hex: string);   // like &#x22A4;
			HtmlCodeEntity(code: string); // like &forall;

	parseHtml(text: string) -> Maybe<[HtmlElement]>;
	html2s(html : [HtmlElement]) -> string;
}

html_parser : ref Maybe<[PegOp]> = ref None();

htmlParser() -> [PegOp] {
	onlyOnce(html_parser, \ -> 
		compilePegGrammar("#include base/html.lingo")
	);
}

parseHtml(text: string) -> Maybe<[HtmlElement]> {
	triple = parsic3(htmlParser(), text, SemanticActions(
		mergeTree(defaultPegActions.t, pairs2tree([
			Pair("makeHtmlSingleTag", \s -> HtmlTag(s[0], s[1], [])),
			Pair("makeHtmlBodyTag", \s -> HtmlTag(s[0], s[1], s[2]))
		]))),
		[]
	);
	if (triple.third == "") Some(triple.first) else None();
}

html2s(html : [HtmlElement]) -> string {
	concatStrings(map(html, htmlElement2s));
}

htmlElement2s(elem : HtmlElement) -> string {
	switch (elem) {
		HtmlTag(title, attribs, body): {
			attribs_s = concatStrings(map(attribs, \attr -> attr.key + "='" + attr.val + "' "));
			if (body == []) {
				"<" + title + (if (length(attribs) == 0) "" else " ") + attribs_s + "/>";
			} else {
				"<" + title + (if (length(attribs) == 0) "" else " ") + attribs_s + ">" + html2s(body) + "</" + title + ">";
			}
		}
		HtmlText(text): text;
		HtmlDecEntity(dec): "&#" + dec + ";";  // like &#8828
		HtmlHexEntity(hex): "&#x" + hex + ";"; // like &#x22A4;
		HtmlCodeEntity(code): "&" + code + ";" // like &forall;
	}
}
