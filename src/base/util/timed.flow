import ds/cart_prod;
import ds/set;
import ds/vector;
import base/util/timer;

export {

	RuTaskTimer(
		timer : RuTimer,
		interrupted : ref bool // true iff a task was not fully completed 
	);
	ruMakeTaskTimer(limit : double) -> RuTaskTimer;

	// Different iter functions with timer
	ruIter(a : [?], fn : (?) -> void, task : RuTaskTimer) -> void;
	ruIteri(a : [?], fn : (int, ?) -> void, task : RuTaskTimer) -> void;
	ruIterTree(t : Tree<?, ??>, fn : (?, ??) -> void, task : RuTaskTimer) -> void;
	ruIterSet(s : Set<?>, fn : (?) -> void, task : RuTaskTimer) -> void;
	ruIterList(l : List<?>, fn : (?) -> void, task : RuTaskTimer) -> void;
	ruIterCartProd(prod : CartProd<?>, f : ([?]) -> void, task : RuTaskTimer) -> void;

	// Different fold functions with timer
	ruFold(a : [?], init: ??, fn : (??, ?) -> ??, task : RuTaskTimer) -> ??;
	ruFoldi(a : [?], init: ??, fn : (int, ??, ?) -> ??, task : RuTaskTimer) -> ??;
	ruFoldTree(t : Tree<?, ??>, acc : ???, fn : (?, ??, ???) -> ???, task : RuTaskTimer) -> ???;
	ruFoldSet(s : Set<?>, init : ??, fn : (??, ?) -> ??, task : RuTaskTimer) -> ??;
	ruFoldList(l : List<?>, acc : ??, fn : (??, ?) -> ??, task : RuTaskTimer) -> ??;
	ruFoldCartProd(prod : CartProd<?>, init : ??, f : (??, [?]) -> ??, task : RuTaskTimer) -> ??;

	// timed mapping
	ruMap(a : [?], fn : (?) -> ??, defval : ??, task : RuTaskTimer) -> [??];
	ruMapi(a : [?], fn : (int, ?) -> ??, defval : ??, task : RuTaskTimer) -> [??];
	//ruMapTree(t : Tree<?, ??>, fn : (?, ??) -> ???, task : RuTaskTimer) -> Tree<?, ???>;
	//ruMapSet(s : Set<?>, fn : (?) -> ??, task : RuTaskTimer) -> Set<??>;
	//ruaMapList(l : List<?>, fn : (?) -> ??, task : RuTaskTimer) -> List<??>;

	ruIterHashMap(m : HashMap<?, ??>, fn : (?, ??) -> void, task : RuTaskTimer) -> void;
	ruRvector2array(v : Vector<?>) -> [?];

	native ruEvalTimed0 : (fn : () -> ??, defval : ??, time_limit : double) -> ?? = RussellTimed.evalTimed0;
	native ruEvalTimed1 : (fn : (?) -> ??, arg : ?, defval : ??, time_limit : double) -> ?? = RussellTimed.evalTimed1;
	native ruEvalTimed2 : (fn : (?, ??) -> ???, arg1 : ?, arg2 : ??, defval : ???, time_limit : double) -> ??? = RussellTimed.evalTimed2;
	native ruEvalTimed3 : (fn : (?, ??, ???) -> ????, arg1 : ?, arg2 : ??, arg3 : ???, defval : ????, time_limit : double) -> ???? = RussellTimed.evalTimed3;
	native ruEvalTimed4 : (fn : (?, ??, ???, ????) -> ?????, arg1 : ?, arg2 : ??, arg3 : ???, arg4 : ????, defval : ?????, time_limit : double) -> ????? = RussellTimed.evalTimed4;
	native ruEvalTimed5 : (fn : (?, ??, ???, ????, ?????) -> ??????, arg1 : ?, arg2 : ??, arg3 : ???, arg4 : ????, arg5 : ?????, defval : ??????, time_limit : double) -> ?????? = RussellTimed.evalTimed5;
}

ruMakeTaskTimer(limit : double) -> RuTaskTimer {
	RuTaskTimer(ruMakeLimitedTimer(limit), ref false);
}

ruIter(a : [?], fn : (?) -> void, task : RuTaskTimer) -> void {
	ruDoIter(a, fn, 0, task);
}

ruDoIter(a : [?], fn : (?) -> void, i : int, task : RuTaskTimer) -> void {
	if (i == length(a)) { } else 
	if (ruTimeIsOver(task.timer)) { task.interrupted := true; } else {
		fn(a[i]);
		ruDoIter(a, fn, i + 1, task);
	}
}

ruIteri(a : [?], fn : (int, ?) -> void, task : RuTaskTimer) -> void {
	ruDoIteri(a, fn, 0, task);
}

ruDoIteri(a : [?], fn : (int, ?) -> void, i : int, task : RuTaskTimer) -> void {
	if (i == length(a)) { } else 
	if (ruTimeIsOver(task.timer)) { task.interrupted := true; } else {
		fn(i, a[i]);
		ruDoIteri(a, fn, i + 1, task);
	}
}

ruIterTree(tree : Tree<?, ??>, f : (?, ??) -> void, task : RuTaskTimer) -> void {
	if (ruTimeIsOver(task.timer)) { task.interrupted := true; } else {
		switch (tree : Tree) {
			TreeEmpty(): { }
			TreeNode(k, v, left, right, depth): {
				f(k, v);
				ruIterTree(left, f, task);
				ruIterTree(right, f, task);
			}
		}
	}
}

ruIterSet(s : Set<?>, fn : (?) -> void, task : RuTaskTimer) -> void {
	ruIterTree(s.tree, \k, v -> fn(k), task);
}

ruIterList(l : List<?>, fn : (?) -> void, task : RuTaskTimer) -> void {
	if (ruTimeIsOver(task.timer)) { task.interrupted := true; } else {
		switch (l) {
			EmptyList(): { };
			Cons(h, t): {
				fn(h);
				ruIterList(t, fn, task);
			}
		}
	}
}


ruIterCartProd(prod : CartProd<?>, f : ([?]) -> void, task : RuTaskTimer) -> void {
	if (sizeCartProd(prod) > 0) {
		ruDoIterCartProd(prod, initCartProd(prod), f, task)
	}
}

ruDoIterCartProd(prod : CartProd<?>, v : [int], f : ([?]) -> void, task : RuTaskTimer) -> void {
	if (ruTimeIsOver(task.timer)) {
		task.interrupted := true;
	} else {
		f(mapi(v, \i, n -> prod.sets[i][n]));
		switch (nextCartProd(v, prod)) {
			Some(next): ruDoIterCartProd(prod, next, f, task);
			None(): {};
		}
	}
}

ruFold(a : [?], init: ??, fn : (??, ?) -> ??, task : RuTaskTimer) -> ?? {
	ruDoFold(a, init, fn, 0, task);
}

ruDoFold(a : [?], acc: ??, fn : (??, ?) -> ??, i : int, task : RuTaskTimer) -> ?? {
	if (i == length(a)) { acc; } else 
	if (ruTimeIsOver(task.timer)) { task.interrupted := true; acc; } else {
		ruDoFold(a, fn(acc, a[i]), fn, i + 1, task);
	}
}

ruFoldi(a : [?], init: ??, fn : (int, ??, ?) -> ??, task : RuTaskTimer) -> ?? {
	ruDoFoldi(a, init, fn, 0, task);
}

ruDoFoldi(a : [?], acc: ??, fn : (int, ??, ?) -> ??, i : int, task : RuTaskTimer) -> ?? {
	if (i == length(a)) { acc; } else 
	if (ruTimeIsOver(task.timer)) { task.interrupted := true; acc; } else {
		ruDoFoldi(a, fn(i, acc, a[i]), fn, i + 1, task);
	}
}

ruFoldTree(tree : Tree<?, ??>, acc : ???, f : (?, ??, ???) -> ???, task : RuTaskTimer) -> ??? {
	if (ruTimeIsOver(task.timer)) acc else {
		switch (tree : Tree) {
			TreeEmpty(): acc;
			TreeNode(k, v, left, right, depth): {
				acc1 = ruFoldTree(left, acc, f, task);
				acc2 = f(k, v, acc1);
				ruFoldTree(right, acc2, f, task);
			}
		}
	}
}

ruFoldSet(s : Set<?>, init : ??, fn : (??, ?) -> ??, task : RuTaskTimer) -> ?? {
	ruFoldTree(s.tree, init, \k, v, acc -> fn(acc, k), task);
}

ruFoldList(l : List<?>, acc : ??, fn : (??, ?) -> ??, task : RuTaskTimer) -> ?? {
	if (ruTimeIsOver(task.timer)) {
		task.interrupted := true;
		acc;
	} else {
		switch (l) {
			EmptyList(): acc;
			Cons(h, t): ruFoldList(t, fn(acc, h), fn, task);
		}
	}
}

ruFoldCartProd(prod : CartProd<?>, init : ??, f : (??, [?]) -> ??, task : RuTaskTimer) -> ?? {
	if (sizeCartProd(prod) == 0) init else
	ruDoFoldCartProd(prod, initCartProd(prod), init, f, task)
}

ruDoFoldCartProd(prod : CartProd<?>, v : [int], val : ??, f : (??, [?]) -> ??, task : RuTaskTimer) -> ?? {
	if (ruTimeIsOver(task.timer)) {
		task.interrupted := true;
		val;
	} else {
		d = mapi(v, \i, n -> prod.sets[i][n]);
		new_val = f(val, d);
		switch (nextCartProd(v, prod)) {
			Some(next): ruDoFoldCartProd(prod, next, new_val, f, task);
			None(): new_val;
		}
	}
}


ruMap(a : [?], fn : (?) -> ??, defval : ??, task : RuTaskTimer) -> [??] {
	reverseA(list2array(ruDoMap(a, fn, defval, task, makeList(), 0)));
}

ruDoMap(a : [?], fn : (?) -> ??, defval : ??, task : RuTaskTimer, acc : List<??>, i : int) -> List<??> {
	if (i == length(a)) acc else
	if (ruTimeIsOver(task.timer)) {
		task.interrupted := true;
		ruDoMap(a, fn, defval, task, Cons(defval, acc), i + 1);
	} else {
		ruDoMap(a, fn, defval, task, Cons(fn(a[i]), acc), i + 1);
	}
}

ruMapi(a : [?], fn : (int, ?) -> ??, defval : ??, task : RuTaskTimer) -> [??] {
	reverseA(list2array(ruDoMapi(a, fn, defval, task, makeList(), 0)));
}

ruDoMapi(a : [?], fn : (int, ?) -> ??, defval : ??, task : RuTaskTimer, acc : List<??>, i : int) -> List<??> {
	if (i == length(a)) acc else
	if (ruTimeIsOver(task.timer)) {
		task.interrupted := true;
		ruDoMapi(a, fn, defval, task, Cons(defval, acc), i + 1);
	} else {
		ruDoMapi(a, fn, defval, task, Cons(fn(i, a[i]), acc), i + 1);
	}
}


//ruMapTree(t : Tree<?, ??>, fn : (?, ??) -> ???, task : RuTaskTimer) -> Tree<?, ???>;
//ruMapSet(s : Set<?>, fn : (?) -> ??, task : RuTaskTimer) -> Set<??>;
//ruaMapList(l : List<?>, fn : (?) -> ??, task : RuTaskTimer) -> List<??>;

ruIterHashMap(m : HashMap<?, ??>, fn : (?, ??) -> void, task : RuTaskTimer) -> void {
	time_task = if (task.timer.limit == -1.0) -1.0 else ruTimeLeft(task.timer);
	task.interrupted := ruIterHashMapNative(m.map, fn, time_task);
}

native ruIterHashMapNative : (m : native, fn : (?, ??) -> void, time_task : double) -> bool = RussellTimed.iterHashMapTimed;

ruRvector2array(v : Vector<?>) -> [?] {
	rvector2arrayNative(v.vect);
}

native rvector2arrayNative : (v : native) -> [?] = RussellTimed.rvector2array;