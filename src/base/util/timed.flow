export {
	native ruEvalTimed0 : (fn : () -> ??, defval : ??, time_limit : double) -> ?? = RussellTimed.evalTimed0;
	native ruEvalTimed1 : (fn : (?) -> ??, arg : ?, defval : ??, time_limit : double) -> ?? = RussellTimed.evalTimed1;
	native ruEvalTimed2 : (fn : (?, ??) -> ???, arg1 : ?, arg2 : ??, defval : ???, time_limit : double) -> ??? = RussellTimed.evalTimed2;
	native ruEvalTimed3 : (fn : (?, ??, ???) -> ????, arg1 : ?, arg2 : ??, arg3 : ???, defval : ????, time_limit : double) -> ???? = RussellTimed.evalTimed3;
	native ruEvalTimed4 : (fn : (?, ??, ???, ????) -> ?????, arg1 : ?, arg2 : ??, arg3 : ???, arg4 : ????, defval : ?????, time_limit : double) -> ????? = RussellTimed.evalTimed4;
	native ruEvalTimed5 : (fn : (?, ??, ???, ????, ?????) -> ??????, arg1 : ?, arg2 : ??, arg3 : ???, arg4 : ????, arg5 : ?????, defval : ??????, time_limit : double) -> ?????? = RussellTimed.evalTimed5;
/*
	// Task is a triple: a function, timeout for its execution and default value
	TimeoutTask(
		fn : () -> ?,     // the task itself
		timeout : double, // timeout for execution in milliseconds
		defval : ?        // the value, which is used, when function is interrupted by timeout
	);
	native concurrentTimeout : (tasks : [TimeoutTask<?>], timeout : double) -> [?] = RussellTimed.concurrentTimeout;
	native sequentialTimeout : (tasks : [TimeoutTask<?>], timeout : double) -> [?] = RussellTimed.sequentialTimeout;
*/
}
