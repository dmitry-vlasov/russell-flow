import ds/cart_prod;
import ds/set;
import ds/vector;
import base/util/timer;

export {
	// Different iter functions with timer
	ruIter(a : [?], fn : (?) -> void, timer : RuTimer) -> void;
	ruIteri(a : [?], fn : (int, ?) -> void, timer : RuTimer) -> void;
	ruIterTree(t : Tree<?, ??>, fn : (?, ??) -> void, timer : RuTimer) -> void;
	ruIterSet(s : Set<?>, fn : (?) -> void, timer : RuTimer) -> void;
	ruIterList(l : List<?>, fn : (?) -> void, timer : RuTimer) -> void;

	// Different fold functions with timer
	ruFold(a : [?], init: ??, fn : (??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldi(a : [?], init: ??, fn : (int, ??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldTree(t : Tree<?, ??>, acc : ???, fn : (?, ??, ???) -> ???, timer : RuTimer) -> ???;
	ruFoldSet(s : Set<?>, init : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldList(l : List<?>, acc : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldCartProd(prod : CartProd<?>, init : ??, f : (??, [?]) -> ??, timer : RuTimer) -> ??;
	ruIterCartProd(prod : CartProd<?>, f : ([?]) -> void, timer : RuTimer) -> void;

	ruIterHashMap(m : HashMap<?, ??>, fn : (?, ??) -> void, timer : RuTimer) -> void;
	ruRvector2array(v : Vector<?>) -> [?];
}

ruIter(a : [?], fn : (?) -> void, timer : RuTimer) -> void {
	ruDoIter(a, fn, timer, 0);
}

ruDoIter(a : [?], fn : (?) -> void, timer : RuTimer, i : int) -> void {
	if (i == length(a) || ruTimeIsOver(timer)) { } else {
		fn(a[i]);
		ruDoIter(a, fn, timer, i + 1);
	}
}

ruIteri(a : [?], fn : (int, ?) -> void, timer : RuTimer) -> void {
	ruDoIteri(a, fn, timer, 0);
}

ruDoIteri(a : [?], fn : (int, ?) -> void, timer : RuTimer, i : int) -> void {
	if (i == length(a) || ruTimeIsOver(timer)) { } else {
		fn(i, a[i]);
		ruDoIteri(a, fn, timer, i + 1);
	}
}

ruIterTree(tree : Tree<?, ??>, f : (?, ??) -> void, timer : RuTimer) -> void {
	if (ruTimeIsOver(timer)) { } else {
		switch (tree : Tree) {
			TreeEmpty(): { }
			TreeNode(k, v, left, right, depth): {
				f(k, v);
				ruIterTree(left, f, timer);
				ruIterTree(right, f, timer);
			}
		}
	}
}

ruIterSet(s : Set<?>, fn : (?) -> void, timer : RuTimer) -> void {
	ruIterTree(s.tree, \k, v -> fn(k), timer);
}

ruIterList(l : List<?>, fn : (?) -> void, timer : RuTimer) -> void {
	if (ruTimeIsOver(timer)) { } else {
		switch (l) {
			EmptyList(): { };
			Cons(h, t): {
				fn(h);
				ruIterList(t, fn, timer);
			}
		}
	}
}


ruFold(a : [?], init: ??, fn : (??, ?) -> ??, timer : RuTimer) -> ?? {
	ruDoFold(a, init, fn, timer, 0);
}

ruDoFold(a : [?], acc: ??, fn : (??, ?) -> ??, timer : RuTimer, i : int) -> ?? {
	if (i == length(a) || ruTimeIsOver(timer)) acc else {
		ruDoFold(a, fn(acc, a[i]), fn, timer, i + 1);
	}
}

ruFoldi(a : [?], init: ??, fn : (int, ??, ?) -> ??, timer : RuTimer) -> ?? {
	ruDoFoldi(a, init, fn, timer, 0);
}

ruDoFoldi(a : [?], acc: ??, fn : (int, ??, ?) -> ??, timer : RuTimer, i : int) -> ?? {
	if (i == length(a) || ruTimeIsOver(timer)) acc else {
		ruDoFoldi(a, fn(i, acc, a[i]), fn, timer, i + 1);
	}
}

ruFoldTree(tree : Tree<?, ??>, acc : ???, f : (?, ??, ???) -> ???, timer : RuTimer) -> ??? {
	if (ruTimeIsOver(timer)) acc else {
		switch (tree : Tree) {
			TreeEmpty(): acc;
			TreeNode(k, v, left, right, depth): {
				acc1 = ruFoldTree(left, acc, f, timer);
				acc2 = f(k, v, acc1);
				ruFoldTree(right, acc2, f, timer);
			}
		}
	}
}

ruFoldSet(s : Set<?>, init : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ?? {
	ruFoldTree(s.tree, init, \k, v, acc -> fn(acc, k), timer);
}


ruFoldList(l : List<?>, acc : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ?? {
	if (ruTimeIsOver(timer)) acc else {
		switch (l) {
			EmptyList(): acc;
			Cons(h, t): ruFoldList(t, fn(acc, h), fn, timer);
		}
	}
}

ruFoldCartProd(prod : CartProd<?>, init : ??, f : (??, [?]) -> ??, timer : RuTimer) -> ?? {
	if (sizeCartProd(prod) == 0) init else
	ruDoFoldCartProd(prod, initCartProd(prod), init, f, timer)
}

ruDoFoldCartProd(prod : CartProd<?>, v : [int], val : ??, f : (??, [?]) -> ??, timer : RuTimer) -> ?? {
	if (ruTimeIsOver(timer)) val else {
		d = mapi(v, \i, n -> prod.sets[i][n]);
		new_val = f(val, d);
		switch (nextCartProd(v, prod)) {
			Some(next): ruDoFoldCartProd(prod, next, new_val, f, timer);
			None(): new_val;
		}
	}
}

ruIterCartProd(prod : CartProd<?>, f : ([?]) -> void, timer : RuTimer) -> void {
	if (sizeCartProd(prod) > 0) {
		ruDoIterCartProd(prod, initCartProd(prod), f, timer)
	}
}

ruDoIterCartProd(prod : CartProd<?>, v : [int], f : ([?]) -> void, timer : RuTimer) -> void {
	if (!ruTimeIsOver(timer)) {
		f(mapi(v, \i, n -> prod.sets[i][n]));
		switch (nextCartProd(v, prod)) {
			Some(next): ruDoIterCartProd(prod, next, f, timer);
			None(): {};
		}
	}
}

ruIterHashMap(m : HashMap<?, ??>, fn : (?, ??) -> void, timer : RuTimer) -> void {
	time_limit = if (timer.limit == -1.0) -1.0 else ruTimeLeft(timer);
	ruIterHashMapNative(m.map, fn, time_limit);
}

native ruIterHashMapNative : (m : native, fn : (?, ??) -> void, time_limit : double) -> void = RussellTimed.iterHashMapTimed;

ruRvector2array(v : Vector<?>) -> [?] {
	rvector2arrayNative(v.vect);
}

native rvector2arrayNative : (v : native) -> [?] = RussellTimed.rvector2array;