import lingo/linecolumn;
import formats/lsp;
import base/line_col;

export {
	RuRange(start : int, end : int);
	RuLocation(path : string, range : RuRange);

	ruNameByLineCol(line : int, col : int, src : string) -> string ;
	ruNameByPos(pos : int, src : string) -> string;
	ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange>;

	ruRangeCode2LspLocation(range : RuRange, path : string, code : string) -> LspLocation;
	ruRangeResolver2LspLocation(range : RuRange, path : string, resolver : LineResolver) -> LspLocation;
	ruRangePosTree2LspLocation(range : RuRange, path : string, pos_tree : Tree<int, RuLineCol>) -> LspLocation;
	
	ruRange2s(range : RuRange, msg : string, path : string, code : string) -> string;
	ruRangeWithResolver2s(path : string, range : RuRange, msg : string, resolver : LineResolver) -> string;
}

ruNameByLineCol(line : int, col : int, src : string) -> string {
	resolver = makeLineResolver(src);
	ruNameByPos(findLineIndex(resolver, line, col), src);
}

ruNameByPos(pos : int, src : string) -> string {
	eitherMap(ruNameRangeByPos(pos, src), \range -> substring(src, range.start, range.end - range.start + 1), "");
}

ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange> {
	is_name_char = \s -> s != "(" && s != ":" && s != ")" && s !="," && s != "=" && isNotSpace(s);
	if (pos < 0 || pos >= strlen(src) || !isNotSpace(getCharAt(src, pos))) None() else {
		start = for(pos, 
			\i -> if (i <= 0) false else is_name_char(getCharAt(src, i - 1)), 
			\i -> i - 1
		);
		end = for(pos, 
			\i -> if (i + 1 >= strlen(src)) false else is_name_char(getCharAt(src, i + 1)), 
			\i -> i + 1
		);
		Some(RuRange(start, end));
	}
}

ruRangeCode2LspLocation(range : RuRange, path : string, code : string) -> LspLocation {
	resolver = makeLineResolver(code);
	ruRangeResolver2LspLocation(range, path, resolver);
}

ruRangeResolver2LspLocation(range : RuRange, path : string, resolver : LineResolver) -> LspLocation {
	s = findLine(resolver, range.start);
	if (range.end < 0) {
		LspLocation(
			URI("file", URIAuthority("", "", ""), path, "", ""), 
			LspRange(
				LspPosition(s.lineno - 1, s.lineIndex),
				LspPosition(-1, -1)
			)
		);
	} else {
		e = findLine(resolver, range.end);
		LspLocation(
			URI("file", URIAuthority("", "", ""), path, "", ""), 
			LspRange(
				LspPosition(s.lineno - 1, s.lineIndex),
				LspPosition(e.lineno - 1, e.lineIndex)
			)
		);
	}
}

ruRangePosTree2LspLocation(range : RuRange, path : string, pos_tree : Tree<int, RuLineCol>) -> LspLocation {
	beg = lookupTreeDef(pos_tree, range.start, ruNoLineCol);
	if (range.end < 0) {
		LspLocation(
			URI("file", URIAuthority("", "", ""), path, "", ""), 
			LspRange(
				LspPosition(beg.line, beg.col),
				LspPosition(-1, -1)
			)
		);
	} else {
		end = lookupTreeDef(pos_tree, range.end, ruNoLineCol);
		LspLocation(
			URI("file", URIAuthority("", "", ""), path, "", ""), 
			LspRange(
				LspPosition(beg.line, beg.col),
				LspPosition(end.line, end.col)
			)
		);
	}
}

ruRange2s(range : RuRange, msg : string, path : string, code : string) -> string {
	if (path == "") "" else {
		resolver = makeLineResolver(code);
		ruRangeWithResolver2s(path, range, msg, resolver);
	}
}

ruRangeWithResolver2s(path : string, range : RuRange, msg : string, resolver : LineResolver) -> string {
	if (path == "") "" else {
		s = findLine(resolver, range.start);
		if (range.end < 0) {
			path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		} else {
			e = findLine(resolver, range.end);
			path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + i2s(e.lineno) + ":" + i2s(e.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		}
	}
}
