import ds/set;
import ds/hashset;
import math/math;

export {
	ruiLogN(n : int, N : int) -> int;
	ruiExpN(n : int, N : int) -> int;

	rudLogN(n : double, N : int) -> int;
	rudExpN(n : double, N : int) -> int;

	ruSetsIntersect(s1 : Set<?>, s2 : Set<?>) -> bool;
	ruHashSetsIntersect(s1 : HashSet<?>, s2 : HashSet<?>) -> bool;
	ruIsSubset(s1 : Set<?>, s2 : Set<?>) -> bool;
	ruExistsi(a : [?], fn : (int, ?) -> bool) -> bool;

	ruMaxIntFromArray(ints : [int]) -> int;
	ruMinIntFromArray(ints : [int]) -> int;
	ruSumIntsFromArray(ints : [int]) -> int;
	ruMaxDoubleFromArray(ints : [double]) -> double;
	ruMinDoubleFromArray(ints : [double]) -> double;
	ruSumDoublesFromArray(ints : [double]) -> double;

	ruTransposeMatrix(m : [[?]]) -> [[?]];

	ruSplitModulo(a : [?], m : int) -> [[?]];
	ruConcatAModulo(a : [[?]]) -> [?];
}

ruiLogN(n : int, N : int) -> int {
	if (n < 0) ruiLogN(-n, N) else 
	if (n < N) 1 else {
		1 + ruiLogN(n / N, N);
	}
}

ruiExpN(n : int, N : int) -> int {
	if (n < 0) ruiExpN(-n, N) else 
	if (n == 0) 1 else {
		N * ruiExpN(n - 1, N);
	}
}

rudLogN(n : double, N : int) -> int {
	if (n < 0.0) rudLogN(-n, N) else 
	if (n < i2d(N)) 1 else {
		1 + rudLogN(n / i2d(N), N);
	}
}

rudExpN(n : double, N : int) -> int {
	if (n < 0.0) rudExpN(-n, N) else 
	if (n == 0.0) 1 else {
		N * rudExpN(n - 1.0, N);
	}
}

ruSetsIntersect(s1 : Set<?>, s2 : Set<?>) -> bool {
	if (sizeSet(s2) < sizeSet(s1)) {
		ruSetsIntersect(s2, s1);
	} else {
		existsSet(s1, \v -> containsSet(s2, v));
	}
}

ruHashSetsIntersect(s1 : HashSet<?>, s2 : HashSet<?>) -> bool {
	if (sizeHashSet(s2) < sizeHashSet(s1)) {
		ruHashSetsIntersect(s2, s1);
	} else {
		existsHashSet(s1, \v -> containsHashSet(s2, v));
	}
}

ruIsSubset(s1 : Set<?>, s2 : Set<?>) -> bool {
	!existsSet(s1, \x -> !containsSet(s2, x));
}

ruExistsi(a : [?], fn : (int, ?) -> bool) -> bool {
	iteriUntil(a, fn) != length(a);
}

ruMaxIntFromArray(ints : [int]) -> int {
	fold(ints, 0, \acc, i -> max(acc, i));
}

ruMinIntFromArray(ints : [int]) -> int {
	fold(ints, 0, \acc, i -> min(acc, i));
}

ruSumIntsFromArray(ints : [int]) -> int {
	fold(ints, 0, \acc, i -> acc + i);
}

ruMaxDoubleFromArray(ints : [double]) -> double {
	fold(ints, 0.0, \acc, i -> max(acc, i));
}

ruMinDoubleFromArray(ints : [double]) -> double {
	fold(ints, 0.0, \acc, i -> min(acc, i));
}

ruSumDoublesFromArray(ints : [double]) -> double {
	fold(ints, 0.0, \acc, i -> acc + i);
}

ruTransposeMatrix(m : [[?]]) -> [[?]] {
	if (length(m) == 0) [] else {
		dimx = length(m);
		dimy = length(m[0]);
		map(enumFromTo(0, dimy - 1), \i ->
			map(enumFromTo(0, dimx - 1), \j -> m[j][i])
		);
	}
}

ruSplitModulo1(a : [?], m : int) -> [[?]] {
	n = length(a) / m;
	rest = length(a) % m;
	generate(0, n, \i -> {
		k = if (i + 1 < n || rest == 0) m else rest;
		generate(0, k, \j -> a[i * m + j]);
	});
}

ruSplitModulo(a : [?], m : int) -> [[?]] {
	n = length(a) / m;
	rest = length(a) % m;
	generate(0, m, \i ->
		if (i < rest) {
			generate(0, n + 1, \j -> a[j * m + i]);
		} else {
			generate(0, n, \j -> a[j * m + i]);
		}
	);
}

ruConcatAModulo(a : [[?]]) -> [?] {
	m = length(a);
	len = fold(a, 0, \acc, x -> acc + length(x));
	generate(0, len, \i -> a[i % m][i / m]);
}