import base/html/html;
import math/matrix;

export {
	ruHtml2md(html : [HtmlElement]) -> string;
}

ruHtml2md(html : [HtmlElement]) -> string {
	ruDoHtml2md(html, "*");
}

ruDoHtml2md(html : [HtmlElement], indent : string) -> string {
	concatStrings(map(html, \elem -> ruHtmlElement2md(elem, indent)))
}

ruHtmlElement2md(html : HtmlElement, indent : string) -> string {
	switch (html) {
		HtmlTag(open, attribs, body, close): {
			contents = ruDoHtml2md(body, indent);
			if (strlen(open) == 2 && getCharAt(open, 0) == "h") {
				ruHtmlHeading2md(s2i(getCharAt(open, 1)), contents);
			} else if (open == "p") {
				trim2(contents, " \n\t\r") + "\n\n";
			} else if (open == "br") {
				"\n";
			} else if (open == "strong") {
				"**" + contents + "**";
			} else if (open == "em") {
				"*" + contents + "*";
			} else if (open == "blockquote") {
				strGlue(map(strSplit(contents, "\n"), \line -> "> " + line), "\n");
			} else if (open == "ol" || open == "ul") {
				ruHtmlList2md(open, body, indent);
			} else if (open == "sub") {
				"_" + contents;
			} else if (open == "table") {
				ruHtmlTable2md(body);
			} else {
				contents;
			}
		}
		HtmlText(text): text;
		HtmlComment(text): "";
		HtmlEntity(prefix, body): unescapeHtmlEntity(html);
	}
}

ruHtmlHeading2md(level : int, body : string) -> string {
	if (level < 1 || level > 5) {
		fail("Illegal heading level: " + i2s(level));
		body;
	} else if (strContains(body, "\n")) {
		fail("Heading has new lines:\n" + body);
		body;
	} else {
		if (level == 1) {
			body1 = trim(body);
			body1 + "\n" + strRepeat("=", strlen(body1)) + "\n";
		} else if (level == 2) {
			body1 = trim(body);
			body1 + "\n" + strRepeat("-", strlen(body1)) + "\n";
		} else  {
			strRepeat("#", level) + (if (startsWith(body, " ")) "" else " ") + body;
		}
	}
}

insertPrefix2md(pref : string, s : string) -> string {
	non_space = findiDef(s2a(s), \code -> code > 32, -1);
	if (non_space == -1) {
		s + pref;
	} else {
		spaces = strLeft(s, non_space);
		contents = strRight(s, non_space);
		spaces + pref + contents;
	}
}

ruHtmlList2md(tag : string, body : [HtmlElement], indent : string) -> string {
	next_indent = if (indent == "*") "+" else if (indent == "+") "-" else "*";
	i = ref 0;
	"\n" + concatStrings(
		map(body, \elem ->  {
			str = ruHtmlElement2md(elem, next_indent);
			switch (elem) {
				HtmlTag(open, attibs, cont, close): {
					if (open != "li") str else {
						i := ^i + 1;
						if (tag == "ol") {
							insertPrefix2md(i2s(^i) + ". ", str);
						} else {
							insertPrefix2md(indent + " ", str);
						}
					}
				}
				default: str;
			}
		})
	);
}

ruExtractHtmlTags(body : [HtmlElement]) -> [HtmlTag] {
	filtermap(body, \elem ->
		switch(elem) {
			HtmlTag(open, attibs, body1, close): Some(elem);
			default: None();
		}
	);
}

ruFirstTag(body : [HtmlElement]) -> HtmlTag {
	tags = ruExtractHtmlTags(body);
	firstElement(tags, HtmlTag("", [], [], "")); 
}

ruHtmlTable2md(children : [HtmlElement]) -> string {
	first_row = ruFirstTag(children);
	first_col = ruFirstTag(first_row.children);
	headers = if (first_col.open != "th") None() else {
		Some(filtermap(first_row.children, \elem ->
			switch(elem) {
				HtmlTag(open, attibs, children1, close): {
					if (open != "th") None() else Some(ruDoHtml2md(children1, ""));
				}
				default: None();
			}
		));
	}
	tags = filtermap(children, \elem ->
		switch(elem) {
			HtmlTag(__,__,__,__): Some(elem);
			default: None();
		}
	);
	rows = filtermap(children, \elem ->
		switch(elem) {
			HtmlTag(open, attibs, children1, close): {
				if (open != "tr") None() else {
					col_tags = ruExtractHtmlTags(children1);
					if (col_tags == []) None() else {
						if (col_tags[0].open == "th") None() else {
							cols = filtermap(children1, \elem1 -> 
								switch(elem1) {
									HtmlTag(open1, attibs1, cell, close1): {
										if (open1 != "td") None() else {
											Some(ruDoHtml2md(cell, ""));
										}
									}
									default: None();
								}
							);
							Some(cols);
						}
					}
				}
			}
			default: None();
		}
	);
	cols = transposeMatrix(rows);
	"\n" + ruStringMatrix2s(cols, headers, None());
}
