import lingo/compiler/syntaxtree_util;
import formats/html/html;
import base/util/str;
import base/html/parser;
import base/html/ast;

export {
	HtmlNode ::= HtmlTag, HtmlText, HtmlEntity, HtmlComment;
		HtmlTag(
			tag: string,
			attribs: [HtmlAttrib],
			children: [HtmlNode]
		);
		HtmlAttrib(key: string, val: string);
		HtmlText(text: string);
		HtmlComment(text: string);
		HtmlEntity(
			prefix : string, // Prefixes: &# - decimal, &#x - hex, & - string
			body : string    // codes:    8828,         22A4       forall
		);
	parseHtml(text: string) -> Pair<[HtmlNode], string>;
	html2s(html : [HtmlNode]) -> string;
	HtmlNode2s(elem : HtmlNode) -> string;

	unescapeHtmlEntity(entity : HtmlEntity) -> string;
}

parseHtml(text: string) -> Pair<[HtmlNode], string> {
	err = ref "";
	on_err = \s -> err := ^err + (if (^err == "") "" else "\n") + "html parsing error: " + s;
	plain = parseHtmlPlain(text, on_err);
	elements = structHtml(plain, on_err);
	Pair(elements, ^err);
}

HtmlTagKind ::= HtmlTagOpen, HtmlTagClose, HtmlTagClopen;
	HtmlTagOpen(); HtmlTagClose(); HtmlTagClopen();

structHtml(elems : [Pair<HtmlNode, HtmlTagKind>], err : (string) -> void) -> [HtmlNode] {
	stack = structHtmlElem(elems, 0, err, ParseHtmlStack(HtmlTag("html", [], []), makeList(), None()));
	if  (stack.parent != None()) {
		err("non-empty stack at the end of html parsing:\n" + parseHtmlStack2s(stack));
	}
	list2array(stack.elems);
}

ParseHtmlStack(
	tag : HtmlTag,
	elems : List<HtmlNode>,
	parent : Maybe<ParseHtmlStack>
);

parseHtmlStackDepth(stack : ParseHtmlStack) -> int {
	switch (stack.parent) {
		Some(parent): 1 + parseHtmlStackDepth(parent);
		None(): 0;
	}
}

strIndentN(s : string, n : int) -> string {
	ruIndentWith(s, strRepeat("\t", n));
}

parseHtmlStack2s(stack : ParseHtmlStack) -> string {
	s = strIndentN(
		HtmlNode2s(stack.tag) + "[\n" + rtrim2(strIndent(html2sFormatted(list2array(stack.elems))), "\t\n") + "\n]",
		parseHtmlStackDepth(stack)
	);
	switch (stack.parent) {
		Some(parent): {
			parseHtmlStack2s(parent) + "\n------------------------\n" + s
		}
		None(): {
			s;
		}
	}
}

closeHtmlTag(depth : int, stack : ParseHtmlStack, err : (string) -> void) -> ParseHtmlStack {
	if (depth == 0) stack else {
		switch (stack.parent) {
			Some(parent): {
				new_stack = ParseHtmlStack(parent with
					elems = Cons(
						HtmlTag(stack.tag with 
							children = list2array(stack.elems)
						),
						parent.elems
					),
				);
				closeHtmlTag(depth - 1, new_stack, err);
			}
			None(): {
				err("no parent of: " + HtmlNode2s(stack.tag));
				stack;
			}
		}
	}
}

closeAllHtmlTags(stack : ParseHtmlStack) -> ParseHtmlStack {
	switch (stack.parent) {
		Some(parent): {
			new_stack = ParseHtmlStack(parent with
				elems = Cons(
					HtmlTag(stack.tag with 
						children = list2array(stack.elems)
					),
					parent.elems
				),
			);
			closeAllHtmlTags(new_stack);
		}
		None(): {
			stack;
		}
	}
}

structHtmlElem(elems : [Pair<HtmlNode, HtmlTagKind>], i : int, err : (string) -> void, stack : ParseHtmlStack) -> ParseHtmlStack {
	if (i == length(elems)) {
		closeAllHtmlTags(stack); 
	} else {
		elem = elems[i].first;
		stack1 = switch (elem) {
			HtmlTag(tag, attribs, __): {
				switch (elems[i].second) {
					HtmlTagClopen(): {
						ParseHtmlStack(stack with elems = Cons(elem, stack.elems));
					}
					HtmlTagOpen(): {
						if (tag == "br" || tag == "p") {
							ParseHtmlStack(stack with elems = Cons(HtmlTag(tag, [], []), stack.elems));
						} else {
							depth = if (tag == "li") {
								if (stack.tag.tag == "li") 1 else 0;
							} else if (tag == "tr") {
								if (stack.tag.tag == "tr") 1 else
								if (stack.tag.tag == "td") 2 else 0;
							} else if (tag == "td") {
								if (stack.tag.tag == "td") 1 else 0;
							} else {
								0;
							}
							ParseHtmlStack(elem, makeList(), Some(closeHtmlTag(depth, stack, err)));
						}
					}
					HtmlTagClose(): {
						if (tag == "br" || tag == "p") {
							stack;
						} else {
							if (stack.tag.tag != tag) {
								depth = if (tag == "tr") {
									if (stack.tag.tag == "table") 0 else 
									if (stack.tag.tag == "td") 2 else 0;
								} else if (tag == "ul" || tag == "ol") {
									if (stack.tag.tag == "li") 2 else 0;
								} else if (tag == "table") {
									if (stack.tag.tag == "tr") 2 else
									if (stack.tag.tag == "td") 3 else 0;
								} else {
									0;
								}
								closeHtmlTag(depth, stack, err);
							} else {
								closeHtmlTag(1, stack, err);
							}
						}
					}
				}
			}
			default: {
				ParseHtmlStack(stack with elems = Cons(elem, stack.elems));
			}
		}
		structHtmlElem(elems, i + 1, err, stack1);
	}
}

html2s(html : [HtmlNode]) -> string {
	concatStrings(map(html, HtmlNode2s));
}

HtmlNode2s(elem : HtmlNode) -> string {
	switch (elem) {
		HtmlTag(tag, attribs, body): {
			attribs_s = concatStrings(
				mapi(attribs, \i, attr -> 
					attr.key + "='" + attr.val + "'" + if (i + 1 != length(attribs)) " " else ""
				)
			);
			if (length(body) > 0) {
				open_tag = "<" + tag + (if (length(attribs) == 0) "" else " ") + attribs_s + ">";
				close_tag = "</" + tag + ">";
				open_tag + html2s(body) + close_tag;
			} else {
				"<" + tag + (if (length(attribs) == 0) "" else " ") + attribs_s + "/>"
			}
		}
		HtmlText(text):       text;
		HtmlComment(text):    "<!--" + text + "-->";
		HtmlEntity(prefix, body): prefix + body + ";";
	}
}

html2sFormatted(html : [HtmlNode]) -> string {
	concatStrings(map(html, HtmlNode2sFormatted));
}

HtmlNode2sFormatted(elem : HtmlNode) -> string {
	switch (elem) {
		HtmlTag(tag, attribs, body): {
			attribs_s = concatStrings(
				mapi(attribs, \i, attr -> 
					attr.key + "='" + attr.val + "'" + if (i + 1 != length(attribs)) " " else ""
				)
			);
			if (body == []) {
				"<" + tag + (if (length(attribs) == 0) "" else " ") + attribs_s + "/>\n";
			} else {
				open_tag = "<" + tag + (if (length(attribs) == 0) "" else " ") + attribs_s + ">";
				close_tag = "</" + tag + ">";
				open_tag + "\n" + rtrim2(strIndent(html2sFormatted(body)), "\n\t") + "\n" + close_tag + "\n";
			}
		}
		HtmlText(text):       "\"" + escapeStr(text) + "\"\n";
		HtmlComment(text):    "<!--" + escapeStr(text) + "-->\n";
		HtmlEntity(prefix, body): prefix + body + ";";
	}
}

isHexDigits(s) {
	isHexDigits0(s, 0, strlen(s))
}

isHexDigits0(s : string, index : int, len : int) -> bool {
	if (index < len) isHexDigit(getCharAt(s, index)) && isHexDigits0(s, index+1, len) else len > 0;
}

parseHtmlPlain(src : string, err : (string) -> void) -> [Pair<HtmlNode, HtmlTagKind>] {
	pr1 = parse_html_source(src);
	st = pr1.first;
	if (st.end != strlen(src)) {
		msg = "met: '" + pr1.second.met + "', while expected: '" + strGlue(pr1.second.expected, ", ") + "'";
		err("Syntax error: " + msg + ", html source:\n" + 
				strIndent(src)
		);
		[]
	} else {
		htmlMakeElements(st, src, err);
	}
}

htmlMakeElements(st : SyntaxTree, src : string, err : (string) -> void) -> [Pair<HtmlNode, HtmlTagKind>] {
	synt_trees = get_html_source_html_element_s(st);
	map(synt_trees,
		\elem -> {
			if (elem.rule == st_html_text) {
				Pair(HtmlText(grabSTText(elem, src)), HtmlTagOpen());
			} else if (elem.rule == st_html_comment) {
				comment = grabSTText(get_html_source_html_comment_text(elem), src);
				Pair(HtmlComment(comment), HtmlTagOpen());
			} else if (elem.rule == st_html_entity) {
				prefix = grabSTText(get_html_source_html_entity_prefix(elem), src);
				body = grabSTText(get_html_source_html_entity_body(elem), src);
				Pair(HtmlEntity(prefix, body), HtmlTagOpen());
			} else if (elem.rule == st_html_tag) {
				open = grabSTText(get_html_source_html_tag_open(elem), src);
				close = grabSTText(get_html_source_html_tag_close(elem), src);
				tag = toLowerCase(grabSTText(get_html_source_html_id(elem), src));
				attribs = htmlMakeAttribs(get_html_source_html_attrib_s(elem), src);
				if (open == "<" && close == "/>") {
					Pair(HtmlTag(tag, attribs, []), HtmlTagClopen());
				} else if (open == "<" && close == ">") {
					Pair(HtmlTag(tag, attribs, []), HtmlTagOpen());
				} else if (open == "</" && close == ">") {
					Pair(HtmlTag(tag, attribs, []), HtmlTagClose());
				} else {
					err("Illegal tag: " + grabSTText(elem, src));
					Pair(HtmlComment(""), HtmlTagOpen());
				}
			} else {
				// Shouldn't happen
				Pair(HtmlComment(""), HtmlTagOpen());
			}
		}
	);
}

htmlMakeAttribs(sts : [SyntaxTree], src : string) -> [HtmlAttrib] {
	map(sts,
		\elem -> {
			make_attrib = \v -> {
				key = toLowerCase(grabSTText(get_html_source_html_id(elem), src));
				val = toLowerCase(v);
				HtmlAttrib(key, val);
			}
			if (elem.rule == st_html_attrib1) {
				make_attrib(grabSTText(get_html_source_html_attrib1_val(elem), src));
			} else if (elem.rule == st_html_attrib2) {
				make_attrib(grabSTText(get_html_source_html_attrib2_val(elem), src));
			} else if (elem.rule == st_html_attrib3) {
				make_attrib(grabSTText(get_html_source_html_attrib1_val(elem), src));
			} else if (elem.rule == st_html_attrib4) {
				make_attrib("1");
			} else {
				// Shouldn't happen
				HtmlAttrib("", "");
			}
		}
	);
}

unescapeHtmlEntity(entity : HtmlEntity) -> string {
	if (entity.prefix == "&#") {
		fromCharCode(s2i(entity.body)); // like &#8828,
	} else if (entity.prefix == "&#x") {
		fromCharCode(parseHex(entity.body)); // like &#x22A4;
	} else {
		unescapeHtml2("&" + entity.body + ";"); // like &forall;
	}
}
