import lingo/pegcode/driver;
import lingo/pegcode/parsic;
import lingo/compiler/syntaxtree_util;
import base/db;
import base/util/str;
import base/html/parser;
import base/html/ast;
import string_utils;

export {
	HtmlElement ::= HtmlTag, HtmlText, HtmlEntity, HtmlComment;
		HtmlTag(
			open: string,
			attribs: [HtmlAttrib],
			body: [HtmlElement],
			close: string
		);
		HtmlAttrib(key: string, val: string);
		HtmlText(text: string);
		HtmlComment(text: string);
		HtmlEntity(
			prefix : string, // Prefixes: &# - decimal (like &#8828), &#x - hex (like &#x22A4), & - label (like &forall)
			body : string
		);
	parseHtml(text: string) -> Pair<[HtmlElement], string>;
	html2s(html : [HtmlElement]) -> string;
	htmlElement2s(elem : HtmlElement) -> string;
	html2sFormatted(html : [HtmlElement]) -> string;
	htmlElement2sFormatted(elem : HtmlElement) -> string;

	// Decodes pairs like: igrave -> 236, (&igrave -> &#236).
	htmlEntity2UnicodeId(entity: HtmlEntity) -> int;
}

parseHtml(text: string) -> Pair<[HtmlElement], string> {
	pair = parseHtmlPlain(text);
	err = ref pair.second;
	elements = structHtml(
		pair.first, 
		\s -> err := ^err + (if (^err == "") "" else "\n") + "html parsing error: " + s
	);
	Pair(elements, ^err);
}

structHtml(elems : [HtmlElement], err : (string) -> void) -> [HtmlElement] {
	stack = structHtmlElem(elems, 0, err, ParseHtmlStack(HtmlTag("html", [], [], "html"), makeList(), None()));
	if  (stack.parent != None()) {
		err("non-empty stack at the end of html parsing:\n" + parseHtmlStack2s(stack));
	}
	list2array(stack.elems);
}

ParseHtmlStack(
	tag : HtmlTag,
	elems : List<HtmlElement>,
	parent : Maybe<ParseHtmlStack>
);

parseHtmlStackDepth(stack : ParseHtmlStack) -> int {
	switch (stack.parent) {
		Some(parent): 1 + parseHtmlStackDepth(parent);
		None(): 0;
	}
}

strIndentN(s : string, n : int) -> string {
	ruIndentWith(s, strRepeat("\t", n));
}

parseHtmlStack2s(stack : ParseHtmlStack) -> string {
	s = strIndentN(
		htmlElement2s(stack.tag) + "[\n" + rtrim2(strIndent(html2sFormatted(list2array(stack.elems))), "\t\n") + "\n]",
		parseHtmlStackDepth(stack)
	);
	switch (stack.parent) {
		Some(parent): {
			parseHtmlStack2s(parent) + "\n------------------------\n" + s
		}
		None(): {
			s;
		}
	}
}

closeHtmlTag(depth : int, stack : ParseHtmlStack, err : (string) -> void) -> ParseHtmlStack {
	if (depth == 0) stack else {
		switch (stack.parent) {
			Some(parent): {
				new_stack = ParseHtmlStack(parent with
					elems = Cons(
						HtmlTag(stack.tag with 
							body = list2array(stack.elems),
							close = parent.tag.open
						),
						parent.elems
					),
				);
				closeHtmlTag(depth - 1, new_stack, err);
			}
			None(): {
				err("no parent of: " + htmlElement2s(stack.tag));
				stack;
			}
		}
	}
}

closeAllHtmlTags(stack : ParseHtmlStack) -> ParseHtmlStack {
	switch (stack.parent) {
		Some(parent): {
			new_stack = ParseHtmlStack(parent with
				elems = Cons(
					HtmlTag(stack.tag with 
						body = list2array(stack.elems),
						close = parent.tag.open
					),
					parent.elems
				),
			);
			closeAllHtmlTags(new_stack);
		}
		None(): {
			stack;
		}
	}
}

structHtmlElem(elems : [HtmlElement], i : int, err : (string) -> void, stack : ParseHtmlStack) -> ParseHtmlStack {
	if (i == length(elems)) {
		closeAllHtmlTags(stack); 
	} else {
		elem = elems[i];
		stack1 = switch (elem) {
			HtmlTag(open, attribs, __, close): {
				if (open != "" && close != "") {
					ParseHtmlStack(stack with elems = Cons(elem, stack.elems));
				} else if (open != "") {
					if (open == "br" || open == "p") {
						ParseHtmlStack(stack with elems = Cons(HtmlTag(open, [], [], open), stack.elems));
					} else {
						depth = if (open == "li") {
							if (stack.tag.open == "li") 1 else 0;
						} else if (open == "tr") {
							if (stack.tag.open == "tr") 1 else
							if (stack.tag.open == "td") 2 else 0;
						} else if (open == "td") {
							if (stack.tag.open == "td") 1 else 0;
						} else {
							0;
						}
						ParseHtmlStack(elem, makeList(), Some(closeHtmlTag(depth, stack, err)));
					}
				} else if (close != "") {
					if (close == "br" || close == "p") {
						stack;
					} else {
						if (stack.tag.open != close) {
							depth = if (close == "tr") {
								if (stack.tag.open == "table") 0 else 
								if (stack.tag.open == "td") 2 else 0;
							} else if (close == "ul" || close == "ol") {
								if (stack.tag.open == "li") 2 else 0;
							} else if (close == "table") {
								if (stack.tag.open == "tr") 2 else
								if (stack.tag.open == "td") 3 else 0;
							} else {
								0;
							}
							closeHtmlTag(depth, stack, err);
						} else {
							closeHtmlTag(1, stack, err);
						}
					}
				} else {
					err("empty tag");
					stack;
				}
			}
			default: {
				ParseHtmlStack(stack with elems = Cons(elem, stack.elems));
			}
		}
		structHtmlElem(elems, i + 1, err, stack1);
	}
}

html2s(html : [HtmlElement]) -> string {
	concatStrings(map(html, htmlElement2s));
}

htmlElement2s(elem : HtmlElement) -> string {
	switch (elem) {
		HtmlTag(open, attribs, body, close): {
			attribs_s = concatStrings(
				mapi(attribs, \i, attr -> 
					attr.key + "='" + attr.val + "'" + if (i + 1 != length(attribs)) " " else ""
				)
			);
			if (length(body) > 0) {
				open_tag = if (open == "") "" else {
					"<" + open + (if (length(attribs) == 0) "" else " ") + attribs_s + ">"
				}; 
				close_tag = if (close == "") "" else {
					"</" + close + ">"
				};
				open_tag + html2s(body) + close_tag;
			} else {
				"<" + (if (open != "") open else close) + (if (length(attribs) == 0) "" else " ") + attribs_s + "/>"
			}
		}
		HtmlText(text):       text;
		HtmlComment(text):    "<!--" + text + "-->";
		HtmlEntity(prefix, body): prefix + body + ";";
	}
}

html2sFormatted(html : [HtmlElement]) -> string {
	concatStrings(map(html, htmlElement2sFormatted));
}

htmlElement2sFormatted(elem : HtmlElement) -> string {
	switch (elem) {
		HtmlTag(open, attribs, body, close): {
			attribs_s = concatStrings(
				mapi(attribs, \i, attr -> 
					attr.key + "='" + attr.val + "'" + if (i + 1 != length(attribs)) " " else ""
				)
			);
			if (body == []) {
				"<" + open + (if (length(attribs) == 0) "" else " ") + attribs_s + "/>\n";
			} else {
				open_tag = if (open == "") "" else {
					"<" + open + (if (length(attribs) == 0) "" else " ") + attribs_s + ">"
				}; 
				close_tag = if (close == "") "</" + open + ">" else {
					"</" + close + ">"
				};
				open_tag + "\n" + rtrim2(strIndent(html2sFormatted(body)), "\n\t") + "\n" + close_tag + "\n";
			}
		}
		HtmlText(text):       "\"" + escapeStr(text) + "\"\n";
		HtmlComment(text):    "<!--" + escapeStr(text) + "-->\n";
		HtmlEntity(prefix, body): prefix + body + ";";
	}
}

isHexDigits(s) {
	isHexDigits0(s, 0, strlen(s))
}

isHexDigits0(s : string, index : int, len : int) -> bool {
	if (index < len) isHexDigit(getCharAt(s, index)) && isHexDigits0(s, index+1, len) else len > 0;
}

htmlEntity2UnicodeId(entity: HtmlEntity) -> int {
	if (entity.prefix == "&#") {
		// like &#8828
		if (isDigits(entity.body)) s2i(entity.body) else -1;
	} else if (entity.prefix == "&#x") {
		// like &#x22A4;
		if (isHexDigits(entity.body)) parseHex(entity.body) else -1;
	} else {
		// like &forall;
		table = onlyOnce(html2code_table, make_html2code_table);
		uni_code = lookupTreeDef(table, entity.body, "");
		if (uni_code != "") s2i(uni_code) else -1;
	}
}

html2code_table : ref Maybe<Tree<string, string>> = ref None();

make_html2code_table() -> Tree<string, string> {
	json_table = ruGetDbItem("common", ["html2unicode"]);
	table = map(getJsonObjectValue(json_table, []), \p -> 
		Pair(p.first, getJsonStringValue(p.second, ""))
	);
	pairs2tree(table);
}

parseHtmlPlain(src : string) -> Pair<[HtmlElement], string> {
	pr1 = parse_html_source(src);
	st = pr1.first;
	if (st.end != strlen(src)) {
		err = "met: '" + pr1.second.met + "', while expected: '" + strGlue(pr1.second.expected, ", ") + "'";
		Pair([],
			"Syntax error: " + err + ", html source:\n" + 
				strIndent(src)
		);
	} else {
		Pair(htmlMakeElements(st, src), "");
	}
}

htmlMakeElements(st : SyntaxTree, src : string) -> [HtmlElement] {
	synt_trees = get_html_source_html_element_s(st);
	map(synt_trees,
		\elem -> {
			if (elem.rule == st_html_text) {
				HtmlText(grabSTText(elem, src));
			} else if (elem.rule == st_html_comment) {
				comment = grabSTText(get_html_source_html_comment_text(elem), src);
				HtmlComment(comment);
			} else if (elem.rule == st_html_entity) {
				prefix = grabSTText(get_html_source_html_entity_prefix(elem), src);
				body = grabSTText(get_html_source_html_entity_body(elem), src);
				HtmlEntity(prefix, body);
			} else if (elem.rule == st_html_tag) {
				open = grabSTText(get_html_source_html_tag_open(elem), src);
				close = grabSTText(get_html_source_html_tag_close(elem), src);
				tag = toLowerCase(grabSTText(get_html_source_html_id(elem), src));
				attribs = htmlMakeAttribs(get_html_source_html_attrib_s(elem), src);
				if (open == "<" && close == "/>") {
					HtmlTag(tag, attribs, [], tag);
				} else if (open == "<") {
					HtmlTag(tag, attribs, [], "");
				} else {
					HtmlTag("", attribs, [], tag);
				}
			} else {
				// Shouldn't happen
				HtmlComment("");
			}
		}
	);
}

htmlMakeAttribs(sts : [SyntaxTree], src : string) -> [HtmlAttrib] {
	map(sts,
		\elem -> {
			make_attrib = \v -> {
				key = toLowerCase(grabSTText(get_html_source_html_id(elem), src));
				val = toLowerCase(v);
				HtmlAttrib(key, val);
			}
			if (elem.rule == st_html_attrib1) {
				make_attrib(grabSTText(get_html_source_html_attrib1_val(elem), src));
			} else if (elem.rule == st_html_attrib2) {
				make_attrib(grabSTText(get_html_source_html_attrib2_val(elem), src));
			} else if (elem.rule == st_html_attrib3) {
				make_attrib(grabSTText(get_html_source_html_attrib1_val(elem), src));
			} else if (elem.rule == st_html_attrib4) {
				make_attrib("1");
			} else {
				// Shouldn't happen
				HtmlAttrib("", "");
			}
		}
	);
}
