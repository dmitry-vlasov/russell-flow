import ds/cart_prod;
import ds/trie;
import fs/filesystem;
import net/url_parameter;
import sys/concurrent;
import sys/system;
import sys/target;
import math/stringmath;
import text/blueprint;
import lingo/linecolumn;
import formats/lsp;
import math/uuid;

import base/util/str;
import base/util/time;
import base/util/fs;

import base/println;

export {
	ruIf(cond : bool, val : ?, f : (?) -> ?) -> ?;
	ruConcurrent(jobs : [() -> ?]) -> [?];
	ruConcurrentVoid(jobs : [() -> void]) -> void;
	ruConcurrentLimited(jobs : [() -> ?], limit : int) -> [?];
	ruConcurrentLimitedVoid(jobs : [() -> void], limit : int) -> void;
	ruSequential(jobs : [() -> ?]) -> [?];
	ruSequentialVoid(jobs : [() -> void]) -> void;

	ruiLogN(n : int, N : int) -> int;
	ruiExpN(n : int, N : int) -> int;

	rudLogN(n : double, N : int) -> int;
	rudExpN(n : double, N : int) -> int;

	ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void;

	RuRange(start : int, end : int);
	RuLocation(path : string, range : RuRange);

	ruNameByLineCol(line : int, col : int, src : string) -> string ;
	ruNameByPos(pos : int, src : string) -> string;
	ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange>;

	ruSetsIntersect(s1 : Set<?>, s2 : Set<?>) -> bool;
	ruIsSubset(s1 : Set<?>, s2 : Set<?>) -> bool;
	ruExistsi(a : [?], fn : (int, ?) -> bool) -> bool;

	ruDebugLog1(message : string) -> void;

	ruMaxIntFromArray(ints : [int]) -> int;
	ruSumIntsFromArray(ints : [int]) -> int;
	ruMaxDoubleFromArray(ints : [double]) -> double;
	ruSumDoublesFromArray(ints : [double]) -> double;

	ruSetJsonNestedField(json: Json, fields: [string], name : string, value : Json) -> Json;
	ruConcurrentHashMap2Tree(hash_map : native) -> Tree<?, ??>;

	// Different fold functions with timer
	ruFold(a : [?], init: ??, fn : (??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldi(a : [?], init: ??, fn : (int, ??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldTree(t : Tree<?, ??>, acc : ???, fn : (?, ??, ???) -> ???, timer : RuTimer) -> ???;
	ruFoldSet(s : Set<?>, init : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldList(l : List<?>, acc : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ??;
	ruFoldCartProd(prod : CartProd<?>, init : ??, f : (??, [?]) -> ??, timer : RuTimer) -> ??;

	ruIterCartProd(prod : CartProd<?>, f : ([?]) -> void, timer : RuTimer) -> void;

	ruCompressInd(i : int) -> string;
	ruDecompressInd(least_s : string, most_s : [string]) -> int;
}

ruIf(cond : bool, val : ?, f : (?) -> ?) -> ? {
	if (cond) f(val) else val
}

ruConcurrentVoid(jobs : [() -> void]) -> void {
	ruConcurrent(map(jobs, \job -> \-> { job(); 0; }));
	{}
}

jobs_pool = initConcurrentHashMap();

ruConcurrent(jobs : [() -> ?]) -> [?] {
	wrap_job = \job -> \ -> {
		job_uuid = makeUuid();
		setConcurrentHashMap(jobs_pool, job_uuid, timestamp());
		ret = job();
		removeConcurrentHashMap(jobs_pool, job_uuid);
		ret;
	}
	concurrent(true, map(jobs, wrap_job));
	//sequential(true, jobs);
}

ruSequential(jobs : [() -> ?]) -> [?] {
	sequential(true, jobs);
}

ruSequentialVoid(jobs : [() -> void]) -> void {
	ruSequential(map(jobs, \job -> \-> { job(); 0; }));
	{}
}

ruConcurrentLimited(jobs : [() -> ?], limit : int) -> [?] {
	concatA(
		map(
			splitByNumber(jobs, limit),
			ruConcurrent
		)
	);
}

ruConcurrentLimitedVoid(jobs : [() -> void], limit : int) -> void {
	iter(
		splitByNumber(jobs, limit),
		ruConcurrentVoid
	);
}

ruiLogN(n : int, N : int) -> int {
	if (n < 0) ruiLogN(-n, N) else 
	if (n < N) 1 else {
		1 + ruiLogN(n / N, N);
	}
}

ruiExpN(n : int, N : int) -> int {
	if (n < 0) ruiExpN(-n, N) else 
	if (n == 0) 1 else {
		N * ruiExpN(n - 1, N);
	}
}

rudLogN(n : double, N : int) -> int {
	if (n < 0.0) rudLogN(-n, N) else 
	if (n < i2d(N)) 1 else {
		1 + rudLogN(n / i2d(N), N);
	}
}

rudExpN(n : double, N : int) -> int {
	if (n < 0.0) rudExpN(-n, N) else 
	if (n == 0.0) 1 else {
		N * rudExpN(n - 1.0, N);
	}
}


ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void {
	message_with_limestamp = "[" + time2string(timestamp()) + "] " + message;
	log_file = if (fileExists(log_name)) getFileContent(log_name) else "";
	log_lines = strSplit(log_file, "\n");
	log_lines_cut = if (length(log_lines) > log_size) tailFrom(log_lines, log_size / 8) else log_lines;
	updated_log_lines = concat(log_lines_cut, [message_with_limestamp]);
	updated_log_file = strGlue(updated_log_lines, "\n");
	setFileContent(log_name, updated_log_file);
	{}
}

ruNameByLineCol(line : int, col : int, src : string) -> string {
	resolver = makeLineResolver(src);
	ruNameByPos(findLineIndex(resolver, line, col), src);
}

ruNameByPos(pos : int, src : string) -> string {
	eitherMap(ruNameRangeByPos(pos, src), \range -> substring(src, range.start, range.end - range.start + 1), "");
}

ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange> {
	is_name_char = \s -> s != "(" && s != ":" && s != ")" && s !="," && s != "=" && isNotSpace(s);
	if (pos < 0 || pos >= strlen(src) || !isNotSpace(getCharAt(src, pos))) None() else {
		start = for(pos, 
			\i -> if (i <= 0) false else is_name_char(getCharAt(src, i - 1)), 
			\i -> i - 1
		);
		end = for(pos, 
			\i -> if (i + 1 >= strlen(src)) false else is_name_char(getCharAt(src, i + 1)), 
			\i -> i + 1
		);
		Some(RuRange(start, end));
	}
}

ruSetsIntersect(s1 : Set<?>, s2 : Set<?>) -> bool {
	if (sizeSet(s2) < sizeSet(s1)) {
		ruSetsIntersect(s2, s1);
	} else {
		existsSet(s1, \v -> containsSet(s2, v));
	}
}

ruIsSubset(s1 : Set<?>, s2 : Set<?>) -> bool {
	!existsSet(s1, \x -> !containsSet(s2, x));
}

ruExistsi(a : [?], fn : (int, ?) -> bool) -> bool {
	iteriUntil(a, fn) != length(a);
}

ruDebugLog1(message : string) -> void {
	log_file = "./russell_debug1.log";
	log_dir = ruDirName(log_file);
	if (log_dir != "") {
		err = ensureDirectoryExists(log_dir);
		if (err != "") {
			ruPrintln(err);
		} else {
			ruWriteLogMessage(message, log_file, 256);
		}
	}
}

ruSetJsonNestedField(json: Json, fields: [string], name : string, value : Json) -> Json {
	switch (json) {
		JsonNull():
			JsonObject([
				if (fields == []) Pair(name, value) else 
				Pair(fields[0], ruSetJsonNestedField(JsonNull(), tail(fields), name, value))
			]);
		JsonObject(members): {
			if (fields == []) {
				switch (findi(members, \member -> member.first == name)) {
					Some(i): JsonObject(replace(members, i, Pair(name, value)));
					None(): JsonObject(concat(members, [Pair(name, value)]));
				}
			} else {
				switch (findi(members, \member -> member.first == fields[0])) {
					Some(i):
						JsonObject(replace(members, i, 
							Pair(fields[0], ruSetJsonNestedField(members[i].second, tail(fields), name, value))
						));
					None(): 
						JsonObject(concat(members, [
							Pair(fields[0], ruSetJsonNestedField(JsonNull(), tail(fields), name, value))
						]));
				}
			}
		}
		default: ruSetJsonNestedField(JsonNull(), fields, name, value);
	}
}


ruMaxIntFromArray(ints : [int]) -> int {
	fold(ints, 0, \acc, i -> max(acc, i));
}

ruSumIntsFromArray(ints : [int]) -> int {
	fold(ints, 0, \acc, i -> acc + i);
}

ruMaxDoubleFromArray(ints : [double]) -> double {
	fold(ints, 0.0, \acc, i -> max(acc, i));
}

ruSumDoublesFromArray(ints : [double]) -> double {
	fold(ints, 0.0, \acc, i -> acc + i);
}

ruConcurrentHashMap2Tree(hash_map : native) -> Tree<?, ??> {
	keys = keysConcurrentHashMap(hash_map);
	values = valuesConcurrentHashMap(hash_map);
	pairs2tree(mapi(keys, \i, k -> Pair(k, values[i])));
}

ruFold(a : [?], init: ??, fn : (??, ?) -> ??, timer : RuTimer) -> ?? {
	ruDoFold(a, init, fn, timer, 0);
}

ruDoFold(a : [?], acc: ??, fn : (??, ?) -> ??, timer : RuTimer, i : int) -> ?? {
	if (i == length(a) || ruTimeIsOver(timer)) acc else {
		ruDoFold(a, fn(acc, a[i]), fn, timer, i + 1);
	}
}

ruFoldi(a : [?], init: ??, fn : (int, ??, ?) -> ??, timer : RuTimer) -> ?? {
	ruDoFoldi(a, init, fn, timer, 0);
}

ruDoFoldi(a : [?], acc: ??, fn : (int, ??, ?) -> ??, timer : RuTimer, i : int) -> ?? {
	if (i == length(a) || ruTimeIsOver(timer)) acc else {
		ruDoFoldi(a, fn(i, acc, a[i]), fn, timer, i + 1);
	}
}

ruFoldTree(tree : Tree<?, ??>, acc : ???, f : (?, ??, ???) -> ???, timer : RuTimer) -> ??? {
	if (ruTimeIsOver(timer)) acc else {
		switch (tree : Tree) {
			TreeEmpty(): acc;
			TreeNode(k, v, left, right, depth): {
				acc1 = ruFoldTree(left, acc, f, timer);
				acc2 = f(k, v, acc1);
				ruFoldTree(right, acc2, f, timer);
			}
		}
	}
}

ruFoldSet(s : Set<?>, init : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ?? {
	ruFoldTree(s.tree, init, \k, v, acc -> fn(acc, k), timer);
}


ruFoldList(l : List<?>, acc : ??, fn : (??, ?) -> ??, timer : RuTimer) -> ?? {
	if (ruTimeIsOver(timer)) acc else {
		switch (l) {
			EmptyList(): acc;
			Cons(h, t): ruFoldList(t, fn(acc, h), fn, timer);
		}
	}
}

ruFoldCartProd(prod : CartProd<?>, init : ??, f : (??, [?]) -> ??, timer : RuTimer) -> ?? {
	if (sizeCartProd(prod) == 0) init else
	ruDoFoldCartProd(prod, initCartProd(prod), init, f, timer)
}

ruDoFoldCartProd(prod : CartProd<?>, v : [int], val : ??, f : (??, [?]) -> ??, timer : RuTimer) -> ?? {
	if (ruTimeIsOver(timer)) val else {
		d = mapi(v, \i, n -> prod.sets[i][n]);
		new_val = f(val, d);
		switch (nextCartProd(v, prod)) {
			Some(next): ruDoFoldCartProd(prod, next, new_val, f, timer);
			None(): new_val;
		}
	}
}

ruIterCartProd(prod : CartProd<?>, f : ([?]) -> void, timer : RuTimer) -> void {
	if (sizeCartProd(prod) > 0) {
		ruDoIterCartProd(prod, initCartProd(prod), f, timer)
	}
}

ruDoIterCartProd(prod : CartProd<?>, v : [int], f : ([?]) -> void, timer : RuTimer) -> void {
	if (!ruTimeIsOver(timer)) {
		f(mapi(v, \i, n -> prod.sets[i][n]));
		switch (nextCartProd(v, prod)) {
			Some(next): ruDoIterCartProd(prod, next, f, timer);
			None(): {};
		}
	}
}

ruCompressInd(i : int) -> string {
	least = i % 20;
	most = ref [];
	for(i / 20, \k -> (k > 0), \k -> {
		refArrayPush(most, ((k - 1) % 5) + 1);
		(k - 1) / 5
	});
	fold(reverseA(^most), "", \acc, digit -> acc + fromCharCode(digit + 84)) + fromCharCode(least + 65)
}

ruDecompressInd(least_s : string, most_s : [string]) -> int {
	least = getCharCodeAt(least_s, 0) - 65;
	most_digits = map(most_s, \d -> 
		getCharCodeAt(d, 0) - 84
	);
	most = fold(reverseA(most_digits), Pair(0, 1), \acc, d -> 
		Pair(acc.first + d * acc.second, acc.second * 5)
	).first;
	20 * most + least;
}
