import ds/cart_prod;
import ds/trie;
import fs/filesystem;
import net/url_parameter;
import sys/concurrent;
import sys/system;
import sys/target;
import math/stringmath;
import text/blueprint;
import lingo/linecolumn;
import formats/lsp;
import math/uuid;

import base/util/str;
import base/util/time;
import base/util/fs;
import base/util/concurrent;
import base/util/math;
import base/util/timed;

import base/println;

export {
	ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void;

	RuRange(start : int, end : int);
	RuLocation(path : string, range : RuRange);

	ruNameByLineCol(line : int, col : int, src : string) -> string ;
	ruNameByPos(pos : int, src : string) -> string;
	ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange>;

	ruDebugLog1(message : string) -> void;

	ruSetJsonNestedField(json: Json, fields: [string], name : string, value : Json) -> Json;
	ruConcurrentHashMap2Tree(hash_map : native) -> Tree<?, ??>;

	ruCompressInd(i : int) -> string;
	ruDecompressInd(least_s : string, most_s : [string]) -> int;
}

ruWriteLogMessage(message : string, log_name : string, log_size : int) -> void {
	message_with_limestamp = "[" + time2string(timestamp()) + "] " + message;
	log_file = if (fileExists(log_name)) getFileContent(log_name) else "";
	log_lines = strSplit(log_file, "\n");
	log_lines_cut = if (length(log_lines) > log_size) tailFrom(log_lines, log_size / 8) else log_lines;
	updated_log_lines = concat(log_lines_cut, [message_with_limestamp]);
	updated_log_file = strGlue(updated_log_lines, "\n");
	setFileContent(log_name, updated_log_file);
	{}
}

ruNameByLineCol(line : int, col : int, src : string) -> string {
	resolver = makeLineResolver(src);
	ruNameByPos(findLineIndex(resolver, line, col), src);
}

ruNameByPos(pos : int, src : string) -> string {
	eitherMap(ruNameRangeByPos(pos, src), \range -> substring(src, range.start, range.end - range.start + 1), "");
}

ruNameRangeByPos(pos : int, src : string) -> Maybe<RuRange> {
	is_name_char = \s -> s != "(" && s != ":" && s != ")" && s !="," && s != "=" && isNotSpace(s);
	if (pos < 0 || pos >= strlen(src) || !isNotSpace(getCharAt(src, pos))) None() else {
		start = for(pos, 
			\i -> if (i <= 0) false else is_name_char(getCharAt(src, i - 1)), 
			\i -> i - 1
		);
		end = for(pos, 
			\i -> if (i + 1 >= strlen(src)) false else is_name_char(getCharAt(src, i + 1)), 
			\i -> i + 1
		);
		Some(RuRange(start, end));
	}
}

ruDebugLog1(message : string) -> void {
	log_file = "./russell_debug1.log";
	log_dir = ruDirName(log_file);
	if (log_dir != "") {
		err = ensureDirectoryExists(log_dir);
		if (err != "") {
			ruPrintln(err);
		} else {
			ruWriteLogMessage(message, log_file, 256);
		}
	}
}

ruSetJsonNestedField(json: Json, fields: [string], name : string, value : Json) -> Json {
	switch (json) {
		JsonNull():
			JsonObject([
				if (fields == []) Pair(name, value) else 
				Pair(fields[0], ruSetJsonNestedField(JsonNull(), tail(fields), name, value))
			]);
		JsonObject(members): {
			if (fields == []) {
				switch (findi(members, \member -> member.first == name)) {
					Some(i): JsonObject(replace(members, i, Pair(name, value)));
					None(): JsonObject(concat(members, [Pair(name, value)]));
				}
			} else {
				switch (findi(members, \member -> member.first == fields[0])) {
					Some(i):
						JsonObject(replace(members, i, 
							Pair(fields[0], ruSetJsonNestedField(members[i].second, tail(fields), name, value))
						));
					None(): 
						JsonObject(concat(members, [
							Pair(fields[0], ruSetJsonNestedField(JsonNull(), tail(fields), name, value))
						]));
				}
			}
		}
		default: ruSetJsonNestedField(JsonNull(), fields, name, value);
	}
}

ruConcurrentHashMap2Tree(hash_map : native) -> Tree<?, ??> {
	keys = keysConcurrentHashMap(hash_map);
	values = valuesConcurrentHashMap(hash_map);
	pairs2tree(mapi(keys, \i, k -> Pair(k, values[i])));
}

ruCompressInd(i : int) -> string {
	least = i % 20;
	most = ref [];
	for(i / 20, \k -> (k > 0), \k -> {
		refArrayPush(most, ((k - 1) % 5) + 1);
		(k - 1) / 5
	});
	fold(reverseA(^most), "", \acc, digit -> acc + fromCharCode(digit + 84)) + fromCharCode(least + 65)
}

ruDecompressInd(least_s : string, most_s : [string]) -> int {
	least = getCharCodeAt(least_s, 0) - 65;
	most_digits = map(most_s, \d -> 
		getCharCodeAt(d, 0) - 84
	);
	most = fold(reverseA(most_digits), Pair(0, 1), \acc, d -> 
		Pair(acc.first + d * acc.second, acc.second * 5)
	).first;
	20 * most + least;
}
