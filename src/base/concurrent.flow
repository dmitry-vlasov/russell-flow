import sys/concurrent;
import math/uuid;
import base/conf;

export {
	ruConcurrent(jobs : [(RuConf) -> ?], conf : RuConf) -> [?];
	ruConcurrentVoid(jobs : [(RuConf) -> void], conf : RuConf) -> void;
	ruConcurrentLimited(jobs : [(RuConf) -> ?], limit : int, conf : RuConf) -> [?];
	ruConcurrentLimitedVoid(jobs : [(RuConf) -> void], limit : int, conf : RuConf) -> void;
	ruSequential(jobs : [(RuConf) -> ?], conf : RuConf) -> [?];
	ruSequentialVoid(jobs : [(RuConf) -> void], conf : RuConf) -> void;

	ruMakeAtomicArrayPush(arr : ref [?]) -> (?) -> ?;
	ruMakeAtomicSetTree(tree : ref Tree<?, ??>) -> (?, ??) -> ??;
	ruAtomicDoubleAdd(v : ref double) -> (double) -> double;
	ruAtomicIntAdd(v : ref int) -> (int) -> int;
	ruAtomicIntInc(v : ref int) -> (int) -> void;
	ruAtomicRefArrayPush(arr : ref [?]) -> (?) -> void;

	ruSetConcurrencyEnabled(enabled : bool) -> void;
}

ru_concurrency_enabled = ref true;

ruSetConcurrencyEnabled(enabled : bool) -> void {
	ru_concurrency_enabled := enabled;
}

ruConcurrentVoid(jobs : [(RuConf) -> void], conf : RuConf) -> void {
	ruConcurrent(map(jobs, \job -> \cf -> { job(cf); 0; }), conf);
	{}
}

ruConcurrent(jobs : [(RuConf) -> ?], conf : RuConf) -> [?] {
	if (^ru_concurrency_enabled && !containsKeyTree(conf.opts, "in-concurrent-thread")) {
		concurrent(true, map(jobs, \job -> \-> job(ruSetConfOpt(conf, "in-concurrent-thread", "1"))));
	} else {
		sequential(true, map(jobs, \job -> \-> job(conf)));
	}
}

ruSequential(jobs : [(RuConf) -> ?], conf : RuConf) -> [?] {
	sequential(true, map(jobs, \job -> \ -> job(conf)));
}

ruSequentialVoid(jobs : [(RuConf) -> void], conf : RuConf) -> void {
	ruSequential(map(jobs, \job -> \cf -> { job(cf); 0; }), conf);
	{}
}

ruConcurrentLimited(jobs : [(RuConf) -> ?], limit : int, conf : RuConf) -> [?] {
	concatA(
		map(
			splitByNumber(jobs, limit),
			\chunk -> ruConcurrent(chunk, conf)
		)
	);
}

ruConcurrentLimitedVoid(jobs : [(RuConf) -> void], limit : int, conf : RuConf) -> void {
	iter(
		splitByNumber(jobs, limit),
		\chunk -> ruConcurrentVoid(chunk, conf)
	);
}

ruMakeAtomicArrayPush(arr : ref [?]) -> (?) -> ? {
	synchronizedUnaryFn(arr, \x -> { refArrayPush(arr, x); x });
}

ruMakeAtomicSetTree(tree : ref Tree<?, ??>) -> (?, ??) -> ?? {
	synchronizedBinaryFn(tree, \k, v -> { tree := setTree(^tree, k, v); v });
}

ruAtomicDoubleAdd(v : ref double) -> (double) -> double {
	synchronizedUnaryFn(v, \delta -> { v := ^v + delta; ^v });
}

ruAtomicIntAdd(v : ref int) -> (int) -> int {
	synchronizedUnaryFn(v, \delta -> { v := ^v + delta; ^v });
}

ruAtomicIntInc(v : ref int) -> (int) -> void {
	add = ruAtomicIntAdd(v);
	\delta -> { add(delta); {} }
}

ruAtomicRefArrayPush(arr : ref [?]) -> (?) -> void {
	push = synchronizedUnaryFn(arr, \x -> { refArrayPush(arr, x); x });
	\x -> { push(x); {}	}
}
