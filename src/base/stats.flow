import sys/concurrent;
import base/util/math;

export {
	RuStatsRow(
		info : string,
		data : Tree<string, double>,
	);
	RuStatTable(
		name : string,
		size : ref int,
		array : native
	);
	RuTimeTable(
		name : string,
		size : ref int,
		time : ref int
	);

	ruAddStats(table_name : string, row : RuStatsRow) -> void;
	ruShowStats(table_name : string, f : ([RuStatsRow]) -> string) -> string;
	ruExistsStats(table_name : string) -> bool;
	ruGetStats(table_name : string) -> RuStatTable;
	ruGetStatsRow(table : RuStatTable, i : int) -> RuStatsRow;

	ruNumStats() -> ([RuStatsRow]) -> string;
	ruMaxStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruMinStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruSumStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruAvgStats(field_name : string) -> ([RuStatsRow]) -> string;
	ruSigmaStats(field_name : string) -> ([RuStatsRow]) -> string;

	ruDistribLogSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
	ruDistribLogAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
	ruDistribLinSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;
	ruDistribLinAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string;

	ruAddTime(table_name : string, time : int) -> void;
	ruShowTime(table_name : string) -> string;

	ruFoldStats(table_name : string, init : ?, fn : (?, RuStatsRow) -> ?) -> ?;
	ruFoldiStats(table_name : string, init : ?, fn : (int, ?, RuStatsRow) -> ?) -> ?;
	ruMapStats(table_name : string, fn : (RuStatsRow) -> ?) -> [?];
	ruMapiStats(table_name : string, fn : (int, RuStatsRow) -> ?) -> [?];

	RuDistribStats(
		avg : double,
		dev : double,
		median : double,
		min : double,
		max : double
	);

	ruTable2DistribStats(table : [double]) -> RuDistribStats;
	ruDistribStats2s(distrib : RuDistribStats) -> string;
	//ruTable2DistribStr(table : [double]) -> string;
}

stats_store = initConcurrentHashMap();
time_store = initConcurrentHashMap();

ruEmptyStatTable = RuStatTable("", ref 0, initConcurrentHashMap());
ruEmptyTimeTable = RuTimeTable("", ref 0, ref 0);
ruEmptyStatsRow  = RuStatsRow("", makeTree());

ruAddStats(table_name : string, row : RuStatsRow) -> void {
	if (!containsConcurrentHashMap(stats_store, table_name)) {
		setConcurrentHashMap(stats_store, table_name, RuStatTable(table_name, ref 0, initConcurrentHashMap()));
	}
	table = getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable);
	setConcurrentHashMap(table.array, atomicRefIntAddition(table.size, 1), row);
}

ruAddTime(table_name : string, time : int) -> void {
	if (!containsConcurrentHashMap(time_store, table_name)) {
		setConcurrentHashMap(time_store, table_name, RuTimeTable(table_name, ref 0, ref 0));
	}
	table = getConcurrentHashMap(time_store, table_name, ruEmptyTimeTable);
	atomicRefIntAddition(table.size, 1);
	atomicRefIntAddition(table.time, time);
	{}
}

ruShowTime(table_name : string) -> string {
	if (!containsConcurrentHashMap(time_store, table_name)) "" else {
		table = getConcurrentHashMap(time_store, table_name, ruEmptyTimeTable);
		if (^(table.size) == 0) "no data" else {
			time = i2d(^(table.time));
			size = i2d(^(table.size));
			"sum: " + i2s(^(table.time)) + ", avg: " + d2s(time / size);
		}
	}
}

ruShowStats(table_name : string, f : ([RuStatsRow]) -> string) -> string {
	f(valuesConcurrentHashMap(
		getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable).array
	));
}

ruExistsStats(table_name : string) -> bool {
	containsConcurrentHashMap(stats_store, table_name);
}

ruGetStats(table_name : string) -> RuStatTable {
	getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable);
}

ruGetStatsRow(table : RuStatTable, i : int) -> RuStatsRow {
	getConcurrentHashMap(table.array, 0, ruEmptyStatsRow);
}

ruMaxStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		max_row = fold(rows, Pair(ruEmptyStatsRow, 0.0), \acc, row ->
			switch (lookupTree(row.data, field_name)) {
				Some(val): if (val > acc.second) Pair(row, val) else acc;
				None(): acc;
			}
		).first;
		strGlue(map(tree2pairs(max_row.data), \p -> p.first + "=" + d2s(p.second)), ", ") + (if (max_row.info == "") "" else ": " + max_row.info);
	}
}

ruMinStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		if (rows == []) "" else {
			max_row = fold(rows, Pair(ruEmptyStatsRow, lookupTreeDef(rows[0].data, field_name, 0.0)), \acc, row -> 
				switch (lookupTree(row.data, field_name)) {
					Some(val): if (val < acc.second) Pair(row, val) else acc;
					None(): acc;
				}
			).first;
			strGlue(map(tree2pairs(max_row.data), \p -> p.first + "=" + d2s(p.second)), ", ") + (if (max_row.info == "") "" else ": " + max_row.info);
		}
	}
}


ruNumStats() -> ([RuStatsRow]) -> string {
	\rows -> i2s(length(rows))
}

ruSumStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows ->
		d2s(fold(rows, 0.0, \acc, row ->
			switch (lookupTree(row.data, field_name)) {
				Some(val): acc + val;
				None(): acc;
			}
		))
}

ruAvgStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		if (length(rows) == 0) "" else {
			summ = fold(rows, 0.0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): acc + val;
					None(): acc;
				}
			);
			avg = summ / i2d(length(rows));
			d2s(avg);
		}
	}
}

ruSigmaStats(field_name : string) -> ([RuStatsRow]) -> string {
	\rows -> {
		if (length(rows) == 0) "" else {
			summ = fold(rows, 0.0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): acc + val;
					None(): acc;
				}
			);
			avg = summ / i2d(length(rows));
			delta = fold(rows, 0.0, \acc, row ->
				switch (lookupTree(row.data, field_name)) {
					Some(val): acc + val * val;
					None(): acc;
				}
			);
			d2s(sqrt(delta / i2d(length(rows))));
		}
	}
}

//ruGuessDistribStatsKind(table_name : string, field_key : string, field_val : string) -> string {
//	table = ruGetStats(table_name);
//}

ruDistribLogSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = rudLogN(key, n);
					switch (lookupTree(row.data, field_val)) {
						Some(val): setTree(acc, k, val + lookupTreeDef(acc, k, 0.0));
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "^" + i2s(p.first - 1) + " - "+ i2s(n) + "^" + i2s(p.first) + "]: " + d2s(p.second)
			), 
			"\n"
		);
	}
}

ruDistribLogAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = rudLogN(key, n);
					switch (lookupTree(row.data, field_val)) {
						Some(val): {
							p = lookupTreeDef(acc, k, Pair(0.0, 0));
							setTree(acc, k, Pair(val + p.first, 1 + p.second));
						}
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "^" + i2s(p.first - 1) + " - "+ i2s(n) + "^" + i2s(p.first) + "]: " + d2s(p.second.first / i2d(p.second.second))
			), 
			"\n"
		);
	}
}

ruDistribLinSumStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = round(key) / n;
					switch (lookupTree(row.data, field_val)) {
						Some(val): setTree(acc, k, val + lookupTreeDef(acc, k, 0.0));
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "*" + i2s(p.first) + " - "+ i2s(n) + "*" + i2s(p.first + 1) + "]: " + d2s(p.second)
			), 
			"\n"
		);
	}
}

ruDistribLinAvgStats(field_key : string, field_val : string, n : int) -> ([RuStatsRow]) -> string {
	\rows -> {
		distrib = fold(rows, makeTree(), \acc, row ->
			switch (lookupTree(row.data, field_key)) {
				Some(key): {
					k = round(key) / n;
					switch (lookupTree(row.data, field_val)) {
						Some(val): {
							p = lookupTreeDef(acc, k, Pair(0.0, 0));
							setTree(acc, k, Pair(val + p.first, 1 + p.second));
						}
						None(): acc;
					}
				}
				None(): acc;
			}
		);
		strGlue(
			map(
				tree2pairs(distrib), \p -> 
					"[" + i2s(n) + "*" + i2s(p.first) + " - "+ i2s(n) + "*" + i2s(p.first + 1) + "]: " + d2s(p.second.first / i2d(p.second.second))
			), 
			"\n"
		);
	}
}

ruFoldStats(table_name : string, init : ?, fn : (?, RuStatsRow) -> ?) -> ? {
	table = getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable);
	fold(enumFromTo(0, ^(table.size)), init, \acc, key ->
		fn(acc, getConcurrentHashMap(table.array, key, ruEmptyStatsRow))
	);
}

ruFoldiStats(table_name : string, init : ?, fn : (int, ?, RuStatsRow) -> ?) -> ? {
	table = getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable);
	foldi(enumFromTo(0, ^(table.size)), init, \i, acc, key ->
		fn(i, acc, getConcurrentHashMap(table.array, key, ruEmptyStatsRow))
	);
}

ruMapStats(table_name : string, fn : (RuStatsRow) -> ?) -> [?] {
	table = getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable);
	map(enumFromTo(0, ^(table.size)), \key ->
		fn(getConcurrentHashMap(table.array, key, ruEmptyStatsRow))
	);
}

ruMapiStats(table_name : string, fn : (int, RuStatsRow) -> ?) -> [?] {
	table = getConcurrentHashMap(stats_store, table_name, ruEmptyStatTable);
	mapi(enumFromTo(0, ^(table.size)), \i, key ->
		fn(i, getConcurrentHashMap(table.array, key, ruEmptyStatsRow))
	);
}

ruTable2DistribStats(table : [double]) -> RuDistribStats {
	size = i2d(length(table));
	max = ruMaxDoubleFromArray(table);
	min = ruMinDoubleFromArray(table);
	sum = ruSumDoublesFromArray(table);
	avg = sum / size;
	sum1 = fold(table, 0.0, \acc, v -> 
		acc + (avg - v) * (avg - v)
	);
	dev = sqrt(sum1 / size);
	table_sorted = sort(table);
	median = table_sorted[length(table) / 2];
	RuDistribStats(avg, dev, median, min, max);
}

ruDistribStats2s(distrib : RuDistribStats) -> string {
	"average:   " + d2s(distrib.avg) + "\n" +
	"deviation: " + d2s(distrib.dev) + "\n" +
	"median:    " + d2s(distrib.median) + "\n" +
	"min:       " + d2s(distrib.min) + "\n" +
	"max:       " + d2s(distrib.max)
}