import base/conf;
import ru/cache;
import comm;

export {
	ruBaseCommands : [RuComm];
	ruRunGC(unit : RuUnit) -> Maybe<RuState>;
}

ruBaseCommands = 
	concat(
		concat3(ruConfCommands, ruSyncCommands, ruCacheCommands), 
		concat(ruStatsCommands, ruMiscCommands)
	);

ru_conf_stack : ref List<RuConf> = ref makeList();

ruMiscCommands = [
	RuComm(RuCommDescr("run-gc", "misc", "force garbage collection", "", false, false, [], []), ruRunGC),
	RuComm(RuCommDescr("russell-dir", "misc", "prints a russell distribution directory", "", false, false, [], []), 
		\unit -> { unit.out.onMessage(findRussellDir()); Some(unit.state); }
	),
	RuComm(RuCommDescr("cwd", "misc", "show true current working directory", "", false, false, [], []),
		\unit -> { unit.out.onMessage(ruCurrentWorkingDir()); Some(unit.state); }
	),
];

ruConfCommands = [
	RuComm(RuCommDescr("conf-set", "conf", "update configuration", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruSetConf(unit.state.conf, unit.task.args)))
	),
	RuComm(RuCommDescr("conf-unset", "conf", "remove a configuration option", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruUnsetConf(unit.state.conf, unit.task.args)))
	),
	RuComm(RuCommDescr("conf", "conf", "a shortcut for 'conf-set'", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruSetConf(unit.state.conf, unit.task.args))) 
	),
	RuComm(RuCommDescr("conf-merge", "conf", "merge current and given configs", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruMergeConfs(unit.state.conf, ruTree2Conf(unit.task.args)))) 
	),
	RuComm(RuCommDescr("conf-clear", "conf", "clear configuration", "", false, false, [], []),
		\unit -> Some(RuState(unit.state with conf = ruTree2Conf(makeTree())))
	),
	RuComm(RuCommDescr("conf-show", "conf", "show current configuration key-value pairs", "", false, false, [], []), 
		\unit -> {
			conf_str = ruConf2s(unit.state.conf);
			unit.out.onMessage(
				"Config: " + (if (conf_str == "") "<EMPTY>" else "\n" + strIndent(conf_str))
			);
			Some(unit.state);
		}
	),
	RuComm(
		RuCommDescr(
			"conf-load", "conf", "load config file from given directory", "dir", false, false,
			[RuCommArg("dir", false, "project directory with config file", "")], []
		), 
		\unit -> {
			conf = unit.state.conf;
			conf_dir = ruResolveRelativePath(lookupTreeDef(unit.task.args, "dir", "."), conf.workingDir);
			file_conf = ruReadConfFromDir(conf_dir);
			Some(RuState(unit.state with conf = ruSetConf(conf, file_conf)));
		}
	),
	RuComm(
		RuCommDescr(
			"conf-save", "conf", "save values to the config file", "dir", false, false,
			[RuCommArg("dir", true, "project directory", ".")], []
		), 
		\unit -> {
			conf = unit.state.conf;
			dir0 = lookupTreeDef(unit.task.args, "dir", ".");
			dir = if (conf.workingDir == "") dir0 else conf.workingDir + "/" + dir0;
			ensureDirectoryExists(dir);
			if (setFileContent(dir + "/russell.conf", ruConf2s(conf))) {
				Some(unit.state);
			} else {
				unit.out.onError("Failed to save config", []);
				None();
			}
		}
	),
	RuComm(RuCommDescr("conf-push", "conf", "push current conf onto a stack, current conf will be created from command arguments", "", false, false, [], []),
		\unit -> {
			ru_conf_stack := Cons(unit.state.conf, ^ru_conf_stack);
			Some(RuState(unit.state with conf = ruTree2Conf(unit.task.args)));
		}
	),
	RuComm(RuCommDescr("conf-pop", "conf", "pop a conf from a stack", "", false, false, [], []),
		\unit -> {
			if (isEmptyList(^ru_conf_stack)) {
				unit.out.onError("Attempt to pop an empty conf stack", []);
			}
			conf = headList(^ru_conf_stack, ruTree2Conf(unit.task.args));
			ru_conf_stack := tailList(^ru_conf_stack);
			Some(RuState(unit.state with conf = conf));
		}
	),
];

ruRunGC(unit : RuUnit) -> Maybe<RuState> {
	gc();
	Some(unit.state);
}

ruStatsCommands = [
	RuComm(RuCommDescr("stats-math", "stats", "show math statistics", "", false, false, [], []),
		\unit -> {
			env = ruUnitEnv(unit);
			unit.out.onMessage("Mathematics statistics:");
			unit.out.onMessage("-----------------------");
			unit.out.onMessage(ruMathStats(ruMathFromSources(unit.state.ru, env)) + "\n");
			Some(unit.state); 
		}
	),
	RuComm(RuCommDescr("stats-math-1", "stats", "show math statistics", "", false, false, [], []),
		\unit -> {
			env = ruUnitEnv(unit);
			stats = ruMathStats1(ruMathFromSources(unit.state.ru, env));
			Some(RuState(unit.state with
				vars = setTree(unit.state.vars, "stats-math-1.stats", stats);
			)); 
		}
	),
	RuComm(RuCommDescr("stats-mem", "stats", "show memory usage statistics", "", false, false, 
			[RuCommArg("show", true, "set this option to '1' in order to print memory statistics to the output", "")], []
		),
		\unit -> {
			if (lookupTreeDef(unit.task.args, "show", "") == "1") {
				unit.out.onMessage(
					memory2s(usedMemory()) + " + " + memory2s(freeMemory()) + " free = " + memory2s(totalMemory())
				);
			}
			Some(RuState(unit.state with
				vars = setTree(setTree(setTree(unit.state.vars, 
					"stats-mem.used", ValDouble(usedMemory())),
					"stats-mem.free", ValDouble(freeMemory())),
					"stats-mem.total", ValDouble(totalMemory())
				)
			)); 
		}
	),
	RuComm(
		RuCommDescr(
			"stats-cache", "stats", "show cache statistics", "", false, false,
			[RuCommArg("full", true, "show cached names", "")], []
		), 
		\unit -> {
			unit.out.onMessage(ruCacheInfo(lookupTreeDef(unit.task.args, "full", "") == "1"));
			Some(unit.state);
		}
	)
];

ruCacheCommands = [
	RuComm(
		RuCommDescr(
			"cache-load", "sync", "read cached sources", "file", false, false,
			[RuCommArg("file", true, "input file", "")], []
		),
		\unit -> {
			env = ruUnitEnv(unit);
			conf = env.conf;
			file = lookupTreeDef(unit.task.args, "file", "");
			timer = ruMakeTimer();
			if (file != "") {
				ruLoadToMemCache(file, env); 
			} else {
				ruLoadMemCacheFromDisk(env);
			}
			if (ruVerbose(conf) > 0) {
				if (ruTimePassed(timer) > 100.0) {
					unit.out.onMessage("cache loaded in " + ruTimePassed2s(timer));
				}
			}
			Some(unit.state); 
		}
	),
	RuComm(
		RuCommDescr(
			"cache-clear", "sync", "clear up a cache: mem, disk or all", "cache", false, false,
			[RuCommArg("cache", false, "which cache: mem, disk or all to clear", "mem")], []
		),
		\unit -> {
			env = ruUnitEnv(unit);
			cache = lookupTreeDef(unit.task.args, "cache", "");
			if (cache == "mem") {
				ruClearMemCache();
			} else if (cache == "disk") {
				ruClearDiskCache(env);
			} else if (cache == "all") {
				ruClearCache(env);
			}
			Some(unit.state); 
		}
	),
	RuComm(
		RuCommDescr(
			"cache-save", "sync", "save cached sources", "file", false, false,
			[RuCommArg("file", true, "input file", "")], []
		),
		\unit -> { 
			env = ruUnitEnv(unit);
			file = lookupTreeDef(unit.task.args, "file", "");
			if (file == "") {
				ruSaveCache(env); 
			} else {
				ruSaveCacheFile(file, env); 
			}
			Some(unit.state); 
		}
	),
];

ruSyncCommands = [
	RuComm(
		RuCommDescr(
			"sync-file-source", "sync", "load an updated file source", "file", false, false,
			[RuCommArg("file", false, "input file", ""),  RuCommArg("text", false, "updated source", "")], []
		),
		\unit -> { 
			ruSetFileSourceCode(
				lookupTreeDef(unit.task.args, "file", ""), 
				lookupTreeDef(unit.task.args, "text", "")
			); 
			Some(unit.state);
		}
	),
	RuComm(
		RuCommDescr(
			"sync-file-changed", "sync", "apply changes to a file source", "file", false, false,
			[RuCommArg("file", false, "input file", ""),  RuCommArg("change", false, "change in JSON format", "")], []
		),
		\unit -> {
			env = ruUnitEnv(unit);
			json = lookupTreeDef(unit.task.args, "change-json", "");
			switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
				Some(params): {
					path = ruCorrectUriPath(params.textDocument.uri.path);
					contents = ruFileSourceCode(path);
					changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
					ruSetFileSourceCode(path, changed);
				}
				None(): {
					unit.out.onMessage("file-change: An option 'change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams");
				}
			}
			Some(unit.state);
		}
	),
	RuComm(
		RuCommDescr(
			"sync-file-saved", "sync", "file was saved", "file", false, false,
			[RuCommArg("file", false, "input file", "")], []
		),
		\unit -> { 
			ruLoadFileSourceCode(lookupTreeDef(unit.task.args, "file", "")); 
			Some(unit.state);
		}
	)
];
