import base/conf;
import ru/cache/cache;
import comm;

export {
	ruBaseCommands : [RuComm];
	ruRunGC(unit : RuUnit) -> Maybe<RuState>;
}

ruBaseCommands = concat3(ruConfCommands, ruStatsCommands, ruMiscCommands);

ru_conf_stack : ref List<RuConf> = ref makeList();

ruMiscCommands = [
	RuComm(RuCommDescr("run-gc", "misc", "force garbage collection", "", false, false, [], []), ruRunGC),
	RuComm(RuCommDescr("russell-dir", "misc", "prints a russell distribution directory", "", false, false, [], []), 
		\unit -> { unit.out.onMessage(findRussellDir()); Some(unit.state); }
	),
	RuComm(RuCommDescr("cwd", "misc", "show true current working directory", "", false, false, [], []),
		\unit -> { unit.out.onMessage(ruCurrentWorkingDir()); Some(unit.state); }
	),
];

ruConfCommands = [
	RuComm(RuCommDescr("conf-set", "conf", "update configuration", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruSetConf(unit.state.conf, unit.task.args)))
	),
	RuComm(RuCommDescr("conf-unset", "conf", "remove a configuration option", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruUnsetConf(unit.state.conf, unit.task.args)))
	),
	RuComm(RuCommDescr("conf", "conf", "a shortcut for 'conf-set'", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruSetConf(unit.state.conf, unit.task.args))) 
	),
	RuComm(RuCommDescr("conf-merge", "conf", "merge current and given configs", "", false, false, [], []), 
		\unit -> Some(RuState(unit.state with conf = ruMergeConfs(unit.state.conf, ruTree2Conf(unit.task.args)))) 
	),
	RuComm(RuCommDescr("conf-clear", "conf", "clear configuration", "", false, false, [], []),
		\unit -> Some(RuState(unit.state with conf = ruTree2Conf(makeTree())))
	),
	RuComm(RuCommDescr("conf-show", "conf", "show current configuration key-value pairs", "", false, false, [], []), 
		\unit -> {
			conf_str = ruConf2s(unit.state.conf);
			unit.out.onMessage(
				"Config: " + (if (conf_str == "") "<EMPTY>" else "\n" + strIndent(conf_str))
			);
			Some(unit.state);
		}
	),
	RuComm(
		RuCommDescr(
			"conf-load", "conf", "load config file from given directory", "dir", false, false,
			[RuCommArg("dir", false, "project directory with config file", "")], []
		), 
		\unit -> {
			conf = unit.state.conf;
			conf_dir = ruResolveRelativePath(lookupTreeDef(unit.task.args, "dir", "."), conf.workingDir);
			file_conf = ruReadConfFromDir(conf_dir);
			Some(RuState(unit.state with conf = ruSetConf(conf, file_conf)));
		}
	),
	RuComm(
		RuCommDescr(
			"conf-save", "conf", "save values to the config file", "dir", false, false,
			[RuCommArg("dir", true, "project directory", ".")], []
		), 
		\unit -> {
			conf = unit.state.conf;
			dir0 = lookupTreeDef(unit.task.args, "dir", ".");
			dir = if (conf.workingDir == "") dir0 else conf.workingDir + "/" + dir0;
			ensureDirectoryExists(dir);
			if (setFileContent(dir + "/russell.conf", ruConf2s(conf))) {
				Some(unit.state);
			} else {
				unit.out.onError("Failed to save config", []);
				None();
			}
		}
	),
	RuComm(RuCommDescr("conf-push", "conf", "push current conf onto a stack, current conf will be created from command arguments", "", false, false, [], []),
		\unit -> {
			ru_conf_stack := Cons(unit.state.conf, ^ru_conf_stack);
			Some(RuState(unit.state with conf = ruTree2Conf(unit.task.args)));
		}
	),
	RuComm(RuCommDescr("conf-pop", "conf", "pop a conf from a stack", "", false, false, [], []),
		\unit -> {
			if (isEmptyList(^ru_conf_stack)) {
				unit.out.onError("Attempt to pop an empty conf stack", []);
			}
			conf = headList(^ru_conf_stack, ruTree2Conf(unit.task.args));
			ru_conf_stack := tailList(^ru_conf_stack);
			Some(RuState(unit.state with conf = conf));
		}
	),
];

ruRunGC(unit : RuUnit) -> Maybe<RuState> {
	gc();
	Some(unit.state);
}

ruStatsCommands = [
	RuComm(RuCommDescr("stats-math", "stats", "show math statistics", "", false, false, [], []),
		\unit -> {
			env = ruUnitEnv(unit);
			unit.out.onMessage("Mathematics statistics:");
			unit.out.onMessage("-----------------------");
			unit.out.onMessage(ruMathStats2s(ruMathFromSources(unit.state.ru, env), env) + "\n");
			Some(unit.state); 
		}
	),
	RuComm(RuCommDescr("stats-math-1", "stats", "show math statistics", "", false, false, [], []),
		\unit -> {
			env = ruUnitEnv(unit);
			stats = ruMathStats(ruMathFromSources(unit.state.ru, env), env);
			Some(RuState(unit.state with
				vars = setTree(unit.state.vars, "stats-math-1.stats", stats);
			)); 
		}
	),
	RuComm(RuCommDescr("stats-mem", "stats", "show memory usage statistics", "", false, false, 
			[RuCommArg("show", true, "set this option to '1' in order to print memory statistics to the output", "")], []
		),
		\unit -> {
			if (lookupTreeDef(unit.task.args, "show", "") == "1") {
				unit.out.onMessage(
					memory2s(usedMemory()) + " + " + memory2s(freeMemory()) + " free = " + memory2s(totalMemory())
				);
			}
			Some(RuState(unit.state with
				vars = setTree(setTree(setTree(unit.state.vars, 
					"stats-mem.used", ValDouble(usedMemory())),
					"stats-mem.free", ValDouble(freeMemory())),
					"stats-mem.total", ValDouble(totalMemory())
				)
			)); 
		}
	),
	RuComm(
		RuCommDescr(
			"stats-cache", "stats", "show cache statistics", "", false, false,
			[RuCommArg("full", true, "show cached names", "")], []
		), 
		\unit -> {
			env = ruUnitEnv(unit);
			unit.out.onMessage(ruCacheInfo(lookupTreeDef(unit.task.args, "full", "") == "1", env));
			Some(unit.state);
		}
	)
];
