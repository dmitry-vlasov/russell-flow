import base/conf;
import command;

export {
	ruBaseCommands : [RuComm];
	ruRunGC(task : ScTask, state : RuState) -> Maybe<RuState>;
}

ruBaseCommands = 
	concat(
		concat3(ruConfCommands, ruSyncCommands, ruCacheCommands), 
		concat(ruStatsCommands, ruMiscCommands)
	);

ru_conf_stack : ref List<RuConf> = ref makeList();

ruMiscCommands = [
	RuComm(RuCommDescr("run-gc", "misc", "force garbage collection", "", false, false, [], []), ruRunGC),
	RuComm(RuCommDescr("russell-dir", "misc", "prints a russell distribution directory", "", false, false, [], []), 
		\task, env -> {
			env.conf.onMessage(findRussellDir());
			Some(env);
		}
	),
	RuComm(RuCommDescr("cwd", "misc", "show true current working directory", "", false, false, [], []),
		\task, env -> {
			env.conf.onMessage(ruCurrentWorkingDir());
			Some(env);
		}
	),
];

ruConfCommands = [
	RuComm(RuCommDescr("conf-set", "conf", "update configuration", "", false, false, [], []), 
		\task, env -> Some(RuState(env with conf = ruSetConf(env.conf, task.args)))
	),
	RuComm(RuCommDescr("conf-unset", "conf", "remove a configuration option", "", false, false, [], []), 
		\task, env -> Some(RuState(env with conf = ruUnsetConf(env.conf, task.args)))
	),
	RuComm(RuCommDescr("conf", "conf", "a shortcut for 'conf-set'", "", false, false, [], []), 
		\task, env -> Some(RuState(env with conf = ruSetConf(env.conf, task.args))) 
	),
	RuComm(RuCommDescr("conf-merge", "conf", "merge current and given configs", "", false, false, [], []), 
		\task, env -> Some(RuState(env with conf = ruMergeConfs(env.conf, ruTree2Conf(task.args)))) 
	),
	RuComm(RuCommDescr("conf-clear", "conf", "clear configuration", "", false, false, [], []),
		\task, env -> Some(RuState(env with conf = ruTree2Conf(makeTree())))
	),
	RuComm(RuCommDescr("conf-show", "conf", "show current configuration key-value pairs", "", false, false, [], []), 
		\task, env -> {
			conf_str = ruConf2s(env.conf);
			env.conf.onMessage(
				"Config: " + (if (conf_str == "") "<EMPTY>" else "\n" + strIndent(conf_str))
			);
			Some(env);
		}
	),
	RuComm(
		RuCommDescr(
			"conf-load", "conf", "load config file from given directory", "dir", false, false,
			[RuCommArg("dir", false, "project directory with config file", "")], []
		), 
		\task, env -> {
			conf_dir = ruResolveRelativePath(lookupTreeDef(task.args, "dir", "."), env.conf.workingDir);
			file_conf = ruReadConfFromDir(conf_dir);
			Some(RuState(env with conf = ruSetConf(env.conf, file_conf)));
		}
	),
	RuComm(
		RuCommDescr(
			"conf-save", "conf", "save values to the config file", "dir", false, false,
			[RuCommArg("dir", true, "project directory", ".")], []
		), 
		\task, env -> {
			conf = env.conf;
			dir0 = lookupTreeDef(task.args, "dir", ".");
			dir = if (conf.workingDir == "") dir0 else conf.workingDir + "/" + dir0;
			ensureDirectoryExists(dir);
			if (setFileContent(dir + "/russell.conf", ruConf2s(conf))) {
				Some(env);
			} else {
				conf.onError("Failed to save config", []);
				None();
			}
		}
	),
	RuComm(RuCommDescr("conf-push", "conf", "push current conf onto a stack, current conf will be created from command arguments", "", false, false, [], []),
		\task, env -> {
			ru_conf_stack := Cons(env.conf, ^ru_conf_stack);
			Some(RuState(env with conf = ruTree2Conf(task.args)));
		}
	),
	RuComm(RuCommDescr("conf-pop", "conf", "pop a conf from a stack", "", false, false, [], []),
		\task, env -> {
			if (isEmptyList(^ru_conf_stack)) {
				env.conf.onError("Attempt to pop an empty conf stack", []);
			}
			conf = headList(^ru_conf_stack, ruTree2Conf(task.args));
			ru_conf_stack := tailList(^ru_conf_stack);
			Some(RuState(env with conf = conf));
		}
	),
];

ruRunGC(task : ScTask, state : RuState) -> Maybe<RuState> {
	gc();
	Some(state);
}

ruStatsCommands = [
	RuComm(RuCommDescr("stats-math", "stats", "show math statistics", "", false, false, [], []),
		\task, env -> { 
			env.conf.onMessage("Mathematics statistics:");
			env.conf.onMessage("-----------------------");
			env.conf.onMessage(ruMathStats(ruMakeMathFromSources(env.ru, env.conf)) + "\n");
			Some(env); 
		}
	),
	RuComm(RuCommDescr("stats-math-1", "stats", "show math statistics", "", false, false, [], []),
		\task, env -> {
			stats = ruMathStats1(ruMakeMathFromSources(env.ru, env.conf));
			Some(RuState(env with
				vars = setTree(env.vars, "stats-math-1.stats", stats);
			)); 
		}
	),
	RuComm(RuCommDescr("stats-mem", "stats", "show memory usage statistics", "", false, false, [], []),
		\task, env -> {
			env.conf.onMessage(
				memory2s(usedMemory()) + " + " + memory2s(freeMemory()) + " free = " + memory2s(totalMemory())
			);
			Some(env); 
		}
	),
	RuComm(
		RuCommDescr(
			"stats-cache", "stats", "show cache statistics", "", false, false,
			[RuCommArg("full", true, "show cached names", "")], []
		), 
		\task, env -> {
			env.conf.onMessage(ruCacheInfo(lookupTreeDef(task.args, "full", "") == "1"));
			Some(env);
		}
	)
];

ruCacheCommands = [
	RuComm(
		RuCommDescr(
			"cache-load", "sync", "read cached sources", "file", false, false,
			[RuCommArg("file", true, "input file", "")], []
		),
		\task, env -> {
			conf = env.conf;
			file = lookupTreeDef(task.args, "file", "");
			timer = ruMakeTimer();
			if (file != "") {
				ruLoadToMemCache(file, conf); 
			} else {
				ruLoadMemCacheFromDisk(conf);
			}
			if (ruVerbose(conf) > 0) {
				if (ruTimePassed(timer) > 100.0) {
					conf.onMessage("cache loaded in " + ruTimePassed2s(timer));
				}
			}
			Some(env); 
		}
	),
	RuComm(
		RuCommDescr(
			"cache-clear", "sync", "clear up a cache: mem, disk or all", "cache", false, false,
			[RuCommArg("cache", false, "which cache: mem, disk or all to clear", "mem")], []
		),
		\task, env -> {
			cache = lookupTreeDef(task.args, "cache", "");
			if (cache == "mem") {
				ruClearMemCache();
			} else if (cache == "disk") {
				ruClearDiskCache(env.conf);
			} else if (cache == "all") {
				ruClearCache(env.conf);
			}
			Some(env); 
		}
	),
	RuComm(
		RuCommDescr(
			"cache-save", "sync", "save cached sources", "file", false, false,
			[RuCommArg("file", true, "input file", "")], []
		),
		\task, env -> { 
			file = lookupTreeDef(task.args, "file", "");
			if (file == "") {
				ruSaveCache(env.conf); 
			} else {
				ruSaveCacheFile(file, env.conf); 
			}
			Some(env); 
		}
	),
];

ruSyncCommands = [
	RuComm(
		RuCommDescr(
			"sync-file-source", "sync", "load an updated file source", "file", false, false,
			[RuCommArg("file", false, "input file", ""),  RuCommArg("text", false, "updated source", "")], []
		),
		\task, env -> { 
			ruSetFileSource(lookupTreeDef(task.args, "file", ""), 
			lookupTreeDef(task.args, "text", "")); 
			Some(env);
		}
	),
	RuComm(
		RuCommDescr(
			"sync-file-changed", "sync", "apply changes to a file source", "file", false, false,
			[RuCommArg("file", false, "input file", ""),  RuCommArg("change", false, "change in JSON format", "")], []
		),
		\task, env -> {
			json = lookupTreeDef(task.args, "change-json", "");
			switch (json2LspDidChangeTextDocumentParams(parseJson(json))) {
				Some(params): {
					path = ruCorrectUriPath(params.textDocument.uri.path);
					contents = ruFileSource(path);
					changed = fold(params.contentChanges, contents, \acc, changes -> lspApplyContentChangeEvent(changes, acc));
					ruSetFileSource(path, changed);
				}
				None(): {
					env.conf.onMessage("file-change: An option 'change-json' must be a vaid Json-encoded LSP DidChangeTextDocimentParams");
				}
			}
			Some(env);
		}
	),
	RuComm(
		RuCommDescr(
			"sync-file-saved", "sync", "file was saved", "file", false, false,
			[RuCommArg("file", false, "input file", "")], []
		),
		\task, env -> { 
			ruLoadFileSource(lookupTreeDef(task.args, "file", "")); 
			Some(env);
		}
	)
];
