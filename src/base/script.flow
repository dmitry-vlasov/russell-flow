import lingo/pegcode/driver;
import base/task;
import base/conf;

export {
	ScScript ::= ScSeq, ScAssign, ScIf, ScWhile, RuTask;
		ScSeq(seq : [ScScript]);
		ScAssign(var : string, exp : ScExp);
		ScIf(cond : ScCond, script : ScScript);
		ScWhile(cond : ScCond, script : ScScript);

	ScCond(op : string, lhs : ScExp, rhs : ScExp);

	ScExp ::= ScBinOp, ScUnOp, ScIntConst, ScVar;
		ScBinOp(op : string, lhs : ScExp, rhs : ScExp);
		ScUnOp(op : string, exp : ScExp);
		ScIntConst(val : int);
		ScVar(var : string);

	ruParseScript(str : string) -> ScScript;
	ruScript2Json(script : ScScript) -> Json;
	ruJson2Script(json : Json) -> Maybe<ScScript>;

	ruScript2s(script : ScScript) -> string;
}

ruMakeScTask(as : [flow]) -> RuTask {
	RuTask(as[0], 
		pairs2tree(map(
			filtermap(strSplit(flow2s(as[1]), " "), \s0 -> {
				s = trim2(s0, " \n\t\r");
				if (s == "") None() else Some(s);
			}),
			\s -> {
				sp = strSplit(s, "=");
				if (length(sp) == 1) Pair(s, "") else Pair(sp[0], sp[1]);
			}
		))
	);
}

ruMakeScScript(as : [flow]) -> ScScript {
	s1 = cast(as[0] : flow -> ScScript);
	s2 = cast(as[1] : flow -> ScSeq);
	if (length(s2.seq) == 0) s1 else { 
		ScSeq(concat([s1], s2.seq));
	}
}

ru_script_parser = compilePegGrammar("#include base/script.lingo");
ru_script_actions = SemanticActions(mergeTree(defaultPegActions.t, 
	pairs2tree([
		Pair("makeScTask", ruMakeScTask),
		Pair("makeScScript", ruMakeScScript),
		Pair("makeEmptySeq", \__ -> ScSeq([]))
	])
));

ruParseScript(str : string) -> ScScript {
	parsic(ru_script_parser, str, ru_script_actions);
}

ruScript2Json(j : ScScript) -> Json {
	cond2json = \cond -> {
		JsonObject([
			Pair("op", JsonString(cond.op)),
			Pair("lhs", ruScExp2Json(cond.lhs)),
			Pair("rhs", ruScExp2Json(cond.rhs))
		]);
	}
	switch (j) {
		ScSeq(seq): {
			JsonObject([
				Pair("struct", JsonString("ScSeq")),
				Pair("seq", JsonArray(map(seq, ruScript2Json)))
			]);
		}
		ScAssign(var, val): {
			JsonObject([
				Pair("struct", JsonString("ScAssign")),
				Pair("var", JsonString(var)),
				Pair("exp", ruScExp2Json(val))
			]);
		}
		ScIf(cond, script): {
			JsonObject([
				Pair("struct", JsonString("ScIf")),
				Pair("cond", cond2json(cond)),
				Pair("script", ruScript2Json(script)),
			]);
		}
		ScWhile(cond, script): {
			JsonObject([
				Pair("struct", JsonString("ScWhile")),
				Pair("cond", cond2json(cond)),
				Pair("script", ruScript2Json(script)),
			]);
		}
		RuTask(comm, args): {
			JsonObject([
				Pair("struct", JsonString("RuTask")),
				Pair("command", JsonString(comm)),
				Pair("args", JsonArray(map(tree2pairs(args), 
					\arg -> JsonObject([
						Pair("var", JsonString(arg.first)),
						Pair("value", JsonString(arg.second))
					])
				)))
			]);
		}
	}
}

ruScExp2Json(e : ScExp) -> Json {
	switch (e) {
		ScBinOp(op, lhs, rhs): {
			JsonObject([
				Pair("struct", JsonString("ScBinOp")),
				Pair("op", JsonString(op)),
				Pair("lhs", ruScExp2Json(lhs)),
				Pair("rhs", ruScExp2Json(rhs))
			]);
		}
		ScUnOp(op, ex): {
			JsonObject([
				Pair("struct", JsonString("ScUnOp")),
				Pair("op", JsonString(op)),
				Pair("exp", ruScExp2Json(ex))
			]);
		}
		ScIntConst(val): {
			JsonObject([
				Pair("struct", JsonString("ScIntConst")),
				Pair("val", JsonDouble(i2d(val)))
			]);
		}
		ScVar(var): {
			JsonObject([
				Pair("struct", JsonString("ScVar")),
				Pair("var", JsonString(var))
			]);
		}
	}
}

jsonObjectHasAllFields(json : JsonArray, fields : [string]) -> bool {
	forall(fields, \field -> jsonObjectHasField(json, field));
}

ruJson2Script(json : Json) -> Maybe<ScScript> {
	json2cond = \j -> {
		op = getJsonStringField(j, "op", "");
		if (op == "") None() else {
			maybeMap2(\lhs, rhs -> ScCond(op, lhs, rhs))
			(
				ruJson2Eval(getJsonFieldValue(j, "lhs", JsonNull())),
				ruJson2Eval(getJsonFieldValue(j, "rhs", JsonNull()))
			);
		}
	}
	struct = getJsonStringField(json, "struct", "");
	if (struct == "") None() else
	if (struct == "ScSeq") {
		json_seq = getJsonArrayField(json, "seq");
		seq = filtermap(getJsonArrayField(json, "seq"), ruJson2Script);
		if (length(json_seq) == length(seq)) {
			Some(ScSeq(seq));
		} else {
			None();
		}
	} else 
	if (struct == "ScAssign") {
		var = getJsonStringField(json, "var", "");
		if (var == "") None() else {
			json_val = getJsonFieldValue(json, "exp", JsonNull());
			maybeMap(
				ruJson2Eval(json_val),
				\val -> ScAssign(var, val)
			);
		}
	} else 
	if (struct == "ScIf") {
		maybeMap2(\cond, script -> ScIf(cond, script))(
			json2cond(getJsonFieldValue(json, "cond", JsonNull())),
			ruJson2Script(getJsonFieldValue(json, "script", JsonNull()))
		);
	} else 
	if (struct == "ScWhile") {
		maybeMap2(\cond, script -> ScWhile(cond, script))(
			json2cond(getJsonFieldValue(json, "cond", JsonNull())),
			ruJson2Script(getJsonFieldValue(json, "script", JsonNull()))
		);
	} else 
	if (struct == "RuTask") {
		comm = getJsonStringField(json, "command", "");
		if (comm == "") None() else {
			json_args = getJsonArrayField(json, "args");
			args = filtermap(getJsonArrayField(json, "args"), \opt -> {
				var = getJsonStringField(opt, "var", "");
				if (var == "") None() else {
					Some(Pair(var, getJsonStringField(opt, "value", "")))
				}
			});
			if (length(json_args) != length(args)) None() else {
				Some(RuTask(comm, pairs2tree(args)));
			}
		}
	} else {
		None();
	}
}

ruJson2Eval(json : Json) -> Maybe<ScExp> {
	struct = getJsonStringField(json, "struct", "");
	if (struct == "") None() else
	if (struct == "ScBinOp") {
		op = getJsonStringField(json, "op", "");
		if (op == "") None() else {
			maybeMap2(\lhs, rhs -> ScBinOp(op, lhs, rhs))
			(
				ruJson2Eval(getJsonFieldValue(json, "lhs", JsonNull())),
				ruJson2Eval(getJsonFieldValue(json, "rhs", JsonNull())),
			);
		}
	} else 
	if (struct == "ScUnOp") {
		op = getJsonStringField(json, "op", "");
		if (op == "") None() else {
			maybeMap(
				ruJson2Eval(getJsonFieldValue(json, "exp", JsonNull())), 
				\ex -> ScUnOp(op, ex)
			);
		} 
	} else 
	if (struct == "ScIntConst") {
		if (!jsonObjectHasField(json, "val")) None() else {
			val = getJsonDoubleField(json, "op", 0.0);
			Some(ScIntConst(round(val)));
		} 
	} else 
	if (struct == "ScVar") {
		if (!jsonObjectHasField(json, "var")) None() else {
			var = getJsonStringField(json, "var", "");
			Some(ScVar(var));
		} 
	} else {
		None();
	}
}

ruScript2s(j : ScScript) -> string {
	cond2s = \cond -> {
		"(" + ruEval2s(cond.lhs) + " " + cond.op + " " + ruEval2s(cond.rhs) + ")";
	}
	switch (j) {
		ScSeq(seq):         strGlue(map(seq, ruScript2s), "\n");
		ScAssign(var, val): var + " = " + ruEval2s(val) + ";";
		ScIf(cond, script):    "if " + cond2s(cond) + " {\n" + strIndent(ruScript2s(script)) + "\n}";
		ScWhile(cond, script): "while " + cond2s(cond) + " {\n" + strIndent(ruScript2s(script)) + "\n}";
		RuTask(comm, args): ruTask2s(j);
	}
}

ruEval2s(e : ScExp) -> string {
	switch (e) {
		ScBinOp(op, lhs, rhs): "(" + ruEval2s(lhs) + " " + op + " " + ruEval2s(rhs) + ")";
		ScUnOp(op, ex): op + ruEval2s(ex);
		ScIntConst(val): i2s(val);
		ScVar(var): var;
	}
}
