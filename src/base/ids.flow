import sys/concurrent;
import text/binary;
import base/log;

export {
	s2id(s : string) -> int;
	id2s(id : int) -> string;
	ruSaveIds(conf : RuConf) -> void;
	ruReadIds(conf : RuConf) -> void;
}

ru_s2id_map = initConcurrentHashMap();
ru_id2s_map = initConcurrentHashMap();
ru_id_counter = ref 0;
ru_add_counter = ref 0;

s2id(s : string) -> int {
	if (containsConcurrentHashMap(ru_s2id_map, s)) {
		getConcurrentHashMap(ru_s2id_map, s, -1);
	} else {
		id = atomicRefIntAddition(ru_id_counter, 1);
		sets2id(s, id);
		id;
	}
}

id2s(id : int) -> string {
	if (!containsConcurrentHashMap(ru_id2s_map, id)) {
		ruCrash("Id '" + i2s(id) + "' is not registred in the id-to-string map");
		"";
	} else {
		getConcurrentHashMap(ru_id2s_map, id, "");
	}
}

sets2id(s : string, id : int) -> void {
	if (containsConcurrentHashMap(ru_s2id_map, s)) {
		ruCrash("String '" + s + "' is already in the string-to-id map");
	} else if (containsConcurrentHashMap(ru_id2s_map, id)) {
		ruCrash("Id '" + i2s(id) + "' is already in the id-to-string map");
	} else {
		atomicRefIntAddition(ru_add_counter, 1);
		setConcurrentHashMap(ru_s2id_map, s, id);
		setConcurrentHashMap(ru_id2s_map, id, s);
	}
}

ruSaveIds(conf : RuConf) -> void {
	if (^ru_add_counter > 0) {
		arr = map(keysConcurrentHashMap(ru_s2id_map), \s -> 
			Pair(s, getConcurrentHashMap(ru_s2id_map, s, -1))
		);
		cache_dir = ruCacheDir(conf);
		file = cache_dir + "/ids.map";
		setFileContent(file, toBinary(arr));
		ru_add_counter := 0;
	}
}

ruReadIds(conf : RuConf) -> void {
	cache_dir = ruCacheDir(conf);
	file = cache_dir + "/ids.map";
	if (fileExists(file)) {
		raw = deserializeBinary(getFileContent(file), IllegalStruct());
		if (raw == IllegalStruct()) {
			conf.onError("WARNING: Illegal structure of id maps file for '" + file + "'", []);
		} else {
			ids = cast(raw : flow -> [Pair<string, int>]);	
			iter(ids, \p -> sets2id(p.first, p.second));
			ru_id_counter := length(ids);
			ru_add_counter := 0;
		}
	}
}
