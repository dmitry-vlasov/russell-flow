import ds/tree;
import string;

export {
	RuTrie(
		data : Maybe<??>,
		map : Tree<?, RuTrie<?, ??>>,
	);
	ruTrieEmpty = RuTrie(None(), makeTree());

	ruAdd2Trie(key : [?], data : Maybe<??>, trie : RuTrie<?, ??>, conflict : (??, ??) -> ??) -> RuTrie<?, ??>;
	ruRemoveFromTrie(key : [?], trie : RuTrie<?, ??>) -> RuTrie<?, ??>;
	ruTrie2s(t : RuTrie<?, ??>, show_key : (?) -> string, show_val : (??) -> string) -> string;
	ruMergeRuTrie(t1 : RuTrie<?, ??>, t2 : RuTrie<?, ??>, conflict : (??, ??) -> ??) -> RuTrie<?, ??>;
}

ruAdd2Trie(key : [?], data : Maybe<??>, trie : RuTrie<?, ??>, conflict : (??, ??) -> ??) -> RuTrie<?, ??> {
	if (length(key) == 0) trie else doRuAdd2Trie(0, key, data, trie, conflict)
}
ruRemoveFromTrie(key : [?], trie : RuTrie<?, ??>) -> RuTrie<?, ??> {
	if (length(key) == 0) trie else doRuRemoveFromTrie(0, key, trie)
}

ruTrie2s(t : RuTrie<?, ??>, show_key : (?) -> string, show_val : (??) -> string) -> string {
	foldTree(doRuTrie2tree(t, [], makeTree(), show_key, show_val), "",
		\path, val, acc ->
			acc + strGlue(path, " ") + " --> " + val + "\n"
	)
}

doRuAdd2Trie(i : int, key : [?], data : Maybe<??>, trie : RuTrie<?, ??>, conflict : (??, ??) -> ??) -> RuTrie<?, ??> {
	n = lookupTreeDef(trie.map, key[i], ruTrieEmpty);
	if (i + 1 == length(key)) {
		RuTrie(trie.data, setTree(trie.map, key[i], RuTrie(ruInsertData2Trie(n.data, data, conflict), n.map)));
	} else {
		RuTrie(trie.data, setTree(trie.map, key[i], doRuAdd2Trie(i + 1, key, data, n, conflict)));
	}
}

doRuRemoveFromTrie(i : int, key : [?], trie : RuTrie<?, ??>) -> RuTrie<?, ??> {
	n = lookupTreeDef(trie.map, key[i], ruTrieEmpty);
	if (i + 1 == length(key)) {
		RuTrie(trie.data, setTree(trie.map, key[i], RuTrie(None(), n.map)));
	} else {
		RuTrie(trie.data, setTree(trie.map, key[i], doRuRemoveFromTrie(i + 1, key, n)));
	}
}


doRuTrie2tree(trie : RuTrie<?, ??>, path : [string], acc : Tree<[string], string>, show_key : (?) -> string, show_val : (??) -> string) -> Tree<[string], string> {
	foldTree(trie.map, acc, 
		\k, v, ac -> {
			path1 = concat(path, [show_key(k)]);
			ac1 = doRuTrie2tree(v, path1, ac, show_key, show_val);
			switch (v.data) {
				None(): ac1;
				Some(d): setTree(ac1, path1, show_val(d));
			}
		}
	)
}

ruInsertData2Trie(md1 : Maybe<??>, md2 : Maybe<??>, conflict : (??, ??) -> ??) -> Maybe<??> {
	eitherMap(md1, \d1 -> eitherMap(md2, \d2 -> Some(conflict(d1, d2)), md1), md2)
}

ruMergeRuTrie(t1 : RuTrie<?, ??>, t2 : RuTrie<?, ??>, conflict : (??, ??) -> ??) -> RuTrie<?, ??> {
	RuTrie(
		ruInsertData2Trie(t1.data, t2.data, conflict),
		mergeTreeCustom(t1.map, t2.map, \__, s1, s2 -> ruMergeRuTrie(s1, s2, conflict))
	)
}
