import sys/system;
import ds/list;
import timer;
import comm;
import base/concurrent;

export {

	RuMemStats(
		time : double,
		used : double,
		free : double,
		total: double
	);

	ruStartMemoryTracker() -> void;
	ruStopMemoryTracker() -> void;
	ruGetMemoryTracker() -> [RuMemStats];

	ruMemTrackerCommands : [RuComm];
}

ruMemTrackerCommands = [
	RuComm(RuCommInfo("mem-tracker-start", "misc", "start memory info tracker", "", false, false, [], []),
		\unit -> { ruStartMemoryTracker(); Some(unit.state); }
	),
	RuComm(RuCommInfo("mem-tracker-stop", "misc", "stop memory info tracker", "", false, false, [], []),
		\unit -> { ruStopMemoryTracker(); Some(unit.state); }
	),
	RuComm(RuCommInfo("mem-tracker-info", "misc", "show memory info tracker", "", false, false,
		[
			RuCommArg("what", false, "one of: free, used, total.", "used"),
			RuCommArg("step", false, "step of output - im seconds. 0 mins no compression", "10"),
		], []),
		\unit -> {
			stats = ruGetMemoryTracker();
			what = ruTaskStringArg(unit.task, "what", "used");
			step = ruTaskIntArg(unit.task, "step", 10);
			table = map(ruGetMemoryTracker(), \row ->
				Pair(row.time,
					if (what == "free") row.free else
					if (what == "used") row.used else
					if (what == "total") row.total else row.used
				)
			);
			squeezed = if (step <= 0) table else ruSqueezeTable(table, step);
			unit.out.println(
				what + " memory:\n" +
				ruPlotTableCustom(squeezed, 64,
					\t -> ruTime2s(t - ruStartTime),
					\v -> memory2s(v)
				)
			);
			Some(unit.state);
		}
	)
];

ru_memory_tracker_stopper : ref Maybe<() -> void> = ref None();
ru_memory_tracker_stats : ref List<RuMemStats> = ref makeList();

/*
native concurrentAsyncCallback : (
		threadPool : native,
		task : (callback : (?) -> void, forceExit : () -> void) -> void,
		onDone : (?) -> void,
		onFail : (string) -> void
	) -> void = Native.concurrentAsyncCallback;
*/

ruStartMemoryTracker() -> void {
	if (isNone(^ru_memory_tracker_stopper)) {
		ru_memory_tracker_stats := makeList();
		ruDeferredCall(\->
			ru_memory_tracker_stopper := Some(
				scheduleTimerTask(100,
					\-> ru_memory_tracker_stats := Cons(
						RuMemStats(
							timestamp(),
							usedMemory(),
							freeMemory(),
							totalMemory()
						),
						^ru_memory_tracker_stats
					),
					true, "memory_tracker"
				)
			)
		);
	}
}

ruStopMemoryTracker() -> void {
	switch (^ru_memory_tracker_stopper) {
		Some(stop): {
			ru_memory_tracker_stopper := None();
			stop();
		}
		None(): {}
	}
}

ruGetMemoryTracker() -> [RuMemStats] {
	list2array(^ru_memory_tracker_stats);
}
