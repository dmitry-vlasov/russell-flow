import lingo/linecolumn;
import math/stringmath;
import net/http;
import text/serialize;
import formats/lsp;

import parse/mm_load;
import parse/ru_load;
import parse/ru_parse;
import parse/ru_collect_math;
import parse/mm_parse;
import parse/mm_collect_math;
import ru_2_mm;
import mm_2_ru;
import mm_verify;
import ru_split;
import ru_imports;
import ru_command;
import ru_write;

export {
	ruIoCommands() -> [RuComm];
	mmCommWrite(task : RuTask, env : RuEnv) -> RuEnv;
	ruCommWrite(task : RuTask, env : RuEnv) -> RuEnv;
	ruCommReadRu(task : RuTask, env : RuEnv) -> RuEnv;
	ruCommReadMm(task : RuTask, env : RuEnv) -> RuEnv;
	ruCommRead(task : RuTask, env : RuEnv) -> RuEnv;
	ruTranslateCommands() -> [RuComm];
}

ruIoCommands() -> [RuComm] {[
	RuComm(
		"read", "io", "read a Russell file",
		[RuCommArg("file", false, "input file", "")],
		ruCommRead
	),
	RuComm(
		"read-ru", "io", "read a Russell file",
		[RuCommArg("file", false, "input file", "")],
		ruCommReadRu
	),
	RuComm(
		"read-mm", "io", "read a Metamath file",
		[RuCommArg("file", false, "input file", "")],
		ruCommReadMm
	),
	RuComm(
		"write-mm", "io", "write a Metamath file to a filesystem",
		[
			RuCommArg("file", true, "input file", ""), 
			RuCommArg("all", true, "write all files", ""), 
			RuCommArg("all-to-one", true, "write all files to a one", ""),
			RuCommArg("strip-comments", true, "self evident", "")
		],
		mmCommWrite
	),
	RuComm(
		"write-ru", "io", "write a Russell file to a filesystem",
		[
			RuCommArg("file", true, "input file", ""), 
			RuCommArg("all", true, "write all files", ""), 
			RuCommArg("all-to-one", true, "write all files to a one", "")
		],
		ruCommWrite
	),
	RuComm(
		"split-math", "misc", "split a single file into a filesystem",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> {
			file = lookupTreeDef(task.args, "file", "");
			module = ruTrimPath(file, env.conf, ".ru");
			RuEnv(env with ruMath = ruSplitMath(env.ruMath, env.conf, module));
		}
	),
	RuComm(
		"fix-left-recursion", "misc", "make all grammar rules non-left-recursive",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> RuEnv(env with ruMath = ruFixLeftRecursiveRules(env.ruMath, env.conf))
	),
	RuComm(
		"optimize-imports", "misc", "optimize imports", [],
		\task, env -> RuEnv(env with ruMath = ruOptimizeImports(env.ruMath, env.conf))
	),
]}

mmCommWrite(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.mmMath;
	conf = env.conf;
	write_mm = \src0 : MmSource -> {
		path = src0.info.path;
		ensureDirectoryExists(ruDirName(path));
		if (env.conf.verbose > 1) {
			conf.onMessage("\tmm writing : '" + path + "'");
		}
		src = if (lookupTreeDef(task.args, "strip-comments", "") == "1") mmStripComments(src0) else src0;
		if (!setFileContent(path, mm2s(src))) {
			conf.onMessage("error while writing '" + path + "'");
		}
	}
	if (lookupTreeDef(task.args, "file", "") != "") {
		file = lookupTreeDef(task.args, "file", "");
		if (!endsWith(file, ".mm")) {
			conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
		} else {
			module = ruTrimPath(file, conf, ".mm");
			switch (lookupTree(math.sources, module)) {
				Some(src): write_mm(src);
				None(): conf.onMessage("source: '" + file + "' is not found");
			}
		}
	} else if (lookupTreeDef(task.args, "all", "") == "1") {
		start = timestamp();
		iter(getTreeValues(math.sources), write_mm);
		time = (timestamp() - start);
		if (conf.verbose > 0 && time > 100.0) {
			conf.onMessage("mm written " + i2s(sizeTree(math.sources)) + " files in " + d2st(time/ 1000.0, 2) + "s");
		}
	} else if (lookupTreeDef(task.args, "all-to-one", "") != "") {
		file = lookupTreeDef(task.args, "all-to-one", "");
		if (!endsWith(file, ".mm")) {
			conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
		} else {
			write_mm(mmMath2SingleSource(env.mmMath, file, env.conf));
		}
	}
	env;
}

ruCommWrite(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	if (lookupTreeDef(task.args, "file", "") != "") {
		file = lookupTreeDef(task.args, "file", "");
		if (!endsWith(file, ".ru")) {
			conf.onError("Wrong file extension " + file + ", mus be *.ru", []);
		} else {
			module = ruTrimPath(file, conf, ".ru");
			switch (lookupTree(math.sources, module)) {
				Some(src): ruWriteSource(src, math, conf);
				None(): conf.onMessage("source: " + file + " is not found");
			}
		}
	} else if (lookupTreeDef(task.args, "all", "") == "1") {
		start = timestamp();
		iter(getTreeValues(math.sources), 
			\src -> ruWriteSource(src, math, conf)
		);
		time = (timestamp() - start);
		if (conf.verbose > 0 && time > 100.0) {
			conf.onMessage("ru written " + i2s(sizeTree(math.sources)) + " files in " + d2st(time/ 1000.0, 2) + "s");
		}
	} else if (lookupTreeDef(task.args, "all-to-one", "") != "") {
		file = lookupTreeDef(task.args, "all-to-one", "");
		if (!endsWith(file, ".ru")) {
			conf.onError("Wrong file extension " + file + ", mus be *.ru", []);
		} else {
			ruWriteSource(ruMath2SingleSource(math, ruRemoveExt(file, ".ru"), conf), math, conf);
		}
	}
	env;
}

ruCommReadRu(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".ru")) {
		env.conf.onError("Wrong file extension: " + file + ", must be *.ru", []);
		env;
	} else {
		path = resolveRelativePath(file);
		module = ruTrimPath(path, env.conf, getFileExt(file));
		ru = maybeBind(
			maybeBind(ruLoadAll(env.conf, module, ruFromCache), \loaded ->
				ruParseAll(getTreeValues(loaded), env.conf)
			), 
			\parsed -> ruCollectMath(parsed, env.conf)
		);
		eitherMap(ru, \math -> RuEnv(env with ruMath = math), env);
	}
}

ruCommReadMm(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".mm")) {
		env.conf.onError("Wrong file extension " + file + ", mus be *.mm", []);
		env;
	} else {
		path = resolveRelativePath(file);
		module = ruTrimPath(path, env.conf, getFileExt(file));
		mm = maybeBind(mmLoad(env.conf, module), \loaded ->
			maybeBind(mmParse(getTreeValues(loaded), env.conf), \parsed ->
				maybeBind(mmCollectMath(parsed, env.conf), \collected ->
					mmVerifyMath(collected, env.conf)
				)
			)
		);
		eitherMap(mm, \math -> RuEnv(env with mmMath = math), env);
	}
}

ruCommRead(task : RuTask, env : RuEnv) -> RuEnv {
	file = lookupTreeDef(task.args, "file", "");
	if (endsWith(file, ".ru")) {
		ruCommReadRu(task, env);
	} else if (endsWith(file, ".mm")) {
		ruCommReadMm(task, env);
	} else {
		env.conf.onError("Unknown file extension: " + file + ", must be *.ru or *.mm", []);
		env;
	}
}

ruTranslateCommands() -> [RuComm] {[
	RuComm(
		"ru-to-mm", "translate", "translate Russell to Metamath", [],
		\task, env -> RuEnv(env with mmMath = ru2mm(env.ruMath, env.conf))
	),
	RuComm(
		"mm-to-ru", "translate", "translate Metamath to Russell",
		[RuCommArg("file", false, "input file", "")],
		\task, env -> eitherMap(ruCollectMath(mm2ru(env.mmMath, env.conf), env.conf), \math -> RuEnv(env with ruMath = math), env)
	),
]}
