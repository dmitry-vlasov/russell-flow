import sys/concurrent;
import net/url_parameter;

export {
	// In server mode this function transfers argument to the http
	// response buffer as well as to the console output. Id is a thread id.
	ruPrintln(str : string) -> void;

	// Returns accumulated output string (buffer). 
	ruOutput() -> string;

	// Clears the output buffers, accociated with a thread id.
	ruClearOutput() -> void;

	// Set the skip printing flag for a given thread
	ruSetSkipPrinting(val : bool) -> void;

	// Set the skip buffering flag for a given thread
	ruSetSkipBuffering(val : bool) -> void;
}

ruOutputBuffer = initConcurrentHashMap();
ruSkipPrinting = initConcurrentHashMap();
ruSkipBuffering = initConcurrentHashMap();

ruGetSkipPrinting() -> bool {
	getConcurrentHashMap(ruSkipPrinting, getThreadId(), false);
}

ruSetSkipBuffering(val : bool) -> void {
	setConcurrentHashMap(ruSkipBuffering, getThreadId(), val);
}

ruGetSkipBuffering() -> bool {
	getConcurrentHashMap(ruSkipBuffering, getThreadId(), false);
}

ruSetSkipPrinting(val : bool) -> void {
	setConcurrentHashMap(ruSkipPrinting, getThreadId(), val);
}

ruPrintln(str : string) -> void {
	if (!ruGetSkipBuffering()) {
		if (!containsConcurrentHashMap(ruOutputBuffer, getThreadId())) {
			setConcurrentHashMap(ruOutputBuffer, getThreadId(), ref []);
		}
		refArrayPush(getConcurrentHashMap(ruOutputBuffer, getThreadId(), ref []), str);
	}
	if (!ruGetSkipPrinting()) {
		println(str);
	}
}

ruOutput() -> string {
	if (!containsConcurrentHashMap(ruOutputBuffer, getThreadId())) "" else
	strGlue(^(getConcurrentHashMap(ruOutputBuffer, getThreadId(), ref [])), "\n");
}

ruClearOutput() -> void {
	setConcurrentHashMap(ruOutputBuffer, getThreadId(), ref []);
}
