import sys/concurrent;
import net/url_parameter;
import ru_conf;

export {
	// In server mode this function transfers argument to the http
	// response buffer as well as to the console output. Id is a thread id.
	ruPrintln(str : string, conf : RuConf) -> void;

	// Returns accumulated output string (buffer). 
	ruOutput(conf : RuConf) -> string;

	// Clears the output buffers, accociated with a thread id.
	ruClearOutput(conf : RuConf) -> void;

	// Set the skip printing flag for a given thread
	ruSetSkipPrinting(conf : RuConf, val : bool) -> void;

	// Set the skip buffering flag for a given thread
	ruSetSkipBuffering(conf : RuConf, val : bool) -> void;
}

ruOutputBuffer = initConcurrentHashMap();
ruSkipPrinting = initConcurrentHashMap();
ruSkipBuffering = initConcurrentHashMap();

ruGetSkipPrinting(conf : RuConf) -> bool {
	getConcurrentHashMap(ruSkipPrinting, conf.threadId, false);
}

ruSetSkipBuffering(conf : RuConf, val : bool) -> void {
	setConcurrentHashMap(ruSkipBuffering, conf.threadId, val);
}

ruGetSkipBuffering(conf : RuConf) -> bool {
	getConcurrentHashMap(ruSkipBuffering, conf.threadId, false);
}

ruSetSkipPrinting(conf : RuConf, val : bool) -> void {
	setConcurrentHashMap(ruSkipPrinting, conf.threadId, val);
}

ruPrintln(str : string, conf : RuConf) -> void {
	if (!ruGetSkipBuffering(conf)) {
		if (!containsConcurrentHashMap(ruOutputBuffer, conf.threadId)) {
			setConcurrentHashMap(ruOutputBuffer, conf.threadId, ref []);
		}
		refArrayPush(getConcurrentHashMap(ruOutputBuffer, conf.threadId, ref []), str);
	}
	if (!ruGetSkipPrinting(conf)) {
		println(str);
	}
}

ruOutput(conf : RuConf) -> string {
	if (!containsConcurrentHashMap(ruOutputBuffer, conf.threadId)) "" else
	strGlue(^(getConcurrentHashMap(ruOutputBuffer, conf.threadId, ref [])), "\n");
}

ruClearOutput(conf : RuConf) -> void {
	setConcurrentHashMap(ruOutputBuffer, conf.threadId, ref []);
}
