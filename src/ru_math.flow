import parse/ru_type_env;
import ru_conf;
import ru_src;

export {
	RuMath(
		sources : Tree<string, RuSource>,
		consts  : Tree<string, RuConst>,
		types   : Tree<string, RuTypeEnv>,
		rules   : Tree<string, RuRule>,
		names   : Tree<string, string>,
		assertions : Tree<string, RuAssertion>,
		conf : RuConf
	);

	ruMakeRuMath(conf : RuConf) -> RuMath;
	ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace;
	ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom>;
	ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem>;
	ruMathDefs(math : RuMath) ->Tree<string, RuDef>;

	ruMathStats(math : RuMath) -> string;
	ruMathInfo(math : RuMath) -> string;

	ruMergeRuMath(m1 : RuMath, m2 : RuMath) -> RuMath;

	ruAddErr2Math(math : RuMath, msg : string) -> RuMath;
	ruMath2SingleSource(math : RuMath, file : string) -> RuSource;

	ruFixLeftRecursiveRules(math : RuMath) -> RuMath;
	ruCollectNames(math : RuMath) -> RuMath;
	ruSuperTypeName(super : string, infer : string) -> string;
}

ruSuperTypeName(super : string, infer : string) -> string {
	infer + "-" + super
}

ruMakeRuMath(conf : RuConf) -> RuMath {
	RuMath(makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), conf)
}

ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace {
	RuPlace(lookupTreeDef(math.names, name, "<no src>"), pos)
}
ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> 
			switch (ass) { 
				RuAxiom(__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
	)
}

ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> 
			switch (ass) { 
				RuTheorem(__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
	)
}

ruMathDefs(math : RuMath) ->Tree<string, RuDef> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> 
			switch (ass) { 
				RuDef(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
	)
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"sources:    " + i2s(sizeTree(math.sources)),
		"consts:     " + i2s(sizeTree(math.consts)),
		"types:      " + i2s(sizeTree(math.types)),
		"rules:      " + i2s(sizeTree(math.rules)),
		"assertions: " + i2s(sizeTree(math.assertions)),
		"  axioms:   " + i2s(sizeTree(ruMathAxioms(math))),
		"  theorems: " + i2s(sizeTree(ruMathTheorems(math))),
		"  defs:     " + i2s(sizeTree(ruMathDefs(math)))
	], "\n")
}

ruMathInfo(math : RuMath) -> string {
	strGlue([
		"sources:    " + strGlue(getTreeKeys(math.sources), ", "),
		"consts:     " + strGlue(getTreeKeys(math.consts), ", "),
		"types:      " + strGlue(getTreeKeys(math.types), ", "),
		"rules:      " + strGlue(getTreeKeys(math.rules), ", "),
		"assertions: " + strGlue(getTreeKeys(math.assertions), ", "),
	], "\n")
}

ruMergeRuMath(m1 : RuMath, m2 : RuMath) -> RuMath {
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \name, s1, s2 -> { m1.conf.onError("duplicate source: " + name, []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \name, c1, c2 -> { m1.conf.onError("duplicate constant: " + name, []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \type, e1, e2 -> ruMergeRuTypeEnv(e1, e2)),
		mergeTreeCustom(m1.rules, m2.rules, \name, r1, r2 -> { m1.conf.onError("duplicate rule: " + name, []); r1 }),
		mergeTreeCustom(m1.names, m2.names, \name, s1, s2 -> { m1.conf.onError("duplicate name: " + name, []); s1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \name, a1, a2 -> { m1.conf.onError("duplicate assertion: " + name, []); a1 }),
		m1.conf
	)
}

ruAddErr2Math(math : RuMath, msg : string) -> RuMath {
	RuMath(math with conf = ruAddErr2Conf(math.conf, msg))
}

ruMath2SingleSource(math : RuMath, path : string) -> RuSource {
	file = ruRemoveExt(path, ".ru");
	RuSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			ruMathCollectSource(src, math, acc)
		).first,
		RuFileInfo(file, file + ".ru", 0.0, 0.0)
	);
}

ruMathCollectSource(src : RuSource, math : RuMath, acc : Pair<[RuBlock], Set<string>>) -> Pair<[RuBlock], Set<string>> {
	if (containsSet(acc.second, src.info.file)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.file)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.path)) {
					Some(inc_src): ruMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

ruFixLeftRecursiveRules(math : RuMath) -> RuMath {
	fixRule = \r -> 
		if (length(r.term.expr) <= 1) r else {
			switch (r.term.expr[0]) {
				RuVar(__,__):
					RuRule(r with term = RuTerm(r.term with expr = 
						concat3([RuConstRef("(")], r.term.expr, [RuConstRef(")")])
					));
				default: r;
			}
		}
	fixSource = \s -> 
		RuSource(s with
			decls = map(s.decls, \decl -> 
				switch (decl) {
					RuRule(__,__,__,__): fixRule(decl);
					default: decl;
				}
			)
		);
	if (math.conf.verbose > 0) {
		println("ru potentially left-recursive rules are fixed");
	}
	RuMath(math with
		rules = mapTree(math.rules, fixRule),
		sources = mapTree(math.sources, fixSource)
	);
}

ruCollectNames(math : RuMath) -> RuMath {
	RuMath(math with 
		names = foldTree(math.sources, makeTree(), \__, src, acc ->
			fold(src.decls, acc, \ac, decl ->
				switch (decl) {
					RuConst(name,__,__,__):            setTree(ac, name, src.info.file);
					RuType(name, supers,__):
						fold(supers, setTree(ac, name, src.info.file), \a, super -> setTree(a, ruSuperTypeName(super, name), src.info.file));
					RuRule(name,__,__,__):             setTree(ac, name, src.info.file);
					RuAxiom(name,__,__,__,__,__):      setTree(ac, name, src.info.file);
					RuDef(name,__,__,__,__,__,__,__):  setTree(ac, name, src.info.file);
					RuTheorem(name,__,__,__,__,__,__): setTree(ac, name, src.info.file);
					RuTheory(name,__,__):              setTree(ac, name, src.info.file);
					default: ac;
				}
			)
		)
	);
}
