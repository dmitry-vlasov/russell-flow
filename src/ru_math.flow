import parse/ru_type_env;
import ru_conf;
import ru_src;

export {
	RuMath(
		sources : Tree<string, RuSource>,
		consts  : Tree<string, RuConst>,
		types   : Tree<string, RuTypeEnv>,
		rules   : Tree<string, RuRule>,
		names   : Tree<string, string>,
		assertions : Tree<string, RuAssertion>,
		conf : RuConf
	);

	ruMakeMath(conf : RuConf) -> RuMath;
	ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace;
	ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom>;
	ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem>;
	ruMathDefs(math : RuMath) ->Tree<string, RuDef>;
	ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule>;

	ruMathStats(math : RuMath) -> string;
	ruMathInfo(math : RuMath) -> string;

	ruMergeMath(m1 : RuMath, m2 : RuMath) -> RuMath;
	ruRemoveSource(src : RuSource, m : RuMath) -> RuMath;
	ruAddSource(src : RuSource, m : RuMath) -> RuMath;

	ruAddErr2Math(math : RuMath, msg : string) -> RuMath;
	ruMath2SingleSource(math : RuMath, file : string) -> RuSource;

	ruFixLeftRecursiveRules(math : RuMath) -> RuMath;
	ruCollectMathNames(math : RuMath) -> RuMath;
	ruCollectSourceNames(src : RuSource, math : RuMath) -> RuMath;
	ruCollectAllImported(name : string, math : RuMath) -> Set<RuSource>;

	ruOrderSources(math : RuMath) -> [RuSource];
	ruReplaceTheorem(th : RuTheorem, math : RuMath) -> RuMath;
	ruNameSource(name : string, math : RuMath) -> RuSource;

	ruSourceTheorems(src : RuSource) -> [RuTheorem];
	ruTheorem(name : string, math : RuMath) -> RuTheorem;
}

ruMakeMath(conf : RuConf) -> RuMath {
	RuMath(makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), conf)
}

ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, 
			lookupTreeDef(math.names, name, ""), ruNoSource
		).info.file, pos
	)
}
ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> 
			switch (ass) { 
				RuAxiom(__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
	)
}

ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> 
			switch (ass) { 
				RuTheorem(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
	)
}

ruMathDefs(math : RuMath) ->Tree<string, RuDef> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> 
			switch (ass) { 
				RuDef(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
	)
}

ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule> {
	switch (lookupTree(math.types, infer)) {
		Some(infEnv): lookupTree(infEnv.supers, super);
		None(): {
			math.conf.onError("unknown type: " + infer, []);
			quit(0);
			None();
		}
	}
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"sources:    " + i2s(sizeTree(math.sources)),
		"consts:     " + i2s(sizeTree(math.consts)),
		"types:      " + i2s(sizeTree(math.types)),
		"rules:      " + i2s(sizeTree(math.rules)),
		"assertions: " + i2s(sizeTree(math.assertions)),
		"  axioms:   " + i2s(sizeTree(ruMathAxioms(math))),
		"  theorems: " + i2s(sizeTree(ruMathTheorems(math))),
		"  defs:     " + i2s(sizeTree(ruMathDefs(math)))
	], "\n")
}

ruMathInfo(math : RuMath) -> string {
	strGlue([
		"sources:    " + strGlue(getTreeKeys(math.sources), ", "),
		"consts:     " + strGlue(getTreeKeys(math.consts), ", "),
		"types:      " + strGlue(getTreeKeys(math.types), ", "),
		"rules:      " + strGlue(getTreeKeys(math.rules), ", "),
		"assertions: " + strGlue(getTreeKeys(math.assertions), ", "),
	], "\n")
}

ruMergeMath(m1 : RuMath, m2 : RuMath) -> RuMath {
	/*RuMath(
		mergeTree(m1.sources, m2.sources),
		mergeTree(m1.consts, m2.consts),
		mergeTree(m1.types, m2.types),
		mergeTree(m1.rules, m2.rules),
		mergeTree(m1.names, m2.names),
		mergeTree(m1.assertions, m2.assertions),
		m1.conf
	);*/
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \name, s1, s2 -> { m1.conf.onError("duplicate source: " + name, []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \name, c1, c2 -> { m1.conf.onError("duplicate constant: " + name, []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \type, e1, e2 -> ruMergeRuTypeEnv(e1, e2)),
		mergeTreeCustom(m1.rules, m2.rules, \name, r1, r2 -> { m1.conf.onError("duplicate rule: " + name, []); r1 }),
		mergeTreeCustom(m1.names, m2.names, \name, s1, s2 -> { m1.conf.onError("duplicate name: " + name, []); s1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \name, a1, a2 -> { m1.conf.onError("duplicate assertion: " + name, []); a1 }),
		m1.conf
	);
}

ruRemoveSource(src : RuSource, m : RuMath) -> RuMath {
	if (!containsKeyTree(m.sources, src.info.file)) m else {
		fold(src.decls, 
			RuMath(m with sources = removeFromTree(m.sources, src.info.file)), 
			\acc, block -> {
				switch (block) {
					RuConst(name,__,__,__):
						RuMath(acc with 
							consts = removeFromTree(acc.consts, name),
							names = removeFromTree(acc.names, name)
						);
					RuType(name,__,__):
						RuMath(acc with 
							types = removeFromTree(acc.types, name),
							names = removeFromTree(acc.names, name)
						);
					RuRule(name,__,__,__):
						RuMath(acc with 
							rules = removeFromTree(acc.rules, name),
							names = removeFromTree(acc.names, name)
						);
					RuAxiom(name,__,__,__,__,__):
						RuMath(acc with 
							assertions = removeFromTree(acc.assertions, name),
							names = removeFromTree(acc.names, name)
						);
					RuTheorem(name,__,__,__,__,__,__,__):
						RuMath(acc with 
							assertions = removeFromTree(acc.assertions, name),
							names = removeFromTree(acc.names, name)
						);
					RuDef(name,__,__,__,__,__,__,__):
						RuMath(acc with 
							assertions = removeFromTree(acc.assertions, name),
							names = removeFromTree(acc.names, name)
						);
					RuComment(__,__): acc;
					RuTheory(name, __,__): acc; // TODO
				}
			}
		);
	}
}

ruAddSource(src : RuSource, m : RuMath) -> RuMath {
	file = src.info.file;
	fold(src.decls, 
		RuMath(m with sources = setTree(m.sources, src.info.file, src)), 
		\acc, block -> {
			switch (block) {
				RuConst(name,__,__,__):
					RuMath(acc with 
						consts = setTree(acc.consts, name, block),
						names = setTree(acc.names, name, file)
					);
				RuType(name,__,__):
					RuMath(acc with 
						types = setTree(acc.types, name, ruMakeTypeEnv(block, acc.types, file, m.conf)),
						names = setTree(acc.names, name, file)
					);
				RuRule(name, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(env): {
							RuMath(acc with 
								rules = setTree(acc.rules, name, block),
								types = setTree(acc.types, env.type.name,
									RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(name, term.type, sizeTree(vars), 0)),
											env.trie, m.conf
										)
									)
								),
								names = setTree(acc.names, name, file)
							);
						}
						None(): {
							m.conf.onError("type " + term.type + " is not found", [RuPlace(file, pos)]);
							acc
						}
					}
				RuAxiom(name,__,__,__,__,__):
					RuMath(acc with 
						assertions = setTree(acc.assertions, name, block),
						names = setTree(acc.names, name, file)
					);
				RuTheorem(name,__,__,__,__,__,__,__):
					RuMath(acc with 
						assertions = setTree(acc.assertions, name, block),
						names = setTree(acc.names, name, file)
					);
				RuDef(name,__,__,__,__,__,__,__):
					RuMath(acc with 
						assertions = setTree(acc.assertions, name, block),
						names = setTree(acc.names, name, file)
					);
				RuComment(__,__): acc;
				RuTheory(name, __,__): acc; // TODO
			}
		}
	);
}

ruAddErr2Math(math : RuMath, msg : string) -> RuMath {
	RuMath(math with conf = ruAddErr2Conf(math.conf, msg))
}

ruMath2SingleSource(math : RuMath, path : string) -> RuSource {
	file = ruRemoveExt(path, ".ru");
	RuSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			ruMathCollectSource(src, math, acc)
		).first,
		RuFileInfo(file, file + ".ru", 0.0, 0.0)
	);
}

ruMathCollectSource(src : RuSource, math : RuMath, acc : Pair<[RuBlock], Set<string>>) -> Pair<[RuBlock], Set<string>> {
	if (containsSet(acc.second, src.info.file)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.file)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.path)) {
					Some(inc_src): ruMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

ruFixLeftRecursiveRules(math : RuMath) -> RuMath {
	start = timestamp();
	fixRule = \r -> 
		if (length(r.term.expr) <= 1) r else {
			switch (r.term.expr[0]) {
				RuVar(__,__):
					RuRule(r with term = RuTerm(r.term with expr = 
						concat3([RuConstRef("(")], r.term.expr, [RuConstRef(")")])
					));
				default: r;
			}
		}
	fixSource = \s -> 
		RuSource(s with
			decls = map(s.decls, \decl -> 
				switch (decl) {
					RuRule(__,__,__,__): fixRule(decl);
					default: decl;
				}
			)
		);
	if (math.conf.verbose > 0) {
		println("ru potentially left-recursive rules are fixed" + " in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	RuMath(math with
		rules = mapTree(math.rules, fixRule),
		sources = mapTree(math.sources, fixSource)
	);
}

ruCollectMathNames(math : RuMath) -> RuMath {
	foldTree(math.sources, math, 
		\__, src, acc -> ruCollectSourceNames(src, acc)
	)
}

ruCollectSourceNames(src : RuSource, math : RuMath) -> RuMath {
	src_name = src.info.file;
	RuMath(math with names = 
		fold(src.decls, math.names, \ac, decl ->
			switch (decl) {
				RuConst(name,__,__,__):               setTree(ac, name, src_name);
				RuType(name, supers,__):
					fold(supers, setTree(ac, name, src_name), \a, super -> setTree(a, ruSuperTypeName(super, name), src_name));
				RuRule(name,__,__,__):                setTree(ac, name, src_name);
				RuAxiom(name,__,__,__,__,__):         setTree(ac, name, src_name);
				RuDef(name,__,__,__,__,__,__,__):     setTree(ac, name, src_name);
				RuTheorem(name,__,__,__,__,__,__,__): setTree(ac, name, src_name);
				RuTheory(name,__,__):                 setTree(ac, name, src_name);
				default: ac;
			}
		)
	)
}

ruCollectAllImported(name : string, math : RuMath) -> Set<RuSource> {
	ruDoCollectAllImported(ruNameSource(name, math), math, makeSet())
}

ruDoCollectAllImported(src : RuSource, math : RuMath, acc : Set<RuSource>) -> Set<RuSource> {
	if (containsSet(acc, src)) acc else {
		fold(src.imports, insertSet(acc, src), 
			\ac, imp -> ruDoCollectAllImported(lookupTreeDef(math.sources, imp.path, ruNoSource), math, ac)
		)
	}
}

ruOrderSources(math : RuMath) -> [RuSource] {
	foldTree(math.sources, Pair([], makeSet()), \__, src, acc ->
		ruDoOrderSources(src, math, acc)
	).first
}

ruDoOrderSources(src : RuSource, math : RuMath, acc : Pair<[RuSource], Set<string>>) -> Pair<[RuSource], Set<string>> {
	if (containsSet(acc.second, src.info.file)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.file)), \ac, imp ->
			ruDoOrderSources(lookupTreeDef(math.sources, imp.path, ruNoSource), math, ac)
		);
		Pair(concat(acc1.first, [src]), acc1.second);
	}
}

ruReplaceTheorem(th : RuTheorem, math : RuMath) -> RuMath {
	src = ruNameSource(th.name, math);
	updated_src = RuSource(src with decls = 
		ruReplaceArray(src.decls, ruIndexOfDecl(th.name, src), th)
	);
	RuMath(math with 
		assertions = setTree(math.assertions, th.name, th),
		sources = setTree(math.sources, src.info.file, updated_src)
	);
}

ruNameSource(name : string, math : RuMath) -> RuSource {
	lookupTreeDef(math.sources, lookupTreeDef(math.names, name, ""), ruNoSource)
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruTheorem(name : string, math : RuMath) -> RuTheorem {
	ass = lookupTreeDef(math.assertions, name, ruNoAxiom);
	switch (ass) {
		RuTheorem(__,__,__,__,__,__,__,__): ass;
		default: {
			math.conf.onError("theorem " + name + " is not found", []);
			ruNoTheorem;
		}
	}
}
