import math/uuid;
import script/funcs;
import command;

export {
	ruExec(s : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState>;
}

ruExec(script : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	script_start = timestamp();
	log_script = exists(ruScriptTasks(script), \task -> !existsTree(task.args, \arg, __ -> arg == "do_not_log_this"));
	script_src = ruScript2s(script);
	uuid = ruMakeUuid();
	if (log_script) {
		ruScriptLog("<" + uuid + "> Script started:  " + ruServerEscapeString(script_src), env.conf);
	}
	ret = ruDoExec(script, commands, onMessage, env);
	if (isNone(ret)) {
		onMessage("error at evaluation of \n" + script_src + "\n");
	}
	if (log_script) {
		ruScriptLog(
			"<" + uuid + "> Script finished: " +
			(if (isSome(ret)) "Ok " else "Fail ") + 
			"in " + d2st((timestamp() - script_start) / 1000.0, 2) + "s", env.conf
		);
	}
	ret
}

ruDoExec(script : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	switch (script) {
		ScSeq(seq):
			ruExecSeq(seq, commands, onMessage, env);
		ScAssign(var, ex): 
			ruExecAssign(var, ex, onMessage, env);
		ScIf(cond, s): 
			ruExecIf(cond, s, commands, onMessage, env);
		ScIfElse(cond, pos, neg): 
			ruExecIfElse(cond, pos, neg, commands, onMessage, env);
		ScWhile(cond, s): 
			ruExecWhile(cond, s, commands, onMessage, env);
		ScPrint(ex): 
			ruExecPrint(ex, onMessage, env);
		ScTask(comm, args): 
			ruExecTask(script, commands, onMessage, env);
	}
}

ruExecSeq(seq : [ScScript], commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	fold(seq, Some(env), \acc, s -> 
		maybeBind(acc, \ac -> ruDoExec(s, commands, onMessage, ac))
	);
}

ruExecAssign(var : string, ex : ScExp, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	maybeMap(ruEval(ex, env.vars), \val -> 
		RuState(env with vars = setTree(env.vars, var, val))
	);
}

ruExecIf(cond : ScExp, script : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	maybeBind(ruEval(cond, env.vars), \val -> 
		switch (val) {
			ValBool(c): {
				if (c) {
					ruDoExec(script, commands, onMessage, env);
				} else {
					Some(env);
				}
			}
			default: {
				onMessage("'if' condition must return boolean value " + ruScExp2s(cond));
				None();
			}
		}
	);
}

ruExecIfElse(cond : ScExp, pos : ScScript, neg : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	maybeBind(ruEval(cond, env.vars), \val -> 
		switch (val) {
			ValBool(c): {
				if (c) {
					ruDoExec(pos, commands, onMessage, env);
				} else {
					ruDoExec(neg, commands, onMessage, env);
				}
			}
			default: {
				onMessage("'if' condition must return boolean value " + ruScExp2s(cond));
				None();
			}
		}
	);
}

ruExecWhile(cond : ScExp, script : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	maybeBind(ruEval(cond, env.vars), \val ->
		switch (val) {
			ValBool(c): {
				if (c) {
					maybeBind(
						ruDoExec(script, commands, onMessage, env),
						\env1 -> ruExecWhile(cond, script, commands, onMessage, env1)
					);
				} else {
					Some(env);
				}
			}
			default: {
				onMessage("'while' condition must return boolean value " + ruScExp2s(cond));
				None();
			}
		}
	);
}

ruExecPrint(ex : ScExp, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	maybeMap(ruEval(ex, env.vars), \val -> {
		onMessage(ruValue2s(val));
		env;
	});
}

ruExecTask(task : ScTask, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	upd_conf = \e -> {
		RuState(e with 
			conf = RuConf(e.conf with 
				onMessage = onMessage,
				onError = ruMakeOnError(e.conf.opts, onMessage)
			)
		);
	}
	switch (lookupTree(commands, task.command)) {
		Some(command): {
			fold(ruPrepareTask(task, command, env.conf), Some(env),  
				\ac, t -> maybeBind(ac, \e -> {
					task_start = timestamp();
					log_task = !existsTree(t.args, \arg,__ -> arg == "do_not_log_this");
					task_src = ruTask2s(t);
					uuid = ruMakeUuid();
					if (log_task) {
						ruScriptLog("<" + uuid + "> Task started:    " + task_src + " ... ", env.conf);
					}
					ret = command.run(t, upd_conf(e));
					if (log_task) {
						ruScriptLog(
							"<" + uuid + "> Task finished:   " +
							(if (isSome(ret)) "Ok " else "Fail ") +
							"in " + d2st((timestamp() - task_start) / 1000.0, 2) + "s", env.conf
						);
					}
					ret;
				})
			);
		}
		None(): {
			onMessage("Unknown command: '" + task.command + "'");
			None();
		}
	}
}

ruPrepareTask(task : ScTask, command : RuComm, conf : RuConf) -> [ScTask] {
	induced_tasks = 
		if (containsKeyTree(task.args, "file") || conf.projectRoots == []) {
			[task];
		} else {
			map(conf.projectRoots, \root -> ScTask(task with args = setTree(task.args, "file", root)));
		}
	filtermap(induced_tasks, 
		\t -> {
			args_w_module = eitherMap(
				lookupTree(t.args, "file"), 
				\file -> {
					absolute = resolveRelativePath(file);
					w_file = setTree(t.args, "file", absolute);
					if (containsKeyTree(w_file, "module")) {
						w_file;
					} else {
						setTree(w_file, "module", ruTrimPath(absolute, conf, getFileExt(file)));
					}
				}, 
				t.args
			);
			args_w_defvals = fold(command.args, args_w_module, \acc, arg ->
				if (arg.defval == "") acc else {
					if (containsKeyTree(acc, arg.name)) acc else setTree(acc, arg.name, arg.defval)
				}
			);
			updated_args = foldTree(args_w_defvals, makeTree(), \k, v, acc -> 
				if (v != "" || k == command.defarg || command.defarg == "") setTree(acc, k, v) else setTree(acc, command.defarg, k)
			);
			updated_task = ScTask(t with args = updated_args);
			check = forall(command.args, \arg ->
				if (arg.optional || containsKeyTree(updated_task.args, arg.name)) true else {
					conf.onMessage("Obligatory argument '" + arg.name + "' of the command '" + updated_task.command + "' is missing");
					false;
				}
			);
			if (!check) None() else Some(updated_task);
		}
	);
}
