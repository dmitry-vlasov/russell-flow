import math/uuid;
import script/eval;
import script/load;
import script/run;
import comm;

export {
	ruExecScript(s : ScComm, commands : Tree<string, RuComm>, state : RuState, out : RuOut) -> RuState;
}

ruExecScript(script : ScComm, commands : Tree<string, RuComm>, state : RuState, out : RuOut) -> RuState {
	timer = ruMakeTimer();
	log_script = exists(ruScCommTasks(script), \task -> !existsTree(task.args, \arg, __ -> arg == "do_not_log_this"));
	script_src = ruScComm2s(script);
	uuid = ruMakeUuid();
	if (log_script) {
		ruScriptLog("<" + uuid + "> Script started:  " + ruServerEscapeString(script_src), state.conf);
	}
	exec_state = ruDoExecScript(script, RuExecEnv(commands, RuExecState(state, makeTree()), out, ref false));
	if (log_script) {
		ruScriptLog(
			"<" + uuid + "> Script finished: " + 
			"in " + ruTimePassed2s(timer), state.conf
		);
	}
	exec_state.global
}

RuExecEnv(
	commands : Tree<string, RuComm>,
	state : RuExecState, 
	out : RuOut,
	stop : ref bool
);

ruDoExecScript(script : ScComm, env : RuExecEnv) -> RuExecState {
	switch (script) {
		ScSeq(seq):
			ruExecSeq(seq, env);
		ScAssign(var, ex): 
			ruExecAssign(var, ex, env);
		ScLet(var, ex, scope): 
			ruExecLet(var, ex, scope, env);
		ScIf(cond, pos, neg): 
			ruExecIf(cond, pos, neg, env);
		ScWhile(cond, s): 
			ruExecWhile(cond, s, env);
		ScOutput(mode, ex): 
			ruExecOutput(mode, ex, env);
		ScTask(comm, args): 
			ruExecTask(script, env);
		ScAction(action): {
			if (action == "stop") {
				// Stop execution of a script
				env.stop := true;
				env.state;
			} else if (action == "exit") {
				// Terminate the programm
				env.stop := true;
				RuExecState(env.state with global = RuState(env.state.global with exit = true));
			} else {
				env.out.onError("Unknown action: '" + action + "', must be 'stop' or 'exit'", []);
				env.state;
			}
		}
	}
}

ruExecSeq(seq : [ScComm], env : RuExecEnv) -> RuExecState {
	fold(seq, env.state, \acc, script -> 
		if (^(env.stop)) acc else 
		ruDoExecScript(script, RuExecEnv(env with state = acc))
	);
}

ruExecAssign(var : string, ex : ScExp, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		val = switch (ex) {
			ScLambda(__,__): {
				fn = ref flow(0);
				closure = RuExecState(env.state with 
					local = setTree(env.state.local, var, fn)
				);
				fn := ruEval(ex, closure, env.out);
				^fn
			}
			default: ruEval(ex, env.state, env.out);
		}
		if (runtimeValueType(val) == "RuRuntimeError") {
			env.out.onMessage("at assigning '" + ruScExp2s(ex) + "' to '" + var + "' met " + ruScValue2s(val));
		}
		/*switch (val) {
			ScError(errs): {
				env.out.onMessage("at assigning '" + ruScExp2s(ex) + "' to '" + var + "' met " + ruScValue2s(val));
			}
			default: { }
		}*/
		if (containsKeyTree(env.state.local, var)) {
			RuExecState(env.state with 
				local = setTree(env.state.local, var, val)
			);
		} else {
			RuExecState(env.state with 
				global = RuState(env.state.global with 
					vars = setTree(env.state.global.vars, var, val)
				)
			);
		}
	}
}

ruExecLet(var : string, ex : ScExp, scope : ScComm, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		val = ruEval(ex, env.state, env.out);
		if (runtimeValueType(val) == "RuRuntimeError") {
			env.out.onMessage("at assigning '" + ruScExp2s(ex) + "' to '" + var + "' met " + ruScValue2s(val));
		}
		ruDoExecScript(scope, RuExecEnv(env with 
			state = RuExecState(env.state with 
				local = setTree(env.state.local, var, val)
			)
		));
	}
}

ruExecIf(cond : ScExp, pos : ScComm, mneg : Maybe<ScComm>, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		val = ruEval(cond, env.state, env.out);
		val_type = runtimeValueType(val);
		if (val_type == "bool") {
			c = cast(val : flow -> bool);
			if (c) {
				ruDoExecScript(pos, env);
			} else {
				switch (mneg) {
					Some(neg): ruDoExecScript(neg, env);
					None(): env.state;
				}
			}
		} else if (val_type == "error") {
			env.out.onMessage("at computing 'if' condition '" + ruScExp2s(cond) + "' met " + ruScValue2s(val));
			env.state;
		} else {
			env.out.onMessage("'if' condition '" + ruScExp2s(cond) + "' must return boolean value, while returned " + ruScValue2s(val));
			env.state;
		}
	}
}

ruExecWhile(cond : ScExp, script : ScComm, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		val = ruEval(cond, env.state, env.out);
		val_type = runtimeValueType(val);
		if (val_type == "bool") {
			c = cast(val : flow -> bool);
			if (c) {
				state = ruDoExecScript(script, env);
				ruExecWhile(cond, script, RuExecEnv(env with state = state));
			} else {
				env.state;
			}
		} else if (val_type == "error") {
			env.out.onMessage("at computing 'while' condition '" + ruScExp2s(cond) + "' met " + ruScValue2s(val));
			env.state;
		} else {
			env.out.onMessage("'while' condition '" + ruScExp2s(cond) + "' must return boolean value, while returned " + ruScValue2s(val));
			env.state;
		}
	}
}

ruExecPrint(ex : ScExp, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		val = ruEval(ex, env.state, env.out);
		msg = ruApplyScriptVars(ruScValue2s(val), ruExecStateVars(env.state), env.state.global.conf);
		env.out.onMessage(strReplaces(msg, ["\\n", "\n", "\\t", "\t"]));
		env.state;
	}
}

ruExecOutput(mode : string, ex : ScExp, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		val = ruEval(ex, env.state, env.out);
		msg = unescapeStr(ruApplyScriptVars(ruScValue2s(val), ruExecStateVars(env.state), env.state.global.conf));
		if (mode == "print") {
			env.out.onMessage(msg);
		} else if (mode == "output") {
			env.out.onData(msg);
		} else {
			env.out.onError("unknown output mode: '" + mode + "', must be 'print' or 'output'. Message:\n" + msg, []);
		}
		env.state;
	}
}

ruExecTask(task : ScTask, env : RuExecEnv) -> RuExecState {
	if (^(env.stop)) env.state else {
		state = env.state.global;
		new_state = switch (lookupTree(env.commands, task.command)) {
			Some(command): {
				ruRun(
					RuUnit(task, state, env.out), 
					\unit -> either(command.run(unit), unit.state), 
					command.info
				);
			}
			None(): {
				switch (ruLoadScript(task.command, RuEnv(env.state.global.conf, env.out))) {
					Some(src): {
						ruRun(
							RuUnit(task, state, env.out), 
							\unit -> ruExecScript(src.command, env.commands, unit.state, unit.out), 
							src.commInfo
						);
					}
					None(): {
						env.out.onMessage("Unknown command or script: '" + task.command + "' in:\n" + ruTask2s(task));
						state;
					}
				}
			}
		}
		RuExecState(env.state with global = new_state);
	}
}
