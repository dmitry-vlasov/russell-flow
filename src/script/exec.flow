import math/uuid;
import script/funcs;
import script/load;
import script/util;
import command;

export {
	ruExec(s : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState>;
}

ruExec(script : ScScript, commands : Tree<string, RuComm>, onMessage : (string) -> void, env : RuState) -> Maybe<RuState> {
	timer = ruMakeTimer();
	log_script = exists(ruScriptTasks(script), \task -> !existsTree(task.args, \arg, __ -> arg == "do_not_log_this"));
	script_src = ruScript2s(script);
	uuid = ruMakeUuid();
	if (log_script) {
		ruScriptLog("<" + uuid + "> Script started:  " + ruServerEscapeString(script_src), env.conf);
	}
	err = ref false;
	ret = ruDoExec(script, RuExecEnv(commands, onMessage, env, err));
	if (log_script) {
		ruScriptLog(
			"<" + uuid + "> Script finished: " +
			(if (isSome(ret)) "Ok " else "Fail ") + 
			"in " + ruTimePassed2s(timer), env.conf
		);
	}
	ret
}

RuExecEnv(
	commands : Tree<string, RuComm>, 
	onMessage : (string) -> void, 
	state : RuState, 
	err : ref bool
);

ruDoExec(script : ScScript, env : RuExecEnv) -> Maybe<RuState> {
	ret = switch (script) {
		ScSeq(seq):
			ruExecSeq(seq, env);
		ScAssign(var, ex): 
			ruExecAssign(var, ex, env);
		ScIf(cond, s): 
			ruExecIf(cond, s, env);
		ScIfElse(cond, pos, neg): 
			ruExecIfElse(cond, pos, neg, env);
		ScWhile(cond, s): 
			ruExecWhile(cond, s, env);
		ScPrint(ex): 
			ruExecPrint(ex, env);
		ScTask(comm, args): 
			ruExecTask(script, env);
		ScExit(): 
			None();
	}
	if (isNone(ret) && !^(env.err)) {
		if (script != ScExit()) {
			env.onMessage("error at evaluation of <<<\n" + ruScript2s(script) + "\n>>>");
		}
		env.err := true;
	}
	ret;
}

ruExecSeq(seq : [ScScript], env : RuExecEnv) -> Maybe<RuState> {
	fold(seq, Some(env.state), \acc, s -> 
		maybeBind(acc, \state -> ruDoExec(s, RuExecEnv(env with state = state)))
	);
}

ruExecAssign(var : string, ex : ScExp, env : RuExecEnv) -> Maybe<RuState> {
	maybeMap(ruEval(ex, env.state.vars, env.state.conf), \val -> 
		RuState(env.state with vars = setTree(env.state.vars, var, val))
	);
}

ruExecIf(cond : ScExp, script : ScScript, env : RuExecEnv) -> Maybe<RuState> {
	maybeBind(ruEval(cond, env.state.vars, env.state.conf), \val -> 
		switch (val) {
			ValBool(c): {
				if (c) {
					ruDoExec(script, env);
				} else {
					Some(env.state);
				}
			}
			default: {
				env.onMessage("'if' condition must return boolean value " + ruScExp2s(cond));
				None();
			}
		}
	);
}

ruExecIfElse(cond : ScExp, pos : ScScript, neg : ScScript, env : RuExecEnv) -> Maybe<RuState> {
	maybeBind(ruEval(cond, env.state.vars, env.state.conf), \val -> 
		switch (val) {
			ValBool(c): {
				if (c) {
					ruDoExec(pos, env);
				} else {
					ruDoExec(neg, env);
				}
			}
			default: {
				env.onMessage("'if' condition must return boolean value " + ruScExp2s(cond));
				None();
			}
		}
	);
}

ruExecWhile(cond : ScExp, script : ScScript, env : RuExecEnv) -> Maybe<RuState> {
	maybeBind(ruEval(cond, env.state.vars, env.state.conf), \val ->
		switch (val) {
			ValBool(c): {
				if (c) {
					maybeBind(
						ruDoExec(script, env),
						\state -> ruExecWhile(cond, script, RuExecEnv(env with state = state))
					);
				} else {
					Some(env.state);
				}
			}
			default: {
				env.onMessage("'while' condition must return boolean value " + ruScExp2s(cond));
				None();
			}
		}
	);
}

ruExecPrint(ex : ScExp, env : RuExecEnv) -> Maybe<RuState> {
	maybeMap(ruEval(ex, env.state.vars, env.state.conf), \val -> {
		env.onMessage(ruApplyScriptVars(ruValue2s(val), env.state.vars, env.state.conf));
		env.state;
	});
}

ruExecTask(task : ScTask, env : RuExecEnv) -> Maybe<RuState> {
	state = env.state;
	conf = state.conf;
	switch (lookupTree(env.commands, task.command)) {
		Some(command): {
			t0 = ruAddCommandDefaults(task, command.descr, conf);
			fold(ruMakeInducedTasks(t0, command.descr, env.state.conf), Some(env.state),  \ac, t1 -> 
				maybeBind(ac, \s -> {
					t = ruEvalTaskArgs(t1, s);
					if (!ruCheckCommandArgs(t, command.descr, conf)) None() else {
						timer = ruMakeTimer();
						log_task = !existsTree(t.args, \arg,__ -> arg == "do_not_log_this");
						task_src = ruTask2s(t);
						uuid = ruMakeUuid();
						t_env = ruUpdateTaskConf(s, lookupTreeDef(t.args, "file", ""), env.onMessage);
						if (log_task) {
							ruScriptLog("<" + uuid + "> Task started:    " + task_src + " ... ", state.conf);
						}
						ret = command.run(t, t_env);
						if (log_task) {
							ruScriptLog(
								"<" + uuid + "> Task finished:   " +
								(if (isSome(ret)) "Ok " else "Fail ") +
								"in " + ruTimePassed2s(timer), state.conf
							);
						}
						ret;
					}
				})
			);
		}
		None(): {
			switch (ruLoadScript(task.command, env.state.conf)) {
				Some(src): {
					fold([task] /*ruMakeInducedTasks(task, env.state.conf)*/, Some(env.state),  
						\ac, t0 -> maybeBind(ac, \s -> {
							t = ruEvalTaskArgs(t0, s);
							s1 = RuState(s with 
								vars = mergeTree(env.state.vars, mapTree(t.args, \str -> 
									ValString(ruApplyScriptVars(str, s.vars, s.conf))
								))
							);
							t_env = ruUpdateTaskConf(s1, lookupTreeDef(t.args, "file", ""), env.onMessage);
							ruExec(src.script, env.commands, env.onMessage, t_env);
						})
					);
				}
				None(): {
					env.onMessage("Unknown command or script: '" + task.command + "'");
					None();
				}
			}
		}
	}
}
