import comm;

import script/funcs/boolean;
import script/funcs/compare;
import script/funcs/convert;
import script/funcs/numeric;
import script/funcs/time;
import script/funcs/util;

export {
	ruEval(ex : ScExp, state : RuState, out : RuOut) -> ScValue;
}

ru_script_fns : ref Maybe<Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	onlyOnce(ru_script_fns, 
		\-> values2tree(concatA([
			ruScriptBooleanFuncs(),
			ruScriptCompareFuncs(),
			ruScriptConvertFuncs(),
			ruScriptNumericFuncs(),
			ruScriptTimeFuncs(),
			ruScriptUtilFuncs()
		]), \sf -> sf.name)
	);
}

ruEval(ex : ScExp, state : RuState, out : RuOut) -> ScValue {
	conf = state.conf;
	switch (ex) {
		ScInfixOp(e, args): {
			vals = map(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state, out)
			);
			func = lookupTreeDef(ruScriptFns(), args[0].op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs(vals),
				if (func.name != "") [] else ["infix operator: '" + args[0].op + "'' is not found"]
			);
			if (length(errs) > 0) {
				scErrorVal(errs);
			} else {
				func.fn(vals, state, out);
			}
		}
		ScPrefixOp(op, e): {
			val = ruEval(e, state, out);
			func = lookupTreeDef(ruScriptFns(), op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs([val]),
				if (func.name != "") [] else ["prefix operator: '" + op + "'' is not found"]
			);
			if (length(errs) > 0) {
				scErrorVal(errs);
			} else {
				func.fn([val], state, out);
			}
		}
		ScCall(fn, args): {
			vals = map(args, \arg -> ruEval(arg, state, out));
			func = lookupTreeDef(ruScriptFns(), fn, ruNoScriptFn);
			errs = concat(
				ruErrorArgs(vals),
				if (func.name != "") [] else ["function: '" + fn + "'' is not found"]
			);
			if (length(errs) > 0) {
				scErrorVal(errs);
			} else {
				func.fn(vals, state, out);
			}
		}
		ScIndex(e, i): {
			e_val = ruEval(e, state, out);
			i_val = ruEval(i, state, out);
			errs = ruErrorArgs([e_val, i_val]);
			e_type = scTypeGen(e_val.type);
			if (e_type == "map") {
				mapping = cast(e_val.val : flow -> Tree<flow, flow>);
				switch (lookupTree(mapping, i_val.val)) {
					Some(v): ScValue(v, scUnwrapMapVal(e_val.type));
					None():  scUndefVal;
				}
			} else if (e_type == "array") {
				arr = cast(e_val.val : flow -> [flow]);
				if (scTypeGen(i_val.type) == "int") {
					ind = cast(i_val.val : flow -> int);
					ScValue(arr[ind], scUnwrapArrayType(e_val.type));
				} else {
					scUndefVal;
				}
			} else {
				err = "first argument of index operator must be a map or array, got: " + scType2s(e_val.type);
				ScValue(concat(errs, [err]), scErrorType)
			}
			/*switch (e_val) {
				ScMap(mapping): {
					switch (lookupTree(mapping, i_val)) {
						Some(v): v;
						None():  ScUndef();
					}
				}
				ScArray(arr): {
					switch (i_val) {
						ScInt(ind): {
							if (0 <= ind && ind < length(arr)) {
								arr[ind];
							} else {
								ScUndef();
							}
						}
						default: {
							 ScError(concat(errs, ["second argument of array index operator must be an integer value, but got: " + ruScValue2s(i_val)]));
						}
					}
				}
				default: ScError(concat(errs, ["first argument of index operator must be a map or array"]));
			}*/
		}
		ScLambda(args, body): {
			// ScValue(val : flow, type : ScType);
			if (length(args) == 0) {
				func = \ -> ruEval(body, state, out);
			}
			vals = map(args, \arg -> ruEval(arg, state, out));
			func = lookupTreeDef(ruScriptFns(), fn, ruNoScriptFn);
			errs = concat(
				ruErrorArgs(vals),
				if (func.name != "") [] else ["function: '" + fn + "'' is not found"]
			);
			if (length(errs) > 0) {
				scErrorVal(errs);
			} else {
				func.fn(vals, state, out);
			}
		}
		ScUndefConst():     scUndefVal;
		ScBoolConst(val):   scBoolVal(val);
		ScIntConst(val):    scIntVal(val);
		ScDoubleConst(val): scDoubleVal(val);
		ScStringConst(val): scStringVal(val);
		ScVar(var):         ruEvalVar(var, state, out);
	}
}

ruEvalVar(var : string, state : RuState, out : RuOut) -> ScValue {
	conf = state.conf;
	switch (lookupTree(state.vars, var)) {
		Some(val): val;
		None(): {
			if (startsWith(var, "conf.")) {
				opt = strRight(var, 5);
				switch (lookupTree(conf.opts, opt)) {
					Some(val): scStringVal(val);
					None(): {
						if (opt == "working-dir") {
							scStringVal(conf.workingDir);
						} else if (opt == "verbose") {
							scIntVal(conf.verbose);
						} else if (opt == "import-roots") {
							scStringArrayVal(conf.importRoots);
						} else if (opt == "project-roots") {
							scStringArrayVal(conf.projectRoots);
						} else {
							scUndefVal;
						}
					}
				}
			} else if (var == "sources") {
				ScValue(
					foldTree(state.ru, makeTree(), \id, src, acc -> 
						setTree(acc, id2s(id), src)
					),
					scMapType(scStringType, scConstType("RuSource"))
				);
			} /*else if (var == "math") {
				math = ruMathFromSources(state.ru, RuEnv(conf, out));
				ScValue(pairs2tree([
					Pair(ScString("sources"), ScMap(foldTree(math.sources, makeTree(), \id, src, acc -> 
						setTree(acc, ScString(id2s(id)), ScData("RuSource", src))
					))),
					Pair(ScString("consts"), ScMap(foldTree(math.decls.lang.consts, makeTree(), \id, const, acc -> 
						setTree(acc, ScString(id2s(id)), ScData("RuConst", const))
					))),
					Pair(ScString("types"), ScMap(foldTree(math.decls.lang.types, makeTree(), \id, type, acc -> 
						setTree(acc, ScString(id2s(id)), ScData("RuType", type))
					))),
					Pair(ScString("rules"), ScMap(foldTree(math.decls.lang.rules, makeTree(), \id, rule, acc -> 
						setTree(acc, ScString(id2s(id)), ScData("RuRule", rule))
					))),
					Pair(ScString("assertions"), ScMap(foldTree(math.decls.assertions, makeTree(), \id, assertion, acc -> 
						setTree(acc, ScString(id2s(id)), ScData("RuAssertion", assertion))
					))),
				]));
			} */ else {
				scUndefVal;
			}
		}
	}
}
