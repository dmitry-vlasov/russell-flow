import ds/tree;
import base/util/timer;
import base/conf;
import script/value;
import script/script;

import script/funcs/boolean;
import script/funcs/compare;
import script/funcs/numeric;
import script/funcs/time;
import script/funcs/util;

export {
	ruEval(ex : ScExp, state : Tree<string, ValValue>, conf : RuConf) -> Maybe<ValValue>;
}

ru_script_fns : ref Maybe< Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	init_script_fns = \-> pairs2tree(concatA([
		ruScriptBooleanFuncs(),
		ruScriptCompareFuncs(),
		ruScriptNumericFuncs(),
		ruScriptTimeFuncs(),
		ruScriptUtilFuncs()
	]));
	onlyOnce(ru_script_fns, init_script_fns);
}

ruEval(ex : ScExp, state : Tree<string, ValValue>, conf : RuConf) -> Maybe<ValValue> {
	switch (ex) {
		ScInfixOp(e, args): {
			vals = filtermap(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state, conf)
			);
			if (length(vals) != length(args) + 1) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), args[0].op),
					\func -> func.fn(vals, conf)
				);
			}
		}
		ScPrefixOp(op, e): {
			maybeBind2(\func, val -> func.fn([val], conf))
			(
				lookupTree(ruScriptFns(), op),
				ruEval(e, state, conf)
			);
		}
		ScFunc(fn, args): {
			vals = filtermap(args, \arg -> ruEval(arg, state, conf));
			if (length(vals) != length(args)) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), fn),
					\func -> func.fn(vals, conf)
				);
			}
		}
		ScIndex(e, i): {
			maybeBind2(\ev, val -> 
				switch (ev) {
					ValMap(mapping): {
						key = ruValue2s(val);
						switch (lookupTree(mapping, key)) {
							Some(v): Some(v);
							None():  Some(ValUndef());
						}
					}
					ValArray(arr): {
						switch (val) {
							ValInt(ind): {
								if (0 <= ind && ind < length(arr)) {
									Some(arr[ind]);
								} else {
									Some(ValUndef());
								}
							}
							default: Some(ValUndef());
						}
					}
					default: None();
				}
			)(ruEval(e, state, conf), ruEval(i, state, conf));
		}
		ScUndefConst():     Some(ValUndef());
		ScBoolConst(val):   Some(ValBool(val));
		ScIntConst(val):    Some(ValInt(val));
		ScDoubleConst(val): Some(ValDouble(val));
		ScStringConst(val): Some(ValString(val));
		ScVar(var): {
			switch (lookupTree(state, var)) {
				Some(val): Some(val);
				None(): {
					switch (lookupTree(conf.opts, var)) {
						Some(val): Some(ValString(val));
						None(): {
							if (var == "working-dir") {
								Some(ValString(conf.workingDir));
							} else if (var == "verbose") {
								Some(ValInt(conf.verbose));
							} else if (var == "import-roots") {
								Some(ValArray(map(conf.importRoots, \r -> ValString(r))));
							} else if (var == "project-roots") {
								Some(ValArray(map(conf.projectRoots, \r -> ValString(r))));
							} else {
								Some(ValUndef());
							}
						}
					}
				}
			}
		}
	}
}
