import comm;

import script/funcs/boolean;
import script/funcs/compare;
import script/funcs/numeric;
import script/funcs/time;
import script/funcs/util;

export {
	ruEval(ex : ScExp, state : RuState) -> Maybe<ValValue>;
}

ru_script_fns : ref Maybe<Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	onlyOnce(ru_script_fns, 
		\-> pairs2tree(concatA([
			ruScriptBooleanFuncs(),
			ruScriptCompareFuncs(),
			ruScriptNumericFuncs(),
			ruScriptTimeFuncs(),
			ruScriptUtilFuncs()
		]))
	);
}

ruEval(ex : ScExp, state : RuState) -> Maybe<ValValue> {
	conf = state.conf;
	switch (ex) {
		ScInfixOp(e, args): {
			vals = filtermap(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state)
			);
			if (length(vals) != length(args) + 1) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), args[0].op),
					\func -> func.fn(vals, conf)
				);
			}
		}
		ScPrefixOp(op, e): {
			maybeBind2(\func, val -> func.fn([val], conf))
			(
				lookupTree(ruScriptFns(), op),
				ruEval(e, state)
			);
		}
		ScFunc(fn, args): {
			vals = filtermap(args, \arg -> ruEval(arg, state));
			if (length(vals) != length(args)) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), fn),
					\func -> func.fn(vals, conf)
				);
			}
		}
		ScIndex(e, i): {
			maybeBind2(\ev, val -> 
				switch (ev) {
					ValMap(mapping): {
						key = ruValue2s(val);
						switch (lookupTree(mapping, key)) {
							Some(v): Some(v);
							None():  Some(ValUndef());
						}
					}
					ValArray(arr): {
						switch (val) {
							ValInt(ind): {
								if (0 <= ind && ind < length(arr)) {
									Some(arr[ind]);
								} else {
									Some(ValUndef());
								}
							}
							default: Some(ValUndef());
						}
					}
					default: None();
				}
			)(ruEval(e, state), ruEval(i, state));
		}
		ScUndefConst():     Some(ValUndef());
		ScBoolConst(val):   Some(ValBool(val));
		ScIntConst(val):    Some(ValInt(val));
		ScDoubleConst(val): Some(ValDouble(val));
		ScStringConst(val): Some(ValString(val));
		ScVar(var): {
			switch (lookupTree(state.vars, var)) {
				Some(val): Some(val);
				None(): {
					if (startsWith(var, "conf.")) {
						opt = strRight(var, 5);
						switch (lookupTree(conf.opts, opt)) {
							Some(val): Some(ValString(val));
							None(): {
								if (opt == "working-dir") {
									Some(ValString(conf.workingDir));
								} else if (opt == "verbose") {
									Some(ValInt(conf.verbose));
								} else if (opt == "import-roots") {
									Some(ValArray(map(conf.importRoots, \r -> ValString(r))));
								} else if (opt == "project-roots") {
									Some(ValArray(map(conf.projectRoots, \r -> ValString(r))));
								} else {
									Some(ValUndef());
								}
							}
						}
					} else {
						Some(ValUndef());
					}
				}
			}
		}
	}
}
