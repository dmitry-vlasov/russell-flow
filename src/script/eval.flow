import comm;

import script/funcs/boolean;
import script/funcs/compare;
import script/funcs/convert;
import script/funcs/numeric;
import script/funcs/time;
import script/funcs/util;
import base/reflect;

export {
	ruEval(ex : ScExp, state : RuExecState, out : RuOut) -> flow;
}

ru_script_fns : ref Maybe<Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	onlyOnce(ru_script_fns, 
		\-> values2tree(concatA([
			ruScriptBooleanFuncs(),
			ruScriptCompareFuncs(),
			ruScriptConvertFuncs(),
			ruScriptNumericFuncs(),
			ruScriptTimeFuncs(),
			ruScriptUtilFuncs()
		]), \sf -> sf.name)
	);
}

ruEval(ex : ScExp, state : RuExecState, out : RuOut) -> flow {
	conf = state.global.conf;
	switch (ex) {
		ScInfixOp(e, args): {
			vals = map(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state, out)
			);
			func = lookupTreeDef(ruScriptFns(), args[0].op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs(vals),
				if (func.name != "") [] else ["infix operator: '" + args[0].op + "'' is not found"]
			);
			if (length(errs) > 0) {
				flow(RuRuntimeError(errs));
			} else {
				func.fn(vals, state, out);
			}
		}
		ScPrefixOp(op, e): {
			val = ruEval(e, state, out);
			func = lookupTreeDef(ruScriptFns(), op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs([val]),
				if (func.name != "") [] else ["prefix operator: '" + op + "'' is not found"]
			);
			if (length(errs) > 0) {
				RuRuntimeError(errs);
			} else {
				func.fn([val], state, out);
			}
		}
		ScCall(fn, args): {
			fv = ruEval(fn, state, out);
			argsv = map(args, \arg -> ruEval(arg, state, out));
			if (length(ruErrorArgs(argsv)) > 0) {
				RuRuntimeError(ruErrorArgs(argsv));
			} else {
				fn_type = runtimeValueType(fv);
				if (fn_type == "ScriptFn") {
					func = cast(fv : flow -> ScriptFn);
					func.fn(argsv, state, out);
				} else if (fn_type == "function") {
					ruEvalCall(fv, argsv);
				} else {
					RuRuntimeError(["Calling non-function:\n" + toString(fv) + "\nin:\n" + ruScExp2s(ex)]);
				}
			}
		}
		ScCond(cond, pos, neg): {
			cond_val = ruEval(cond, state, out);
			if (cast(cond_val : flow -> bool)) {
				ruEval(pos, state, out)
			} else {
				ruEval(neg, state, out)
			}
		}
		ScIndex(e, i): {
			e_val = ruEval(e, state, out);
			i_val = ruEval(i, state, out);
			errs = ruErrorArgs([e_val, i_val]);
			e_type = runtimeValueType(e_val);
			if (e_type == "TreeNode" || e_type == "TreeEmpty") {
				mapping = cast(e_val : flow -> Tree<flow, flow>);
				lookupTreeDef(mapping, i_val, RuUndefVal());
			} else if (e_type == "array") {
				arr = cast(e_val : flow -> [flow]);
				if (runtimeValueType(i_val) == "int") {
					ind = cast(i_val : flow -> int);
					if (0 <= ind && ind < length(arr)) {
						arr[ind];
					} else {
						err = "index " + i2s(ind) + " " + if (ind < 0) "is negative" else " is out of bounds: " + i2s(length(arr));
						RuRuntimeError(concat(errs, [err]))
					}
				} else {
					RuUndefVal();
				}
			} else {
				err = "first argument of index operator must be a map or array, got: " + runtimeValueType(e_val);
				RuRuntimeError(concat(errs, [err]))
			}
		}
		ScField(e, field): {
			e_val = ruEval(e, state, out);
			struct_name = extractStructName(e_val);
			if (struct_name == "") {
				RuRuntimeError(["Accessing field of not a struct:\n" + ruScValue2s(e_val)]);
			} else {
				fields = structFieldNames(struct_name);
				i = elemIndex(fields, field, -1);
				if (i != -1) {
					struct_args = extractStructArguments(e_val);
					struct_args[i];
				} else {
					RuRuntimeError(["Unknow field: '" + field + "' of struct '" + struct_name + "'"]);
				}
			}
		}
		ScStruct(name, args): {
			if (isStructName(name)) {
				arg_vals = map(args, \arg -> ruEval(arg, state, out));
				makeStructValue(name, arg_vals, IllegalStruct());
			} else {
				RuRuntimeError(["Creating non-struct: " + name + "\nin:\n" + ruScExp2s(ex)]);
			}
		}
		ScLambda(args, body): {
			closure = foldSet(ruScExpVars(makeSet(), ex), makeTree(), \acc, var -> 
				switch (lookupTree(state.local, var)) {
					Some(val): setTree(acc, var, val);
					None(): {
						switch (lookupTree(state.global.vars, var)) {
							Some(val): setTree(acc, var, val);
							None(): {
								acc;
							}
						}
					}
				}
			);
			ruEvalLambda(args, body, closure, state, out);
		}
		ScArray(arr): {
			map(arr, \x -> ruEval(x, state, out));
		}
		ScMap(pairs): {
			pairs2tree(
				map(pairs, \p -> 
					Pair(ruEval(p.first, state, out), ruEval(p.second, state, out))
				)
			);
		}
		ScUndefConst():     RuUndefVal();
		ScBoolConst(val):   val;
		ScIntConst(val):    val;
		ScDoubleConst(val): val;
		ScStringConst(val): val;
		ScVar(var):         ruEvalVar(var, state, out);
	}
}

ruEvalCall(fv : flow, argsv : [flow]) -> flow {
	arity = extractFuncArity(fv);
	if (arity == 0) {
		cast(fv : flow -> (() -> flow))();
	} else if (arity == 1) {
		cast(fv : flow -> ((flow) -> flow))(argsv[0]);
	} else if (arity == 2) {
		cast(fv : flow -> ((flow, flow) -> flow))(argsv[0], argsv[1]);
	} else if (arity == 3) {
		cast(fv : flow -> ((flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2]);
	} else if (arity == 4) {
		cast(fv : flow -> ((flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3]);
	} else if (arity == 5) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4]);
	} else if (arity == 6) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5]);
	} else if (arity == 7) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6]);
	} else if (arity == 8) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7]);
	} else if (arity == 9) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8]);
	} else if (arity == 10) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8], argsv[9]);
	} else if (arity == 11) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8], argsv[9], argsv[10]);
	} else if (arity == 12) {
		cast(fv : flow -> ((flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow, flow) -> flow))(argsv[0], argsv[1], argsv[2], argsv[3], argsv[4], argsv[5], argsv[6], argsv[7], argsv[8], argsv[9], argsv[10], argsv[11]);
	} else {
		// TODO: add more arities
		RuRuntimeError(["unsupported arity " + i2s(arity)]);
	}
}

ruEvalLambda(
	vs : [ScVar], body : ScExp,
	closure : Tree<string, flow>,
	state : RuExecState, out : RuOut
) -> flow {
	vars = map(vs, \v -> v.var);
	arity = length(vars);
	if (arity == 0) {
		flow(\ -> {
			call_state = RuExecState(state with local = closure);
			ruEval(body, call_state, out);
		});
	} else if (arity == 1) {
		flow(\a0 -> {
			call_state = RuExecState(state with 
				local = setTree(closure, vars[0], a0)
			);
			ruEval(body, call_state, out);
		});
	} else if (arity == 2) {
		flow(\a0, a1 -> {
			call_state = RuExecState(state with 
				local = setTree(setTree(closure, vars[0], a0), vars[1], a1)
			);
			ruEval(body, call_state, out);
		});
	} else if (arity == 3) {
		flow(\a0, a1, a2 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 4) {
		flow(\a0, a1, a2, a3 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 5) {
		flow(\a0, a1, a2, a3, a4 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 6) {
		flow(\a0, a1, a2, a3, a4, a5 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 7) {
		flow(\a0, a1, a2, a3, a4, a5, a6 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5),
					Pair(vars[6], a6)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 8) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5),
					Pair(vars[6], a6),
					Pair(vars[7], a7)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 9) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5),
					Pair(vars[6], a6),
					Pair(vars[7], a7),
					Pair(vars[8], a8)
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 10) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5),
					Pair(vars[6], a6),
					Pair(vars[7], a7),
					Pair(vars[8], a8),
					Pair(vars[9], a9),
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 11) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5),
					Pair(vars[6], a6),
					Pair(vars[7], a7),
					Pair(vars[8], a8),
					Pair(vars[9], a9),
					Pair(vars[10], a10),
				])
			));
			ruEval(body, call_state, out);
		});
	} else if (arity == 12) {
		flow(\a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 -> {
			call_state = RuExecState(state with 
				local = mergeTree(closure, pairs2tree([
					Pair(vars[0], a0), 
					Pair(vars[1], a1),
					Pair(vars[2], a2),
					Pair(vars[3], a3),
					Pair(vars[4], a4),
					Pair(vars[5], a5),
					Pair(vars[6], a6),
					Pair(vars[7], a7),
					Pair(vars[8], a8),
					Pair(vars[9], a9),
					Pair(vars[10], a10),
					Pair(vars[11], a11),
				])
			));
			ruEval(body, call_state, out);
		});
	} else {
		RuRuntimeError(["unsupproted arity: " + i2s(arity) + " for lambda\n" + ruScValue2s(ScLambda(vs, body))]);
	}
}


ruEvalVar(var : string, state : RuExecState, out : RuOut) -> flow {
	conf = state.global.conf;
	switch (lookupTree(state.local, var)) {
		Some(val): val;
		None(): {
			switch (lookupTree(state.global.vars, var)) {
				Some(val): val;
				None(): {
					if (var == "conf") {
						flow(conf)
					} else if (var == "state") {
						flow(state.global);
					} else {
						switch (lookupTree(ruScriptFns(), var)) {
							Some(fn): {
								fn;
							}
							None(): {
								if (hasRuntimeFunction(var)) {
									getRuntimeFunction(var);
								} else {
									flow(RuUndefVal());
								}
							}
						}
					}
				}
			}
		}
	}
}
