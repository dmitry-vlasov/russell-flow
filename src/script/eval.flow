import comm;

import script/funcs/boolean;
import script/funcs/compare;
import script/funcs/convert;
import script/funcs/numeric;
import script/funcs/time;
import script/funcs/util;
import base/reflect;

export {
	ruEval(ex : ScExp, state : RuExecState, out : RuOut) -> flow;
}

ru_script_fns : ref Maybe<Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	onlyOnce(ru_script_fns, 
		\-> values2tree(concatA([
			ruScriptBooleanFuncs(),
			ruScriptCompareFuncs(),
			ruScriptConvertFuncs(),
			ruScriptNumericFuncs(),
			ruScriptTimeFuncs(),
			ruScriptUtilFuncs()
		]), \sf -> sf.name)
	);
}

ruEval(ex : ScExp, state : RuExecState, out : RuOut) -> flow {
	conf = state.global.conf;
	switch (ex) {
		ScInfixOp(e, args): {
			vals = map(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state, out)
			);
			func = lookupTreeDef(ruScriptFns(), args[0].op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs(vals),
				if (func.name != "") [] else ["infix operator: '" + args[0].op + "'' is not found"]
			);
			if (length(errs) > 0) {
				flow(RuRuntimeError(errs));
			} else {
				func.fn(vals, state, out);
			}
		}
		ScPrefixOp(op, e): {
			val = ruEval(e, state, out);
			func = lookupTreeDef(ruScriptFns(), op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs([val]),
				if (func.name != "") [] else ["prefix operator: '" + op + "'' is not found"]
			);
			if (length(errs) > 0) {
				RuRuntimeError(errs);
			} else {
				func.fn([val], state, out);
			}
		}
		ScCall(fn, args): {
			fn_val = ruEval(fn, state, out);
			vals = map(args, \arg -> ruEval(arg, state, out));
			if (length(ruErrorArgs(vals)) > 0) {
				RuRuntimeError(ruErrorArgs(vals));
			} else {
				if (runtimeValueType(fn_val.type) != "func") {
					RuRuntimeError(["Calling non-function:\n" + toString(fn_val) + "\nin:\n" + ruScExp2s(ex)]);
				} else {
					func = cast(fn_val.val : flow -> ScriptFn);
					func.fn(vals, state, out);
				}
			}
		}
		ScCond(cond, pos, neg): {
			cond_val = ruEval(cond, state, out);
			if (cast(cond_val.val : flow -> bool)) {
				ruEval(pos, state, out)
			} else {
				ruEval(neg, state, out)
			}
		}
		ScIndex(e, i): {
			e_val = ruEval(e, state, out);
			i_val = ruEval(i, state, out);
			errs = ruErrorArgs([e_val, i_val]);
			e_type = runtimeValueType(e_val);
			if (e_type == "Tree") {
				mapping = cast(e_val.val : flow -> Tree<flow, flow>);
				lookupTreeDef(mapping, i_val, RuUndefVal());
			} else if (e_type == "array") {
				arr = cast(e_val : flow -> [flow]);
				if (runtimeValueType(i_val) == "int") {
					ind = cast(i_val : flow -> int);
					if (0 <= ind && ind < length(arr)) {
						arr[ind];
					} else {
						err = "index " + i2s(ind) + " " + if (ind < 0) "is negative" else " is out of bounds: " + i2s(length(arr));
						RuRuntimeError(concat(errs, [err]))
					}
				} else {
					RuUndefVal();
				}
			} else {
				err = "first argument of index operator must be a map or array, got: " + scType2s(e_val.type);
				RuRuntimeError(concat(errs, [err]))
			}
		}
		ScGet(m, k): {
			m_val = ruEval(m, state, out);
			k_val = ruEval(k, state, out);
			errs = ruErrorArgs([m_val, k_val]);
			m_type = runtimeValueType(m_val.type);
			if (m_type == "map") {
				mapping = cast(m_val.val : flow -> Tree<flow, flow>);
				lookupTreeDef(mapping, k_val.val, RuUndefVal());
			} else {
				err = "first argument of . operator must be a map, got: " + scType2s(m_val.type);
				RuRuntimeError(concat(errs, [err]))
			}
		}
		ScLambda(args, body): {
			closure = foldSet(ruScExpVars(makeSet(), ex), makeTree(), \acc, var -> 
				switch (lookupTree(state.local, var)) {
					Some(val): setTree(acc, var, val);
					None(): {
						switch (lookupTree(state.global.vars, var)) {
							Some(val): setTree(acc, var, val);
							None(): {
								acc;
							}
						}
					}
				}
			);
			ScriptFn(
				ruScExp2s(ex),
				\vs, st, o -> {
					call_locals = foldi(args, closure, \i, acc, arg -> setTree(acc, arg.var, vs[i]));
					ruEval(body, RuExecState(st with local = call_locals), o);
				}
			);
		}
		ScArray(arr): {
			map(arr, \x -> ruEval(x, state, out));
		}
		ScMap(pairs): {
			pairs_vals = map(pairs, \p -> 
				Pair(ruEval(p.first, state, out), ruEval(p.second, state, out))
			);
			pairs2tree(map(pairs_vals, \p -> Pair(p.first.val, p.second.val)));
		}
		ScUndefConst():     RuUndefVal();
		ScBoolConst(val):   val;
		ScIntConst(val):    val;
		ScDoubleConst(val): val;
		ScStringConst(val): val;
		ScVar(var):         ruEvalVar(var, state, out);
	}
}

ruEvalVar(var : string, state : RuExecState, out : RuOut) -> flow {
	conf = state.global.conf;
	switch (lookupTree(state.local, var)) {
		Some(val): val;
		None(): {
			switch (lookupTree(state.global.vars, var)) {
				Some(val): val;
				None(): {
					if (startsWith(var, "conf.")) {
						opt = strRight(var, 5);
						switch (lookupTree(conf.opts, opt)) {
							Some(val): flow(val);
							None(): {
								if (opt == "working-dir") {
									flow(conf.workingDir);
								} else if (opt == "verbose") {
									flow(conf.verbose);
								} else if (opt == "import-roots") {
									flow(conf.importRoots);
								} else if (opt == "project-roots") {
									flow(conf.projectRoots);
								} else {
									RuUndefVal();
								}
							}
						}
					} else if (var == "sources") {
						foldTree(state.global.ru, makeTree(), \id, src, acc -> 
							setTree(acc, id2s(id), src)
						);
					} /*else if (var == "math") {
						math = ruMathFromSources(state.ru, RuEnv(conf, out));
						ScValue(pairs2tree([
							Pair(ScString("sources"), ScMap(foldTree(math.sources, makeTree(), \id, src, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuSource", src))
							))),
							Pair(ScString("consts"), ScMap(foldTree(math.decls.lang.consts, makeTree(), \id, const, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuConst", const))
							))),
							Pair(ScString("types"), ScMap(foldTree(math.decls.lang.types, makeTree(), \id, type, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuType", type))
							))),
							Pair(ScString("rules"), ScMap(foldTree(math.decls.lang.rules, makeTree(), \id, rule, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuRule", rule))
							))),
							Pair(ScString("assertions"), ScMap(foldTree(math.decls.assertions, makeTree(), \id, assertion, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuAssertion", assertion))
							))),
						]));
					} */ else {
						switch (lookupTree(ruScriptFns(), var)) {
							Some(fn): {
								fn;
							}
							None(): {
								//native hasRuntimeFunction : (string) -> bool = RussellReflection.hasRuntimeFunction;
								//native callRuntimeFunction : (string, [flow]) -> flow = RussellReflection.callRuntimeFunction;
								// ScriptFn(
								//	name : string,
								//	fn : ([ScValue], state : RuExecState, out : RuOut) -> ScValue
								//);
								if (hasRuntimeFunction(var)) {
									ScriptFn(var, \args, __,__-> callRuntimeFunction(var, args));
								} else {
									flow(RuUndefVal());
								}
							}
						}
					}
				}
			}
		}
	}
}
