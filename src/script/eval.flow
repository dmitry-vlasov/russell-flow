import comm;

import script/funcs/boolean;
import script/funcs/compare;
import script/funcs/convert;
import script/funcs/numeric;
import script/funcs/time;
import script/funcs/util;

export {
	ruEval(ex : ScExp, state : RuExecState, out : RuOut) -> ScValue;
}

ru_script_fns : ref Maybe<Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	onlyOnce(ru_script_fns, 
		\-> values2tree(concatA([
			ruScriptBooleanFuncs(),
			ruScriptCompareFuncs(),
			ruScriptConvertFuncs(),
			ruScriptNumericFuncs(),
			ruScriptTimeFuncs(),
			ruScriptUtilFuncs()
		]), \sf -> sf.name)
	);
}

ruEval(ex : ScExp, state : RuExecState, out : RuOut) -> ScValue {
	conf = state.global.conf;
	switch (ex) {
		ScInfixOp(e, args): {
			vals = map(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state, out)
			);
			func = lookupTreeDef(ruScriptFns(), args[0].op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs(vals),
				if (func.name != "") [] else ["infix operator: '" + args[0].op + "'' is not found"]
			);
			if (length(errs) > 0) {
				scErrorVal(errs);
			} else {
				func.fn(vals, state, out);
			}
		}
		ScPrefixOp(op, e): {
			val = ruEval(e, state, out);
			func = lookupTreeDef(ruScriptFns(), op, ruNoScriptFn);
			errs = concat(
				ruErrorArgs([val]),
				if (func.name != "") [] else ["prefix operator: '" + op + "'' is not found"]
			);
			if (length(errs) > 0) {
				scErrorVal(errs);
			} else {
				func.fn([val], state, out);
			}
		}
		ScCall(fn, args): {
			fn_val = ruEval(fn, state, out);
			vals = map(args, \arg -> ruEval(arg, state, out));
			if (length(ruErrorArgs(vals)) > 0) {
				scErrorVal(ruErrorArgs(vals));
			} else {
				if (scTypeGen(fn_val.type) != "func") {
					scErrorVal(["Calling non-function:\n" + toString(fn_val) + "\nin:\n" + ruScExp2s(ex)]);
				} else {
					func = cast(fn_val.val : flow -> ScriptFn);
					func.fn(vals, state, out);
				}
			}
		}
		ScCond(cond, pos, neg): {
			cond_val = ruEval(cond, state, out);
			if (cast(cond_val.val : flow -> bool)) {
				ruEval(pos, state, out)
			} else {
				ruEval(neg, state, out)
			}
		}
		ScIndex(e, i): {
			e_val = ruEval(e, state, out);
			i_val = ruEval(i, state, out);
			errs = ruErrorArgs([e_val, i_val]);
			e_type = scTypeGen(e_val.type);
			if (e_type == "map") {
				mapping = cast(e_val.val : flow -> Tree<flow, flow>);
				switch (lookupTree(mapping, i_val.val)) {
					Some(v): ScValue(v, scUnwrapMapVal(e_val.type));
					None():  scUndefVal;
				}
			} else if (e_type == "array") {
				arr = cast(e_val.val : flow -> [flow]);
				if (scTypeGen(i_val.type) == "int") {
					ind = cast(i_val.val : flow -> int);
					if (0 <= ind && ind < length(arr)) {
						ScValue(arr[ind], scUnwrapArrayType(e_val.type));
					} else {
						err = "index " + i2s(ind) + " " + if (ind < 0) "is negative" else " is out of bounds: " + i2s(length(arr));
						ScValue(concat(errs, [err]), scErrorType)
					}
				} else {
					scUndefVal;
				}
			} else {
				err = "first argument of index operator must be a map or array, got: " + scType2s(e_val.type);
				ScValue(concat(errs, [err]), scErrorType)
			}
		}
		ScGet(m, k): {
			m_val = ruEval(m, state, out);
			k_val = ruEval(k, state, out);
			errs = ruErrorArgs([m_val, k_val]);
			m_type = scTypeGen(m_val.type);
			if (m_type == "map") {
				mapping = cast(m_val.val : flow -> Tree<flow, flow>);
				switch (lookupTree(mapping, k_val.val)) {
					Some(v): ScValue(v, scUnwrapMapVal(m_val.type));
					None():  scUndefVal;
				}
			} else {
				err = "first argument of . operator must be a map, got: " + scType2s(m_val.type);
				ScValue(concat(errs, [err]), scErrorType)
			}
		}
		ScLambda(args, body): {
			closure = foldSet(ruScExpVars(makeSet(), ex), makeTree(), \acc, var -> 
				switch (lookupTree(state.local, var)) {
					Some(val): setTree(acc, var, val);
					None(): {
						switch (lookupTree(state.global.vars, var)) {
							Some(val): setTree(acc, var, val);
							None(): {
								acc;
							}
						}
					}
				}
			);
			ScValue(
				ScriptFn(
					ruScExp2s(ex),
					\vs, st, o -> {
						call_locals = foldi(args, closure, \i, acc, arg -> setTree(acc, arg.var, vs[i]));
						ruEval(body, RuExecState(st with local = call_locals), o);
					}
				),
				scFuncType(
					map(args, \arg -> scAnyType),
					scAnyType
				)
			);
		}
		ScArray(arr): {
			arr_val = map(arr, \x -> ruEval(x, state, out));
			el_type = if (length(arr_val) == 0) scUndefType else arr_val[0].type;
			ScValue(map(arr_val, \v -> v.val), ScTypeGen("array", [el_type]));
		}
		ScMap(pairs): {
			pairs_vals = map(pairs, \p -> 
				Pair(ruEval(p.first, state, out), ruEval(p.second, state, out))
			);
			key_type = if (length(pairs_vals) == 0) scUndefType else pairs_vals[0].first.type;
			val_type = if (length(pairs_vals) == 0) scUndefType else pairs_vals[0].second.type;
			ScValue(
				pairs2tree(map(pairs_vals, \p -> Pair(p.first.val, p.second.val))), 
				ScTypeGen("map", [key_type, val_type])
			);
		}
		ScUndefConst():     scUndefVal;
		ScBoolConst(val):   scBoolVal(val);
		ScIntConst(val):    scIntVal(val);
		ScDoubleConst(val): scDoubleVal(val);
		ScStringConst(val): scStringVal(val);
		ScVar(var):         ruEvalVar(var, state, out);
	}
}

ruEvalVar(var : string, state : RuExecState, out : RuOut) -> ScValue {
	conf = state.global.conf;
	switch (lookupTree(state.local, var)) {
		Some(val): val;
		None(): {
			switch (lookupTree(state.global.vars, var)) {
				Some(val): val;
				None(): {
					if (startsWith(var, "conf.")) {
						opt = strRight(var, 5);
						switch (lookupTree(conf.opts, opt)) {
							Some(val): scStringVal(val);
							None(): {
								if (opt == "working-dir") {
									scStringVal(conf.workingDir);
								} else if (opt == "verbose") {
									scIntVal(conf.verbose);
								} else if (opt == "import-roots") {
									scStringArrayVal(conf.importRoots);
								} else if (opt == "project-roots") {
									scStringArrayVal(conf.projectRoots);
								} else {
									scUndefVal;
								}
							}
						}
					} else if (var == "sources") {
						ScValue(
							foldTree(state.global.ru, makeTree(), \id, src, acc -> 
								setTree(acc, id2s(id), src)
							),
							scMapType(scStringType, scConstType("RuSource"))
						);
					} /*else if (var == "math") {
						math = ruMathFromSources(state.ru, RuEnv(conf, out));
						ScValue(pairs2tree([
							Pair(ScString("sources"), ScMap(foldTree(math.sources, makeTree(), \id, src, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuSource", src))
							))),
							Pair(ScString("consts"), ScMap(foldTree(math.decls.lang.consts, makeTree(), \id, const, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuConst", const))
							))),
							Pair(ScString("types"), ScMap(foldTree(math.decls.lang.types, makeTree(), \id, type, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuType", type))
							))),
							Pair(ScString("rules"), ScMap(foldTree(math.decls.lang.rules, makeTree(), \id, rule, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuRule", rule))
							))),
							Pair(ScString("assertions"), ScMap(foldTree(math.decls.assertions, makeTree(), \id, assertion, acc -> 
								setTree(acc, ScString(id2s(id)), ScData("RuAssertion", assertion))
							))),
						]));
					} */ else {
						switch (lookupTree(ruScriptFns(), var)) {
							Some(fn): {
								ScValue(fn, scFuncType([], scAnyType));
							}
							None(): scUndefVal;
						}
					}
				}
			}
		}
	}
}
