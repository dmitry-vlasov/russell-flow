import ds/tree;
import ds/set;
import string;

export {
    // General algebraic types: type variables and type constructors.
    ScType ::= ScTypeVar, ScTypeGen;

    // Type variable (polymorphic) - a variable for a type.
    ScTypeVar(name : string);

    // General form of an algebraic type: a function on types.
    ScTypeGen(
        name : string, 
        args : [ScType]
    );

	// The name of an outer type function. If is a type variable, returns "".
	scTypeGen(type : ScType) -> string;

    // Substitute type variables with approptiate values from 'sub'
    scInstantiateType(tp : ScType, sub : Tree<string, ScType>) -> ScType;
	scTypeContainsVar(tp : ScType, var : string) -> bool;
	scTypeVars(acc : Set<string>, tp : ScType) -> Set<string>;
	scRenameTypeVars(tp : ScType, renaming : Tree<string, string>) -> ScType;

	// Return a version of 'right' type so that all typevars in it are not present in 'left'.
	scMakeVarsDisjointed(left : ScType, right : ScType) -> ScType;
}


scTypeGen(type : ScType) -> string {
	switch (type) {
        ScTypeVar(name): "";
        ScTypeGen(name, __): name;
	}	
}

scInstantiateType(tp : ScType, sub : Tree<string, ScType>) -> ScType {
    switch (tp) {
        ScTypeVar(v): lookupTreeDef(sub, v, tp);
        ScTypeGen(__, as): {
            ScTypeGen(tp with args = map(as, \a -> scInstantiateType(a, sub)));
        }
    }
}

scTypeContainsVar(tp : ScType, var : string) -> bool {
	switch (tp) {
        ScTypeVar(v): v == var;
        ScTypeGen(__, as): {
			exists(as, \a -> scTypeContainsVar(a, var));
        }
    }
}

scTypeVars(acc : Set<string>, tp : ScType) -> Set<string> {
	switch (tp) {
        ScTypeVar(v): insertSet(acc, v);
        ScTypeGen(__, as): {
			fold(as, acc, scTypeVars);
        }
    }
}

scRenameTypeVars(tp : ScType, renaming : Tree<string, string>) -> ScType {
	switch (tp) {
        ScTypeVar(v): ScTypeVar(lookupTreeDef(renaming, v, v));
        ScTypeGen(nm, as): {
			ScTypeGen(nm, map(as, \a -> scRenameTypeVars(a, renaming)));
        }
    }
}

scGenerateFreshVar(vars : Set<string>, var : string, ind : int) -> string {
	if (!containsSet(vars, var)) var else {
		fresh = var + "_" + i2s(ind);
		if (!containsSet(vars, fresh)) fresh else 
		scGenerateFreshVar(vars, var, ind + 1);
	}
}

scMakeVarsDisjointed(left : ScType, right : ScType) -> ScType {
	left_vars = scTypeVars(makeSet(), left);
	right_vars = scTypeVars(makeSet(), right);
	if (sizeSet(intersectSets(left_vars, right_vars)) == 0) right else {
		renaming = foldSet(right_vars, makeTree(), \acc, var -> 
			setTree(acc, var, scGenerateFreshVar(left_vars, var, 0))
		);
		scRenameTypeVars(right, renaming);
	}
}
