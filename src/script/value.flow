import base/conf;

export {
	ValValue ::= ValScalar, ValArray, ValMap, ValUndef, ValData;
		ValUndef();
		ValArray(arr : [ValValue]);
		ValMap(map : Tree<ValValue, ValValue>);
		ValData(type : string, data : flow);

	ValScalar ::= ValVoid, ValBool, ValInt, ValDouble, ValString;
		ValVoid();
		ValBool(val : bool);
		ValInt(val : int);
		ValDouble(val : double);
		ValString(val : string);
	
	ruValue2s(v : ValValue) -> string;
	ruScriptDepth(vals : Tree<string, ValValue>) -> int;

	ruHasStringArg(args : [ValValue]) -> bool;
	ruAllArgsAreArrays(args : [ValValue]) -> bool;
	ruAllArgsAreMaps(args : [ValValue]) -> bool;

	ruEvalBinaryBoolFn(args : [ValValue], fn : (bool, bool) -> bool) -> Maybe<ValValue>;
	ruEvalIntFn(args : [ValValue], fn : ([int]) -> Maybe<int>) -> Maybe<ValValue>;
	ruEvalStringFn(args : [ValValue], fn : ([string]) -> Maybe<string>) -> Maybe<ValValue>;
	ruEvalDoubleFn(args : [ValValue], fn : ([double]) -> Maybe<double>) -> Maybe<ValValue>;
	ruEvalIntPred(args : [ValValue], fn : ([int]) -> Maybe<bool>) -> Maybe<ValValue>;
	ruEvalStringPred(args : [ValValue], fn : ([string]) -> Maybe<bool>) -> Maybe<ValValue>;
	ruEvalDoublePred(args : [ValValue], fn : ([double]) -> Maybe<bool>) -> Maybe<ValValue>;
	ruEvalArrayFn(args : [ValValue], fn : ([[ValValue]]) -> Maybe<[ValValue]>) -> Maybe<ValValue>;
	ruEvalTreeFn(args : [ValValue], fn : ([Tree<ValValue, ValValue>]) -> Maybe<Tree<ValValue, ValValue>>) -> Maybe<ValValue>;
}

ruValue2s(v : ValValue) -> string {
	switch (v) {
		ValArray(arr) : {
			arr_s = map(arr, ruValue2s);
			has_newlines = exists(arr_s, \s -> strContains(s, "\n"));
			length = fold(arr_s, 0, \acc, s -> acc + strlen(s) + 2);
			if (has_newlines || length > 80) {
				"[\n" + strIndent(strGlue(arr_s, "\n")) + "\n]";
			} else {
				"[" + strGlue(arr_s, ", ") + "]";
			}
		}
		ValMap(m): {
			keys = map(getTreeKeys(m), ruValue2s);
			vals = map(getTreeValues(m), ruValue2s);
			has_newlines = exists(vals, \s -> strContains(s, "\n"));
			length = 
				fold(keys, 0, \acc, key -> acc + strlen(key) + 1) + 
				fold(vals, 0, \acc, val -> acc + strlen(val) + 2);
			if (has_newlines || length > 80) {
				"[\n" + strIndent(strGlue(map(tree2pairs(m), \p -> ruValue2s(p.first) + "=" + ruValue2s(p.second)), "\n")) + "\n]";
			} else {
				"[" + strGlue(map(tree2pairs(m), \p -> ruValue2s(p.first) + "=" + ruValue2s(p.second)), ", ") + "]";
			}
		}
		ValData(type, data): type + ": " + toString(data);
		ValUndef():    "undef";
		ValVoid():     "void";
		ValBool(val):   b2s(val);
		ValInt(val):    i2s(val);
		ValDouble(val): d2s(val);
		ValString(val): val;
	}
}

ruScriptDepth(vals : Tree<string, ValValue>) -> int {
	switch(lookupTreeDef(vals, "script.depth", ValInt(0))) {
		ValInt(n): n;
		default: 0;
	};
}

ruHasStringArg(args : [ValValue]) -> bool {
	exists(args, \arg -> 
		switch (arg) {
			ValString(__): true;
			default: false;
		}
	);
}

ruAllArgsAreArrays(args : [ValValue]) -> bool {
	forall(args, \arg -> 
		switch (arg) {
			ValArray(__): true;
			default: false;
		}
	);
}

ruAllArgsAreMaps(args : [ValValue]) -> bool {
	forall(args, \arg -> 
		switch (arg) {
			ValMap(__): true;
			default: false;
		}
	);
}

ruEvalBinaryBoolFn(args : [ValValue], fn : (bool, bool) -> bool) -> Maybe<ValValue> {
	bool_args = filtermap(args, \arg -> 
		switch (arg) {
			ValBool(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(bool_args) || length(bool_args) != 2) None() else {
		Some(ValBool(fn(bool_args[0], bool_args[0])));
	}
}

ruEvalIntFn(args : [ValValue], fn : ([int]) -> Maybe<int>) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		maybeMap(fn(int_args), \val -> ValInt(val));
	}
}

ruEvalStringFn(args : [ValValue], fn : ([string]) -> Maybe<string>) -> Maybe<ValValue> {
	str_args = map(args, ruValue2s);
	maybeMap(fn(str_args), \val -> ValString(val));
}

ruEvalDoubleFn(args : [ValValue], fn : ([double]) -> Maybe<double>) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		maybeMap(fn(double_args), \val -> ValDouble(val));
	}
}

ruEvalIntPred(args : [ValValue], fn : ([int]) -> Maybe<bool>) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		maybeMap(fn(int_args), \val -> ValBool(val));
	}
}

ruEvalStringPred(args : [ValValue], fn : ([string]) -> Maybe<bool>) -> Maybe<ValValue> {
	str_args = map(args, ruValue2s);
	maybeMap(fn(str_args), \val -> ValBool(val));
}

ruEvalDoublePred(args : [ValValue], fn : ([double]) -> Maybe<bool>) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		maybeMap(fn(double_args), \val -> ValBool(val));
	}
}

ruEvalArrayFn(args : [ValValue], fn : ([[ValValue]]) -> Maybe<[ValValue]>) -> Maybe<ValValue> {
	arr_args = filtermap(args, \arg -> switch (arg) {
		ValArray(arr): Some(arr);
		default: None();
	});
	maybeMap(fn(arr_args), \arr -> ValArray(arr));
}

ruEvalTreeFn(args : [ValValue], fn : ([Tree<ValValue, ValValue>]) -> Maybe<Tree<ValValue, ValValue>>) -> Maybe<ValValue> {
	map_args = filtermap(args, \arg -> switch (arg) {
		ValMap(m): Some(m);
		default: None();
	});
	maybeMap(fn(map_args), \map -> ValMap(map));
}
