import base/conf;
import script/types/type_gens;

export {
	ScValue(val : flow, type : ScType);

	ruScValue2s(v : ScValue) -> string;
	ruScValues2s(vs : [ScValue]) -> string;
	ruScriptDepth(vals : Tree<string, ScValue>) -> int;

	ruHasStringArg(args : [ScValue]) -> bool;
	ruHasUndefArg(args : [ScValue]) -> bool;
	ruErrorArgs(args : [ScValue]) -> [string];

	ruAllArgsAreVoid(args : [ScValue]) -> bool;
	ruAllArgsAreUndef(args : [ScValue]) -> bool;
	ruAllArgsAreArrays(args : [ScValue]) -> bool;
	ruAllArgsAreMaps(args : [ScValue]) -> bool;
	ruAllArgsAreOfSameType(args : [ScValue]) -> bool;

	ruFilterBoolArgs(args : [ScValue]) -> Maybe<[bool]>;
	ruFilterIntArgs(args : [ScValue]) -> Maybe<[int]>;
	ruFilterDoubleArgs(args : [ScValue]) -> Maybe<[double]>;
	ruFilterStringArgs(args : [ScValue]) -> Maybe<[string]>;
	ruFilterArrayArgs(args : [ScValue]) -> Maybe<[[?]]>;
	ruFilterMapArgs(args : [ScValue]) -> Maybe<[Tree<?, ??>]>;
	//ruFilterValueArgs(args : [ScValue]) -> Maybe<[ScValue]>;

	ruEvalArityError(args : [ScValue], sign : string, arity : int) -> ScValue;
	ruEvalComputeError(args : [ScValue], sign : string) -> ScValue;
	ruEvalArgTypeError(args : [ScValue], sign : string, type : string) -> ScValue;

	scErrorVal(err : [string]) -> ScValue;
	scIntVal(v : int) -> ScValue;
	scStringVal(v : string) -> ScValue;
	scDoubleVal(v : double) -> ScValue;
	scBoolVal(v : bool) -> ScValue;
	scStringArrayVal(v : [string]) -> ScValue;
	scIntArrayVal(v : [int]) -> ScValue;
	scUndefVal = ScValue(0, scUndefType);
}

ruScValue2s(v : ScValue) -> string {
	type_gen = scTypeGen(v.type);
	if (type_gen == "array") {
		arr = cast(v.val : flow -> [flow]);
		arr_type = scUnwrapArrayType(v.type);
		arr_s = map(arr, \w -> ruScValue2s(ScValue(w, arr_type)));
		has_newlines = exists(arr_s, \s -> strContains(s, "\n"));
		length = fold(arr_s, 0, \acc, s -> acc + strlen(s) + 2);
		if (has_newlines || length > 80) {
			"[\n" + strIndent(strGlue(arr_s, "\n")) + "\n]";
		} else {
			"[" + strGlue(arr_s, ", ") + "]";
		}
	} else if (type_gen == "map") {
		m = cast(v.val : flow -> Tree<flow, flow>);
		key_type = scUnwrapMapKey(v.type);
		val_type = scUnwrapMapVal(v.type);
		keys = map(getTreeKeys(m), \k -> ruScValue2s(ScValue(k, key_type)));
		vals = map(getTreeValues(m), \w -> ruScValue2s(ScValue(w, val_type)));
		has_newlines = exists(vals, \s -> strContains(s, "\n"));
		length = 
			fold(keys, 0, \acc, key -> acc + strlen(key) + 1) + 
			fold(vals, 0, \acc, val -> acc + strlen(val) + 2);
		if (has_newlines || length > 80) {
			"{\n" + 
				strIndent(strGlue(map(tree2pairs(m), \p -> 
					ruScValue2s(ScValue(p.first, key_type)) + "=" + ruScValue2s(ScValue(p.second, val_type))
				), 
				"\n")) + 
			"\n}";
		} else {
			"{" + 
				strGlue(map(tree2pairs(m), \p -> 
					ruScValue2s(ScValue(p.first, key_type)) + "=" + ruScValue2s(ScValue(p.second, val_type))
				), 
				", ") + 
			"}";
		}
	} else if (type_gen == "int") {
		val = cast(v.val : flow -> int);
		i2s(val);
	} else if (type_gen == "bool") {
		val = cast(v.val : flow -> bool);
		b2s(val);
	} else if (type_gen == "double") {
		val = cast(v.val : flow -> double);
		d2s(val);
	} else if (type_gen == "string") {
		cast(v.val : flow -> string);
	} else if (type_gen == "flow") {
		toString(v.val);
	} /*else if (type_gen == "value") {
		val_type = scUnwrapValueType(v.type);
		"value(" + ruScValue2s(ScValue(v.val, val_type)) + ")";
	} */ else if (type_gen == "error") {
		errs = cast(v.val : flow -> [string]);
		if (length(errs) == 0) "error" else 
		if (length(errs) == 1) "error: " + errs[0] else 
		"errors:\n" + strIndent(strGlue(errs, "\n"));
	} else {
		"undef";
	}
}

ruScValues2s(vs : [ScValue]) -> string {
	strGlue(map(vs, ruScValue2s), ", ");
}

ruScriptDepth(vals : Tree<string, ScValue>) -> int {
	v = lookupTreeDef(vals, "script.depth", ScValue(0, scIntType));
	if (v.type.name == "int") cast(v.val : flow -> int) else 0;
}

ruHasStringArg(args : [ScValue]) -> bool {
	exists(args, \arg -> scTypeGen(arg.type) == "string");
}

ruHasUndefArg(args : [ScValue]) -> bool {
	exists(args, \arg -> scTypeGen(arg.type) == "undef");
}

ruErrorArgs(args : [ScValue]) -> [string] {
	concatA(filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "error") Some(cast(arg.val : flow -> [string])) else None()
	));
}

ruAllArgsAreVoid(args : [ScValue]) -> bool {
	forall(args, \arg -> scTypeGen(arg.type) == "void");
}

ruAllArgsAreUndef(args : [ScValue]) -> bool {
	forall(args, \arg -> scTypeGen(arg.type) == "undef");
}

ruAllArgsAreArrays(args : [ScValue]) -> bool {
	forall(args, \arg -> scTypeGen(arg.type) == "array");
}

ruAllArgsAreMaps(args : [ScValue]) -> bool {
	forall(args, \arg -> scTypeGen(arg.type) == "map");
}

ruAllArgsAreOfSameType(args : [ScValue]) -> bool {
	if (length(args) == 0) true else {
		type_gen = scTypeGen(args[0].type);
		forall(args, \arg -> scTypeGen(arg.type) == type_gen);
	}
}

ruFilterBoolArgs(args : [ScValue]) -> Maybe<[bool]> {
	bool_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "bool") Some(cast(arg.val : flow -> bool)) else None()
	);
	if (length(args) != length(bool_args)) None() else Some(bool_args);
}

ruFilterIntArgs(args : [ScValue]) -> Maybe<[int]> {
	int_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "int") Some(cast(arg.val : flow -> int)) else None()
	);
	if (length(args) != length(int_args)) None() else Some(int_args);
}

ruFilterDoubleArgs(args : [ScValue]) -> Maybe<[double]> {
	double_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "double") Some(cast(arg.val : flow -> double)) else None()
	);
	if (length(args) != length(double_args)) None() else Some(double_args);
}

ruFilterStringArgs(args : [ScValue]) -> Maybe<[string]> {
	str_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "string") Some(cast(arg.val : flow -> string)) else None()
	);
	if (length(args) != length(str_args)) None() else Some(str_args);
}

ruFilterArrayArgs(args : [ScValue]) -> Maybe<[[?]]> {
	arr_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "array") Some(cast(arg.val : flow -> [?])) else None()
	);
	if (length(args) != length(arr_args)) None() else Some(arr_args);
}

ruFilterMapArgs(args : [ScValue]) -> Maybe<[Tree<?, ??>]> {
	map_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "map") Some(cast(arg.val : flow -> Tree<?, ??>)) else None()
	);
	if (length(args) != length(map_args)) None() else Some(map_args);
}

/*ruFilterValueArgs(args : [ScValue]) -> Maybe<[ScValue]> {
	data_args = filtermap(args, \arg -> 
		if (scTypeGen(arg.type) == "value") Some(cast(arg.val : flow -> ScValue)) else None()
	);
	if (length(args) != length(data_args)) None() else Some(data_args);
}*/

ruEvalArityError(args : [ScValue], sign : string, arity : int) -> ScValue {
	ScValue(["function '" + sign + "' must take exactly " + i2s(arity) + " arguments, actual number of arguments: " + i2s(length(args))], scErrorType);
}

ruEvalComputeError(args : [ScValue], sign : string) -> ScValue {
	ScValue(["error while computing '" + sign + "' on arguments: " + ruScValues2s(args)], scErrorType);
}

ruEvalArgTypeError(args : [ScValue], sign : string, type : string) -> ScValue {
	ScValue(["function '" + sign + "' must take only '" + type + "' arguments, actual arguments: " + ruScValues2s(args)], scErrorType);
}

scErrorVal(err : [string]) -> ScValue {
	ScValue(err, scErrorType);
}

scIntVal(v : int) -> ScValue {
	ScValue(v, scIntType);
}

scStringVal(v : string) -> ScValue {
	ScValue(v, scStringType);
}

scDoubleVal(v : double) -> ScValue {
	ScValue(v, scDoubleType);
}

scBoolVal(v : bool) -> ScValue {
	ScValue(v, scBoolType);
}

scStringArrayVal(v : [string]) -> ScValue {
	ScValue(v, scArrayType(scStringType));
}

scIntArrayVal(v : [int]) -> ScValue {
	ScValue(v, scArrayType(scIntType));
}
