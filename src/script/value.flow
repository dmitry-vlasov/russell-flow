import string_utils;
import ds/tree;

export {
	ValValue ::= ValScalar, ValArray, ValMap, ValUndef;
		ValUndef();
		ValArray(arr : [ValValue]);
		ValMap(map : Tree<string, ValValue>);

	ValScalar ::= ValVoid, ValBool, ValInt, ValDouble, ValString;
		ValVoid();
		ValBool(val : bool);
		ValInt(val : int);
		ValDouble(val : double);
		ValString(val : string);
	
	ruValue2s(v : ValValue) -> string;
}

ruValue2s(v : ValValue) -> string {
	switch (v) {
		ValArray(arr) : {
			arr_s = map(arr, ruValue2s);
			has_newlines = exists(arr_s, \s -> strContains(s, "\n"));
			length = fold(arr_s, 0, \acc, s -> acc + strlen(s) + 2);
			if (has_newlines || length > 80) {
				"[\n" + strIndent(strGlue(arr_s, "\n")) + "\n]";
			} else {
				"[" + strGlue(arr_s, ", ") + "]";
			}
		}
		ValMap(m): {
			keys = getTreeKeys(m);
			vals = map(getTreeValues(m), ruValue2s);
			has_newlines = exists(vals, \s -> strContains(s, "\n"));
			length = 
				fold(keys, 0, \acc, key -> acc + strlen(key) + 1) + 
				fold(vals, 0, \acc, val -> acc + strlen(val) + 2);
			if (has_newlines || length > 80) {
				"[\n" + strIndent(strGlue(map(tree2pairs(m), \p -> p.first + "=" + ruValue2s(p.second)), "\n")) + "\n]";
			} else {
				"[" + strGlue(map(tree2pairs(m), \p -> p.first + "=" + ruValue2s(p.second)), ", ") + "]";
			}
		}
		ValUndef(): "undef";
		ValVoid():  "void";
		ValBool(val): b2s(val);
		ValInt(val): i2s(val);
		ValDouble(val): d2s(val);
		ValString(val): val;
	}
}
