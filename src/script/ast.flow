import lingo/pegcode/driver;
import base/util/parse;
import base/util/str;
//import script/types/type_gens;

export {
	ScCommWDocs(comm : ScComm, docs : string);

	ScComm ::= ScCommSeq, ScAssign, ScIf, ScWhile, ScOutput, ScTask, ScAction;
		ScCommSeq(seq : [ScComm]);
		ScAssign(var : ScVar, exp : ScExp);
		ScIf(cond : ScExp, pos : ScComm, neg : Maybe<ScComm>);
		ScWhile(cond : ScExp, script : ScComm);
		ScOutput(mode : string, exp : ScExp);
		ScTask(command : string, args : Tree<string, string>);
		ScAction(action : string, args : [ScExp]);

	ScAccessLval ::= ScFieldLval, ScIndexLval, ScCallLval, ScDirectLval;
		ScFieldLval(field : string, next : ScAccessLval);
		ScIndexLval(ind : ScExp, next : ScAccessLval);
		ScCallLval(args : [ScExp], next : ScAccessLval);
		ScDirectLval();

	ScExp ::= 
		ScInfixOp, ScPrefixOp, ScCall, ScCond, ScLet, ScIndex, ScLambda, ScArray, ScMap, ScField, ScStruct,
		ScUndefConst, ScBoolConst, ScIntConst, ScDoubleConst, ScStringConst, ScVar, ScExpSeq;
		// general
		ScInfixOp(exp : ScExp, args : [ScInfixArg]);
			ScInfixArg(op : string, exp : ScExp);
		ScPrefixOp(op : string, exp : ScExp);
		ScCond(cond : ScExp, pos : ScExp, neg : ScExp);
		ScLet(var : string, exp : ScExp, scope : ScExp);
		// functions: make lambda / call fn
		ScCall(fn : ScExp, args : [ScExp]);
		ScLambda(args : [string], body : ScExp);
		// array: make/access
		ScArray(arr : [ScExp]);
		ScIndex(arr : ScExp, ind : ScExp);
		// maps: make/access
		ScMap(pairs : [Pair<ScExp, ScExp>]);
		ScField(exp : ScExp, key : string);
		ScStruct(name : string, args : [ScExp]);

		ScUndefConst();
		ScBoolConst(val : bool);
		ScIntConst(val : int);
		ScDoubleConst(val : double);
		ScStringConst(val : string);
		ScVar(var : string, access : ScAccessLval);
		ScExpSeq(seq : [ScExp]);

	ruParseScComm(str : string) -> Maybe<ScCommWDocs>;
	ruScComm2Json(script : ScComm) -> Json;
	ruJson2ScComm(json : Json) -> Maybe<ScComm>;

	ruScComm2s(script : ScComm) -> string;
	ruScExp2s(e : ScExp) -> string;
	ruScCommTasks(script : ScComm) -> [ScTask];
	ruScCommSetTasksFile(script : ScComm, file : string) -> ScComm;

	ruTask2s(task : ScTask) -> string;
	ruTask2Json(task : ScTask) -> Json;
	ruJson2Task(json : Json) -> Maybe<ScTask>;
	ruSetNoLogging(task : ScTask) -> ScTask;

	ruSetScCommTaskArg(script : ScComm, key : string, val : string) -> ScComm;

	ruScExpVars(acc : Set<string>, e : ScExp) -> Set<string>;
}

ruMakeScTask(as : [flow]) -> ScTask {
	ScTask(as[0], 
		pairs2tree(map(
			filtermap(
				ruSplitTaskArgs(flow2s(as[1]), 0, RuSplitTaskArgsAcc([], "", false)), 
				\s0 -> {
					s = trim2(s0, " \n\t\r");
					if (s == "" || s == "do_not_log_this") None() else Some(s);
				}
			),
			\s -> {
				sp = strSplit(s, "=");
				if (length(sp) == 1) Pair(s, "") else Pair(sp[0], sp[1]);
			}
		))
	);
}

RuSplitTaskArgsAcc(
	args : [string],
	curr : string,
	inString : bool
);

ruSplitTaskArgs(args : string, i : int, acc : RuSplitTaskArgsAcc) -> [string] {
	if (i == strlen(args)) {
		if (acc.curr == "") acc.args else concat(acc.args, [acc.curr]);
	} else {
		ch = getCharAt(args, i);
		if (acc.inString) {
			if (ch == "\"" && (i == 0 || (i > 0 && getCharAt(args, i - 1) != "\\"))) {
				ruSplitTaskArgs(args, i + 1, 
					RuSplitTaskArgsAcc(acc with inString = false, curr = acc.curr + ch)
				);
			} else {
				ruSplitTaskArgs(args, i + 1, 
					RuSplitTaskArgsAcc(acc with curr = acc.curr + ch)
				);
			}
		} else {
			if (ch == "\"") {
				ruSplitTaskArgs(args, i + 1, 
					RuSplitTaskArgsAcc(acc with inString = true, curr = acc.curr + ch)
				);
			} else if (ch == " " || ch == "\t" || ch == "\n" || ch == "\r") {
				ruSplitTaskArgs(args, i + 1, 
					RuSplitTaskArgsAcc(acc with args = concat(acc.args, [acc.curr]), curr = "")
				);
			} else {
				ruSplitTaskArgs(args, i + 1, 
					RuSplitTaskArgsAcc(acc with curr = acc.curr + ch)
				);
			}
		}
	}
}

ru_script_parser = compilePegGrammar("#include script/script.lingo");
ru_script_actions = SemanticActions(mergeTree(defaultPegActions.t, 
	pairs2tree([
		Pair("makeScTask", ruMakeScTask),
		Pair("makeScript", \s -> if (length(s[0]) == 1) s[0][0] else ScCommSeq(s[0]))
	])
));

ruParseScComm(str : string) -> Maybe<ScCommWDocs> {
	comms = ref [];
	actions = SemanticActions(
		setTree(ru_script_actions.t, "makeDocComment", \s -> { refArrayPush(comms, s[0]); 0})
	);
	ret1 = ruParsic(ru_script_parser, str, actions);
	if (ret1 == "PARSING FAILED") {
		ret2 = ruParsic(ru_script_parser, str + ";", actions);
		if (ret2 == "PARSING FAILED") {
			None();
		} else {
			Some(ScCommWDocs(ret2, concatStrings(^comms)));
		}
	} else {
		//println("PARSED SCRIPT:\n" + ruScComm2s(ret1));
		Some(ScCommWDocs(ret1, concatStrings(^comms)));
	}
}

ruScComm2Json(j : ScComm) -> Json {
	switch (j) {
		ScCommSeq(seq): {
			JsonObject([
				Pair("struct", JsonString("ScCommSeq")),
				Pair("seq", JsonArray(map(seq, ruScComm2Json)))
			]);
		}
		ScAssign(var, ex): {
			JsonObject([
				Pair("struct", JsonString("ScAssign")),
				Pair("var", ruScExp2Json(var)),
				Pair("exp", ruScExp2Json(ex))
			]);
		}
		ScIf(cond, pos, mneg): {
			JsonObject(filtermap([
				Some(Pair("struct", JsonString("ScIf"))),
				Some(Pair("cond", ruScExp2Json(cond))),
				Some(Pair("pos", ruScComm2Json(pos))),
				maybeMap(mneg, \neg -> Pair("neg", ruScComm2Json(neg)))
			], idfn));
		}
		ScWhile(cond, script): {
			JsonObject([
				Pair("struct", JsonString("ScWhile")),
				Pair("cond", ruScExp2Json(cond)),
				Pair("script", ruScComm2Json(script)),
			]);
		}
		ScOutput(mode, ex): {
			JsonObject([
				Pair("struct", JsonString("ScOutput")),
				Pair("mode", JsonString(mode)),
				Pair("exp", ruScExp2Json(ex)),
			]);
		}
		ScTask(comm, args): {
			JsonObject([
				Pair("struct", JsonString("ScTask")),
				Pair("command", JsonString(comm)),
				Pair("args", JsonArray(map(tree2pairs(args), 
					\arg -> JsonObject([
						Pair("var", JsonString(arg.first)),
						Pair("value", JsonString(arg.second))
					])
				)))
			]);
		}
		ScAction(action, args): {
			JsonObject([
				Pair("struct", JsonString("ScAction")),
				Pair("action", JsonString(action)),
				Pair("args", JsonArray(map(args, ruScExp2Json)))
			]);
		}
	}
}

ruScAccessLval2Json(a : ScAccessLval) -> Json {
	switch (a) {
		ScFieldLval(field, next): {
			JsonObject([
				Pair("struct", JsonString("ScFieldLval")),
				Pair("field", JsonString(field)),
				Pair("next", ruScAccessLval2Json(next))
			]);
		}
		ScIndexLval(ind, next): {
			JsonObject([
				Pair("struct", JsonString("ScIndexLval")),
				Pair("ind", ruScExp2Json(ind)),
				Pair("next", ruScAccessLval2Json(next))
			]);
		}
		ScCallLval(args, next): {
			JsonObject([
				Pair("struct", JsonString("ScIndexLval")),
				Pair("args", JsonArray(map(args, ruScExp2Json))),
				Pair("next", ruScAccessLval2Json(next))
			]);
		}
		ScDirectLval(): {
			JsonObject([
				Pair("struct", JsonString("ScDirectLval"))
			]);
		}
	}
}

ruScExp2Json(e : ScExp) -> Json {
	switch (e) {
		ScInfixOp(ex, args): {
			JsonObject([
				Pair("struct", JsonString("ScInfixOp")),
				Pair("exp", ruScExp2Json(ex)),
				Pair("args", JsonArray(map(args, \arg -> 
					JsonObject([
						Pair("op", JsonString(arg.op)),
						Pair("exp", ruScExp2Json(arg.exp))
					])
				)))
			]);
		}
		ScPrefixOp(op, ex): {
			JsonObject([
				Pair("struct", JsonString("ScPrefixOp")),
				Pair("op", JsonString(op)),
				Pair("exp", ruScExp2Json(ex))
			]);
		}
		ScCall(fn, args): {
			JsonObject([
				Pair("struct", JsonString("ScCall")),
				Pair("fn", ruScExp2Json(fn)),
				Pair("args", JsonArray(map(args, ruScExp2Json)))
			]);
		}
		ScCond(cond, pos, neg): {
			JsonObject([
				Pair("struct", JsonString("ScCond")),
				Pair("cond", ruScExp2Json(cond)),
				Pair("pos", ruScExp2Json(pos)),
				Pair("neg", ruScExp2Json(neg))
			]);
		}
		ScLet(var, ex, scope): {
			JsonObject([
				Pair("struct", JsonString("ScLet")),
				Pair("var", JsonString(var)),
				Pair("exp", ruScExp2Json(ex)),
				Pair("scope", ruScExp2Json(scope))
			]);
		}
		ScIndex(ex, ind): {
			JsonObject([
				Pair("struct", JsonString("ScIndex")),
				Pair("ex", ruScExp2Json(ex)),
				Pair("ind", ruScExp2Json(ind))
			]);
		}
		ScLambda(args, body): {
			JsonObject([
				Pair("struct", JsonString("ScLambda")),
				Pair("args", JsonArray(map(args, \v -> JsonString(v)))),
				Pair("body", ruScExp2Json(body))
			]);
		}
		ScArray(arr): {
			JsonObject([
				Pair("struct", JsonString("ScArray")),
				Pair("arr", JsonArray(map(arr, ruScExp2Json))),
			]);
		}
		ScMap(pairs): {
			JsonObject([
				Pair("struct", JsonString("ScMap")),
				Pair("pairs", JsonArray(map(pairs, \p ->
					JsonObject([
						Pair("key", ruScExp2Json(p.first)),
						Pair("val", ruScExp2Json(p.second))
					])
				))),
			]);
		}
		ScField(ex, field): {
			JsonObject([
				Pair("struct", JsonString("ScField")),
				Pair("exp", ruScExp2Json(ex)),
				Pair("field", JsonString(field))
			]);
		}
		ScStruct(name, args): {
			JsonObject([
				Pair("struct", JsonString("ScStruct")),
				Pair("name", JsonString(name)),
				Pair("args", JsonArray(map(args, ruScExp2Json)))
			]);
		}
		ScUndefConst(): {
			JsonObject([
				Pair("struct", JsonString("ScUndefConst"))
			]);
		}
		ScBoolConst(val): {
			JsonObject([
				Pair("struct", JsonString("ScBoolConst")),
				Pair("val", JsonBool(val))
			]);
		}
		ScIntConst(val): {
			JsonObject([
				Pair("struct", JsonString("ScIntConst")),
				Pair("val", JsonDouble(i2d(val)))
			]);
		}
		ScDoubleConst(val): {
			JsonObject([
				Pair("struct", JsonString("ScIntConst")),
				Pair("val", JsonDouble(val))
			]);
		}
		ScStringConst(val): {
			JsonObject([
				Pair("struct", JsonString("ScStringConst")),
				Pair("val", JsonString(val))
			]);
		}
		ScVar(var, access): {
			JsonObject([
				Pair("struct", JsonString("ScVar")),
				Pair("var", JsonString(var)),
				Pair("access", ruScAccessLval2Json(access))
			]);
		}
		ScExpSeq(seq): {
			JsonObject([
				Pair("struct", JsonString("ScExpSeq")),
				Pair("seq", JsonArray(map(seq, ruScExp2Json))),
			]);
		}
	}
}

ruJson2ScAccessLval(json : Json) -> Maybe<ScAccessLval> {
	struct = getJsonStringField(json, "struct", "");
	if (struct == "") None() else
	if (struct == "ScFieldLval") {
		field = getJsonStringField(json, "field", "");
		if (field == "") None() else {
			json_next = getJsonFieldValue(json, "next", JsonNull());
			maybeMap(ruJson2ScAccessLval(json_next), \next ->
				ScFieldLval(field, next)
			);
		}
	} else 
	if (struct == "ScIndexLval") {
		json_ind = getJsonFieldValue(json, "ind", JsonNull());
		json_next = getJsonFieldValue(json, "next", JsonNull());
		maybeMap2(\ind, next -> ScIndexLval(ind, next))(
			ruJson2ScExp(json_ind),
			ruJson2ScAccessLval(json_next),
		);
	} else 
	if (struct == "ScCallLval") {
		json_args = getJsonArrayField(json, "args");
		json_next = getJsonFieldValue(json, "next", JsonNull());
		args = filtermap(json_args, ruJson2ScExp);
		if (length(args) != length(json_args)) None() else {
			maybeMap(ruJson2ScAccessLval(json_next), \next -> ScCallLval(args, next));
		}
	} else 
	if (struct == "ScDirectLval") {
		Some(ScDirectLval());
	} else {
		None();
	}
}

ruJson2ScComm(json : Json) -> Maybe<ScComm> {
	struct = getJsonStringField(json, "struct", "");
	if (struct == "") None() else
	if (struct == "ScCommSeq") {
		json_seq = getJsonArrayField(json, "seq");
		seq = filtermap(json_seq, ruJson2ScComm);
		if (length(json_seq) == length(seq)) {
			Some(ScCommSeq(seq));
		} else {
			None();
		}
	} else 
	if (struct == "ScAssign") {
		json_var = getJsonFieldValue(json, "var", JsonNull());
		maybeBind(ruJson2ScExp(json_var), \var ->
			switch (var) {
				ScVar(__,__): {
					json_exp = getJsonFieldValue(json, "exp", JsonNull());
					maybeMap(ruJson2ScExp(json_exp), \ex -> ScAssign(var, ex));
				}
				default: None();
			}

		)
	} else 
	if (struct == "ScIf") {
		neg = if (!jsonObjectHasField(json, "neg")) None() else {
			ruJson2ScComm(getJsonFieldValue(json, "neg", JsonNull()));
		}
		maybeMap2(\cond, pos -> ScIf(cond, pos, neg))(
			ruJson2ScExp(getJsonFieldValue(json, "cond", JsonNull())),
			ruJson2ScComm(getJsonFieldValue(json, "pos", JsonNull()))
		);
	} else 
	if (struct == "ScWhile") {
		maybeMap2(\cond, script -> ScWhile(cond, script))(
			ruJson2ScExp(getJsonFieldValue(json, "cond", JsonNull())),
			ruJson2ScComm(getJsonFieldValue(json, "script", JsonNull()))
		);
	} else 
	if (struct == "ScOutput") {
		mode = getJsonStringField(json, "mode", "");
		if (mode == "") None() else {
			maybeMap(
				ruJson2ScExp(getJsonFieldValue(json, "exp", JsonNull())),
				\ex -> ScOutput(mode, ex)
			);
		}
	} else 
	if (struct == "ScTask") {
		comm = getJsonStringField(json, "command", "");
		if (comm == "") None() else {
			json_args = getJsonArrayField(json, "args");
			args = filtermap(json_args, \opt -> {
				var = getJsonStringField(opt, "var", "");
				if (var == "") None() else {
					Some(Pair(var, getJsonStringField(opt, "value", "")))
				}
			});
			if (length(json_args) != length(args)) None() else {
				Some(ScTask(comm, pairs2tree(args)));
			}
		}
	} else if (struct == "ScAction") {
		action = getJsonStringField(json, "action", "");
		if (action == "") None() else {
			json_args = getJsonArrayField(json, "args");
			args = filtermap(json_args, ruJson2ScExp);
			if (length(json_args) != length(args)) None() else {
				Some(ScAction(action, args));
			}
		}
	} else {
		None();
	}
}

ruJson2ScExp(json : Json) -> Maybe<ScExp> {
	struct = getJsonStringField(json, "struct", "");
	if (struct == "") None() else
	if (struct == "ScInfixOp") {
		maybeBind(
			ruJson2ScExp(getJsonFieldValue(json, "exp", JsonNull())),
			\exp -> {
				json_args = getJsonArrayField(json, "args");
				if (json_args == []) None() else {
					args = filtermap(json_args, \arg -> {
						op = getJsonStringField(arg, "op", "");
						if (op == "") None() else {
							maybeMap(
								ruJson2ScExp(getJsonFieldValue(arg, "exp", JsonNull())),
								\ex -> ScInfixArg(op, ex)
							);
						}
					});
					if (length(args) != length(json_args)) None() else {
						Some(ScInfixOp(exp, args));
					}
				}
			}
		);
	} else 
	if (struct == "ScPrefixOp") {
		op = getJsonStringField(json, "op", "");
		if (op == "") None() else {
			maybeMap(
				ruJson2ScExp(getJsonFieldValue(json, "exp", JsonNull())), 
				\ex -> ScPrefixOp(op, ex)
			);
		} 
	} else 
	if (struct == "ScCall") {
		fn_json = getJsonFieldValue(json, "fn", JsonNull());
		if (fn_json == JsonNull()) None() else {
			maybeBind(ruJson2ScExp(fn_json), 
				\fn -> if (!jsonObjectHasField(json, "args")) None() else {
					json_args = getJsonArrayField(json, "args");
					args = filtermap(json_args, ruJson2ScExp);
					if (length(args) != length(json_args)) None() else {
						Some(ScCall(fn, args));
					}
				}
			);
		}
	} else 
	if (struct == "ScCond") {
		cond_json = getJsonFieldValue(json, "cond", JsonNull());
		pos_json = getJsonFieldValue(json, "pos", JsonNull());
		neg_json = getJsonFieldValue(json, "neg", JsonNull());
		if (cond_json == JsonNull() || pos_json == JsonNull() || neg_json == JsonNull()) None() else {
			maybeBind(ruJson2ScExp(cond_json), 
				\cond -> maybeMap2(\pos, neg -> ScCond(cond, pos, neg))
				(ruJson2ScExp(pos_json), ruJson2ScExp(neg_json))
			);
		}
	} else 
	if (struct == "ScLet") {
		var = getJsonStringField(json, "var", "");
		if (var == "") None() else {
			json_val = getJsonFieldValue(json, "exp", JsonNull());
			json_scope = getJsonFieldValue(json, "scope", JsonNull());
			maybeMap2(\val, scope -> ScLet(var, val, scope))(
				ruJson2ScExp(json_val),
				ruJson2ScExp(json_scope)
			);
		}
	} else
	if (struct == "ScIndex") {
		ex = getJsonFieldValue(json, "ex", JsonNull());
		if (ex == JsonNull()) None() else {
			if (!jsonObjectHasField(json, "ind")) None() else {
				ind = getJsonFieldValue(json, "ind", JsonNull());
				maybeMap2(\e, i -> ScIndex(e, i))(ruJson2ScExp(ex), ruJson2ScExp(ind));
			}
		}
	} else 
	if (struct == "ScLambda") {
		body_json = getJsonFieldValue(json, "body", JsonNull());
		if (body_json == JsonNull()) None() else {
			if (!jsonObjectHasField(json, "args")) None() else {
				args_json = getJsonArrayField(json, "args");
				args = filtermap(args_json, \arg_json -> 
					switch (arg_json) {
						JsonString(arg): Some(arg);
						default: None();
					}
				);
				if (length(args) != length(args_json)) None() else {
					maybeMap(ruJson2ScExp(body_json), \body -> ScLambda(args, body));
				}
			}
		}
	} else 
	if (struct == "ScArray") {
		if (!jsonObjectHasField(json, "arr")) None() else {
			arr_json = getJsonArrayField(json, "arr");
			arr = filtermap(arr_json, ruJson2ScExp);
			if (length(arr) == length(arr_json)) {
				Some(ScArray(arr));
			} else {
				None();
			}
		}
	} else 
	if (struct == "ScMap") {
		if (!jsonObjectHasField(json, "pairs")) None() else {
			pairs_jsons = getJsonArrayField(json, "pairs");
			pairs = filtermap(pairs_jsons, \pair_json -> {
				key_json = getJsonFieldValue(pair_json, "key", JsonNull());
				val_json = getJsonFieldValue(pair_json, "val", JsonNull());
				maybeMap2(\key, val -> Pair(key, val))(
					ruJson2ScExp(key_json),
					ruJson2ScExp(val_json)
				)
			});
			if (length(pairs) == length(pairs_jsons)) {
				Some(ScMap(pairs));
			} else {
				None();
			}
		}
	} else 
	if (struct == "ScField") {
		maybeBind(ruJson2ScExp(getJsonFieldValue(json, "exp", JsonNull())),
			\ex -> {
				field = getJsonStringField(json, "field", "");
				if (field == "") None() else 
				Some(ScField(ex, field));
			}
		);
	} else
	if (struct == "ScStruct") {
		name = getJsonStringField(json, "name", "");
		if (name == "") None() else {
			if (!jsonObjectHasField(json, "args")) None() else {
				json_args = getJsonArrayField(json, "args");
				args = filtermap(json_args, ruJson2ScExp);
				if (length(args) != length(json_args)) None() else {
					Some(ScStruct(name, args));
				}
			}
		}
	} else 
	if (struct == "ScUndefConst") {
		Some(ScUndefConst());
	} else 
	if (struct == "ScBoolConst") {
		if (!jsonObjectHasField(json, "val")) None() else {
			val = getJsonBoolField(json, "val", false);
			Some(ScBoolConst(val));
		} 
	} else 
	if (struct == "ScIntConst") {
		if (!jsonObjectHasField(json, "val")) None() else {
			val = getJsonDoubleField(json, "val", 0.0);
			Some(ScIntConst(round(val)));
		} 
	} else 
	if (struct == "ScDoubleConst") {
		if (!jsonObjectHasField(json, "val")) None() else {
			val = getJsonDoubleField(json, "val", 0.0);
			Some(ScDoubleConst(val));
		} 
	} else 
	if (struct == "ScStringConst") {
		if (!jsonObjectHasField(json, "val")) None() else {
			val = getJsonStringField(json, "val", "");
			Some(ScStringConst(val));
		} 
	} else 
	if (struct == "ScVar") {
		var = getJsonStringField(json, "var", "");
		if (var == "") None() else {
			json_access = getJsonFieldValue(json, "access", JsonNull());
			maybeMap(ruJson2ScAccessLval(json_access), \access ->
				ScVar(var, access)
			);
		} 
	} else 
	if (struct == "ScExpSeq") {
		if (!jsonObjectHasField(json, "seq")) None() else {
			seq_json = getJsonArrayField(json, "seq");
			seq = filtermap(seq_json, ruJson2ScExp);
			if (length(seq) == length(seq_json)) {
				Some(ScExpSeq(seq));
			} else {
				None();
			}
		}
	} else {
		None();
	}
}

ruScComm2s(s : ScComm) -> string {
	switch (s) {
		ScCommSeq(seq):
			strGlue(map(seq, ruScComm2s), "\n");
		ScAssign(var, val): ruScExp2s(var) + " := " + ruScExp2s(val) + ";";
		ScIf(cond, pos, mneg):
			"if " + ruScExp2s(cond) + " {\n" + strIndent(ruScComm2s(pos)) + "\n}" + 
			eitherMap(mneg, \neg -> " else {\n" + strIndent(ruScComm2s(neg)) + "\n}", "");
		ScWhile(cond, script): 
			"while " + ruScExp2s(cond) + " {\n" + strIndent(ruScComm2s(script)) + "\n}";
		ScOutput(mode, ex): 
			mode + " " + ruScExp2s(ex) + ";";
		ScTask(comm, args): 
			ruTask2s(s);
		ScAction(action, args): 
			action + if (length(args) == 0) "" else "(" + superglue(args, ruScExp2s, ",") + ")";
	}
}

ruScAccessLval2s(a : ScAccessLval) -> string {
	switch (a) {
		ScFieldLval(field, next): 
			"." + field + ruScAccessLval2s(next);
		ScIndexLval(ind, next): 
			"[" + ruScExp2s(ind) + "]" + ruScAccessLval2s(next);
		ScCallLval(args, next): 
			"(" + superglue(args, ruScExp2s, ", ") + ")" + ruScAccessLval2s(next);
		ScDirectLval(): 
			"";
	}
}

ruScExp2s(e : ScExp) -> string {
	too_long = \s -> strContains(s, "\n") || strlen(s) > 64;
	switch (e) {
		ScInfixOp(ex, args): {
			arg_strs = map(concat([ex], map(args, \arg -> arg.exp)), ruScExp2s);
			short = strGlue(arg_strs,  " " + args[0].op + " ");
			if (!too_long(short)) {
				"(" + short + ")";
			} else {
				"(\n" + strIndent(strGlue(arg_strs, args[0].op + "\n")) + "\n)";
			}
		}
		ScPrefixOp(op, ex): op + ruScExp2s(ex);
		ScCall(fn, args): {
			fn_str = ruScExp2s(fn);
			arg_strs = map(args, ruScExp2s);
			short_args = strGlue(map(args, ruScExp2s),", ");
			if (!too_long(short_args)) {
				fn_str + "(" + short_args + ")";
			} else {
				fn_str + "(\n" + strIndent(strGlue(map(args, ruScExp2s),",\n")) + "\n)";
			}
		}
		ScCond(cond, pos, neg): {
			cond_str = ruScExp2s(cond);
			pos_str = ruScExp2s(pos);
			neg_str = ruScExp2s(neg);
			if (!too_long(cond_str)) {
				if (!too_long(pos_str) && !too_long(neg_str)) {
					"(" + ruScExp2s(cond) + "?" + ruScExp2s(pos) + ":" + ruScExp2s(neg) + ")";
				} else {
					"(" + ruScExp2s(cond) + "?\n" + strIndent(ruScExp2s(pos)) + ":\n" + strIndent(ruScExp2s(neg)) + "\n)";
				}
			} else {
				if (!too_long(pos_str) && !too_long(neg_str)) {
					"(\n" + strIndent(ruScExp2s(cond)) + "\n?" + ruScExp2s(pos) + ":" + ruScExp2s(neg) + ")";
				} else {
					"(\n" + strIndent(ruScExp2s(cond)) + "\n?\n" + strIndent(ruScExp2s(pos)) + ":\n" + strIndent(ruScExp2s(neg)) + "\n)";
				}
			}
		}
		ScLet(var, ex, scope): {
			ex_str = ruScExp2s(ex);
			if (!too_long(ex_str)) {
				"let " + var + " = " + ex_str + ";\n" + ruScExp2s(scope);
			} else {
				"let " + var + " = \n" + strIndent(ex_str) + "\n;\n" + ruScExp2s(scope);
			}
		}
		ScIndex(ex, ind): {
			ruScExp2s(ex) + "[" + ruScExp2s(ind) + "]";
		}
		ScLambda(args, body): {
			body_str = ruScExp2s(body);
			if (!too_long(body_str)) {
				"\\" + strGlue(args, ", ") + " -> " + ruScExp2s(body);
			} else {
				"\\" + strGlue(args, ", ") + " ->\n" + strIndent(ruScExp2s(body));
			}
		}
		ScArray(arr): {
			arr_strs = map(arr, ruScExp2s);
			short = strGlue(arr_strs,  ", ");
			if (!too_long(short)) {
				"[" + superglue(arr, ruScExp2s, ", ") + "]";
			} else {
				"[\n" + strIndent(superglue(arr, ruScExp2s, ",\n")) + "\n]";
			}
		}
		ScField(ex, field): 
			ruScExp2s(ex) + "." + field;
		ScStruct(name, args): {
			arg_strs = map(args, ruScExp2s);
			short_args = strGlue(map(args, ruScExp2s),", ");
			if (!too_long(short_args)) {
				name + "(" + short_args + ")";
			} else {
				name + "(\n" + strIndent(strGlue(map(args, ruScExp2s),",\n")) + "\n)";
			}
		}
		ScMap(pairs): {
			pairs_str = superglue(pairs, \p -> ruScExp2s(p.first) + "=" + ruScExp2s(p.second), ", ");
			if (!too_long(pairs_str)) {
				"{" + pairs_str + "}";
			} else {
				"{\n" + strIndent(superglue(pairs, \p -> ruScExp2s(p.first) + "=" + ruScExp2s(p.second), ",\n")) + "\n}";
			}
		}
		ScUndefConst():     "undef";
		ScBoolConst(val):   b2s(val);
		ScIntConst(val):    i2s(val);
		ScDoubleConst(val): d2s(val);
		ScStringConst(val): "\"" + val + "\"";
		ScVar(var, access): var + ruScAccessLval2s(access);
		ScExpSeq(seq): {
			"{\n" + strIndent(strGlue(map(seq, ruScExp2s),";\n")) + "\n}";
		}
	}
}

ruScCommTasks(s : ScComm) -> [ScTask] {
	ruDoScCommTasks([], s);
}

ruDoScCommTasks(acc : [ScTask], s : ScComm) -> [ScTask] {
	switch (s) {
		ScCommSeq(seq):               fold(seq, acc, ruDoScCommTasks);
		ScAssign(__,__):          acc;
		ScIf(cond, pos, mneg):    {
			switch (mneg) {
				None():           ruDoScCommTasks(acc, pos);
				Some(neg):        ruDoScCommTasks(ruDoScCommTasks(acc, pos), neg);
			}
		}
		ScWhile(cond, script):    ruDoScCommTasks(acc, script);
		ScOutput(__,__):          acc;
		ScTask(comm, args):       concat(acc, [s]);
		ScAction(__,__):          acc;
	}
}

ruScCommSetTasksFile(script : ScComm, file : string) -> ScComm {
	set_file = \s -> ruScCommSetTasksFile(s, file);
	switch (script) {
		ScCommSeq(seq):               ScCommSeq(map(seq, set_file));
		ScAssign(__,__):          script;
		ScIf(cond, pos, neg):     ScIf(cond, set_file(pos), maybeMap(neg, set_file));
		ScWhile(cond, s):         ScWhile(cond, set_file(s));
		ScOutput(__,__):          script;
		ScTask(comm, args):       ScTask(comm, setTree(args, "file", file));
		ScAction(__,__):          script;
	}
}


ruTask2Json(task : ScTask) -> Json {
	JsonObject([
		Pair("command", JsonString(task.command)),
		Pair("args", JsonArray(map(tree2pairs(task.args), 
			\arg -> JsonObject([
				Pair("key", JsonString(arg.first)),
				Pair("value", JsonString(arg.second))
			])
		)))
	]);
}

ruJson2Task(json : Json) -> Maybe<ScTask> {
	if (exists(["command", "args"], \field -> !jsonObjectHasField(json, field))) None() else {
		Some(ScTask(
			getJsonStringField(json, "command", ""),
			pairs2tree(map(getJsonArrayField(json, "args"), 
				\opt -> Pair(getJsonStringField(opt, "key", ""), getJsonStringField(opt, "value", ""))
			))
		));
	}
}

ruTask2s(task : ScTask) -> string {
	task.command + " " + 
	strGlue(map(tree2pairs(task.args), \p -> 
		if (p.second == "") p.first else p.first + "=" + ruCutLongStringUpTo(p.second, 256)
	), " ") + ";";
}

ruSetNoLogging(task : ScTask) -> ScTask {
	ScTask(task with args = setTree(task.args, "do_not_log_this", ""));
}

ruSetScCommTaskArg(script : ScComm, key : string, val : string) -> ScComm {
	rec_set = \s -> ruSetScCommTaskArg(s, key, val);
	switch (script) {
		ScCommSeq(seq):            ScCommSeq(map(seq, rec_set));
		ScAssign(__,__):       script;
		ScIf(cond, pos, neg):  ScIf(cond, rec_set(pos), maybeMap(neg, rec_set));
		ScWhile(cond, s):      ScWhile(cond, rec_set(s));
		ScOutput(__,__):       script;
		ScTask(comm, args):    ScTask(comm, setTree(args, key, val));
		ScAction(__,__):       script;
	}
}

ruScExpVars(acc : Set<string>, e : ScExp) -> Set<string> {
	switch (e) {
		ScInfixOp(ex, args): 
			fold(args, ruScExpVars(acc, ex), \ac, arg -> ruScExpVars(ac, arg.exp));
		ScPrefixOp(op, ex): ruScExpVars(acc, ex);
		ScCall(fn, args): 
			fold(args, ruScExpVars(acc, fn), ruScExpVars);
		ScCond(cond, pos, neg): 
			fold([cond, pos, neg], acc, ruScExpVars);
		ScLet(var, ex, scope):
			removeSet(ruScExpVars(acc, scope), var);
		ScIndex(ex, ind):
			ruScExpVars(ruScExpVars(acc, ex), ind);
		ScLambda(args, body):
			filterSet(ruScExpVars(acc, body), \v -> findiDef(args, \arg -> arg == v, -1) == -1);
		ScArray(arr):
			fold(arr, acc ,ruScExpVars);
		ScMap(pairs):
			fold(pairs, acc, \ac, p -> ruScExpVars(ruScExpVars(ac, p.first), p.second));
		ScField(ex, __):
			ruScExpVars(acc, ex);
		ScStruct(name, args): 
			fold(args, acc, ruScExpVars);
		ScUndefConst():     acc;
		ScBoolConst(val):   acc;
		ScIntConst(val):    acc;
		ScDoubleConst(val): acc;
		ScStringConst(val): acc;
		ScVar(var,__):      insertSet(acc, var);
		ScExpSeq(seq):      fold(seq, acc ,ruScExpVars);
	}
}
