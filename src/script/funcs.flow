import ds/tree;
import script/value;
import script/script;

export {
	ruEval(ex : ScExp, state : Tree<string, ValValue>) -> Maybe<ValValue>;
}

ScriptFn(
	fn : ([ValValue]) -> Maybe<ValValue>
);

ru_script_fns : ref Maybe< Tree<string, ScriptFn>> = ref None();

ruHasStringArg(args : [ValValue]) -> bool {
	exists(args, \arg -> 
		switch (arg) {
			ValString(__): true;
			default: false;
		}
	);
}

ruScriptFns() -> Tree<string, ScriptFn> {
	init_script_fns = \-> pairs2tree([
		Pair("+", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringFn(args, \as -> Some(fold(as, "",  \acc, a -> acc + a)));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntFn(args,   \as -> Some(fold(as, 0,    \acc, a -> acc + a)));
					ValDouble(__): ruEvalDoubleFn(args, \as -> Some(fold(as, 0.0, \acc, a -> acc + a)));
					default: None();
				}
			}
		})),
		Pair("*", ScriptFn(\args -> 
			switch (args[0]) {
				ValInt(__):    ruEvalIntFn(args,    \as -> Some(fold(as, 1,   \acc, a -> acc * a)));
				ValDouble(__): ruEvalDoubleFn(args, \as -> Some(fold(as, 1.0, \acc, a -> acc * a)));
				default: None();
			}
		)),
		Pair("-", ScriptFn(\args -> 
			switch (args[0]) {
				ValInt(v):  {
					if (length(args) == 1) Some(ValInt(-v)) else
					ruEvalIntFn(args,    \as -> if (length(as) != 2) None() else Some(as[0] - as[1]));
				}
				ValDouble(v): {
					if (length(args) == 1) Some(ValDouble(-v)) else
					ruEvalDoubleFn(args, \as -> if (length(as) != 2) None() else Some(as[0] - as[1]));
				}
				default: None();
			}
		)),
		Pair("/", ScriptFn(\args -> 
			switch (args[0]) {
				ValInt(v): 
					ruEvalIntFn(args, \as -> if (length(as) != 2 || as[1] == 0) None() else Some(as[0] / as[1]));
				ValDouble(v):
					ruEvalDoubleFn(args, \as -> if (length(as) != 2 || as[1] == 0.0) None() else Some(as[0] / as[1]));
				default: None();
			}
		)),
		Pair("%", ScriptFn(\args -> 
			switch (args[0]) {
				ValInt(v): 
					ruEvalIntFn(args, \as -> if (length(as) != 2 || as[1] == 0) None() else Some(as[0] % as[1]));
				ValDouble(v):
					ruEvalDoubleFn(args, \as -> if (length(as) != 2 || as[1] == 0.0) None() else Some(as[0] % as[1]));
				default: None();
			}
		)),
		Pair("&&", ScriptFn(\args -> 
			switch (args[0]) {
				ValBool(__): ruEvalBinaryBoolFn(args, \a, b -> a && b);
				default: None();
			}
		)),
		Pair("||", ScriptFn(\args -> 
			switch (args[0]) {
				ValBool(__): ruEvalBinaryBoolFn(args, \a, b -> a || b);
				default: None();
			}
		)),
		Pair("!", ScriptFn(\args -> 
			switch (args[0]) {
				ValBool(v): Some(ValBool(!v));
				default: None();
			}
		)),
		Pair("==", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] == as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] == as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] == as[1]));
					default: None();
				}
			}
		})),
		Pair("!=", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] != as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] != as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] != as[1]));
					default: None();
				}
			}
		})),
		Pair("<=", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] <= as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] <= as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] <= as[1]));
					default: None();
				}
			}
		})),
		Pair(">=", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] >= as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] >= as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] >= as[1]));
					default: None();
				}
			}
		})),
		Pair("<", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] < as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] < as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] < as[1]));
					default: None();
				}
			}
		})),
		Pair(">", ScriptFn(\args -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] > as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] > as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] > as[1]));
					default: None();
				}
			}
		})),
	]);
	onlyOnce(ru_script_fns, init_script_fns);
}

ruEval(ex : ScExp, state : Tree<string, ValValue>) -> Maybe<ValValue> {
	switch (ex) {
		ScInfixOp(e, args): {
			vals = filtermap(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state)
			);
			if (length(vals) != length(args) + 1) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), args[0].op),
					\func -> func.fn(vals)
				);
			}
		}
		ScPrefixOp(op, e): {
			maybeBind2(\func, val -> func.fn([val]))
			(
				lookupTree(ruScriptFns(), op),
				ruEval(e, state)
			);
		}
		ScFunc(fn, args): {
			vals = filtermap(args, \arg -> ruEval(arg, state));
			if (length(vals) != length(args)) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), fn),
					\func -> func.fn(vals)
				);
			}
		}
		ScIntConst(val): Some(ValInt(val));
		ScDoubleConst(val): Some(ValDouble(val));
		ScStringConst(val): Some(ValString(val));
		ScVar(var): lookupTree(state, var);
	}
}

ruEvalBinaryBoolFn(args : [ValValue], fn : (bool, bool) -> bool) -> Maybe<ValValue> {
	bool_args = filtermap(args, \arg -> 
		switch (arg) {
			ValBool(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(bool_args) || length(bool_args) != 2) None() else {
		Some(ValBool(fn(bool_args[0], bool_args[0])));
	}
}

ruEvalIntFn(args : [ValValue], fn : ([int]) -> Maybe<int>) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		maybeMap(fn(int_args), \val -> ValInt(val));
	}
}

ruEvalStringFn(args : [ValValue], fn : ([string]) -> Maybe<string>) -> Maybe<ValValue> {
	str_args = map(args, ruValue2s);
	maybeMap(fn(str_args), \val -> ValString(val));
}

ruEvalDoubleFn(args : [ValValue], fn : ([double]) -> Maybe<double>) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		maybeMap(fn(double_args), \val -> ValDouble(val));
	}
}

ruEvalIntPred(args : [ValValue], fn : ([int]) -> Maybe<bool>) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		maybeMap(fn(int_args), \val -> ValBool(val));
	}
}

ruEvalStringPred(args : [ValValue], fn : ([string]) -> Maybe<bool>) -> Maybe<ValValue> {
	str_args = map(args, ruValue2s);
	maybeMap(fn(str_args), \val -> ValBool(val));
}

ruEvalDoublePred(args : [ValValue], fn : ([double]) -> Maybe<bool>) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		maybeMap(fn(double_args), \val -> ValBool(val));
	}
}
