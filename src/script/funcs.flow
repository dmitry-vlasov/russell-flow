import ds/tree;
import base/conf;
import script/value;
import script/script;

export {
	ruEval(ex : ScExp, state : Tree<string, ValValue>, conf : RuConf) -> Maybe<ValValue>;
}

ScriptFn(
	fn : ([ValValue], conf : RuConf) -> Maybe<ValValue>
);

ru_script_fns : ref Maybe< Tree<string, ScriptFn>> = ref None();

ruHasStringArg(args : [ValValue]) -> bool {
	exists(args, \arg -> 
		switch (arg) {
			ValString(__): true;
			default: false;
		}
	);
}

ruScriptFns() -> Tree<string, ScriptFn> {
	init_script_fns = \-> pairs2tree([
		Pair("+", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringFn(args, \as -> Some(fold(as, "",  \acc, a -> acc + a)));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntFn(args,   \as -> Some(fold(as, 0,    \acc, a -> acc + a)));
					ValDouble(__): ruEvalDoubleFn(args, \as -> Some(fold(as, 0.0, \acc, a -> acc + a)));
					default: None();
				}
			}
		})),
		Pair("*", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValInt(__):    ruEvalIntFn(args,    \as -> Some(fold(as, 1,   \acc, a -> acc * a)));
				ValDouble(__): ruEvalDoubleFn(args, \as -> Some(fold(as, 1.0, \acc, a -> acc * a)));
				default: None();
			}
		)),
		Pair("-", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValInt(v):  {
					if (length(args) == 1) Some(ValInt(-v)) else
					ruEvalIntFn(args,    \as -> if (length(as) != 2) None() else Some(as[0] - as[1]));
				}
				ValDouble(v): {
					if (length(args) == 1) Some(ValDouble(-v)) else
					ruEvalDoubleFn(args, \as -> if (length(as) != 2) None() else Some(as[0] - as[1]));
				}
				default: None();
			}
		)),
		Pair("/", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValInt(v): 
					ruEvalIntFn(args, \as -> if (length(as) != 2 || as[1] == 0) None() else Some(as[0] / as[1]));
				ValDouble(v):
					ruEvalDoubleFn(args, \as -> if (length(as) != 2 || as[1] == 0.0) None() else Some(as[0] / as[1]));
				default: None();
			}
		)),
		Pair("%", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValInt(v): 
					ruEvalIntFn(args, \as -> if (length(as) != 2 || as[1] == 0) None() else Some(as[0] % as[1]));
				ValDouble(v):
					ruEvalDoubleFn(args, \as -> if (length(as) != 2 || as[1] == 0.0) None() else Some(as[0] % as[1]));
				default: None();
			}
		)),
		Pair("&&", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValBool(__): ruEvalBinaryBoolFn(args, \a, b -> a && b);
				default: None();
			}
		)),
		Pair("||", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValBool(__): ruEvalBinaryBoolFn(args, \a, b -> a || b);
				default: None();
			}
		)),
		Pair("!", ScriptFn(\args, conf -> 
			switch (args[0]) {
				ValBool(v): Some(ValBool(!v));
				default: None();
			}
		)),
		Pair("==", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] == as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] == as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] == as[1]));
					default: None();
				}
			}
		})),
		Pair("!=", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] != as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] != as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] != as[1]));
					default: None();
				}
			}
		})),
		Pair("<=", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] <= as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] <= as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] <= as[1]));
					default: None();
				}
			}
		})),
		Pair(">=", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] >= as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] >= as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] >= as[1]));
					default: None();
				}
			}
		})),
		Pair("<", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] < as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] < as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] < as[1]));
					default: None();
				}
			}
		})),
		Pair(">", ScriptFn(\args, conf -> {
			if (ruHasStringArg(args)) {
				ruEvalStringPred(args, \as -> if (length(as) != 2) None() else Some(as[0] > as[1]));
			} else {
				switch (args[0]) {
					ValInt(__):    ruEvalIntPred(args,    \as -> if (length(as) != 2) None() else Some(as[0] > as[1]));
					ValDouble(__): ruEvalDoublePred(args, \as -> if (length(as) != 2) None() else Some(as[0] > as[1]));
					default: None();
				}
			}
		})),
		Pair("cwd", ScriptFn(\args, conf ->
			if (length(args) != 0) None() else {
				Some(ValString(ruCurrentWorkingDir()))
			}
		)),
	]);
	onlyOnce(ru_script_fns, init_script_fns);
}

ruEval(ex : ScExp, state : Tree<string, ValValue>, conf : RuConf) -> Maybe<ValValue> {
	switch (ex) {
		ScInfixOp(e, args): {
			vals = filtermap(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state, conf)
			);
			if (length(vals) != length(args) + 1) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), args[0].op),
					\func -> func.fn(vals, conf)
				);
			}
		}
		ScPrefixOp(op, e): {
			maybeBind2(\func, val -> func.fn([val], conf))
			(
				lookupTree(ruScriptFns(), op),
				ruEval(e, state, conf)
			);
		}
		ScFunc(fn, args): {
			vals = filtermap(args, \arg -> ruEval(arg, state, conf));
			if (length(vals) != length(args)) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), fn),
					\func -> func.fn(vals, conf)
				);
			}
		}
		ScBoolConst(val): Some(ValBool(val));
		ScIntConst(val): Some(ValInt(val));
		ScDoubleConst(val): Some(ValDouble(val));
		ScStringConst(val): Some(ValString(val));
		ScVar(var): {
			switch (lookupTree(state, var)) {
				Some(val): Some(val);
				None(): {
					switch (lookupTree(conf.opts, var)) {
						Some(val): Some(ValString(val));
						None(): {
							if (var == "working-dir") {
								Some(ValString(conf.workingDir));
							} else if (var == "verbose") {
								Some(ValInt(conf.verbose));
							} else if (var == "import-roots") {
								Some(ValArray(map(conf.importRoots, \r -> ValString(r))));
							} else if (var == "project-roots") {
								Some(ValArray(map(conf.projectRoots, \r -> ValString(r))));
							} else {
								None();
							}
						}
					}
				}
			}
		}
	}
}

ruEvalBinaryBoolFn(args : [ValValue], fn : (bool, bool) -> bool) -> Maybe<ValValue> {
	bool_args = filtermap(args, \arg -> 
		switch (arg) {
			ValBool(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(bool_args) || length(bool_args) != 2) None() else {
		Some(ValBool(fn(bool_args[0], bool_args[0])));
	}
}

ruEvalIntFn(args : [ValValue], fn : ([int]) -> Maybe<int>) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		maybeMap(fn(int_args), \val -> ValInt(val));
	}
}

ruEvalStringFn(args : [ValValue], fn : ([string]) -> Maybe<string>) -> Maybe<ValValue> {
	str_args = map(args, ruValue2s);
	maybeMap(fn(str_args), \val -> ValString(val));
}

ruEvalDoubleFn(args : [ValValue], fn : ([double]) -> Maybe<double>) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		maybeMap(fn(double_args), \val -> ValDouble(val));
	}
}

ruEvalIntPred(args : [ValValue], fn : ([int]) -> Maybe<bool>) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		maybeMap(fn(int_args), \val -> ValBool(val));
	}
}

ruEvalStringPred(args : [ValValue], fn : ([string]) -> Maybe<bool>) -> Maybe<ValValue> {
	str_args = map(args, ruValue2s);
	maybeMap(fn(str_args), \val -> ValBool(val));
}

ruEvalDoublePred(args : [ValValue], fn : ([double]) -> Maybe<bool>) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		maybeMap(fn(double_args), \val -> ValBool(val));
	}
}
