import ds/tree;
import script/value;
import script/script;

export {
	ruEval(ex : ScExp, state : Tree<string, ValValue>) -> Maybe<ValValue>;
}

ScriptFn(
	fn : ([ValValue]) -> Maybe<ValValue>
);

ru_script_fns : ref Maybe< Tree<string, ScriptFn>> = ref None();

ruScriptFns() -> Tree<string, ScriptFn> {
	init_script_fns = \-> pairs2tree([
		Pair("+", ScriptFn(\args -> 
			switch (args[0]) {
				ValInt(__):    ruEvalIntFn(args, \as -> fold(as, 0, \acc, a -> acc + a));
				ValDouble(__): ruEvalDoubleFn(args, \as -> fold(as, 0.0, \acc, a -> acc + a));
				ValString(__): ruEvalStringFn(args, \as -> fold(as, "", \acc, a -> acc + a));
				default: None();
			}
		)),
		Pair("*", ScriptFn(\args -> 
			switch (args[0]) {
				ValInt(__):    ruEvalIntFn(args, \as -> fold(as, 1, \acc, a -> acc * a));
				ValDouble(__): ruEvalDoubleFn(args, \as -> fold(as, 1.0, \acc, a -> acc * a));
				default: None();
			}
		)),
	]);
	onlyOnce(ru_script_fns, init_script_fns);
}

ruEval(ex : ScExp, state : Tree<string, ValValue>) -> Maybe<ValValue> {
	switch (ex) {
		ScInfixOp(e, args): {
			vals = filtermap(
				concat([e], map(args, \arg -> arg.exp)), 
				\arg -> ruEval(arg, state)
			);
			if (length(vals) != length(args) + 1) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), args[0].op),
					\func -> func.fn(vals)
				);
			}
		}
		ScPrefixOp(op, e): {
			maybeBind2(\func, val -> func.fn([val]))
			(
				lookupTree(ruScriptFns(), op),
				ruEval(e, state)
			);
		}
		ScFunc(fn, args): {
			vals = filtermap(args, \arg -> ruEval(arg, state));
			if (length(vals) != length(args)) None() else {
				maybeBind(
					lookupTree(ruScriptFns(), fn),
					\func -> func.fn(vals)
				);
			}
		}
		ScIntConst(val): Some(ValInt(val));
		ScDoubleConst(val): Some(ValDouble(val));
		ScStringConst(val): Some(ValString(val));
		ScVar(var): lookupTree(state, var);
	}
}

ruEvalIntFn(args : [ValValue], fn : ([int]) -> int) -> Maybe<ValValue> {
	int_args = filtermap(args, \arg -> 
		switch (arg) {
			ValInt(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(int_args)) None() else {
		Some(ValInt(fn(int_args)));
	}
}

ruEvalStringFn(args : [ValValue], fn : ([string]) -> string) -> Maybe<ValValue> {
	str_args = filtermap(args, \arg -> 
		switch (arg) {
			ValString(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(str_args)) None() else {
		Some(ValString(fn(str_args)));
	}
}

ruEvalDoubleFn(args : [ValValue], fn : ([double]) -> double) -> Maybe<ValValue> {
	double_args = filtermap(args, \arg -> 
		switch (arg) {
			ValDouble(v): Some(v);
			default: None();
		}
	);
	if (length(args) != length(double_args)) None() else {
		Some(ValDouble(fn(double_args)));
	}
}