import lingo/pegcode/driver;
import base/util/parse;
import command;

export {
    ruParseScriptDoc(name : string, doc : string) -> RuCommDescr;
}

ru_script_doc_parser = compilePegGrammar("#include script/doc.lingo");

ruParseScriptDoc(name : string, doc : string) -> RuCommDescr {
    descr = ref RuCommDescr(changeFileExt(name, ""), "", "", "", false, []);
    tr = \s -> trim2(s, " \t\r\n");
    ruParsic(ru_script_doc_parser, doc, 
            SemanticActions(mergeTree(defaultPegActions.t, 
            pairs2tree([
                Pair("addHelp", \s -> {
                    descr := RuCommDescr(^descr with help = (^descr).help + " " + tr(s[0])); 0;
                }),
                Pair("addDefarg", \s -> {
                    descr := RuCommDescr(^descr with defarg = tr(s[0])); 0;
                }),
                Pair("addCategory", \s -> {
                    descr := RuCommDescr(^descr with category = tr(s[0])); 0;
                }),
                Pair("addArgWDefval", \s -> {
                    arg_name   = tr(s[0]);
                    arg_body_1 = tr(s[1]);
                    defval     = tr(s[2]);
                    arg_body_2 = tr(s[3]);
                    arg = RuCommArg(
                        arg_name, true, 
                        strReplace(arg_body_1 + arg_body_2, "@optional", ""),
                        defval
                    );
                    descr := RuCommDescr(^descr with args = concat((^descr).args, [arg])); 0;
                }),
                Pair("addArg", \s -> {
                    arg_name = tr(s[0]);
                    arg_body = tr(s[1]);
                    arg = RuCommArg(
                        arg_name, 
                        strContains(arg_body, "@optional"), 
                        strReplace(arg_body, "@optional", ""),
                        ""
                    );
                    descr := RuCommDescr(^descr with args = concat((^descr).args, [arg])); 0;
                })
            ])
        ))
    );
    ^descr;
}
