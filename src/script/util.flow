import script/value;

export {
	ruEvalValueFn(args : [ScValue], fn : ([ScValue]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalBoolFn(args : [ScValue], fn : ([bool]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalIntFn(args : [ScValue], fn : ([int]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalToStringFn(args : [ScValue], fn : ([string]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalStringFn(args : [ScValue], fn : ([string]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalDoubleFn(args : [ScValue], fn : ([double]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalArrayFn(args : [ScValue], fn : ([[ScValue]]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalTreeFn(args : [ScValue], fn : ([Tree<ScValue, ScValue>]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
	ruEvalDataFn(args : [ScValue], fn : ([ScData]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue;
}

ruEvalValueFn(args : [ScValue], fn : ([ScValue]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	if (arity >= 0 && length(args) != arity) {
		ruEvalArityError(args, sign, arity);
	} else {
		switch (fn(args)) {
			Some(v): v;
			None(): ruEvalComputeError(args, sign);
		}
	}
}

ruEvalBoolFn(args : [ScValue], fn : ([bool]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterBoolArgs(args)) {
		Some(bool_args): {
			if (arity >=0 && length(bool_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(bool_args)) {
					Some(v): v;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "bool"); 
		}
	}
}

ruEvalIntFn(args : [ScValue], fn : ([int]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterIntArgs(args)) {
		Some(int_args): {
			if (arity >=0 && length(int_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(int_args)) {
					Some(v): v;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "int"); 
		}
	}
}

ruEvalToStringFn(args : [ScValue], fn : ([string]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	str_args = map(args, ruScValue2s);
	if (arity >=0 && length(str_args) != arity) {
		ruEvalArityError(args, sign, arity);
	} else {
		switch (fn(str_args)) {
			Some(val): val;
			None(): ruEvalComputeError(args, sign);
		}
	}
}

ruEvalStringFn(args : [ScValue], fn : ([string]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterStringArgs(args)) {
		Some(str_args): {
			if (arity >=0 && length(str_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(str_args)) {
					Some(val): val;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "string"); 
		}
	}
}

ruEvalDoubleFn(args : [ScValue], fn : ([double]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterDoubleArgs(args)) {
		Some(double_args): {
			if (arity >=0 && length(double_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(double_args)) {
					Some(val): val;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "double"); 
		}
	}
}

ruEvalArrayFn(args : [ScValue], fn : ([[ScValue]]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterArrayArgs(args)) {
		Some(arr_args): {
			if (arity >=0 && length(arr_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(arr_args)) {
					Some(v): v;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "array"); 
		}
	}
}

ruEvalTreeFn(args : [ScValue], fn : ([Tree<ScValue, ScValue>]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterMapArgs(args)) {
		Some(map_args): {
			if (arity >=0 && length(map_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(map_args)) {
					Some(v): v;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "map");
		}
	}
}

ruEvalDataFn(args : [ScValue], fn : ([ScData]) -> Maybe<ScValue>, sign : string, arity : int) -> ScValue {
	switch (ruFilterDataArgs(args)) {
		Some(data_args): {
			if (arity >=0 && length(data_args) != arity) {
				ruEvalArityError(args, sign, arity);
			} else {
				switch (fn(data_args)) {
					Some(v): v;
					None(): ruEvalComputeError(args, sign);
				}
			}
		}
		None(): {
			ruEvalArgTypeError(args, sign, "map");
		}
	}
}

