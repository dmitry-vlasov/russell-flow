import tools/flowc/eval;
import tools/flowc/flowc_local;
import tools/flowc/manipulation/tail_call;
import base/dir;

export {
	RuRuntime ::= RuRuntimeGlobals, RuRuntimeError;
		RuRuntimeGlobals(globals : HashMap<string, FcEvalGlobal>);
		RuRuntimeError(message : string);

	ruInitRuntime() -> RuRuntime;
}

/*
// Setup the global variables and toplevel functions
	fcInitEvalGlobals(program: FiProgram, onError : (string) -> void, env : FcTypeEnvGlobal) -> HashMap<string, FcEvalGlobal>;

	// Perform the evaluation of function 'name'.
	// Returns the return value, if no errors occur, or 'flow()' as a return value for a runtime error.
	fcCallFunction(name : string, args : [flow], globals : HashMap<string, FcEvalGlobal>) -> flow;
*/

ruRuntimeGlobals : ref Maybe<HashMap<string, FcEvalGlobal>> = ref None();

ruInitRuntime() -> RuRuntime {
	russell_dir = getRussellDir();
	src_dir = pathCombine(russell_dir, "src");
	switch (getCompilerConfig(src_dir)) {
		Failed(msg): RuRuntimeError(msg);
		Some(config0): {
			config = CompilerConfig(config0 with 
				flowfile = "russell.flow",
				includes = concat(config0.includes, [src_dir])
			);
			globEnv = initFcTypeEnvGlobal();
			ensureIncrementalDirectoryExists(config);
			pair = parseAndTypecheckProgram(config, globEnv, config.flowfile);
			program = deadFiCode(pair.first, collectFiEffects(pair.first), makeSet1("for"), makeSet(), false, true, config.verbose);
			optimized = fcOptimizeTailCalls(program);
			errs = ref if (pair.second != 0) "Some errors while loaging of 'russell.flow'" else "";
			onError = \err -> {
				if (^errs == "") {
					errs := err;
				} else {
					errs := ^errs + "\n" + err;
				}
			}
			globals = fcInitEvalGlobals(optimized, onError, globEnv);
			if (^errs != "") {
				RuRuntimeError(^errs);
			} else {
				RuRuntimeGlobals(globals);
			}
		}
	}
}
