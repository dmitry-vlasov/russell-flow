import script/func;
import script/util;

export {
	ruScriptUtilFuncs() -> [ScriptFn];
}

ruScriptUtilFuncs() -> [ScriptFn] {
	[
		ScriptFn("cwd", \args, state, out -> 
			ruEvalValueFn(args, \as -> Some(scStringVal(ruCurrentWorkingDir())),  "cwd", 0)
		),
		ScriptFn("arr", \args, state, out -> {
			type = if (length(args) == 0) scAnyType else scArrayType(args[0].type);
			if (ruAllArgsAreOfSameType(args)) ScValue(args, type) else 
			ScValue(["array must be constructed of elements of the same type, actual arguments: " + ruScValues2s(args)], scErrorType)
		}),
		ScriptFn("map", \args, state, out -> {
			unzipped = unzipi(args, \i,__ -> i % 2 == 0);
			if (!ruAllArgsAreOfSameType(unzipped.first)) {
				ScValue(["keys of a map must be constructed of elements of the same type, actual keys: " + ruScValues2s(unzipped.first)], scErrorType);
			} else if (!ruAllArgsAreOfSameType(unzipped.second)) {
				ScValue(["values of a map must be constructed of elements of the same type, actual keys: " + ruScValues2s(unzipped.second)], scErrorType);
			} else {
				key_type = if (length(unzipped.first) == 0) scAnyType else unzipped.first[0].type;
				val_type = if (length(unzipped.second) == 0) scAnyType else unzipped.second[0].type;
				ScValue(
					pairs2tree(zipWith(unzipped.first, unzipped.second, \k, v -> Pair(k, v))),
					scMapType(key_type, val_type)
				);
			}
		}),
		ScriptFn("isdef", \args, state, out ->
			ruEvalValueFn(args, \as -> Some(scBoolVal(scTypeGen(as[0].type) != "undef")), "isdef", 1)
		),
		ScriptFn("mem2s", \args, state, out ->
			ruEvalDoubleFn(args, \as -> Some(scStringVal(memory2s(as[0]))),  "mem2s", 1)
		),
		ScriptFn("ass2s", \args, state, out ->
			if (length(args) != 1) {
				ScValue(["ass2s function must take exactly one argument, actual arguments: " + ruScValues2s(args)], scErrorType);
			} else {
				arg = args[0];
				type = scTypeGen(arg.type);
				if (type == "string") {
					name = cast(arg.val : flow -> string);
					math = ruMathFromSources(state.ru, RuEnv(state.conf, out));
					switch (lookupTree(math.decls.assertions, s2id(name))) {
						Some(ass): scStringVal(ru2s(ass, math));
						None(): scUndefVal;
					}
				} else if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem"], type)) {
					ScValue(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem"], scErrorType);
				} else {
					ass = cast(arg.val : flow -> RuAssertion);
					math = ruMathFromSources(state.ru, RuEnv(state.conf, out));
					scStringVal(ru2s(ass, math));
				}
			}
		),
		ScriptFn("declSource", \args, state, out ->
			if (length(args) != 1) {
				ScValue(["declSource function must take exactly one argument, actual arguments: " + ruScValues2s(args)], scErrorType);
			} else {
				arg = args[0];
				type = scTypeGen(arg.type);
				if (type == "string") {
					name = cast(arg.val : flow -> string);
					env = RuEnv(state.conf, out);
					math = ruMathFromSources(state.ru, RuEnv(state.conf, out));
					switch (ruFindDecl(s2id_(name), math.decls, env)) {
						Some(decl): scStringVal(id2s(decl.info.src));
						None(): scUndefVal;
					}
				} else if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem"], type)) {
					ScValue(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem"], scErrorType);
				} else {
					decl = cast(arg.val : flow -> RuDecl);
					scStringVal(id2s(decl.info.src));
				}
				/*switch (args[0]) {
					ScData(type, data): {
						if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem", "RuDecl", "RuConst", "RuType", "RuRule"], type)) {
							ScError(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem, RuDecl, RuConst, RuType, RuRule"]);
						} else {
							decl = cast(data : flow -> RuDecl);
							scStringVal(id2s(decl.info.src));
						}
					}
					scStringVal(name): {
						env = RuEnv(state.conf, out);
						math = ruMathFromSources(state.ru, env);
						switch (ruFindDecl(s2id_(name), math.decls, env)) {
							Some(decl): scStringVal(id2s(decl.info.src));
							None(): ScUndef();
						}
					}
					default: ScUndef();
				}*/
			}
		),
	]
}
