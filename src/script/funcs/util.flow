import script/func;
import script/util;

export {
	ruScriptUtilFuncs() -> [ScriptFn];
}

ruScriptUtilFuncs() -> [ScriptFn] {
	[
		ScriptFn("cwd", \args, state, out -> 
			ruEvalValueFn(args, \as -> Some(ScString(ruCurrentWorkingDir())),  "cwd", 0)
		),
		ScriptFn("arr", \args, state, out ->
			if (ruAllArgsAreOfSameType(args)) ScArray(args) else 
			ScError(["array must be constructed of elements of the same type, actual arguments: " + ruScValues2s(args)])
		),
		ScriptFn("map", \args, state, out -> {
			unzipped = unzipi(args, \i,__ -> i % 2 == 0);
			if (!ruAllArgsAreOfSameType(unzipped.first)) {
				ScError(["keys of a map must be constructed of elements of the same type, actual keys: " + ruScValues2s(unzipped.first)]);
			} else if (!ruAllArgsAreOfSameType(unzipped.second)) {
				ScError(["values of a map must be constructed of elements of the same type, actual keys: " + ruScValues2s(unzipped.second)]);
			} else {
				ScMap(
					pairs2tree(zipWith(unzipped.first, unzipped.second, \k, v -> Pair(k, v)))
				);
			}
		}),
		ScriptFn("isdef", \args, state, out ->
			ruEvalValueFn(args, \as -> Some(ScBool(!ruScueIsUndef(as[0]))), "isdef", 1)
		),
		ScriptFn("mem2s", \args, state, out ->
			ruEvalDoubleFn(args, \as -> Some(ScString(memory2s(as[0]))),  "mem2s", 1)
		),
		ScriptFn("ass2s", \args, state, out ->
			if (length(args) != 1) {
				ScError(["ass2s function must take exactly one argument, actual arguments: " + ruScValues2s(args)]);
			} else {
				switch (args[0]) {
					ScData(type, data): {
						if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem"], type)) {
							ScError(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem"]);
						} else {
							ass = cast(data : flow -> RuAssertion);
							math = ruMathFromSources(state.ru, RuEnv(state.conf, out));
							ScString(ru2s(ass, math));
						}
					}
					ScString(name): {
						math = ruMathFromSources(state.ru, RuEnv(state.conf, out));
						switch (lookupTree(math.decls.assertions, s2id(name))) {
							Some(ass): ScString(ru2s(ass, math));
							None(): ScUndef();
						}
					}
					default: ScUndef();
				}
			}
		),
		ScriptFn("declSource", \args, state, out ->
			if (length(args) != 1) {
				ScError(["declSource function must take exactly one argument, actual arguments: " + ruScValues2s(args)]);
			} else {
				switch (args[0]) {
					ScData(type, data): {
						if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem", "RuDecl", "RuConst", "RuType", "RuRule"], type)) {
							ScError(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem, RuDecl, RuConst, RuType, RuRule"]);
						} else {
							decl = cast(data : flow -> RuDecl);
							ScString(id2s(decl.info.src));
						}
					}
					ScString(name): {
						env = RuEnv(state.conf, out);
						math = ruMathFromSources(state.ru, env);
						switch (ruFindDecl(s2id_(name), math.decls, env)) {
							Some(decl): ScString(id2s(decl.info.src));
							None(): ScUndef();
						}
					}
					default: ScUndef();
				}
			}
		),
	]
}
