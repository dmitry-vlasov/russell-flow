import script/func;
import script/util;

export {
	ruScriptUtilFuncs() -> [ScriptFn];
}

ruScriptUtilFuncs() -> [ScriptFn] {
	[
		ScriptFn("cwd", \args, state, out -> 
			ruEvalValueFn(args, \as -> Some(ruCurrentWorkingDir()),  "cwd", 0)
		),
		/*ScriptFn("arr", \args, state, out -> {
			if (ruAllArgsAreOfSameType(args)) ScValue(args, type) else 
			ScValue(["array must be constructed of elements of the same type, actual arguments: " + ruScValues2s(args)])
		}),*/
		/*ScriptFn("map", \args, state, out -> {
			unzipped = unzipi(args, \i,__ -> i % 2 == 0);
			if (!ruAllArgsAreOfSameType(unzipped.first)) {
				ScValue(["keys of a map must be constructed of elements of the same type, actual keys: " + ruScValues2s(unzipped.first)]);
			} else if (!ruAllArgsAreOfSameType(unzipped.second)) {
				ScValue(["values of a map must be constructed of elements of the same type, actual keys: " + ruScValues2s(unzipped.second)]);
			} else {
				key_type = if (length(unzipped.first) == 0) scAnyType else unzipped.first[0].type;
				val_type = if (length(unzipped.second) == 0) scAnyType else unzipped.second[0].type;
				ScValue(
					pairs2tree(zipWith(unzipped.first, unzipped.second, \k, v -> Pair(k, v))),
					scMapType(key_type, val_type)
				);
			}
		}),*/
		ScriptFn("isdef", \args, state, out ->
			ruEvalValueFn(args, \as -> Some(runtimeValueType(as[0]) != "RuUndefVal"), "isdef", 1)
		),
		ScriptFn("mem2s", \args, state, out ->
			ruEvalDoubleFn(args, \as -> Some(memory2s(as[0])),  "mem2s", 1)
		),
		ScriptFn("ass2s", \args, state, out ->
			if (length(args) != 1) {
				flow(RuRuntimeError(["ass2s function must take exactly one argument, actual arguments: " + ruScValues2s(args)]));
			} else {
				arg = args[0];
				type = runtimeValueType(arg);
				if (type == "string") {
					name = cast(arg : flow -> string);
					math = ruMathFromSources(state.global.ru, RuEnv(state.global.conf, out));
					switch (lookupTree(math.decls.assertions, s2id(name))) {
						Some(ass): flow(ru2s(ass, math));
						None(): flow(RuUndefVal());
					}
				} else if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem"], type)) {
					flow(RuRuntimeError(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem"]));
				} else {
					ass = cast(arg : flow -> RuAssertion);
					math = ruMathFromSources(state.global.ru, RuEnv(state.global.conf, out));
					flow(ru2s(ass, math));
				}
			}
		),
		ScriptFn("declSource", \args, state, out ->
			if (length(args) != 1) {
				flow(RuRuntimeError(["declSource function must take exactly one argument, actual arguments: " + ruScValues2s(args)]));
			} else {
				arg = args[0];
				type = runtimeValueType(arg.type);
				if (type == "string") {
					name = cast(arg : flow -> string);
					env = RuEnv(state.global.conf, out);
					math = ruMathFromSources(state.global.ru, RuEnv(state.global.conf, out));
					switch (ruFindDecl(s2id_(name), math.decls, env)) {
						Some(decl): flow(id2s(decl.info.src));
						None(): flow(RuUndefVal());
					}
				} else if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem"], type)) {
					flow(RuRuntimeError(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem"]));
				} else {
					decl = cast(arg : flow -> RuDecl);
					flow(id2s(decl.info.src));
				}
				/*switch (args[0]) {
					ScData(type, data): {
						if (!contains(["RuAssertion", "RuAxiom", "RuDef", "RuTheorem", "RuDecl", "RuConst", "RuType", "RuRule"], type)) {
							ScError(["wrong type of data: '" + type + "', must be one of: RuAssertion, RuAxiom, RuDef, RuTheorem, RuDecl, RuConst, RuType, RuRule"]);
						} else {
							decl = cast(data : flow -> RuDecl);
							id2s(decl.info.src));
						}
					}
					name): {
						env = RuEnv(state.conf, out);
						math = ruMathFromSources(state.ru, env);
						switch (ruFindDecl(s2id_(name), math.decls, env)) {
							Some(decl): id2s(decl.info.src));
							None(): ScUndef();
						}
					}
					default: ScUndef();
				}*/
			}
		),
	]
}
