import script/func;
import script/util;

export {
	ruScriptNumericFuncs() -> [ScriptFn];
}

ruScriptNumericFuncs() -> [ScriptFn] {
	[
		ScriptFn("+", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(fold(as, "",  \acc, a -> acc + a)), "+", -1);
			} else {
				arg = args[0];
				arg_type = runtimeValueType(arg);
				if (arg_type == "int")    ruEvalIntFn(args,    \as -> Some(fold(as, 0,    \acc, a -> acc + a)), "+", -1) else
				if (arg_type == "double") ruEvalDoubleFn(args, \as -> Some(fold(as, 0.0, \acc, a -> acc + a)), "+", -1) else
				if (arg_type == "array")  ruEvalArrayFn(args,  \as -> Some(concatA(as)), "+", -1) else
				if (arg_type == "map")    ruEvalTreeFn(args,   \as -> Some(fold(tail(as), as[0], \acc, t -> mergeTree(acc, t))), "+", -1) else
				RuRuntimeError(["operator + is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScInt(fold(as, 0,    \acc, a -> acc + a))), "+", -1);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScDouble(fold(as, 0.0, \acc, a -> acc + a))), "+", -1);
					ScArray(__):  ruEvalArrayFn(args,  \as -> Some(ScArray(concatA(as))), "+", -1);
					ScMap(__):    ruEvalTreeFn(args,   \as -> Some(ScMap(fold(tail(as), as[0], \acc, t -> mergeTree(acc, t)))), "+", -1);
					default: ScError(["operator + is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		}),
		ScriptFn("*", \args, state, out -> {
			first_arg_type = runtimeValueType(args[0].type);
			if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(fold(as, 1,   \acc, a -> acc * a)), "*", -1) else 
			if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(fold(as, 1.0, \acc, a -> acc * a)), "*", -1) else 
			RuRuntimeError(["operator * is undefined on arguments: " + ruScValues2s(args)]);
			/*switch (args[0]) {
				ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScInt(fold(as, 1,   \acc, a -> acc * a))), "*", -1);
				ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScDouble(fold(as, 1.0, \acc, a -> acc * a))), "*", -1);
				default: ScError(["operator * is undefined on arguments: " + ruScValues2s(args)]);
			}*/
		}),
		ScriptFn("-", \args, state, out -> 
			if (length(args) == 1) {
				first_arg_type = runtimeValueType(args[0].type);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(-as[0]), "-", 1) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(-as[0]), "-", 1) else 
				RuRuntimeError(["operator - is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(v):    ScInt(-v);
					ScDouble(v): ScDouble(-v);
					default: ScError(["operator - is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			} else {
				first_arg_type = runtimeValueType(args[0].type);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] - as[1]), "-", 2) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] - as[1]), "-", 2) else 
				RuRuntimeError(["operator - is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(v):    ruEvalIntFn(args,    \as -> Some(ScInt(as[0] - as[1])), "-", 2);
					ScDouble(v): ruEvalDoubleFn(args, \as -> Some(ScDouble(as[0] - as[1])), "-", 2);
					default: ScError(["operator - is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		),
		ScriptFn("/", \args, state, out -> {
			first_arg_type = runtimeValueType(args[0].type);
			if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] / as[1]), "/", 2) else 
			if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] / as[1]), "/", 2) else 
			RuRuntimeError(["operator / is undefined on arguments: " + ruScValues2s(args)]);
			/*switch (args[0]) {
				ScInt(v):    ruEvalIntFn(args, \as -> if (as[1] == 0) None() else Some(ScInt(as[0] / as[1])), "/", 2);
				ScDouble(v): ruEvalDoubleFn(args, \as -> if (as[1] == 0.0) None() else Some(ScDouble(as[0] / as[1])), "/", 2);
				default:  ScError(["operator / is undefined on arguments: " + ruScValues2s(args)]);
			}*/
		}),
		ScriptFn("%", \args, state, out -> {
			first_arg_type = runtimeValueType(args[0].type);
			if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] % as[1]), "%", 2) else 
			if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] % as[1]), "%", 2) else
			RuRuntimeError(["operator % is undefined on arguments: " + ruScValues2s(args)]);
			/*switch (args[0]) {
				ScInt(v):    ruEvalIntFn(args, \as -> if (as[1] == 0) None() else Some(ScInt(as[0] % as[1])), "%", 2);
				ScDouble(v): ruEvalDoubleFn(args, \as -> if (as[1] == 0.0) None() else Some(ScDouble(as[0] % as[1])), "%", 2);
				default: ScError(["operator % is undefined on arguments: " + ruScValues2s(args)]);
			}*/
		}),
	]
}
