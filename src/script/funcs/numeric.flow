import script/func;
import script/util;

export {
	ruScriptNumericFuncs() -> [ScriptFn];
}

ruScriptNumericFuncs() -> [ScriptFn] {
	[
		ScriptFn("+", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(scStringVal(fold(as, "",  \acc, a -> acc + a))), "+", -1);
			} else {
				arg = args[0];
				arg_type = scTypeGen(arg.type);
				if (arg_type == "int")    ruEvalIntFn(args,    \as -> Some(scIntVal(fold(as, 0,    \acc, a -> acc + a))), "+", -1) else
				if (arg_type == "double") ruEvalDoubleFn(args, \as -> Some(scDoubleVal(fold(as, 0.0, \acc, a -> acc + a))), "+", -1) else
				if (arg_type == "array")  ruEvalArrayFn(args,  \as -> Some(ScValue(concatA(as), arg.type)), "+", -1) else
				if (arg_type == "map")    ruEvalTreeFn(args,   \as -> Some(ScValue(fold(tail(as), as[0], \acc, t -> mergeTree(acc, t)), arg.type)), "+", -1) else
				ScValue(["operator + is undefined on arguments: " + ruScValues2s(args)], scErrorType);
				/*switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScInt(fold(as, 0,    \acc, a -> acc + a))), "+", -1);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScDouble(fold(as, 0.0, \acc, a -> acc + a))), "+", -1);
					ScArray(__):  ruEvalArrayFn(args,  \as -> Some(ScArray(concatA(as))), "+", -1);
					ScMap(__):    ruEvalTreeFn(args,   \as -> Some(ScMap(fold(tail(as), as[0], \acc, t -> mergeTree(acc, t)))), "+", -1);
					default: ScError(["operator + is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		}),
		ScriptFn("*", \args, state, out -> {
			first_arg_type = scTypeGen(args[0].type);
			if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(scIntVal(fold(as, 1,   \acc, a -> acc * a))), "*", -1) else 
			if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(scDoubleVal(fold(as, 1.0, \acc, a -> acc * a))), "*", -1) else 
			ScValue(["operator * is undefined on arguments: " + ruScValues2s(args)], scErrorType);
			/*switch (args[0]) {
				ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScInt(fold(as, 1,   \acc, a -> acc * a))), "*", -1);
				ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScDouble(fold(as, 1.0, \acc, a -> acc * a))), "*", -1);
				default: ScError(["operator * is undefined on arguments: " + ruScValues2s(args)]);
			}*/
		}),
		ScriptFn("-", \args, state, out -> 
			if (length(args) == 1) {
				first_arg_type = scTypeGen(args[0].type);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(scIntVal(-as[0])), "-", 1) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(scDoubleVal(-as[0])), "-", 1) else 
				ScValue(["operator - is undefined on arguments: " + ruScValues2s(args)], scErrorType);
				/*switch (args[0]) {
					ScInt(v):    ScInt(-v);
					ScDouble(v): ScDouble(-v);
					default: ScError(["operator - is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			} else {
				first_arg_type = scTypeGen(args[0].type);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(scIntVal(as[0] - as[1])), "-", 2) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(scDoubleVal(as[0] - as[1])), "-", 2) else 
				ScValue(["operator - is undefined on arguments: " + ruScValues2s(args)], scErrorType);
				/*switch (args[0]) {
					ScInt(v):    ruEvalIntFn(args,    \as -> Some(ScInt(as[0] - as[1])), "-", 2);
					ScDouble(v): ruEvalDoubleFn(args, \as -> Some(ScDouble(as[0] - as[1])), "-", 2);
					default: ScError(["operator - is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		),
		ScriptFn("/", \args, state, out -> {
			first_arg_type = scTypeGen(args[0].type);
			if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(scIntVal(as[0] / as[1])), "/", 2) else 
			if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(scDoubleVal(as[0] / as[1])), "/", 2) else 
			ScValue(["operator / is undefined on arguments: " + ruScValues2s(args)], scErrorType);
			/*switch (args[0]) {
				ScInt(v):    ruEvalIntFn(args, \as -> if (as[1] == 0) None() else Some(ScInt(as[0] / as[1])), "/", 2);
				ScDouble(v): ruEvalDoubleFn(args, \as -> if (as[1] == 0.0) None() else Some(ScDouble(as[0] / as[1])), "/", 2);
				default:  ScError(["operator / is undefined on arguments: " + ruScValues2s(args)]);
			}*/
		}),
		ScriptFn("%", \args, state, out -> {
			first_arg_type = scTypeGen(args[0].type);
			if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(scIntVal(as[0] % as[1])), "%", 2) else 
			if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(scDoubleVal(as[0] % as[1])), "%", 2) else
			ScValue(["operator % is undefined on arguments: " + ruScValues2s(args)], scErrorType);
			/*switch (args[0]) {
				ScInt(v):    ruEvalIntFn(args, \as -> if (as[1] == 0) None() else Some(ScInt(as[0] % as[1])), "%", 2);
				ScDouble(v): ruEvalDoubleFn(args, \as -> if (as[1] == 0.0) None() else Some(ScDouble(as[0] % as[1])), "%", 2);
				default: ScError(["operator % is undefined on arguments: " + ruScValues2s(args)]);
			}*/
		}),
	]
}
