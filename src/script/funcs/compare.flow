import script/func;
import script/util;

export {
	ruScriptCompareFuncs() -> [ScriptFn];
}

ruScriptCompareFuncs() -> [ScriptFn] {
	[
		ScriptFn("==", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(ScBool(as[0] == as[1])), "==", 2);
			} else {
				if (!ruAllArgsAreOfSameType(args)) {
					ScError(["comparing values of different types: " + ruScValues2s(args)]);
				} else {
					switch (args[0]) {
						ScBool(__):    ruEvalBoolFn(args,   \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScInt(__):     ruEvalIntFn(args,    \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScDouble(__):  ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScArray(__):   ruEvalArrayFn(args,  \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScMap(__):     ruEvalTreeFn(args,   \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScData(__,__): ruEvalDataFn(args,   \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						default: ScError(["operator == is undefined on arguments: " + ruScValues2s(args)]);
					}
				}
			}
		}),
		ScriptFn("!=", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
			} else {
				if (!ruAllArgsAreOfSameType(args)) {
					ScError(["comparing values of different types: " + ruScValues2s(args)]);
				} else {
					switch (args[0]) {
						ScBool(__):    ruEvalBoolFn(args,   \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScInt(__):     ruEvalIntFn(args,    \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScDouble(__):  ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScArray(__):   ruEvalArrayFn(args,  \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScMap(__):     ruEvalTreeFn(args,   \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScData(__,__): ruEvalDataFn(args,   \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						default: ScError(["operator != is undefined on arguments: " + ruScValues2s(args)]);
					}
				}
			}
		}),
		ScriptFn("<=", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(ScBool(as[0] <= as[1])), "<=", 2);
			} else {
				switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] <= as[1])), "<=", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] <= as[1])), "<=", 2);
					default: ScError(["operator <= is undefined on arguments: " + ruScValues2s(args)]);
				}
			}
		}),
		ScriptFn(">=", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(ScBool(as[0] >= as[1])), ">=", 2);
			} else {
				switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] >= as[1])), ">=", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] >= as[1])), ">=", 2);
					default: ScError(["operator >= is undefined on arguments: " + ruScValues2s(args)]);
				}
			}
		}),
		ScriptFn("<", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(ScBool(as[0] < as[1])), "<", 2);
			} else {
				switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] < as[1])), "<", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] < as[1])), "<", 2);
					default: ScError(["operator < is undefined on arguments: " + ruScValues2s(args)]);
				}
			}
		}),
		ScriptFn(">", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(ScBool(as[0] > as[1])), ">", 2);
			} else {
				switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] > as[1])), ">", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] > as[1])), ">", 2);
					default: ScError(["operator > is undefined on arguments: " + ruScValues2s(args)]);
				}
			}
		}),
	]
}
