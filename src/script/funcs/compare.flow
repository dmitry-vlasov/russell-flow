import script/func;
import script/util;

export {
	ruScriptCompareFuncs() -> [ScriptFn];
}

ruScriptCompareFuncs() -> [ScriptFn] {
	[
		ScriptFn("==", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(as[0] == as[1]), "==", 2);
			} else {
				if (!ruAllArgsAreOfSameType(args)) {
					RuRuntimeError(["comparing values of different types: " + ruScValues2s(args)]);
				} else {
					first_arg_type = runtimeValueType(args[0]);
					if (first_arg_type == "bool")   ruEvalBoolFn(args,   \as -> Some(as[0] == as[1]), "==", 2) else 
					if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] == as[1]), "==", 2) else 
					if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] == as[1]), "==", 2) else 
					if (first_arg_type == "array")  ruEvalArrayFn(args,  \as -> Some(as[0] == as[1]), "==", 2) else 
					if (first_arg_type == "map")    ruEvalTreeFn(args,   \as -> Some(as[0] == as[1]), "==", 2) else 
					//if (first_arg_type == "wrap")   ruEvalDataFn(args,   \as -> Some(as[0] == as[1])), "==", 2) else
					RuRuntimeError(["operator == is undefined on arguments: " + ruScValues2s(args)]);
					/*switch (args[0]) {
						ScBool(__):    ruEvalBoolFn(args,   \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScInt(__):     ruEvalIntFn(args,    \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScDouble(__):  ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScArray(__):   ruEvalArrayFn(args,  \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScMap(__):     ruEvalTreeFn(args,   \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						ScData(__,__): ruEvalDataFn(args,   \as -> Some(ScBool(as[0] == as[1])), "==", 2);
						default: ScError(["operator == is undefined on arguments: " + ruScValues2s(args)]);
					}*/
				}
			}
		}),
		ScriptFn("!=", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(as[0] != as[1]), "!=", 2);
			} else {
				if (!ruAllArgsAreOfSameType(args)) {
					RuRuntimeError(["comparing values of different types: " + ruScValues2s(args)]);
				} else {
					first_arg_type = runtimeValueType(args[0]);
					if (first_arg_type == "bool")   ruEvalBoolFn(args,   \as -> Some(as[0] != as[1]), "!=", 2) else 
					if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] != as[1]), "!=", 2) else 
					if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] != as[1]), "!=", 2) else 
					if (first_arg_type == "array")  ruEvalArrayFn(args,  \as -> Some(as[0] != as[1]), "!=", 2) else 
					if (first_arg_type == "map")    ruEvalTreeFn(args,   \as -> Some(as[0] != as[1]), "!=", 2) else 
					//if (first_arg_type == "wrap")   ruEvalDataFn(args,   \as -> Some(as[0] != as[1])), "!=", 2) else
					RuRuntimeError(["operator != is undefined on arguments: " + ruScValues2s(args)]);
					/*switch (args[0]) {
						ScBool(__):    ruEvalBoolFn(args,   \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScInt(__):     ruEvalIntFn(args,    \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScDouble(__):  ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScArray(__):   ruEvalArrayFn(args,  \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScMap(__):     ruEvalTreeFn(args,   \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						ScData(__,__): ruEvalDataFn(args,   \as -> Some(ScBool(as[0] != as[1])), "!=", 2);
						default: ScError(["operator != is undefined on arguments: " + ruScValues2s(args)]);
					}*/
				}
			}
		}),
		ScriptFn("<=", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(as[0] <= as[1]), "<=", 2);
			} else {
				first_arg_type = runtimeValueType(args[0]);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] <= as[1]), "<=", 2) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] <= as[1]), "<=", 2) else 
				RuRuntimeError(["operator <= is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] <= as[1])), "<=", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] <= as[1])), "<=", 2);
					default: ScError(["operator <= is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		}),
		ScriptFn(">=", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(as[0] >= as[1]), ">=", 2);
			} else {
				first_arg_type = runtimeValueType(args[0]);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] >= as[1]), ">=", 2) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] >= as[1]), ">=", 2) else 
				RuRuntimeError(["operator >= is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] >= as[1])), ">=", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] >= as[1])), ">=", 2);
					default: ScError(["operator >= is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		}),
		ScriptFn("<", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(as[0] < as[1]), "<", 2);
			} else {
				first_arg_type = runtimeValueType(args[0]);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] < as[1]), "<", 2) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] < as[1]), "<", 2) else 
				RuRuntimeError(["operator < is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] < as[1])), "<", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] < as[1])), "<", 2);
					default: ScError(["operator < is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		}),
		ScriptFn(">", \args, state, out -> {
			if (ruHasStringArg(args)) {
				ruEvalToStringFn(args, \as -> Some(as[0] > as[1]), ">", 2);
			} else {
				first_arg_type = runtimeValueType(args[0]);
				if (first_arg_type == "int")    ruEvalIntFn(args,    \as -> Some(as[0] > as[1]), ">", 2) else 
				if (first_arg_type == "double") ruEvalDoubleFn(args, \as -> Some(as[0] > as[1]), ">", 2) else 
				RuRuntimeError(["operator > is undefined on arguments: " + ruScValues2s(args)]);
				/*switch (args[0]) {
					ScInt(__):    ruEvalIntFn(args,    \as -> Some(ScBool(as[0] > as[1])), ">", 2);
					ScDouble(__): ruEvalDoubleFn(args, \as -> Some(ScBool(as[0] > as[1])), ">", 2);
					default: ScError(["operator > is undefined on arguments: " + ruScValues2s(args)]);
				}*/
			}
		}),
	]
}
