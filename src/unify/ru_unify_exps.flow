import ru_subst;

export {
	ruUnifyExps(es : [RuExp], sub : Tree<RuVar, RuExp>, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruUnifySubs(subs : [Tree<RuVar, RuExp>], math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
}

ruUnifyExps(es : [RuExp], sub : Tree<RuVar, RuExp>, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	if (length(es) <= 1) Some(sub) else {
		ruDoUnifyExps(es, RuUnifyAcc(sub, map(es, \__ -> 0), math))
	}
}

RuUnifyAcc(
	sub : Tree<RuVar, RuExp>,
	inds : [int],
	math : RuMath
);

RuUnifyStepAcc(
	shift : [int],
	vars  : [RuVar],
	exprs : [RuExp],
	rule  : string,
	type  : string,
	ok    : bool,
	all_rules : bool
);

ruUnifyStepVar(step : RuUnifyStepAcc, math : RuMath) -> Maybe<RuVar> {
	maybeBind(
		fold(tail(step.vars), Some(step.vars[0]), \acc, v ->
			maybeBind(acc, \t -> 
				if (v.type == t.type || isSome(ruSuperRule(v.type, t.type, math))) Some(v) else
				if (v.type == t.type || isSome(ruSuperRule(t.type, v.type, math))) Some(t) else None()
			)
		),
		\v -> if (step.type == "" || v.type == step.type || isSome(ruSuperRule(v.type, step.type, math))) Some(v) else None()
	)
}

ruDoUnifyStep(es : [RuExp], acc : RuUnifyAcc) -> RuUnifyStepAcc {
	foldi(
		mapi(es, \i, e -> e.nodes[acc.inds[i]]), 
		RuUnifyStepAcc([], [], [], "", "", true, true), 
		\i, ac, n ->
		switch (n) {
			RuVar(__,__): {
				switch (lookupTree(acc.sub, n)) {
					None():
						RuUnifyStepAcc(ac with
							shift = concat(ac.shift, [1]),
							vars = concat(ac.vars, [n]),
							all_rules = false
						);
					Some(ex): {
						m = ex.nodes[0];
						switch (m) {
							RuRuleRef(rule, type, __,len):
								RuUnifyStepAcc(
									concat(ac.shift, [1]),
									ac.vars,
									concat(ac.exprs, [ex]),
									rule, 
									type, 
									ac.ok && (ac.rule == "" || rule == ac.rule),
									false
								);
							RuVar(v, t):
								RuUnifyStepAcc(ac with 
									shift = concat(ac.shift, [1]),
									vars = concat(ac.vars, [m]),
									all_rules = false
								);
						}
					}
				}
			}
			RuRuleRef(rule, type,__, len): {
				RuUnifyStepAcc(
					concat(ac.shift, [len + 1]),
					ac.vars,
					concat(ac.exprs, [RuExp(subrange(es[i].nodes, acc.inds[i], len + 1), es[i].pos)]),
					rule, type, ac.ok && (ac.rule == "" || rule == ac.rule), ac.all_rules
				);
			}
		}
	);
}

ruDoUnifyExps(es : [RuExp], acc : RuUnifyAcc) -> Maybe<Tree<RuVar, RuExp>> {
	if (all(mapi(acc.inds, \i, n -> n == length(es[i].nodes)))) {
		Some(acc.sub) 
	} else {
		step = ruDoUnifyStep(es, acc);
		if (!step.ok) None() else {
			new_inds = \-> mapi(acc.inds, \j, i -> i + step.shift[j]);
			if (step.rule != "") {
				if (!step.all_rules) {
					maybeBind(ruUnifyExps(step.exprs, acc.sub, acc.math), \s -> {
						ex = ruApplySubst(step.exprs[0], s);
						maybeBind(
							fold(step.vars, Some(s), \ac, v -> 
								maybeBind(ac, \s1 -> ruAdd2Subst1(s1, v, ex, acc.math))
							),
							\s1 -> ruDoUnifyExps(es, 
								RuUnifyAcc(acc with 
									sub = s1,
									inds = new_inds()
								)
							)
						);
					});
				} else {
					ruDoUnifyExps(es, RuUnifyAcc(acc with inds = map(acc.inds, \i -> i + 1)));
				}
			} else {
				maybeBind(ruUnifyStepVar(step, acc.math), \w -> {
					ex = RuExp([w], -1);
					maybeBind(
						fold(step.vars, Some(acc.sub), \ac, v -> 
							maybeBind(ac, \s1 -> ruAdd2Subst1(s1, v, ex, acc.math))
						),
						\s1 -> ruDoUnifyExps(es, 
							RuUnifyAcc(acc with
								sub = s1,
								inds = new_inds()
							)
						)
					);
				});
			}
		}
	}
}

ruUnifySubs(subs : [Tree<RuVar, RuExp>], math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	foldSet(
		fold(subs, makeSet(), \acc, s -> mergeSets(acc, buildSet(getTreeKeys(s)))),
		Some(makeTree()), 
		\acc, v ->
			maybeBind(acc, \sub -> {
				exprs = filtermap(subs, \s -> maybeMap(lookupTree(s, v), \e -> ruApplySubst(e, sub)));
				maybeBind(ruUnifyExps(exprs, sub, math), \sub1 -> {
					e1 = ruApplySubst(exprs[0], sub1);
					switch (lookupTree(sub1, v)) {
						None(): ruAdd2Subst1(sub1, v, e1, math);
						Some(e2):
							maybeBind(ruUnifyExps([e1, e2], sub1, math), \unif -> 
								ruCompose(sub1, unif)
							);
					}
				});
			})
	);
}
