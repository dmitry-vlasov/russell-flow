import math/uuid;
import lsp/util;
import lsp/request;
import lsp/args;

import process;

export {
	ruLspProcessRequest(
		conf : RuConf, json : Json,  
		out : (string) ->  void, 
		exit : () -> void, 
		process : (ScScript, (int) -> void, RuOut) -> void
	) -> void;
}

ruLspMethods = pairs2tree([
	Pair("initialize", ruLspInitialize),
	Pair("initialized", ruLspInitialized),
	Pair("shutdown", ruLspShutdown),
	Pair("exit", ruLspExit),
	Pair("textDocument/didOpen", ruLspTextDocumentDidOpen),
	Pair("textDocument/didChange", ruLspTextDocumentDidChange),
	Pair("textDocument/didSave",ruLspTextDocumentDidSave),
	Pair("textDocument/documentSymbol", ruLspTextDocumentDocumentSymbol),
	Pair("textDocument/declaration", ruLspTextDocumentDeclaration),
	Pair("textDocument/definition", ruLspTextDocumentDefinition),
	Pair("textDocument/references", ruLspTextDocumentReferences),
	Pair("textDocument/hover", ruLspTextDocumentHover),
	Pair("textDocument/rename", ruLspTextDocumentRename),
	Pair("textDocument/codeAction", ruLspTextDocumentCodeAction),
	Pair("workspace/symbol", ruLspWorkspaceSymbol),
	Pair("workspace/executeCommand", ruLspWorkspaceExecuteCommand),
]);

RuServerRequest(
	request : LspRequestMessage,
	callback : (LspResponseMessage) -> void
);

RuLspServerState(
	mutable clientConf : Json,
	mutable currId : int,
	mutable requests : Tree<Json, RuServerRequest>
);

ruLspServerState = RuLspServerState(JsonNull(), 1, makeTree());

ruLspErrorResponse(id : Json, code : int, msg : string) -> Json {
	lspResponseMessage2Json(LspResponseMessage("2.0", id, JsonNull(), 
		Some(LspResponseError(code, msg, JsonNull()))
	));
}

ruLspNormalResponse(id : Json, result : Json) -> Json {
	lspResponseMessage2Json(LspResponseMessage("2.0", id, result, None()));
}

ruLspNotification(method : string, params : Json) -> Json {
	lspNotificationMessage2Json(LspNotificationMessage("2.0", method, params));
}

ruLspProcessRequest(
	conf : RuConf, json : Json, 
	out : (string) ->  void, 
	exit : () -> void, 
	process : (ScScript, (int) -> void, RuOut) -> void
) -> void {
	out_cb = \msg -> {
		js_out = json2string(msg);
		js_len = strlen(expandUtf8(js_out));
		out("Content-Length: " + i2s(js_len) + "\r\n\r\n" + js_out);
	}
	switch (json2LspRequestMessage(json)) {
		Some(request): {
			if (request.method == "") {
				out_cb(ruLspErrorResponse(request.id, 1, "request method is not set"));
			} else {
				switch (lookupTree(ruLspMethods, request.method)) {
					Some(m): m(RuLspArgs(conf, request.id, request.params, out_cb, exit, process));
					None(): {
						out_cb(ruLspErrorResponse(request.id, 1, "request method " + request.method + " is not found"));
					}
				}
			}
		}
		None(): {
			switch (json2LspResponseMessage(json)) {
				Some(response): {
					switch (lookupTree(ruLspServerState.requests, response.id)) {
						Some(req): req.callback(response);
						None(): {
							ruLspServerLog("Server: unknown request: " + json2string(response.id), conf);
						}
					}
				}
				None(): {
					out_cb(ruLspErrorResponse(getJsonFieldValue(json, "id", JsonNull()), 1, "illegal request '" + json2string(json) + "'"));
				}
			}
		}
	}
}

ruLspShutdown(call : RuLspArgs) -> void {
	ruLspServerState.clientConf ::= JsonNull();
	ruLspServerState.currId ::= 1;
	ruLspServerState.requests ::= makeTree();
	ruMemCacheClear(); // reset memory cache
	call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
}

ruLspExit(call : RuLspArgs) -> void {
	call.exit_cb();
}

ruMakeServerRequest(method : string, params : Json, out_cb : (Json) -> void, callback : (LspResponseMessage) -> void) -> void {
	request = LspRequestMessage("2.0", JsonDouble(i2d(ruLspServerState.currId)), method, params);
	ruLspServerState.requests ::= setTree(ruLspServerState.requests, request.id, 
		RuServerRequest(request, callback)
	);
	ruLspServerState.currId ::= ruLspServerState.currId + 1;
	out_cb(lspRequestMessage2Json(request));
}

ruLspInitialized(call: RuLspArgs) -> void {
	if (getJsonBoolField(getJsonNestedField(ruLspServerState.clientConf, ["capabilities", "workspace", "didChangeConfiguration"]), "dynamicRegistration", false)) {
		params = lspRegistrationParams2Json(LspRegistrationParams([
			LspRegistration(makeUuid(), "textDocument/didChange", 
				lspTextDocumentChangeRegistrationOptions2Json(
					LspTextDocumentChangeRegistrationOptions([LspDocumentFilter("flow", "file", "*.{flow}")], 1)
				)
			),
			//LspRegistration(makeUuid(), "workspace/executeCommand", ruExecuteCommandOptions)
		]));
		ruMakeServerRequest("client/registerCapability", params, call.out_cb, nop1);
	}
	// It's a notification, no response.
}

ruExecuteCommandOptions = JsonObject([
	Pair("commands", 
		JsonArray([
			JsonString("verify"), 
			JsonString("metamath"),
			JsonString("math-info"),
			JsonString("find-symbol"),
			JsonString("command"),
		])
	),
	Pair("workDoneProgress", JsonBool(true))
]);

ruLspInitialize(call: RuLspArgs) -> void {
	ruLspServerState.clientConf ::= call.params;
	call.out_cb(ruLspNormalResponse(call.id, 
		JsonObject([
			Pair("capabilities", JsonObject([
					Pair("declarationProvider", JsonBool(true)),
					Pair("definitionProvider", JsonBool(true)),
					Pair("referencesProvider", JsonBool(true)),
					Pair("documentSymbolProvider", JsonBool(true)),
					Pair("hoverProvider", JsonBool(true)),
					Pair("renameProvider", JsonBool(true)),
					Pair("workspaceSymbolProvider", JsonBool(true)),
					Pair("executeCommandProvider", ruExecuteCommandOptions),
					/*Pair("codeActionProvider", 
						JsonObject([
							Pair("codeActionKinds", JsonArray([
								JsonString("verify"), JsonString("prove"), JsonString("reprove"), JsonString("generalize")
							])),
						])
					),*/
					//Pair("codeActionProvider", JsonBool(true)),
					Pair("textDocumentSync",
						JsonObject([
							Pair("openClose", JsonBool(true)),
							Pair("change", JsonDouble(2.0))
						])
					)
				])
			)
		])
	));
}

ruLspMakeOut(lines : ref [string], conf : RuConf) -> RuOut {
	ruMakeOut(\line -> refArrayPush(lines, line), conf.opts);
}

ruLspMakeOutMessage(lines : ref [string], conf : RuConf, message : (Json) -> void) -> RuOut {
	ruMakeOut(
		\line -> {
			message(ruLspNotification("console/message", JsonString(line)));
			refArrayPush(lines, line);
		}, 
		conf.opts
	);
}

ruLspTextDocumentDidOpen(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentItem(getJsonObjectField(call.params, "textDocument"))) {
		Some(textitem): {
			file = ruCorrectUriPath(textitem.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)), 
					ScTask("cache-load", makeTree1("file", file)), 
					ScTask("sync-file-source", setTree(makeTree1("file", file), "text", textitem.text))
				]),
				\code -> {
					if (code != 0) {
						call.out_cb(ruLspErrorResponse(call.id, 1, "error at opening: " + file + "\n" + strGlue(^out_lines, "\n")));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentDidChange(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentItem(getJsonObjectField(call.params, "textDocument"))) {
		Some(textitem): {
			file = ruCorrectUriPath(textitem.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("sync-file-changed", setTree(makeTree1("file", file), "change", json2string(call.params)))
				]),
				\code -> {
					if (code != 0) {
						call.out_cb(ruLspErrorResponse(call.id, 1, "error at applying changes to: " + file + "\n" + strGlue(^out_lines, "\n")));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentDidSave(call: RuLspArgs) -> void {
	switch (json2LspDidSaveTextDocumentParams(call.params)) {
		Some(params): {
			file = ruCorrectUriPath(params.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("sync-file-saved", makeTree1("file", file))
				]),
				\code -> {
					if (code != 0) {
						call.out_cb(ruLspErrorResponse(call.id, 1, "error at saving: " + file + "\n" + strGlue(^out_lines, "\n")));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document item is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentDocumentSymbol(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentIdentifier(getJsonObjectField(call.params, "textDocument"))) {
		Some(textid): {
			file = ruCorrectUriPath(textid.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("info-outline", makeTree1("file", file))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						symbols = ruLspParseSymbols(^out_lines);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(symbols)));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text document id is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentDeclaration(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			file = ruCorrectUriPath(textpos.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("info-decl", pairs2tree([
						Pair("file", file),
						Pair("line", i2s(textpos.position.line)), 
						Pair("col", i2s(textpos.position.character))
					]))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(^out_lines);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentDefinition(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			file = ruCorrectUriPath(textpos.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("info-decl", pairs2tree([
						Pair("file", file),
						Pair("line", i2s(textpos.position.line)), 
						Pair("col", i2s(textpos.position.character))
					]))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(^out_lines);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentReferences(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			file = ruCorrectUriPath(textpos.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("info-uses", pairs2tree([
						Pair("file", file),
						Pair("line", i2s(textpos.position.line)), 
						Pair("col", i2s(textpos.position.character))
					]))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(^out_lines);
						call.out_cb(ruLspNormalResponse(call.id, JsonArray(locations)));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentHover(call: RuLspArgs) -> void {
	switch (json2LspTextDocumentPositionParams(call.params)) {
		Some(textpos): {
			file = ruCorrectUriPath(textpos.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("info-hover", pairs2tree([
						Pair("file", file),
						Pair("line", i2s(textpos.position.line)), 
						Pair("col", i2s(textpos.position.character))
					]))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						out = strGlue(^out_lines, "\n");
						if (isNotSpace(out)) {
							hover = LspHover([LspMarkedString("russell", out)], None());
							call.out_cb(ruLspNormalResponse(call.id, lspHover2Json(hover)));
						} else {
							call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
						}
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentRename(call: RuLspArgs) -> void {
	switch (json2LspRename(call.params)) {
		Some(rename): {
			file = ruCorrectUriPath(rename.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("rename", pairs2tree([
						Pair("file", file),
						Pair("line", i2s(rename.position.line)), 
						Pair("col", i2s(rename.position.character)),
						Pair("to", rename.newName)
					]))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
		}
	}
}

ruLspTextDocumentCodeAction(call: RuLspArgs) -> void {
	switch (json2LspCodeActionParams(call.params)) {
		Some(params): {
			file = ruCorrectUriPath(params.textDocument.uri.path);
			conf = ruLspFileConfig(call.conf, file);
			out_lines = ref [];
			call.process(
				ScSeq([
					ScTask("conf-set", ruConf2Tree(conf)),
					ScTask("actions", pairs2tree([
						Pair("file", file),
						Pair("line", i2s(params.range.start.line)), 
						Pair("col", i2s(params.range.start.character)),
					]))
				]),
				\code -> {
					if (ruDetectLspError(^out_lines, conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						out = strGlue(^out_lines, "\n");
						call.out_cb(ruLspNormalResponse(call.id, parseJson(out)));
					}
				},
				ruLspMakeOut(out_lines, conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "code action params are invalid: " + json2string(call.params)));
		}
	}
}

ruLspWorkspaceSymbol(call: RuLspArgs) -> void {
	switch (json2LspWorkspaceSymbolParams(call.params)) {
		Some(symbol): {
			out_lines = ref [];
			call.process(
				ScTask("info-symbol", makeTree1("name", symbol.query)),
				\code -> {
					if (ruDetectLspError(^out_lines, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						out = strGlue(^out_lines, "\n");
						call.out_cb(ruLspNormalResponse(call.id, parseJson(out)));
					}
				},
				ruLspMakeOut(out_lines, call.conf)
			);
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "text position is invalid: " + json2string(call.params)));
		}
	}
}

ruLspWorkspaceExecuteVerify(call : RuLspArgs, commandParams: LspExecuteCommandParams) -> void {
	if (length(commandParams.arguments) == 0) {
		call.out_cb(ruLspErrorResponse(call.id, 1, "no file for verification is provided"));
	} else {
		params = map(commandParams.arguments, \param -> getJsonStringValue(param, ""));
		switch (find(params, \param -> startsWith(param, "file="))) {
			Some(param): {
				file = substring(param, 5, strlen(param) - 5);
				conf = ruLspFileConfig(call.conf, file);
				target = if (length(params) < 2) file else params[1];
				out_lines = ref [];
				env = RuEnv(conf, ruLspMakeOutMessage(out_lines, conf, call.out_cb));
				call.process(
					ScSeq([
						ScTask("conf-set", ruConf2Tree(RuConf(conf with verbose=1))),
						ScTask("read", makeTree1("file", file)),
						ScTask("verify", makeTree1("target", target))
					]),
					nop1,
					env.out
				);
			}
			None(): {
				call.out_cb(ruLspErrorResponse(call.id, 1, "verify command demands a file=... parameter"));
			}
		}
	}
}

ruLspWorkspaceExecuteFindSymbol(call : RuLspArgs, commandParams: LspExecuteCommandParams) -> void {
	if (length(commandParams.arguments) == 1) {
		name = getJsonStringValue(commandParams.arguments[0], "");
		if (name != "") {
			out_lines = ref [];
			call.process(
				ScSeq([ScTask("info-find", makeTree1("name", name))]),
				\code -> {
					if (ruDetectLspError(^out_lines, call.conf)) {
						call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
					} else {
						locations = ruLspParseLocations(^out_lines);
						if (length(locations) != 1) {
							call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
						} else {
							call.out_cb(ruLspNormalResponse(call.id, locations[0]));
						}
					}
				},
				ruLspMakeOut(out_lines, call.conf)
			);
		} else {
			call.out_cb(ruLspErrorResponse(call.id, 1, "find-symbol first parameter must be a non-empty string"));
		}
	} else {
		call.out_cb(ruLspErrorResponse(call.id, 1, "find-symbol takes a parameter: a symbol name. Passed " + i2s(length(commandParams.arguments)) + " args."));
	}
}

ruLspWorkspaceExecuteMathInfo(call: RuLspArgs, commandParams: LspExecuteCommandParams) -> void {
	kind = if (length(commandParams.arguments) > 0) getJsonStringValue(commandParams.arguments[0], "") else "";
	out_lines = ref [];
	call.process(
		ScTask("info-math", makeTree1("kind", kind)),
		\code -> {
			out = strGlue(^out_lines, "\n");
			if (ruDetectLspError(^out_lines, call.conf)) {
				call.out_cb(ruLspNotification("console/message", JsonString(out)));
				call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
			} else {
				call.out_cb(ruLspNormalResponse(call.id, parseJson(out)));
			}
		},
		ruLspMakeOut(out_lines, call.conf)
	);
}

ruLspWorkspaceExecuteACommand(call: RuLspArgs, commandParams: LspExecuteCommandParams) -> void {
	if (length(commandParams.arguments) > 0) {
		script_src = getJsonStringValue(commandParams.arguments[0], "");
		do_not_log = strContains(script_src, "do_not_log_this");
		out_lines = ref [];
		switch (ruParseScript(script_src)) {
			Some(src): {
				script_with_file = if (length(commandParams.arguments) == 1) src.script else {
					ruScriptSetTasksFile(src.script, getJsonStringValue(commandParams.arguments[1], ""));
				}
				call.process(
					script_with_file,
					\code -> {
						out = strGlue(^out_lines, "\n");
						if (ruDetectLspError(^out_lines, call.conf)) {
							if (do_not_log) {
								call.out_cb(ruLspNotification("console/message", JsonString(out)));
							}
							call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
						} else {
							call.out_cb(ruLspNormalResponse(call.id, JsonString(out)));
						}
					},
					if (do_not_log) {
						ruLspMakeOut(out_lines, call.conf);
					} else {
						ruLspMakeOutMessage(out_lines, call.conf, call.out_cb);
					}
				);
			}
			None(): {
				ruLspServerLog("Syntax error in script: \n" + script_src + "\n", call.conf);
				call.out_cb(ruLspNormalResponse(call.id, JsonNull()));
			}
		}
	} else {
		call.out_cb(ruLspErrorResponse(call.id, 1, "command takes at least one parameter: the command itself. Passed " + i2s(length(commandParams.arguments)) + " args."));
	}
}

ruLspWorkspaceExecuteCommand(call: RuLspArgs) -> void {
	switch (json2LspExecuteCommandParams(call.params)) {
		Some(commandParams): {
			if (commandParams.command == "verify") {
				ruLspWorkspaceExecuteVerify(call, commandParams);
			} else if (commandParams.command == "find-symbol") {
				ruLspWorkspaceExecuteFindSymbol(call, commandParams);
			} else if (commandParams.command == "math-info") {
				ruLspWorkspaceExecuteMathInfo(call, commandParams);
			} else if (commandParams.command == "command") {
				ruLspWorkspaceExecuteACommand(call, commandParams);
			} else {
				call.out_cb(ruLspErrorResponse(call.id, 1, "command '" + commandParams.command + "' is unknown"));
			}
		}
		None(): {
			call.out_cb(ruLspErrorResponse(call.id, 1, "ExecuteCommand request is illegal"));
		}
	}
}
