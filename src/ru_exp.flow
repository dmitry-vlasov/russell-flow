import ru_math;

export {
	ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp;
	ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string;
	ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool;
	ruExpIsVar(e : RuExp) -> bool;
	ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>>;
	ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule>;

	ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruBiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
}

ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	conflict = ref false;
	s0 = mergeTreeCustom(s1, s2, \__, e1, e2 -> if (e1.nodes == e2.nodes) e1 else { conflict := true; e1 });
	if (^conflict) None() else Some(s0);
}

ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExp2s(p.second, math.rules)) 
	, "\n")
}

ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp) -> Maybe<Tree<RuVar, RuExp>> {
	e_vars = ruExp2Vars(e.nodes);
	if (containsSet(e_vars, v)) None() else {
		switch (lookupTree(s, v)) {
			Some(e1): if (e.nodes == e1.nodes) Some(s) else None();
			None(): {
				p = fold(set2array(e_vars), Pair(true, None()), \acc, e_v ->
					if (!acc.first) acc else {
						switch (lookupTree(s, e_v)) {
							Some(e2): {
								e2_vars = ruExp2Vars(e2.nodes);
								if (!containsSet(e2_vars, e_v)) acc else {
									Pair(e2.nodes == [v] && e.nodes == [e_v], Some(e_v));
								}
							}
							None(): acc;
						}
					}
				);
				if (!p.first) None() else {
					switch (p.second) {
						Some(w): Some(removeFromTree(s, w));
						None():  Some(setTree(s, v, e));
					}
				}
			}
		}
	}
}

ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s1, Some(makeTree()), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2Subst(s, v1, ruApplySubst(e1, s2)))
	);
}

ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s2, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1, v2)) Some(s) else ruAdd2Subst(s, v2, e2))
	);
}

ruBiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	maybeBind(ruSemiCompose(s2, s1), \s -> ruCompose(s1, s))
}

RuMatchAcc(
	expInd : int,
	pattInd : int
);

ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	fold(pattern.nodes, Pair(Some(makeTree()), 0), \acc, n1 ->
		switch (acc.first) {
			None(): acc;
			Some(s): {
				switch (n1) {
					RuRuleRef(r1,__,__,__): {
						switch (e.nodes[acc.second]) {
							RuRuleRef(r2,__,__,__): 
								if (r1 == r2) {
									Pair(acc.first, acc.second + 1);
								} else {
									Pair(None(), 0);
								}
							RuVar(__,__): {
								Pair(None(), 0);
							}
						}
					}
					RuVar(v1, t1): {
						n2 = e.nodes[acc.second];
						switch (n2) {
							RuRuleRef(r2, t2, __, len): {
								sub_exp = subrange(e.nodes, acc.second, len + 1);
								if (t1 == t2) {
									Pair(
										ruAdd2Subst(s, n1, RuExp(sub_exp, e.pos)), 
										acc.second + len + 1
									);
								} else {
									switch (ruSuperRule(t2, t1, math)) {
										Some(super): 
											Pair(
												ruAdd2Subst(s, n1,
													RuExp(
														concat([RuRuleRef(super.name, t1, 1, 1)], sub_exp), 
														e.pos
													)
												), 
												acc.second + len + 1
											);
										None(): {
											Pair(None(), 0);
										}
									}
								}
							}
							RuVar(v2, t2): {
								if (t1 == t2) {
									Pair(
										ruAdd2Subst(s, n1, RuExp([n2], e.pos)), 
										acc.second + 1
									);
								} else {
									switch (ruSuperRule(t2, t1, math)) {
										Some(super): 
											Pair(
												ruAdd2Subst(s, n1, RuExp([RuRuleRef(super.name, t1, 1, 1), n2], e.pos)), 
												acc.second + 1
											);
										None(): {
											Pair(None(), 0);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	).first;
}

ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule> {
	switch (lookupTree(math.types, infer)) {
		Some(infEnv): lookupTree(infEnv.supers, super);
		None(): {
			math.conf.onError("unknown type: " + infer, []);
			quit(0);
			None();
		}
	}
}

RuApplyStack(
	parent : Maybe<RuApplyStack>,
	len : int
);

ruApplyComputeLen(arity : int, stack_len : Pair<RuApplyStack, int>) -> Pair<RuApplyStack, int> {
	if (arity == 0) stack_len else {
		switch (stack_len.first.parent) {
			Some(p): 
				ruApplyComputeLen(
					arity - 1, 
					Pair(p, stack_len.first.len + stack_len.second)
				);
			None(): {
				println("empty stack pop at ruApplyComputeLen");
				quit(0);
				stack_len;
			}
		}
	}
}

RuApplyAcc(
	nodes : [RuExpNode],
	stack : RuApplyStack
);

ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp {
	RuExp(reverseA(foldr(e.nodes, RuApplyAcc([], RuApplyStack(None(), 0)), 
		\acc, n -> {
			switch (n) {
				RuRuleRef(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						concat(acc.nodes, [RuRuleRef(r, t, a, st_len.second)]),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(v, t): {
					switch (lookupTree(s, n)) {
						Some(x): 
							RuApplyAcc(
								concat(acc.nodes, x.nodes),
								RuApplyStack(Some(acc.stack), length(x.nodes))
							);
						None(): 
							RuApplyAcc(
								concat(acc.nodes, [n]),
								RuApplyStack(Some(acc.stack), 1)
							);
					}
				}
			}
		}).nodes)
		, e.pos
	)
}

ruExpIsVar(e : RuExp) -> bool {
	if (length(e.nodes) != 1) false else {
		switch (e.nodes[0]) {
			RuVar(__,__): true;
			default: false;
		}
	}
}

ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool {
	forall(getTreeValues(s), ruExpIsVar)
}

ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>> {
	if (length(e.nodes) != length(pattern.nodes)) None() else {
		foldi(e.nodes, Some(makeTree()), \i, acc, v1 ->
			maybeBind(acc, \s -> {
				switch (v1) {
					RuRuleRef(r1,__,__,__): {
						switch (pattern.nodes[i]) {
							RuRuleRef(r2,__,__,__):
								if (r1 == r2) Some(s) else None();
							RuVar(__,__): 
								None();
						}
					}
					RuVar(__, __): {
						v2 = pattern.nodes[i];
						switch (v2) {
							RuRuleRef(r2,__,__,__): None();
							RuVar(__,__):
								if (v1.type != v2.type) None() else {
									switch (lookupTree(s, v2)) {
										Some(w1): if (v1 == w1) Some(s) else None();
										None(): Some(setTree(s, v2, v1));
									}
								}
						}
					}
				}
			})
		)
	}
}
