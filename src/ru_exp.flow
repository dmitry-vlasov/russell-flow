import ru_math;

export {
	ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp;
	ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string;
	ruSubstRPN2s(s : Tree<RuVar, RuExp>) -> string;
	ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp) -> Maybe<Tree<RuVar, RuExp>>;
	ruAdd2Subst1(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool;
	ruExpIsVar(e : RuExp) -> bool;
	ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>>;
	ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule>;

	ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruBiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;

	ruUnifyExps(es : [RuExp], sub : Tree<RuVar, RuExp>, math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
	ruUnifySubstVect(subs : [Tree<RuVar, RuExp>], math : RuMath) -> Maybe<Tree<RuVar, RuExp>>;
}

ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	conflict = ref false;
	s0 = mergeTreeCustom(s1, s2, \__, e1, e2 -> if (e1.nodes == e2.nodes) e1 else { conflict := true; e1 });
	if (^conflict) None() else Some(s0);
}

ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExp2s(p.second, math.rules)) 
	, "\n")
}

ruSubstRPN2s(s : Tree<RuVar, RuExp>) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExpRPN2s(p.second.nodes)) 
	, "\n")
}

ruAdd2Subst1(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	if (e.nodes[0].type == v.type) ruAdd2Subst(s, v, e) else 
	maybeBind(ruSuperRule(e.nodes[0].type, v.type, math), \super ->
		ruAdd2Subst(s, v, RuExp(concat([RuRuleRef(super.name, v.type, 1, 1)], e.nodes), e.pos))
	)
}

ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e0 : RuExp) -> Maybe<Tree<RuVar, RuExp>> {
	e = ruApplySubst(e0, s);
	if (e.nodes == [v]) Some(s) else {
		e_vars = ruExp2Vars(e.nodes);
		if (containsSet(e_vars, v)) None() else {
			switch (lookupTree(s, v)) {
				Some(e1): if (e.nodes == e1.nodes) Some(s) else None();
				None(): {
					p = fold(set2array(e_vars), Pair(true, None()), \acc, e_v ->
						if (!acc.first) acc else {
							switch (lookupTree(s, e_v)) {
								Some(e2): {
									e2_vars = ruExp2Vars(e2.nodes);
									if (!containsSet(e2_vars, e_v)) acc else {
										Pair(e2.nodes == [v] && e.nodes == [e_v], Some(e_v));
									}
								}
								None(): acc;
							}
						}
					);
					if (!p.first) None() else {
						switch (p.second) {
							Some(w): Some(removeFromTree(s, w));
							None():  {
								theta = makeTree1(v, e);
								Some(setTree(mapTree(s, \x -> ruApplySubst(x, theta)), v, e));
							}
						}
					}
				}
			}
		}
	}
}

ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s1, Some(makeTree()), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2Subst(s, v1, ruApplySubst(e1, s2)))
	);
}

ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s2, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1, v2)) Some(s) else ruAdd2Subst(s, v2, e2))
	);
}

ruBiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	maybeBind(ruSemiCompose(s2, s1), \s -> ruCompose(s1, s))
}

ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	add2s = \i, p : Pair<Tree<RuVar, RuExp>, int>, v, ex ->
		switch (lookupTree(p.first, v)) {
			Some(e1): if (ex.nodes == e1.nodes) Some(Pair(p.first, p.second + i)) else None();
			None(): Some(Pair(setTree(p.first, v, ex), p.second + i));
		}
	addVar = \i, t1, t2, n1, p, ec -> 
		if (t1 == t2) {
			add2s(i, p, n1, ec());
		} else {
			maybeBind(ruSuperRule(t2, t1, math), \super ->
				add2s(i, p, n1, RuExp(concat([RuRuleRef(super.name, t1, 1, 1)], ec().nodes), e.pos))
			)
		}
	maybeMap(fold(pattern.nodes, Some(Pair(makeTree(), 0)), \acc, n1 ->
		maybeBind(acc, \p ->
			switch (n1) {
				RuRuleRef(r1,__,__,__): {
					switch (e.nodes[p.second]) {
						RuRuleRef(r2,__,__,__): 
							if (r1 != r2) None() else Some(Pair(p.first, p.second + 1));
						RuVar(__,__): None();
					}
				}
				RuVar(v1, t1): {
					n2 = e.nodes[p.second];
					switch (n2) {
						RuRuleRef(r2, t2, __, len):
							addVar(len + 1, t1, t2, n1, p, \-> RuExp(subrange(e.nodes, p.second, len + 1), e.pos))
						RuVar(v2, t2):
							addVar(1, t1, t2, n1, p, \-> RuExp([n2], e.pos));
					}
				}
			}
		)
	), \p -> p.first);
}

ruSuperRule(infer : string, super : string, math : RuMath) -> Maybe<RuRule> {
	switch (lookupTree(math.types, infer)) {
		Some(infEnv): lookupTree(infEnv.supers, super);
		None(): {
			math.conf.onError("unknown type: " + infer, []);
			quit(0);
			None();
		}
	}
}

RuApplyStack(
	parent : Maybe<RuApplyStack>,
	len : int
);

ruApplyComputeLen(arity : int, stack_len : Pair<RuApplyStack, int>) -> Pair<RuApplyStack, int> {
	if (arity == 0) stack_len else {
		switch (stack_len.first.parent) {
			Some(p): 
				ruApplyComputeLen(
					arity - 1, 
					Pair(p, stack_len.first.len + stack_len.second)
				);
			None(): {
				println("empty stack pop at ruApplyComputeLen");
				quit(0);
				stack_len;
			}
		}
	}
}

RuApplyAcc(
	nodes : [RuExpNode],
	stack : RuApplyStack
);

ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp {
	RuExp(reverseA(foldr(e.nodes, RuApplyAcc([], RuApplyStack(None(), 0)), 
		\acc, n -> {
			switch (n) {
				RuRuleRef(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						concat(acc.nodes, [RuRuleRef(r, t, a, st_len.second)]),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(v, t): {
					switch (lookupTree(s, n)) {
						Some(x):
							RuApplyAcc(
								concat(acc.nodes, reverseA(x.nodes)),
								RuApplyStack(Some(acc.stack), length(x.nodes))
							);
						None(): 
							RuApplyAcc(
								concat(acc.nodes, [n]),
								RuApplyStack(Some(acc.stack), 1)
							);
					}
				}
			}
		}).nodes)
		, e.pos
	)
}

ruExpIsVar(e : RuExp) -> bool {
	if (length(e.nodes) != 1) false else {
		switch (e.nodes[0]) {
			RuVar(__,__): true;
			default: false;
		}
	}
}

ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool {
	forall(getTreeValues(s), ruExpIsVar)
}

ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>> {
	if (length(e.nodes) != length(pattern.nodes)) None() else {
		foldi(e.nodes, Some(makeTree()), \i, acc, v1 ->
			maybeBind(acc, \s -> {
				switch (v1) {
					RuRuleRef(r1,__,__,__): {
						switch (pattern.nodes[i]) {
							RuRuleRef(r2,__,__,__): if (r1 != r2) None() else Some(s);
							RuVar(__,__): None();
						}
					}
					RuVar(__, __): {
						v2 = pattern.nodes[i];
						switch (v2) {
							RuRuleRef(r2,__,__,__): None();
							RuVar(__,__):
								if (v1.type != v2.type) None() else {
									switch (lookupTree(s, v2)) {
										Some(w1): if (v1 == w1) Some(s) else None();
										None(): Some(setTree(s, v2, v1));
									}
								}
						}
					}
				}
			})
		)
	}
}

ruUnifyExps(es : [RuExp], sub : Tree<RuVar, RuExp>, math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	if (length(es) <= 1) Some(sub) else {
		ruDoUnifyExps(es, RuUnifyAcc(sub, map(es, \__ -> 0), math))
	}
}

RuUnifyAcc(
	sub : Tree<RuVar, RuExp>,
	inds : [int],
	math : RuMath
);

RuUnifyRule(
	name : string,
	type : string
);

RuUnifyStepAcc(
	shift : [int],
	vars  : [RuVar],
	exprs : [RuExp],
	rule  : string,
	type  : string,
	ok    : bool
);

ruUnifyStepVar(step : RuUnifyStepAcc, math : RuMath) -> Maybe<RuVar> {
	fold(tail(step.vars), Some(step.vars[0]), \acc, v ->
		maybeBind(acc, \t -> 
			if (v.type == t.type || isSome(ruSuperRule(v.type, t.type, math))) Some(v) else
			if (v.type == t.type || isSome(ruSuperRule(t.type, v.type, math))) Some(t) else None()
		)
	)
}

ruDoUnifyExps(es : [RuExp], acc : RuUnifyAcc) -> Maybe<Tree<RuVar, RuExp>> {
	if (all(mapi(acc.inds, \i, n -> n == length(es[i].nodes)))) {
		Some(acc.sub) 
	} else {
		//println("ruDoUnifyExps: inds=" + strGlue(map(acc.inds, i2s), ", "));
		step = foldi(mapi(es, \i, e -> e.nodes[acc.inds[i]]), RuUnifyStepAcc([], [], [], "", "", true), \i, ac, n ->
			switch (n) {
				RuVar(__,__): {
					//println("var[" + i2s(i) + "]=" + n.name);
					RuUnifyStepAcc(ac with 
						shift = concat(ac.shift, [1]),
						vars = concat(ac.vars, [n])
					);
				}
				RuRuleRef(rule, type,__, len): {
					//println("rule[" + i2s(i) + "]=" + rule);
					RuUnifyStepAcc(
						concat(ac.shift, [len + 1]),
						ac.vars,
						concat(ac.exprs, [RuExp(subrange(es[i].nodes, acc.inds[i], len + 1), es[i].pos)]),
						rule, type, ac.ok && (ac.rule == "" || rule == ac.rule)
					);
				}
			}
		);
		if (!step.ok) None() else {
			if (step.rule != "") {
				if (length(step.vars) > 0) {
					maybeBind(ruUnifyExps(step.exprs, acc.sub, acc.math), \s -> {
						ex = ruApplySubst(step.exprs[0], s);
						maybeBind(
							fold(step.vars, Some(s), \ac, v -> 
								maybeBind(ac, \s1 -> ruAdd2Subst1(s1, v, ex, acc.math))
							),
							\s1 -> ruDoUnifyExps(es, 
								RuUnifyAcc(acc with 
									sub = s1,
									inds = mapi(acc.inds, \j, i -> i + step.shift[j])
								)
							)
						);
					});
				} else {
					ruDoUnifyExps(es, RuUnifyAcc(acc with inds = map(acc.inds, \i -> i + 1)));
				}
			} else {
				maybeBind(ruUnifyStepVar(step, acc.math), \w -> {
					ex = RuExp([w], -1);
					maybeBind(
						fold(step.vars, Some(acc.sub), \ac, v -> 
							maybeBind(ac, \s1 -> ruAdd2Subst1(s1, v, ex, acc.math))
						),
						\s1 -> ruDoUnifyExps(es, 
							RuUnifyAcc(acc with
								sub = s1,
								inds = map(acc.inds, \i -> i + 1)
							)
						)
					);
				});
			}
		}
	}
}

ruUnifySubstVect(subs : [Tree<RuVar, RuExp>], math : RuMath) -> Maybe<Tree<RuVar, RuExp>> {
	//println("unifying subs:");
	//iteri(subs, \i, s -> println(i2s(i) + ":\n" + ruIndent(ruSubst2s(s, math))));
	vars = fold(subs, makeSet(), \acc, s -> mergeSets(acc, buildSet(getTreeKeys(s))));
	//println("vars: " + strGlue(map(set2array(vars), \v -> v.name), ", "));
	ret = foldSet(
		fold(subs, makeSet(), \acc, s -> mergeSets(acc, buildSet(getTreeKeys(s)))), 
		Some(makeTree()), 
		\acc, v ->
			maybeBind(acc, \sub -> {
				exprs = filtermap(subs, \s -> lookupTree(s, v));
				
				//println("\tvar: " + v.name);
				//println("\texprs:\n"  + ruIndent2(strGlue(map(exprs, \ex -> ru2s(ex, math.rules)), "\n")));
				
				
				maybeBind(ruUnifyExps(exprs, sub, math), \sub1 -> {
					//println("\tunifier:\n" + ruIndent2(ruSubst2s(sub1, math)));
					ruAdd2Subst1(sub1, v, ruApplySubst(exprs[0], sub1), math);
				});
			})
	);
	//maybeApply(ret, \s -> println("result:\n" + ruIndent(ruSubst2s(s, math))));
	ret
}
