import ru_refactor;
import prover/ru_prover_util;
import ru_verify;

export {
	ruShortenTheorem(theorem : RuTheorem, math : RuMath) -> Maybe<RuTheorem>;
	ruShortenMath(math : RuMath) -> RuMath;
	ruCommandShortenProofs(math : RuMath) -> RuMath;
}

ruSubProofVolume(i : int, steps : [RuStep]) -> int {
	fold(steps[i].refs, 1, \acc, ref -> acc + ruRefVolume(ref, steps));
}

ruRefVolume(ref : RuRef, steps : [RuStep]) -> int {
	switch (ref) {
		RuHypRef(__,__): 0;
		RuStepRef(j, __): ruSubProofVolume(j, steps);
	}
}

ruRefsEq(r1 : RuRef, r2 : RuRef) -> bool {
	switch (r1) {
		RuHypRef(i, __): 
			switch (r2) {
				RuHypRef(j, __): i == j;
				RuStepRef(__, __): false;
			}
		RuStepRef(i, __):
			switch (r2) {
				RuHypRef(__, __): false;
				RuStepRef(j, __): i == j;
			}
	}
}

ruStepsEq(s1 : RuStep, s2 : RuStep) -> bool {
	s1.ind == s2.ind &&
	s1.assertion == s2.assertion && 
	s1.expr.nodes == s2.expr.nodes &&
	length(s1.refs) == length(s2.refs) &&
	forall(zipWith(s1.refs, s2.refs, \r1, r2 -> Pair(r1, r2)),
		\p -> ruRefsEq(p.first, p.second)
	);
}

RuShortenAcc(
	optimized : [RuStep],
	assertions : RuIndex<RuAssertion>,
	premises : RuIndex<RuRef>,
	steps : [RuStep],
	math : RuMath,
);

ruShortenTheorem(th : RuTheorem, math0 : RuMath) -> Maybe<RuTheorem> {
	cth = ruConstTheorem(th, math0);
	math = cth.math;
	assertions = ruInitAssertionsIndex(th.name, math);
	initPremises = fold(cth.const.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, RuHypRef(hyp.ind, -1), acc));
	optimized = foldi(cth.const.proof.steps, RuShortenAcc([], assertions, initPremises, cth.const.proof.steps, math), \i, acc, step -> {
		least = ruStepVariants(step.ind, cth.const.proof.steps, th.disjs, acc);
		RuShortenAcc(acc with
			optimized = concat(acc.optimized, [least]),
			premises = ruSetIndex(step.expr, RuStepRef(step.ind, -1), acc.premises)
		);
	}).optimized;
	ret = ruRemoveTheoremUnusedSteps(RuTheorem(th with 
		proof = ruTransformProof(RuProof(th.proof with steps = optimized), cth.unconst)
	), math.conf);
	switch (ret) {
		Some(th_opt): {
			if (math.conf.verbose > 0) {
				println("theorem " + th.name + " shortened by " + i2s(length(th.proof.steps) - length(th_opt.proof.steps)) + " steps");
			}
			if (isNone(ruVerifyTheorem(th_opt, math))) {
				println("ERROR IN SHORTENING");
				println("optimized:");
				println(ru2s(th_opt, math.rules));
				println("original:");
				println(ru2s(th, math.rules));
				quit(-1);
			}
		}
		None(): 
			if (math.conf.verbose > 1) {
				println("therem " + th.name + " was not shortened");
			}
	}
	ret
}

RuShortenLeast(
	step : RuStep, // Current least step
	vol  : int     // volume of current least step
);

RuShortenStepAcc(
	up : RuShortenAcc,
	assertion : string,
	sub : Tree<RuVar, RuExp>,
	refs : [RuRef],
	least : ref RuShortenLeast,
	vol : int,
	start : double,
	max_time : double
);

ruStepVariants(i : int, steps : [RuStep], disjs : Set<RuDisj>, acc : RuShortenAcc) -> RuStep {
	step = acc.steps[i];
	least = ref RuShortenLeast(acc.steps[i], ruSubProofVolume(i, acc.steps));
	max_time = s2d(lookupTreeDef(acc.math.conf.opts, "max_time", "1.0"));
	iter(ruUnifyIndex(step.expr, acc.assertions, makeTree(), acc.math), \unif -> {
		if (ruCheckDisjs(unif.sub, unif.data.disjs) && ruCheckDisjs(unif.sub, disjs)) {
			ruRefsVariants(0, unif.data.hyps, 
				RuShortenStepAcc(acc, unif.data.name, unif.sub, [], least, 1, timestamp(), max_time)
			);
		}
	});
	^least.step
}

ruRefsVariants(j : int, hyps : [RuHyp], acc : RuShortenStepAcc) -> void {
	if (j == length(hyps)) {
		new_step = RuStep(^(acc.least).step with refs = acc.refs, assertion = acc.assertion);
		acc.least := RuShortenLeast(new_step, acc.vol);
	} else {
		if (timestamp() - acc.start < acc.max_time) {
			iter(ruUnifyIndex(ruApplySubst(hyps[j].expr, acc.sub), acc.up.premises, acc.sub, acc.up.math), \un -> {
				vol = acc.vol + ruRefVolume(un.data, acc.up.steps);
				if (vol < ^(acc.least).vol) {
					ruRefsVariants(j + 1, hyps, RuShortenStepAcc(acc with 
						refs = concat(acc.refs, [un.data]),
						sub = un.sub,
						vol = vol
					))
				}
			})
		}
	}
}

ruShortenMath(math : RuMath) -> RuMath {
	start = timestamp();
	shortened = filtermap(ruConcurrent(
		map(getTreeValues(ruMathTheorems(math)), 
			\th -> \ -> ruShortenTheorem(th, math)
		)
	), idfn);
	ret = fold(shortened, Pair(math, 0), \acc, th -> {
		orig = ruTheorem(th.name, acc.first);
		gain = length(orig.proof.steps) - length(th.proof.steps);
		Pair(ruReplaceTheorem(th, acc.first), acc.second + gain);
	});
	if (math.conf.verbose > 0) {
		println("shortened " + i2s(length(shortened)) + " theorems,  " +
		"reduced " + i2s(ret.second) + " steps " +
		"in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	ret.first;
}

ruCommandShortenProofs(math : RuMath) -> RuMath {
	target = lookupTreeDef(math.conf.opts, "default", "");
	if (target == "1" || target == "all" || target == "") {
		ruShortenMath(math);
	} else {
		switch (lookupTree(math.assertions, target)) {
			Some(th): {
				switch (th) {
					RuTheorem(__,__,__,__,__,__,__,__): {
						start = timestamp();
						shortened = ruShortenTheorem(th, math);
						ret = eitherMap(shortened, \t -> ruReplaceTheorem(t, math), math);
						if (math.conf.verbose > 0 && isSome(shortened)) {
							println("theorem " + target + " shortened in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
						}
						ret;
					}
					default: {
						println("assertion " + target + " is not a theorem");
						math;
					}
				}
			}
			None(): {
				switch (lookupTree(math.sources, target)) {
					Some(src): {
						start = timestamp();
						shortened = filtermap(ruConcurrent(
							map(ruSourceTheorems(src), 
								\th -> \ -> ruShortenTheorem(th, math)
							)
						), idfn);
						ret = fold(shortened, math, \acc, th -> ruReplaceTheorem(th, acc));
						if (math.conf.verbose > 0) {
							println("shortened " + i2s(length(shortened)) + " theorems in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
						}
						ret;
					}
					None(): {
						println("shortening target " + target + " is not found");
						math;
					}
				}
			}
		}
	}
}
