import ru_refactor;
import prover/ru_prover_util;

export {
	ruShortenTheorem(theorem : RuTheorem, math : RuMath) -> Maybe<RuTheorem>;
}

RuShortenAcc(
	variants : Tree<int,[RuStep]>,
	premises : RuIndex<RuRef>
);

ruSubProofVolume(i : int, steps : [RuStep]) -> int {
	fold(steps[i].refs, 1, \acc, ref ->
		switch (ref) {
			RuHypRef(__,__): acc;
			RuStepRef(j, __): acc + ruSubProofVolume(j, steps);
		}
	);
}

RuShortenStepAcc(
	acc : RuShortenAcc,
	sub : Tree<RuVar, RuExp>,
	refs : [RuRef]
);

ruShortenTheorem(th : RuTheorem, math : RuMath) -> Maybe<RuTheorem> {
	cth = ruConstTheorem(th, math);
	assertions = ruInitAssertionsIndex(th.name, math);
	initPremises = fold(cth.const.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, RuHypRef(hyp.ind, -1), acc));
	variants = fold(cth.const.proof.steps, RuShortenAcc(makeTree(), initPremises), \acc, step -> {
		vol = ruSubProofVolume(step.ind, th.proof.steps);
		fold(ruUnifyIndex(step.expr, assertions, makeTree(), cth.math), acc, \ac, unif -> {
			if (!ruCheckDisjs(unif.sub, unif.data.disjs) || !ruCheckDisjs(unif.sub, cth.const.disjs)) ac else {
				foldi(unif.data.hyps, RuShortenStepAcc(ac, unif.sub, []), \i, a, hyp -> {
						fold(ruUnifyIndex(ruApplySubst(hyp.expr, a.sub), ac.premises, a.sub, cth.math), a, \b, un -> {
							if (i + 1 < length(unif.data.hyps)) RuShortenStepAcc(b.acc, un.sub, concat(a.refs, [un.data])) else {
								new_step = RuStep(step with refs = b.refs);
								new_steps = ruReplaceArray(cth.const.proof.steps, step.ind, new_step);
								if (ruSubProofVolume(step.ind, new_steps) >= vol) b else {
									RuShortenStepAcc(
										RuShortenAcc(b.acc with 
											variants = setTree(b.acc.variants, step.ind,
												concat(lookupTreeDef(b.acc.variants, step.ind, []), [new_step])
											)
										),
										un.sub, []
									);
								}
							}
						})
					}
				).acc;
			}
		})
	}).variants;
	None();
}
