import text/binary;
import formats/lsp;
import ru_src;
import ru_log;

export {
	RuCachedSource(
		source : RuSource, 
		dependencyChanged : () -> bool, 
		version : int
	);

	RuCachedDecl(
		decl : RuDecl,
		info : RuFileInfo
	);

	// Cached source code.
	RuCachedSourceText(
		text : string,
		modified : double
	);

	ruToCache(src : RuSource, conf : RuConf) -> void;
	ruFromCache(file : string, conf : RuConf) -> Maybe<RuCachedSource>;
	ruLoadToCache(file : string, conf : RuConf) -> void;
	ruClearCache() -> void;
	ruSourcesCache() -> [RuSource];
	ruMakeCacheDir(conf : RuConf) -> void;

	ruCachedDecl(name : string) -> [RuCachedDecl];
	ruCachedDecl2s(name : string, conf : RuConf) -> string;
	ruCachedDecls() -> [RuCachedDecl];
	ruCachedAssertoins() -> Tree<string, RuAssertion>;
	ruCachedTheoremAxioms() -> Tree<string, Set<string>>;

	// Lookups a cached file source, if not found - loads and stores.
	ruFileSource(path : string) -> string;
	// Stores a certain string as a source for some path.
	ruSetFileSource(path : string, src : string) -> void;
	// Loads file source from filesystem. May be used to undo fcSetFileSource function.
	ruLoadFileSource(path : string) -> void;

	ruRange2LspLocation(range : RuRange, path : string) -> LspLocation;
	ruRange2s(path : string, range : RuRange, msg : string) -> string;
	ruRangeWithResolver2s(path : string, range : RuRange, msg : string, resolver : LineResolver) -> string;

	// Shows cache statistics
	ruCacheInfo(full : bool) -> string;
	// Declaration statistics
	ruDeclInfo(mode : [string], conf : RuConf) -> string;

	ruDeclRange(d : RuDecl, src : RuSource) -> RuRange;
}

ruCacheVersion = 1;

ruSourceCache = initConcurrentHashMap();
ruNameCache = initConcurrentHashMap();
ruTextCache = initConcurrentHashMap(); // Sources of files as strings
ruDefCache = initConcurrentHashMap();  // Definitions

ruClearCache() -> void {
	clearConcurrentHashMap(ruSourceCache);
	clearConcurrentHashMap(ruNameCache);
	clearConcurrentHashMap(ruTextCache);
	clearConcurrentHashMap(ruDefCache);
}

ruSourcesCache() -> [RuSource] {
	filtermap(valuesConcurrentHashMap(ruSourceCache), idfn);
}

ruMakeCacheDir(conf : RuConf) -> void {
	err = ensureDirectoryExists(ruCacheDir(conf));
	if (err != "") {
		ruPrintln(err, conf);
	}
}

ruCacheDir(conf : RuConf) -> string {
	ruOptDef("cache-dir", getRussellDir() + "/cache", conf);
}

ruCachedPath(file : string, conf : RuConf) -> string {
	ruCacheDir(conf) + "/" + strReplace(strReplace(file, "/", "_"), ":", "_")  + ".cache"
}

RuCachedFileSource(
	source : RuSource,
	version : int
);

ruDepChangedCallback(src : RuSource, conf : RuConf) -> () -> bool {
	\ -> {
		check = exists(src.imports, \imp ->
			switch (ruFromCache(imp.path, conf)) {
				Some(cached): {
					src.info.lastupdate < cached.source.info.lastupdate || cached.dependencyChanged();
				}
				None(): {
					conf.onError("a module " + imp.path + " must be already in cache, but is not there", []); true; 
				}
			}
		);
		setConcurrentHashMap(ruSourceCache, src.info.file, Some(RuCachedSource(src, \ -> check, ruCacheVersion)));
		check
	}
}

ruUpdateNameCache(src : RuSource, conf : RuConf) -> void {
	//ruDebugLog1("ruUpdateNameCache: started " + src.info.file);
	iter(src.decls, \decl ->
		switch (decl) {
			RuDecl(): setConcurrentHashMap(ruNameCache, ruDeclName(decl), Some(RuCachedDecl(decl, src.info)));
			default: { }
		}
	);
	//ruDebugLog1("ruUpdateNameCache: finished " + src.info.file);
}

ruUpdateDefCache(src : RuSource, conf : RuConf) -> void {
	//ruDebugLog1("ruUpdateDefCache: started " + src.info.file);
	iter(src.decls, \decl -> 
		switch (decl) {
			RuDef(__,__,__,__, defm, __,__,__): {
				switch (defm.nodes[0]) {
					RuRuleRef(rule_name,__,__,__): {
						switch (getConcurrentHashMap(ruNameCache, rule_name, None())) {
							Some(cached_rule): {
								rule = cast(cached_rule.decl : RuDecl -> RuRule);
								non_bracket_consts = filtermap(rule.term.expr, \n ->
									switch (n) {
										RuConstRef(name): 
											if (name == "(" || name == ")" || name == "," || name == ":") None() else {
												if (containsConcurrentHashMap(ruDefCache, name)) None() else {
													Some(name);
												}
											};
										RuVar(__,__): None(); 
									}
								);
								//ruDebugLog1("DEFIENDUM: " + ruExpRPN2s(defm.nodes));
								//ruDebugLog1("TERM: " + ruTerm2s(rule.term.expr));

								iter(non_bracket_consts, \defiendum_const ->
									setConcurrentHashMap(ruDefCache, defiendum_const, 
										concat(
											getConcurrentHashMap(ruDefCache, defiendum_const, []),
											[RuCachedDecl(decl, src.info)]
										)
									)
								);
							}
							None(): conf.onError("Rule " + rule_name + " is not found in cache", []);
						}
					}
					default: { 
						ruDebugLog1("not a rule ref: " + ruExpRPN2s(defm.nodes));
					}
				}
			}
			default: { }
		}
	);
	//ruDebugLog1("ruUpdateDefCache: finished " + src.info.file);
}

ruToCache(src : RuSource, conf : RuConf) -> void {
	if (!ruOptIsFalse("caching", conf)) {
		cached = RuCachedSource(src, ruDepChangedCallback(src, conf), ruCacheVersion);
		setConcurrentHashMap(ruSourceCache, src.info.file, Some(cached));
		ruUpdateNameCache(src, conf);
		ruUpdateDefCache(src, conf);
		if (!setFileContent(ruCachedPath(src.info.file, conf), toBinary(RuCachedFileSource(cached.source, cached.version)))) {
			conf.onError("cannot save cached source " + src.info.file, []);
		}
		if (conf.verbose > 1) {
			ruPrintln("saved to cached: " + src.info.file, conf);
		}
	}
}

ruFromCache(file0 : string, conf : RuConf) -> Maybe<RuCachedSource> {
	file = ruTrimPath(file0, conf, ".ru");
	if (ruOptIsFalse("caching", conf)) None() else {
		if (containsConcurrentHashMap(ruSourceCache, file)) {
			getConcurrentHashMap(ruSourceCache, file, None());
		} else {
			path = ruCachedPath(file, conf);
			if (!fileExists(path)) None() else {
				deserialized = deserializeBinary(getFileContent(path), IllegalStruct());
				if (deserialized == IllegalStruct()) {
					conf.onError("WARNING: Illegal structure of cache file for " + file + ". Incremental file deleted.", []);
					ruDeleteFromCache(file, path, conf);
					None();
				} else {
					cached_file = cast(deserialized : flow -> RuCachedFileSource);
					if (cached_file.version == ruCacheVersion) {
						changed = ruFileChanged(cached_file.source.info);
						if (changed != "") {
							if (conf.verbose >= 1) {
								println(changed);
							}
							ruDeleteFromCache(file, path, conf);
							None();
						} else {
							if (conf.verbose > 1) {
								ruPrintln("loaded from cache: " + file, conf);
							}
							cached = RuCachedSource(cached_file.source, ruDepChangedCallback(cached_file.source, conf), cached_file.version);
							setConcurrentHashMap(ruSourceCache, file, Some(cached));
							ruUpdateNameCache(cached.source, conf);
							Some(cached);
						}
					} else {
						if (conf.verbose > 1) {
							ruPrintln("cached file " + file + " is has version " + i2s(cached_file.version) + " while current version is " + i2s(ruCacheVersion), conf);
							ruDeleteFromCache(file, path, conf);
						}
						None();
					}
				}
			}
		}
	}
}

ruLoadToCache(file0 : string,  conf : RuConf) -> void {
	file = ruTrimPath(file0, conf, ".ru");
	//ruDebugLog1("ruLoadToCache: started " + file);
	sources = ruDoLoadToCache(file, conf, [], makeSet()).first;
	//ruDebugLog1("ruLoadToCache: sources are loaded " + file);
	iter(sources, \src -> ruUpdateDefCache(src, conf));
	//ruDebugLog1("ruLoadToCache: finished " + file);
}

ruDoLoadToCache(file : string,  conf : RuConf, acc : [RuSource], visited : Set<string>) -> Pair<[RuSource], Set<string>> {
	if (containsSet(visited, file)) Pair(acc, visited) else {
		new_visited = insertSet(visited, file);
		switch (ruFromCache(file, conf)) {
			Some(cached):
				fold(
					cached.source.imports,
					Pair(concat(acc, [cached.source]), new_visited), 
					\ac, imp -> ruDoLoadToCache(imp.path, conf, ac.first, ac.second)
				);
			None(): Pair(acc, new_visited);
		}
	}
}

ruDeleteFromCache(file : string, path : string, conf : RuConf) -> void {
	if (conf.verbose > 1) {
		ruPrintln("Deleting outdated cached " + file, conf);
	}
	removeConcurrentHashMap(ruSourceCache, file);
	err = deleteFile(path);
	if (err != "") {
		if (fileExists(path)) {
			conf.onError("Could not delete " + path + ": " + err, []);
		}
	}
}

ruCachedDecl(name : string) -> [RuCachedDecl] {
	defs = getConcurrentHashMap(ruDefCache, name, []);
	switch (getConcurrentHashMap(ruNameCache, name, None())) {
		Some(cached): concat(defs, [cached]);
		None(): defs;
	}
}

ruCachedDecls() -> [RuCachedDecl] {
	filtermap(valuesConcurrentHashMap(ruNameCache), idfn);
}

ruCachedAssertoins() -> Tree<string, RuAssertion> {
	pairs2tree(
		filtermap(ruCachedDecls(), \cached -> {
			decl = cached.decl;
			switch (decl) {
				RuAssertion(): Some(Pair(ruDeclName(decl), decl));
				default: None();
			}
		})
	);
}

ruFileSource(path : string) -> string {
	if (!containsConcurrentHashMap(ruTextCache, path)) {
		setConcurrentHashMap(ruTextCache, path, RuCachedSourceText(getFileContent(path), fileModified(path)));
	}
	cached = getConcurrentHashMap(ruTextCache, path, RuCachedSourceText("", 0.0));
	modified = fileModified(path);
	if (cached.modified != modified) {
		// Reload outdated source.
		text = getFileContent(path);
		setConcurrentHashMap(ruTextCache, path, RuCachedSourceText(text, modified));
		text;
	} else {
		cached.text;
	}
}

ruSetFileSource(path : string, text : string) -> void {
	if (!containsConcurrentHashMap(ruTextCache, path)) {
		setConcurrentHashMap(ruTextCache, path, RuCachedSourceText(text, fileModified(path)));
	} else {
		cached = getConcurrentHashMap(ruTextCache, path, RuCachedSourceText("", 0.0));
		setConcurrentHashMap(ruTextCache, path, RuCachedSourceText(text, cached.modified));
	}
}

ruLoadFileSource(path : string) -> void {
	setConcurrentHashMap(ruTextCache, path, RuCachedSourceText(getFileContent(path), fileModified(path)));
}

ruRange2LspLocation(range : RuRange, path : string) -> LspLocation {
	code = ruFileSource(path);
	resolver = makeLineResolver(code);
	s = findLine(resolver, range.start);
	if (range.end < 0) {
		LspLocation(
			URI("file", URIAuthority("", "", ""), path, "", ""), 
			LspRange(
				LspPosition(s.lineno - 1, s.lineIndex),
				LspPosition(-1, -1)
			)
		);
	} else {
		e = findLine(resolver, range.end);
		LspLocation(
			URI("file", URIAuthority("", "", ""), path, "", ""), 
			LspRange(
				LspPosition(s.lineno - 1, s.lineIndex - 1),
				LspPosition(e.lineno - 1, e.lineIndex - 1)
			)
		);
	}
}

ruRange2s(path : string, range : RuRange, msg : string) -> string {
	if (path == "") "" else {
		code = ruFileSource(path);
		resolver = makeLineResolver(code);
		s = findLine(resolver, range.start);
		if (range.end < 0) {
			path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		} else {
			e = findLine(resolver, range.end);
			path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + i2s(e.lineno) + ":" + i2s(e.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		}
	}
}

ruRangeWithResolver2s(path : string, range : RuRange, msg : string, resolver : LineResolver) -> string {
	if (path == "") "" else {
		s = findLine(resolver, range.start);
		if (range.end < 0) {
			path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		} else {
			e = findLine(resolver, range.end);
			path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + i2s(e.lineno) + ":" + i2s(e.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		}
	}
}

ruCachedDecl2s(name : string, conf : RuConf) -> string {
	strGlue(
		filtermap(ruCachedDecl(name), \d -> 
			maybeMap(ruFromCache(d.info.file, conf), \cached -> {
				range = ruDeclRange(d.decl, cached.source);
				text = ruFileSource(cached.source.info.path);
				ruTrimAll(substring(text, range.start, range.end - range.start))
			})
		), "\n"
	);
}

ruCacheInfo(full : bool) -> string {
	ret = 
	"cached sources: " + i2s(sizeConcurrentHashMap(ruSourceCache)) + "\n" +
	"cached names: " + i2s(sizeConcurrentHashMap(ruNameCache)) + "\n" +
	"cached source texts: " + i2s(sizeConcurrentHashMap(ruTextCache)) + "\n" +
	"cached definitions: " + i2s(sizeConcurrentHashMap(ruDefCache)) + "\n" +
	if (!full) "" else {
		"cached sources:\n" + strGlue(map(keysConcurrentHashMap(ruSourceCache), \n -> "\t" + n), "\n") + "\n"
		"cached source texts:\n" + strGlue(map(keysConcurrentHashMap(ruTextCache), \n -> "\t" + n),"\n") + "\n"
		"cached definitions:\n" + strGlue(map(keysConcurrentHashMap(ruDefCache), \n -> "\t" + n),"\n")
	};
	//ruDebugLog1("ruCacheInfo:\n" + ret);
	ret
}

RuDeclInfoAcc(
	consts : [RuConst],
	types : [RuType],
	rules : [RuRule],
	axioms : [RuAxiom],
	defs : [RuDef],
	theorems : [RuTheorem]
);

/*
ruMakeTypeSuperRules(type : RuType) -> Tree<string, Rule> {
	fold(type.supers, makeTree(), \ac, s ->
		switch (ruLookupType(acc, s)) {
			Some(env): {
				foldTree(env.supers,
					setTree(ac, s, ruMakeSuperRule(s, infer, type.pos)), 
					\super, __, a ->
						setTree(a, super, ruMakeSuperRule(super, infer, type.pos))
				)
			}
			None(): {
				acc.conf.onError("unknown super type " + s + " for a type" + infer, [RuPlace(acc.file, type.pos)]);
				ac
			}
		}
	);
}
*/
ruDeclInfo(mode : [string], conf : RuConf) -> string {
	//opts = buildSet(filter(strSplit(mode, ","), isNotSpace));
	opts = buildSet(mode);
	info_acc = fold(
		valuesConcurrentHashMap(ruNameCache), 
		RuDeclInfoAcc([], [], [], [], [], []),
		\acc, c -> {
			switch (c) {
				Some(cached): {
					decl = cached.decl;
					switch (decl) {
						RuConst(__,__,__,__):               RuDeclInfoAcc(acc with consts = concat(acc.consts, [decl]));
						RuType(__,__,__):                   RuDeclInfoAcc(acc with types  = concat(acc.types,  [decl]));
						RuRule(__,__,__,__):                RuDeclInfoAcc(acc with rules  = concat(acc.rules,  [decl]));
						RuAxiom(__,__,__,__,__,__):         RuDeclInfoAcc(acc with axioms = concat(acc.axioms, [decl]));
						RuDef(__,__,__,__,__,__,__,__):     RuDeclInfoAcc(acc with defs   = concat(acc.defs,   [decl]));
						RuTheorem(__,__,__,__,__,__,__,__): RuDeclInfoAcc(acc with theorems = concat(acc.theorems, [decl]));
					}
				}
				None(): acc;
			}
		}
	);
	rules = fold(info_acc.rules, makeTree(), \acc, r -> setTree(acc, r.name, r));
	ruDebugLog1("ruDeclInfo");
	ret = 
	"consts:   " + i2s(length(info_acc.consts)) + "\n" + 
	"types:    " + i2s(length(info_acc.types)) + "\n" + 
	"rules:    " + i2s(length(info_acc.rules)) + "\n" + 
	"axioms:   " + i2s(length(info_acc.axioms)) + "\n" + 
	"defs:     " + i2s(length(info_acc.defs)) + "\n" + 
	"theorems: " + i2s(length(info_acc.theorems)) + "\n" + 
	(if (containsSet(opts, "consts") || containsSet(opts, "all")) {
		"consts:\n" + strGlue(map(info_acc.consts, \c -> "\t" + c.name /*ru2s(c, rules)*/), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "types") || containsSet(opts, "all")) {
		"types:\n" + strGlue(map(info_acc.types, \t -> "\t" + ru2s(t, rules)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "rules") || containsSet(opts, "all")) {
		"rules:\n" + strGlue(map(info_acc.rules, \r -> "\t" + ru2s(r, rules)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "axioms") || containsSet(opts, "all")) {
		"axioms:\n" + strGlue(map(info_acc.axioms, \a : RuAxiom -> {
			/*ruDebugLog1("going to print axiom: " + a.name);
			ret = "\t" + ru2s(a, rules);
			ruDebugLog1("printed:\n" + ret + "\n");
			ret*/
			"\t" + a.name
		}), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "defs") || containsSet(opts, "all")) {
		"defs:\n" + strGlue(map(info_acc.defs, \d -> "\t" + d.name /*ru2s(d, rules)*/), "\n") + "\n"
	} else "");
	ruDebugLog1("ruDeclInfo: " + ret);
	ret
}

ruDeclRange(d : RuDecl, src : RuSource) -> RuRange {
	ind = ruIndexOfDecl(ruDeclName(d), src);
	text = ruFileSource(src.info.path);
	start = src.decls[ruIndexWithComments(ind, src)].pos;
	//start = src.decls[ind].pos;
	end = if (ind + 1 < length(src.decls)) {
		src.decls[ind + 1].pos;
	} else {
		strlen(text);
	}
	switch (d) {
		RuTheorem(__,__,__,__,__,__,__,__):
			RuRange(start, strRangeIndexOf(text, "proof {", start, end));
		default: RuRange(start, end);
	}
}

ruCachedTheoremAxioms() -> Tree<string, Set<string>> {
	assertions = ruCachedAssertoins();
	foldTree(assertions, makeTree(), \name, __, acc -> ruDoCachedTheoremAxioms(assertions, name, acc));
}

ruDoCachedTheoremAxioms(assertions : Tree<string, RuAssertion>, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(assertions, as_name)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(name,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoCachedTheoremAxioms(assertions, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, name, axioms);
						}
					}
				}
				RuAxiom(name,__,__,__,__,__):     setTree(acc, name, makeSet1(name));
				RuDef(name,__,__,__,__,__,__,__): setTree(acc, name, makeSet());
			}
		}
		None(): acc;
	}
}