import text/binary;
import ru_src;

export {
	ruToCache(src : RuSource, conf : RuConf) -> void;
	ruFromCache(file : string, conf : RuConf) -> Maybe<RuSource>;
	ruClearCache() -> void;
	ruSourceCache() -> [RuSource];

	RuCachedDecl(
		decl : RuDecl,
		src : string, // name of a source of origin
	);

	ruCachedDecl(name : string) -> Maybe<RuCachedDecl>;
}

ruCacheVersion = 0;
RuCached(source : RuSource, version : int);
ruMemoryCache = initConcurrentHashMap();
ruNameCache = initConcurrentHashMap();

ruClearCache() -> void {
	clearConcurrentHashMap(ruMemoryCache);
	clearConcurrentHashMap(ruNameCache);
	// TODO: clear serialized sources?..
}

ruSourceCache() -> [RuSource] {
	filtermap(valuesConcurrentHashMap(ruMemoryCache), idfn);
}

ruCachedPath(file : string, conf : RuConf) -> string {
	ruOpt("cache-dir", conf) + "/" + strReplace(strReplace(file, "/", "_"), ":", "_")  + ".cache"
}

ruToCache(src : RuSource, conf : RuConf) -> void {
	if (!ruOptIsFalse("caching", conf)) {
		setConcurrentHashMap(ruMemoryCache, src.info.file, Some(src));
		path = ruCachedPath(src.info.file, conf);
		iter(src.decls, \decl ->
			switch (decl) {
				RuDecl(): setConcurrentHashMap(ruNameCache, ruDeclName(decl), Some(RuCachedDecl(decl, src.info.file)));
				default: { }
			}
		);
		if (!setFileContent(ruCachedPath(src.info.file, conf), toBinary(RuCached(src, ruCacheVersion)))) {
			conf.onError("cannot save cached source " + src.info.file, []);
		}
		if (conf.verbose > 1) {
			println("saved to cached: " + src.info.file);
		}
	}
}

ruFromCache(file : string, conf : RuConf) -> Maybe<RuSource> {
	if (ruOptIsFalse("caching", conf)) None() else {
		if (containsConcurrentHashMap(ruMemoryCache, file)) {
			getConcurrentHashMap(ruMemoryCache, file, None());
		} else {
			path = ruCachedPath(file, conf);
			if (!fileExists(path)) None() else {
				deserialized = deserializeBinary(getFileContent(path), IllegalStruct());
				if (deserialized == IllegalStruct()) {
					conf.onError("WARNING: Illegal structure of cache file for " + file + ". Incremental file deleted.", []);
					ruDeleteFromCache(file, path, conf);
					None();
				} else {
					cached = cast(deserialized : flow -> RuCached);
					if (cached.version == ruCacheVersion) {
						changed = ruFileChanged(cached.source.info);
						if (changed != "") {
							if (conf.verbose >= 1) {
								println(changed);
							}
							ruDeleteFromCache(file, path, conf);
							None();
						} else {
							if (conf.verbose > 1) {
								println("loaded from cache: " + file);
							}
							setConcurrentHashMap(ruMemoryCache, file, Some(cached.source));
							Some(cached.source);
						}
					} else None();
				}
			}
		}
	}
}

ruDeleteFromCache(file : string, path : string, conf : RuConf) -> void {
	if (conf.verbose > 1) {
		println("Deleting outdated cached " + file);
	}
	removeConcurrentHashMap(ruMemoryCache, file);
	err = deleteFile(path);
	if (err != "") {
		if (fileExists(path)) {
			conf.onError("Could not delete " + path + ": " + err, []);
		}
	}
}

ruCachedDecl(name : string) -> Maybe<RuCachedDecl> {
	getConcurrentHashMap(ruNameCache, name, None());
}
