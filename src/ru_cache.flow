import text/binary;
import ru_src;
import ru_log;

export {
	ruToCache(src : RuSource, conf : RuConf) -> void;
	ruFromCache(file : string, conf : RuConf) -> Maybe<RuSource>;
	ruLoadToCache(file : string, conf : RuConf) -> void;
	ruClearCache() -> void;
	ruSourcesCache() -> [RuSource];
	ruMakeCacheDir(conf : RuConf) -> void;

	RuCachedDecl(
		decl : RuDecl,
		src : string, // name of a source of origin
	);

	ruCachedDecl(name : string) -> Maybe<RuCachedDecl>;

	// Lookups a cached file source, if not found - loads and stores.
	ruFileSource(path : string) -> string;
	// Stores a certain string as a source for some path.
	ruSetFileSource(path : string, src : string) -> void;
	// Loads file source from filesystem. May be used to undo fcSetFileSource function.
	ruLoadFileSource(path : string) -> void;

	ruRange2s(info : RuFileInfo, range : RuRange, msg : string) -> string;

	// Shows cache statistics
	ruCacheInfo(full : bool) -> string;

	ruDeclRange(d : RuDecl, src : RuSource) -> RuRange;
}

ruCacheVersion = 1;
RuCached(source : RuSource, version : int);
ruMemoryCache = initConcurrentHashMap();
ruNameCache = initConcurrentHashMap();
ruSourceCache = initConcurrentHashMap(); // Sources of files as strings

ruClearCache() -> void {
	clearConcurrentHashMap(ruMemoryCache);
	clearConcurrentHashMap(ruNameCache);
	// TODO: clear serialized sources?..
}

ruSourcesCache() -> [RuSource] {
	filtermap(valuesConcurrentHashMap(ruMemoryCache), idfn);
}

ruMakeCacheDir(conf : RuConf) -> void {
	err = ensureDirectoryExists(ruCacheDir(conf));
	if (err != "") {
		println(err);
	}
}

ruCacheDir(conf : RuConf) -> string {
	ruOptDef("cache-dir", getRussellDir() + "/cache", conf);
}

ruCachedPath(file : string, conf : RuConf) -> string {
	ruCacheDir(conf) + "/" + strReplace(strReplace(file, "/", "_"), ":", "_")  + ".cache"
}

/*
ruDependencyChangedCallback(conf : RuConf, src : RuSource) -> () -> bool {
	changed = \ -> {
		check = exists(src.imports, \imp ->
			switch (ruFromCache(imp.path, conf)) {
				Some(cached): {
					src.info.lastupdate < cached.src.info.lastupdate || cached.dependencyChanged();
				}
				None(): {
					conf.onError("a module " + imp.path + " must be already in cache, but is not there", []); true; 
				}
			}
		);
		fcAddToCache(globEnv, module.fileinfo.flowfile, FcLoaded(module, \ -> ret));
		check
	}
	fcAddToCache(globEnv, module.fileinfo.flowfile, FcLoaded(module, changed));
	changed
}*/

ruToCache(src : RuSource, conf : RuConf) -> void {
	if (!ruOptIsFalse("caching", conf)) {
		//ruDebugLog("adding to cache: " + src.info.file, conf);
		setConcurrentHashMap(ruMemoryCache, src.info.file, Some(src));
		path = ruCachedPath(src.info.file, conf);
		iter(src.decls, \decl ->
			switch (decl) {
				RuDecl(): setConcurrentHashMap(ruNameCache, ruDeclName(decl), Some(RuCachedDecl(decl, src.info.file)));
				default: { }
			}
		);
		if (!setFileContent(ruCachedPath(src.info.file, conf), toBinary(RuCached(src, ruCacheVersion)))) {
			conf.onError("cannot save cached source " + src.info.file, []);
		}
		if (conf.verbose > 1) {
			println("saved to cached: " + src.info.file);
		}
	}
}

ruFromCache(file0 : string, conf : RuConf) -> Maybe<RuSource> {
	file = ruTrimPath(file0, conf, ".ru");
	if (ruOptIsFalse("caching", conf)) None() else {
		if (containsConcurrentHashMap(ruMemoryCache, file)) {
			getConcurrentHashMap(ruMemoryCache, file, None());
		} else {
			path = ruCachedPath(file, conf);
			if (!fileExists(path)) None() else {
				deserialized = deserializeBinary(getFileContent(path), IllegalStruct());
				if (deserialized == IllegalStruct()) {
					conf.onError("WARNING: Illegal structure of cache file for " + file + ". Incremental file deleted.", []);
					ruDeleteFromCache(file, path, conf);
					None();
				} else {
					cached = cast(deserialized : flow -> RuCached);
					if (cached.version == ruCacheVersion) {
						changed = ruFileChanged(cached.source.info);
						if (changed != "") {
							if (conf.verbose >= 1) {
								println(changed);
							}
							ruDeleteFromCache(file, path, conf);
							None();
						} else {
							if (conf.verbose > 1) {
								println("loaded from cache: " + file);
							}
							setConcurrentHashMap(ruMemoryCache, file, Some(cached.source));
							Some(cached.source);
						}
					} else None();
				}
			}
		}
	}
}

ruLoadToCache(file0 : string,  conf : RuConf) -> void {
	file = ruTrimPath(file0, conf, ".ru");
	if (!containsConcurrentHashMap(ruMemoryCache, file)) {
		maybeApply(ruFromCache(file, conf), \src ->
			iter(src.imports, \imp -> ruLoadToCache(imp.path, conf))
		);
	}
}

ruDeleteFromCache(file : string, path : string, conf : RuConf) -> void {
	if (conf.verbose > 1) {
		println("Deleting outdated cached " + file);
	}
	removeConcurrentHashMap(ruMemoryCache, file);
	err = deleteFile(path);
	if (err != "") {
		if (fileExists(path)) {
			conf.onError("Could not delete " + path + ": " + err, []);
		}
	}
}

ruCachedDecl(name : string) -> Maybe<RuCachedDecl> {
	getConcurrentHashMap(ruNameCache, name, None());
}

RuCachedSourceCode(
	text : string,
	modified : double
);

ruFileSource(path : string) -> string {
	if (!containsConcurrentHashMap(ruSourceCache, path)) {
		setConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode(getFileContent(path), fileModified(path)));
	}
	cached = getConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode("", 0.0));
	modified = fileModified(path);
	if (cached.modified != modified) {
		// Reload outdated source.
		text = getFileContent(path);
		setConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode(text, modified));
		text;
	} else {
		cached.text;
	}
}

ruSetFileSource(path : string, text : string) -> void {
	if (!containsConcurrentHashMap(ruSourceCache, path)) {
		setConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode(text, fileModified(path)));
	} else {
		cached = getConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode("", 0.0));
		setConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode(text, cached.modified));
	}
}

ruLoadFileSource(path : string) -> void {
	setConcurrentHashMap(ruSourceCache, path, RuCachedSourceCode(getFileContent(path), fileModified(path)));
}

ruRange2s(info : RuFileInfo, range : RuRange, msg : string) -> string {
	if (info.path == "") "" else {
		code = ruFileSource(info.path);
		resolver = makeLineResolver(code);
		s = findLine(resolver, range.start);
		if (range.end < 0) {
			info.path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		} else {
			e = findLine(resolver, range.end);
			info.path + ":" + i2s(s.lineno) + ":" + i2s(s.lineIndex + 1) + ":" + i2s(e.lineno) + ":" + i2s(e.lineIndex + 1) + ":" + (if (msg == "") "" else " " + msg);
		}
	}
}

ruCacheInfo(full : bool) -> string {
	"cached sources: " + i2s(sizeConcurrentHashMap(ruMemoryCache)) + "\n" +
	"cached names: " + i2s(sizeConcurrentHashMap(ruNameCache)) + "\n" +
	"cached source texts: " + i2s(sizeConcurrentHashMap(ruSourceCache)) + "\n" +
	if (!full) "" else {
		"cached sources:\n" + strGlue(map(keysConcurrentHashMap(ruMemoryCache), \n -> "\t" + n), "\n") + "\n"
		"cached source texts:\n" + strGlue(map(keysConcurrentHashMap(ruSourceCache), \n -> "\t" + n),"\n")
	}
}

ruDeclRange(d : RuDecl, src : RuSource) -> RuRange {
	ind = ruIndexOfDecl(ruDeclName(d), src);
	text = ruFileSource(src.info.path);
	//start = src.decls[ruIndexWithComments(ind, src)].pos;
	start = src.decls[ind].pos;
	end = if (ind + 1 < length(src.decls)) {
		src.decls[ind + 1].pos;
	} else {
		strlen(text);
	}
	switch (d) {
		RuTheorem(__,__,__,__,__,__,__,__):
			RuRange(start, strRangeIndexOf(text, "proof {", start, end));
		default: RuRange(start, end);
	}
}
