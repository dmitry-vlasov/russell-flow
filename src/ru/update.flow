import ru/parse/parse;
import ru/math;

export {
	//ruUpdateMathPositions(math : RuMath, env : RuEnv) -> RuMath;
	ruUpdateSourcePositions(src : RuSource, math : RuMath, env : RuEnv) -> RuSource;
}


ruUpdateDeclPositions(decl1 : RuBlock, decl2 : RuParseBlock, math : RuMath) -> RuBlock {
	if (ruParseBlockName(decl2) != ruBlockName(decl1)) {
		ruCrash("DECLS DIFFER: " + id2s(ruParseBlockName(decl2)) + " != " + id2s(ruBlockName(decl1)));
	}
	set_pos = \d -> RuDescr(d with pos = decl2.pos);
	switch (decl1) {
		RuConst(descr,__,__):
			RuConst(decl1 with descr = set_pos(descr));
		RuType(descr,__):
			RuType(decl1 with descr = set_pos(descr));
		RuRule(descr,__,term): {
			rule = cast(decl2 : RuParseBlock -> RuParseRule);
			RuRule(decl1 with
				descr = set_pos(descr),
				term = RuTerm(term with pos = rule.term.pos)
			);
		}
		RuAxiom(descr, stat): {
			axiom = cast(decl2 : RuParseBlock -> RuParseAxiom);
			if (length(stat.hyps) != length(axiom.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(axiom.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(axiom.hyps)) + "\n" + 
					ru2s(decl1, math) + "\n" + ruParse2s(axiom)
				);
			}
			RuAxiom(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with
					hyps = mapi(stat.hyps, \i, hyp ->
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = axiom.hyps[i].expr.pos),
							pos = axiom.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = axiom.prop.pos)
				)
			);
		}
		RuTheorem(descr,stat,__,proof): {
			theorem = cast(decl2 : RuParseBlock -> RuParseTheorem);
			if (length(stat.hyps) != length(theorem.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(theorem.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(theorem.hyps)) + "\n" + 
					ru2s(decl1, math) + "\n" + ruParse2s(theorem)
				);
			}
			RuTheorem(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with
					hyps = mapi(stat.hyps, \i, hyp -> 
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = theorem.hyps[i].expr.pos),
							pos = theorem.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = theorem.prop.pos),
				),
				proof = RuProof(proof with 
					steps = mapi(proof.steps, \i, step -> 
						RuStep(step with
							expr = RuExp(step.expr with pos = theorem.proof.steps[i].expr.pos),
							refs = mapi(step.refs, \j, ref -> 
								switch (ref) {
									RuHypRef(ind,__): RuHypRef(ind, theorem.proof.steps[i].refs[j].pos);
									RuStepRef(ind,__): RuStepRef(ind, theorem.proof.steps[i].refs[j].pos);
								}
							),
							pos = theorem.proof.steps[i].pos
						)
					)
				)
			);
		}
		RuDef(descr, stat, defm, defs): {
			def = cast(decl2 : RuParseBlock -> RuParseDef);
			if (length(stat.hyps) != length(def.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(def.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(def.hyps)) + "\n" + 
					ru2s(decl1, math) + "\n" + ruParse2s(def)
				);
			}
			RuDef(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with 
					hyps = mapi(stat.hyps, \i, hyp -> 
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = def.hyps[i].expr.pos),
							pos = def.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = def.prop.pos)
				),
				defm = RuExp(defm with pos = def.defm.pos),
				defs = RuExp(defs with pos = def.defs.pos),
			);
		}
		RuComment(__,__,__): RuComment(decl1 with pos = decl2.pos);
	}
}

ruUpdateSourcePositions(src : RuSource, math : RuMath, env : RuEnv) -> RuSource {
	switch (ruLoadRawSource(src.info.id, env, ruLoadDescr)) {
		Some(loaded): {
			switch (ruParseSource(loaded, env)) {
				Some(parsed): {
					blocks = ruSrc2Blocks(src);
					if (length(blocks) != length(parsed.decls)) {
						ruCrash(
							"length(blocks) != length(parsed.decls)\n" + 
							i2s(length(blocks)) + " != " + i2s(length(parsed.decls))
						);
					}
					ruBclocks2Src(
						RuSource(src with 
							imports = mapi(src.imports, \i, imp -> RuImport(imp with pos = parsed.imports[i].pos))
						),
						mapi(blocks, \i, d -> ruUpdateDeclPositions(d, parsed.decls[i], math))
					);
				}
				None(): src;
			}
		}
		None(): src;
	}
}

/*
ruUpdateMathPositions(math : RuMath, env : RuEnv) -> RuMath {
	foldTree(math.sources, math, \n, src, acc -> {
		module = src.info.module;
		updated = ruUpdateSourcePositions(src, math, env);
		fold(updated.decls, 
			RuMath(acc with sources = setTree(acc.sources, n, updated)),
			\ac, decl -> {
				switch (decl) {
					RuConst(descr,__,__):
						RuMath(ac with consts = setTree(ac.consts, descr.id, decl));
					RuType(descr,__):
						RuMath(ac with types = setTree(ac.types, descr.id, decl));
					RuRule(descr,__,__):
						RuMath(ac with rules = setTree(ac.rules, descr.id, decl));
					RuAxiom(descr,__):
						RuMath(ac with assertions = setTree(ac.assertions, descr.id, decl));
					RuTheorem(descr,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, descr.id, decl));
					RuDef(descr,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, descr.id, decl));
				}
			}
		);
	});
}
*/