import ru/parse/parse;
import ru/math;

export {
	ruUpdateSourceNames(math : RuMath) -> RuMath;
	ruUpdateMathPositions(math : RuMath, conf : RuConf) -> RuMath;
	ruUpdateSourcePositions(src : RuSource, math : RuMath, conf : RuConf) -> RuSource;
}

ruUpdateSourceNames(math : RuMath) -> RuMath {
	foldTree(math.sources, math, \name, src, acc -> {
		module = src.info.module;
		id = src.info.id;
		p = fold(src.decls, Pair(acc, []), \ac, decl -> 
			switch (decl) {
				RuConst(descr,__,__): {
					upd_const = RuConst(decl with descr = RuDescr(descr with src = id));
					Pair(
						RuMath(ac.first with consts = setTree(ac.first.consts, descr.id, upd_const)), 
						concat(ac.second, [upd_const])
					);
				}
				RuType(descr, supers): {
					upd_type = RuType(decl with descr = RuDescr(descr with src = id));
					Pair(
						RuMath(ac.first with 
							types = setTree(ac.first.types, descr.id, upd_type),
							rules = fold(supers, ac.first.rules, \a, super -> {
								rule_id = ruSuperTypeName(super, descr.id);
								rule = lookupTreeDef(a, rule_id, ruNoRule);
								setTree(a, 
									rule_id, 
									RuRule(rule with descr = RuDescr(rule.descr with src = id))
								);
							})
						),
						concat(ac.second, [upd_type])
					);
				}
				RuRule(descr,__,__): {
					upd_rule = RuRule(decl with descr = RuDescr(descr with src = id));
					Pair(
						RuMath(ac.first with rules = setTree(ac.first.rules, descr.id, upd_rule)), 
						concat(ac.second, [upd_rule])
					);
				}
				RuAxiom(descr,__): {
					upd_axiom = RuAxiom(decl with descr = RuDescr(descr with src = id));
					Pair(
						RuMath(ac.first with assertions = setTree(ac.first.assertions, descr.id, upd_axiom)),
						concat(ac.second, [upd_axiom])
					);
				}
				RuTheorem(descr,__,__,__): {
					upd_theorem = RuTheorem(decl with descr = RuDescr(descr with src = id));
					Pair(
						RuMath(ac.first with assertions = setTree(ac.first.assertions, descr.id, upd_theorem)),
						concat(ac.second, [upd_theorem])
					);
				}
				RuDef(descr,__,__,__): {
					upd_def = RuDef(decl with descr = RuDescr(descr with src = id));
					Pair(
						RuMath(ac.first with assertions = setTree(ac.first.assertions, descr.id, upd_def)),
						concat(ac.second, [upd_def])
					);
				}
			}
		);
		upd_src = RuSource(src with decls = p.second);
		RuMath(p.first with sources = setTree(p.first.sources, id, upd_src));
	});
}

//ruUpdateStatementPositions(decl1 : RuBlock, decl2 : RuParseBlock) -> RuBlock 

ruUpdateDeclPositions(decl1 : RuBlock, decl2 : RuParseBlock, math : RuMath) -> RuBlock {
	if (ruParseBlockName(decl2) != ruBlockName(decl1)) {
		ruCrash("DECLS DIFFER: " + id2s(ruParseBlockName(decl2)) + " != " + id2s(ruBlockName(decl1)));
	}
	set_pos = \d -> RuDescr(d with pos = decl2.pos);
	switch (decl1) {
		RuConst(descr,__,__):
			RuConst(decl1 with descr = set_pos(descr));
		RuType(descr,__):
			RuType(decl1 with descr = set_pos(descr));
		RuRule(descr,__,term): {
			rule = cast(decl2 : RuParseBlock -> RuParseRule);
			RuRule(decl1 with
				descr = set_pos(descr),
				term = RuTerm(term with pos = rule.term.pos)
			);
		}
		RuAxiom(descr, stat): {
			axiom = cast(decl2 : RuParseBlock -> RuParseAxiom);
			if (length(stat.hyps) != length(axiom.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(axiom.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(axiom.hyps)) + "\n" + 
					ru2s(decl1, math.rules) + "\n" + ruParse2s(axiom)
				);
			}
			RuAxiom(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with
					hyps = mapi(stat.hyps, \i, hyp ->
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = axiom.hyps[i].expr.pos),
							pos = axiom.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = axiom.prop.pos)
				)
			);
		}
		RuTheorem(descr,stat,__,proof): {
			theorem = cast(decl2 : RuParseBlock -> RuParseTheorem);
			if (length(stat.hyps) != length(theorem.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(theorem.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(theorem.hyps)) + "\n" + 
					ru2s(decl1, math.rules) + "\n" + ruParse2s(theorem)
				);
			}
			RuTheorem(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with
					hyps = mapi(stat.hyps, \i, hyp -> 
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = theorem.hyps[i].expr.pos),
							pos = theorem.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = theorem.prop.pos),
				),
				proof = RuProof(proof with 
					steps = mapi(proof.steps, \i, step -> 
						RuStep(step with
							expr = RuExp(step.expr with pos = theorem.proof.steps[i].expr.pos),
							refs = mapi(step.refs, \j, ref -> 
								switch (ref) {
									RuHypRef(ind,__): RuHypRef(ind, theorem.proof.steps[i].refs[j].pos);
									RuStepRef(ind,__): RuStepRef(ind, theorem.proof.steps[i].refs[j].pos);
								}
							),
							pos = theorem.proof.steps[i].pos
						)
					)
				)
			);
		}
		RuDef(descr, stat, defm, defs): {
			def = cast(decl2 : RuParseBlock -> RuParseDef);
			if (length(stat.hyps) != length(def.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(def.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(def.hyps)) + "\n" + 
					ru2s(decl1, math.rules) + "\n" + ruParse2s(def)
				);
			}
			RuDef(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with 
					hyps = mapi(stat.hyps, \i, hyp -> 
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = def.hyps[i].expr.pos),
							pos = def.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = def.prop.pos)
				),
				defm = RuExp(defm with pos = def.defm.pos),
				defs = RuExp(defs with pos = def.defs.pos),
			);
		}
		RuComment(__,__,__): RuComment(decl1 with pos = decl2.pos);
	}
}

ruUpdateSourcePositions(src : RuSource, math : RuMath, conf : RuConf) -> RuSource {
	switch (ruLoadRawSource(src.info.id, conf, ruLoadDescr)) {
		Some(loaded): {
			switch (ruParseSource(loaded, conf)) {
				Some(parsed): {
					blocks = ruSrc2Blocks(src);
					if (length(blocks) != length(parsed.decls)) {
						ruCrash(
							"length(blocks) != length(parsed.decls)\n" + 
							i2s(length(blocks)) + " != " + i2s(length(parsed.decls))
						);
					}
					ruBclocks2Src(
						RuSource(src with 
							imports = mapi(src.imports, \i, imp -> RuImport(imp with pos = parsed.imports[i].pos))
						),
						mapi(blocks, \i, d -> ruUpdateDeclPositions(d, parsed.decls[i], math))
					);
				}
				None(): src;
			}
		}
		None(): src;
	}
}

ruUpdateMathPositions(math : RuMath, conf : RuConf) -> RuMath {
	foldTree(math.sources, math, \n, src, acc -> {
		module = src.info.module;
		updated = ruUpdateSourcePositions(src, math, conf);
		fold(updated.decls, 
			RuMath(acc with sources = setTree(acc.sources, n, updated)),
			\ac, decl -> {
				switch (decl) {
					RuConst(descr,__,__):
						RuMath(ac with consts = setTree(ac.consts, descr.id, decl));
					RuType(descr,__):
						RuMath(ac with types = setTree(ac.types, descr.id, decl));
					RuRule(descr,__,__):
						RuMath(ac with rules = setTree(ac.rules, descr.id, decl));
					RuAxiom(descr,__):
						RuMath(ac with assertions = setTree(ac.assertions, descr.id, decl));
					RuTheorem(descr,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, descr.id, decl));
					RuDef(descr,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, descr.id, decl));
				}
			}
		);
	});
}
