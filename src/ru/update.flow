import ru/parse/parse;
import ru/math;

export {
	ruUpdateSourcePositions(src : RuSource, math : RuMath, env : RuEnv) -> RuSource;
}


ruUpdateDeclPositions(decl1 : RuDecl, decl2 : RuParseDecl, math : RuMath) -> RuDecl {
	if (decl1.descr.id != decl2.id) {
		ruCrash("DECLS DIFFER: " + id2s(decl1.descr.id) + " != " + id2s(decl2.id));
	}
	set_pos = \d -> RuDescr(d with pos = decl2.pos);
	switch (decl1) {
		RuConst(descr,__,__):
			RuConst(decl1 with descr = set_pos(descr));
		RuType(descr,__):
			RuType(decl1 with descr = set_pos(descr));
		RuRule(descr,__,term): {
			rule = cast(decl2 : RuParseDecl -> RuParseRule);
			RuRule(decl1 with
				descr = set_pos(descr),
				term = RuTerm(term with pos = rule.term.pos)
			);
		}
		RuAxiom(descr, stat): {
			axiom = cast(decl2 : RuParseDecl -> RuParseAxiom);
			if (length(stat.hyps) != length(axiom.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(axiom.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(axiom.hyps)) + "\n" + 
					ru2s(decl1, math) + "\n" + ruParse2s(axiom)
				);
			}
			RuAxiom(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with
					hyps = mapi(stat.hyps, \i, hyp ->
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = axiom.hyps[i].expr.pos),
							pos = axiom.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = axiom.prop.pos)
				)
			);
		}
		RuTheorem(descr,stat,__,proof): {
			theorem = cast(decl2 : RuParseDecl -> RuParseTheorem);
			if (length(stat.hyps) != length(theorem.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(theorem.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(theorem.hyps)) + "\n" + 
					ru2s(decl1, math) + "\n" + ruParse2s(theorem)
				);
			}
			RuTheorem(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with
					hyps = mapi(stat.hyps, \i, hyp -> 
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = theorem.hyps[i].expr.pos),
							pos = theorem.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = theorem.prop.pos),
				),
				proof = RuProof(proof with 
					steps = mapi(proof.steps, \i, step -> 
						RuStep(step with
							expr = RuExp(step.expr with pos = theorem.proof.steps[i].expr.pos),
							refs = mapi(step.refs, \j, ref -> 
								switch (ref) {
									RuHypRef(ind,__): RuHypRef(ind, theorem.proof.steps[i].refs[j].pos);
									RuStepRef(ind,__): RuStepRef(ind, theorem.proof.steps[i].refs[j].pos);
								}
							),
							pos = theorem.proof.steps[i].pos
						)
					)
				)
			);
		}
		RuDef(descr, stat, defm, defs): {
			def = cast(decl2 : RuParseDecl -> RuParseDef);
			if (length(stat.hyps) != length(def.hyps)) {
				ruCrash(
					"length(stat.hyps) != length(def.stat.hyps)\n" + 
					i2s(length(stat.hyps)) + " != " + i2s(length(def.hyps)) + "\n" + 
					ru2s(decl1, math) + "\n" + ruParse2s(def)
				);
			}
			RuDef(decl1 with 
				descr = set_pos(descr),
				stat = RuStatement(stat with 
					hyps = mapi(stat.hyps, \i, hyp -> 
						RuHyp(hyp with 
							expr = RuExp(hyp.expr with pos = def.hyps[i].expr.pos),
							pos = def.hyps[i].pos
						)
					),
					prop = RuExp(stat.prop with pos = def.prop.pos)
				),
				defm = RuExp(defm with pos = def.defm.pos),
				defs = RuExp(defs with pos = def.defs.pos),
			);
		}
	}
}

ruUpdateSourcePositions(src : RuSource, math : RuMath, env : RuEnv) -> RuSource {
	switch (ruLoadRawSource(src.info.id, env, ruLoadDescr)) {
		Some(loaded): {
			switch (ruParseSource(loaded, env)) {
				Some(parsed): {
					if (length(parsed.decls) != length(parsed.decls)) {
						ruCrash(
							"length(blocks) != length(parsed.decls)\n" + 
							i2s(length(parsed.decls)) + " != " + i2s(length(parsed.decls))
						);
					}
					RuSource(src with 
						imports = mapi(src.imports, \i, imp -> RuImport(imp with pos = parsed.imports[i].pos)),
						decls = mapi(src.decls, \i, d -> ruUpdateDeclPositions(d, parsed.decls[i], math))
					);
				}
				None(): src;
			}
		}
		None(): src;
	}
}
