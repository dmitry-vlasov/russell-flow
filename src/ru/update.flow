import ru/parse/parse;
import ru/math;

export {
	ruUpdateSourceNames(math : RuMath) -> RuMath;
	ruUpdateMathPositions(math : RuMath, conf : RuConf) -> RuMath;
	ruUpdateSourcePositions(src : RuSource, conf : RuConf) -> RuSource;
}

ruUpdateSourceNames(math : RuMath) -> RuMath {
	foldTree(math.sources, math, \name, src, acc -> {
		module = src.info.module;
		p = fold(src.decls, Pair(acc, []), \ac, decl -> 
			switch (decl) {
				RuConst(n,__,__,__,__): {
					upd_const = RuConst(decl with src = module);
					Pair(
						RuMath(ac.first with consts = setTree(ac.first.consts, n, upd_const)), 
						concat(ac.second, [upd_const])
					);
				}
				RuType(n,__,__,__): {
					upd_type = RuType(decl with src = module);
					upd_math = switch (lookupTree(ac.first.types, n)) {
						Some(env): {
							foldTree(
								env.supers,
								RuMath(ac.first with types = setTree(ac.first.types, n, RuTypeEnv(env with type = upd_type))),
								\__, super, a -> 
									RuMath(a with rules = setTree(a.rules, super.name, RuRule(super with src = module)))
							);
						}
						None(): ac.first;
					}
					Pair(upd_math, concat(ac.second, [upd_type]));
				}
				RuRule(n,__,__,__,__): {
					upd_rule = RuRule(decl with src = module);
					Pair(
						RuMath(ac.first with rules = setTree(ac.first.rules, n, upd_rule)), 
						concat(ac.second, [upd_rule])
					);
				}
				RuAxiom(n,__,__,__,__,__,__): {
					upd_axiom = RuAxiom(decl with src = module);
					Pair(
						RuMath(ac.first with assertions = setTree(ac.first.assertions, n, upd_axiom)),
						concat(ac.second, [upd_axiom])
					);
				}
				RuTheorem(n,__,__,__,__,__,__,__,__): {
					upd_theorem = RuTheorem(decl with src = module);
					Pair(
						RuMath(ac.first with assertions = setTree(ac.first.assertions, n, upd_theorem)),
						concat(ac.second, [upd_theorem])
					);
				}
				RuDef(n,__,__,__,__,__,__,__,__): {
					upd_def = RuDef(decl with src = module);
					Pair(
						RuMath(ac.first with assertions = setTree(ac.first.assertions, n, upd_def)),
						concat(ac.second, [upd_def])
					);
				}
				default: 
					Pair(ac.first, concat(ac.second, [decl]));
			}
		);
		upd_src = RuSource(src with decls = p.second);
		RuMath(p.first with sources = setTree(p.first.sources, module, upd_src));
	});
}

ruUpdateDeclPositions(decl1 : RuBlock, decl2 : RuParseBlock) -> RuBlock {
	switch (decl1) {
		RuConst(__,__,__,__,__):
			RuConst(decl1 with pos = decl2.pos);
		RuType(__,__,__,__):
			RuType(decl1 with pos = decl2.pos);
		RuRule(__,__,__,term,__): {
			rule = cast(decl2 : RuParseBlock -> RuParseRule);
			RuRule(decl1 with
				pos = rule.pos,
				term = RuTerm(term with pos = rule.term.pos)
			);
		}
		RuAxiom(__,__,__,__,hyps, prop,__): {
			axiom = cast(decl2 : RuParseBlock -> RuParseAxiom);
			RuAxiom(decl1 with 
				pos = axiom.pos,
				hyps = mapi(hyps, \i, hyp -> 
					RuHyp(hyp with 
						expr = RuExp(hyp.expr with pos = axiom.hyps[i].expr.pos),
						pos = axiom.hyps[i].pos
					)
				),
				prop = RuExp(prop with pos = axiom.prop.pos)
			);
		}
		RuTheorem(__,__,__,__,__,hyps, prop, proof,__): {
			theorem = cast(decl2 : RuParseBlock -> RuParseTheorem);
			RuTheorem(decl1 with 
				pos = theorem.pos,
				hyps = mapi(hyps, \i, hyp -> 
					RuHyp(hyp with 
						expr = RuExp(hyp.expr with pos = theorem.hyps[i].expr.pos),
						pos = theorem.hyps[i].pos
					)
				),
				prop = RuExp(prop with pos = theorem.prop.pos),
				proof = RuProof(proof with 
					steps = mapi(proof.steps, \i, step -> 
						RuStep(step with
							expr = RuExp(step.expr with pos = theorem.proof.steps[i].expr.pos),
							refs = mapi(step.refs, \j, ref -> 
								switch (ref) {
									RuHypRef(ind,__): RuHypRef(ind, theorem.proof.steps[i].refs[j].pos);
									RuStepRef(ind,__): RuStepRef(ind, theorem.proof.steps[i].refs[j].pos);
								}
							),
							pos = theorem.proof.steps[i].pos
						)
					)
				)
			);
		}
		RuDef(__,__,__,__, hyps, defm, defs, prop,__): {
			def = cast(decl2 : RuParseBlock -> RuParseDef);
			RuDef(decl1 with 
				pos = def.pos,
				hyps = mapi(hyps, \i, hyp -> 
					RuHyp(hyp with 
						expr = RuExp(hyp.expr with pos = def.hyps[i].expr.pos),
						pos = def.hyps[i].pos
					)
				),
				defm = RuExp(defm with pos = def.defm.pos),
				defs = RuExp(defs with pos = def.defs.pos),
				prop = RuExp(prop with pos = def.prop.pos)
			);
		}
		RuComment(__,__,__): RuComment(decl1 with pos = decl2.pos);
	}
}

ruUpdateSourcePositions(src : RuSource, conf : RuConf) -> RuSource {
	switch (ruLoadRawSource(src.info.path, conf, ruLoadDescr)) {
		Some(loaded): {
			switch (ruParseSource(loaded, conf)) {
				Some(parsed): {
					RuSource(src with 
						imports = mapi(src.imports, \i, imp -> RuImport(imp with pos = parsed.imports[i].pos)),
						decls = mapi(src.decls, \i, d -> ruUpdateDeclPositions(d, parsed.decls[i]))
					);
				}
				None(): src;
			}
		}
		None(): src;
	}
}

ruUpdateMathPositions(math : RuMath, conf : RuConf) -> RuMath {
	foldTree(math.sources, math, \n, src, acc -> {
		module = src.info.module;
		updated = ruUpdateSourcePositions(src, conf);
		fold(updated.decls, 
			RuMath(acc with sources = setTree(acc.sources, n, updated)),
			\ac, decl -> {
				switch (decl) {
					RuConst(name,__,__,__,__):
						RuMath(ac with consts = setTree(ac.consts, name, decl));
					RuType(name,__,__,__): {
						switch (lookupTree(ac.types, name)) {
							Some(env): 
								foldTree(
									env.supers,
									RuMath(ac with 
										types = setTree(ac.types, name, RuTypeEnv(env with type = decl))
									),
									\__, super, a -> 
										RuMath(a with rules = setTree(a.rules, super.name, super))
								);
							None(): ac;
						}
					}
					RuRule(name,__,__,__,__):
						RuMath(ac with rules = setTree(ac.rules, name, decl));
					RuAxiom(name,__,__,__,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, name, decl));
					RuTheorem(name,__,__,__,__,__,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, name, decl));
					RuDef(name,__,__,__,__,__,__,__,__):
						RuMath(ac with assertions = setTree(ac.assertions, name, decl));
					RuComment(__,__,__): ac;
				}
			}
		);
	});
}
