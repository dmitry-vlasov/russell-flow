import ru/subst;

export {
	RuProofTree ::= RuProofStep, RuProofHyp;
	RuProofStep(assertion : int, children : [RuProofTree], stmt : RuStmt);
	RuProofHyp(ind : int, stmt : RuStmt);

	ruNoProofTree = RuProofHyp(-1, ruNoStmt);

	ruMakeLinearProof(proof : RuProofTree) -> [RuStep];
	ruTheoremProofTree(theorem : RuTheorem, math : RuMath) -> RuProofStep;
	ruProofTree2s(node : RuProofTree, math : RuMath) -> string;
	ruUpdateProofNodeHyps(node : RuProofTree, update : Tree<RuHyp, RuHyp>) -> RuProofTree;
	ruSubproofTree(th : RuTheorem, i : int) -> RuProofTree;

	ruProofTreeSteps(tree : RuProofTree) -> [RuProofStep];
	ruProofTreeHyps(tree : RuProofTree) -> [RuProofHyp];
	ruProofTreeNodes(tree : RuProofTree) -> [RuProofTree];
}

RuLienarProofAcc(
	steps : Tree<RuStmt, int>,
	linear : [RuStep]
);

ruMakeLinearProof(proof : RuProofTree) -> [RuStep] {
	ruDoMakeLinearProof(proof, RuLienarProofAcc(makeTree(), [])).linear;
}

ruDoMakeLinearProof(proof : RuProofTree, acc : RuLienarProofAcc) -> RuLienarProofAcc {
	switch (proof) {
		RuProofHyp(hyp, stmt): acc;
		RuProofStep(ass, children, stmt): {
			acc1 = fold(children, acc, \ac, ch -> ruDoMakeLinearProof(ch, ac));
			switch (lookupTree(acc1.steps, stmt)) {
				Some(__): acc1;
				None(): {
					ind = length(acc1.linear);
					refs = map(children, \ch -> 
						switch (ch) {
							RuProofHyp(h, __): RuHypRef(h);
							RuProofStep(__,__, ex): RuStepRef(lookupTreeDef(acc1.steps, ex, -1));
						}
					);
					RuLienarProofAcc(
						setTree(acc1.steps, stmt, ind),
						concat(acc1.linear, [RuStep(ind, ass, refs, stmt, ruNoProof, -1)])
					);
				}
			}
		}
	}
}

ruTheoremProofTree(theorem : RuTheorem, math : RuMath) -> RuProofStep {
	ruDoTheoremProofTree(theorem.proof.steps, theorem.infer.hyps, math, length(theorem.proof.steps) - 1)
}

ruDoTheoremProofTree(steps : [RuStep], hyps : [RuHyp], math : RuMath, i : int) -> RuProofStep {
	step = steps[i];
	RuProofStep(
		step.assertion,
		map(step.refs, \ref -> 
			switch (ref) {
				RuStepRef(j): ruDoTheoremProofTree(steps, hyps, math, j);
				RuHypRef(j):  RuProofHyp(j, hyps[j].stmt);
			}
		),
		step.stmt
	)
}

ruProofTree2s(node : RuProofTree, math : RuMath) -> string {
	switch (node) {
		RuProofStep(__,__,__): concatStrings(map(ruMakeLinearProof(node), \step -> ru2s(step, math)));
		RuProofHyp(hyp, stmt): "<proof hyp " + i2s(hyp) + ", stmt=" + ru2s(stmt, math) + ">";
	}
}

ruUpdateProofNodeHyps(node : RuProofTree, update : Tree<RuHyp, RuHyp>) -> RuProofTree {
	switch (node) {
		RuProofHyp(ind,__):
			switch (findInOrder(update, \h1, h2 -> if (h1.ind == ind) Some(h2) else None())) {
				Some(h2): RuProofHyp(node with ind = h2.ind);
				None(): node;
			}
		RuProofStep(__, children, __):
			RuProofStep(node with children = map(children, \ch -> ruUpdateProofNodeHyps(ch, update)));
	}
}

ruSubproofTree(th : RuTheorem, i : int) -> RuProofTree {
	if (i >= length(th.proof.steps)) {
		ruCrash("illegal proof step index: " + i2s(i) + " >= length(proof.steps): " + i2s(length(th.proof.steps)));
		ruNoProofTree;
	} else {
		step = th.proof.steps[i];
		RuProofStep(
			step.assertion,
			map(step.refs, \rf ->
				switch (rf) {
					RuHypRef(ind):  RuProofHyp(ind, th.infer.hyps[ind].stmt);
					RuStepRef(ind): ruSubproofTree(th, ind);
				}
			),
			step.stmt
		);
	}
}

ruProofTreeSteps(tree : RuProofTree) -> [RuProofStep] {
	filtermap(ruProofTreeNodes(tree), \node ->
		switch (node) {
			RuProofHyp(__,__): None();
			RuProofStep(__,__,__): Some(node);
		}
	);
}

ruProofTreeHyps(tree : RuProofTree) -> [RuProofHyp] {
	filtermap(ruProofTreeNodes(tree), \node ->
		switch (node) {
			RuProofHyp(__,__): Some(node);
			RuProofStep(__,__,__): None();
		}
	);
}

ruProofTreeNodes(tree : RuProofTree) -> [RuProofTree] {
	list2array(ruDoProofTreeNodes(makeList(), tree));
}

ruDoProofTreeNodes(acc : List<RuProofTree>, node : RuProofTree) -> List<RuProofTree> {
	switch (node) {
		RuProofHyp(ind,__): Cons(node, acc);
		RuProofStep(__, children, __): fold(children, Cons(node, acc), ruDoProofTreeNodes);
	}
}
