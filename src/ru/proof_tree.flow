import ru/subst;

export {
	RuProofTree ::= RuProofStep, RuProofHyp;
	RuProofStep(assertion : RuAssertion, children : [RuProofTree], expr : RuExp);
	RuProofHyp(hyp : RuHyp, expr : RuExp);

	ruMakeLinearProof(proof : RuProofTree) -> [RuStep];
	ruMakeTreeProof(theorem : RuTheorem, math : RuMath) -> RuProofStep;
	RuProofTree2s(node : RuProofTree, math : RuMath) -> string;
	RuProofTreeHyps(node : RuProofTree) -> Set<RuProofHyp>;
	ruUpdateProofNodeHyps(node : RuProofTree, update : Tree<RuHyp, RuHyp>) -> RuProofTree;
}

RuLienarProofAcc(
	steps : Tree<RuExp, int>,
	linear : [RuStep]
);

ruMakeLinearProof(proof : RuProofTree) -> [RuStep] {
	ruDoMakeLinearProof(proof, RuLienarProofAcc(makeTree(), [])).linear;
}

ruDoMakeLinearProof(proof : RuProofTree, acc : RuLienarProofAcc) -> RuLienarProofAcc {
	switch (proof) {
		RuProofHyp(hyp, expr): acc;
		RuProofStep(ass, children, expr): {
			acc1 = fold(children, acc, \ac, ch -> ruDoMakeLinearProof(ch, ac));
			switch (lookupTree(acc1.steps, expr)) {
				Some(__): acc1;
				None(): {
					ind = length(acc1.linear);
					refs = map(children, \ch -> 
						switch (ch) {
							RuProofHyp(h, __): RuHypRef(h.ind, -1);
							RuProofStep(__,__, ex): RuStepRef(lookupTreeDef(acc1.steps, ex, -1), -1);
						}
					);
					RuLienarProofAcc(
						setTree(acc1.steps, expr, ind),
						concat(acc1.linear, [RuStep(ind, ass.descr.id, refs, expr, ruNoProof, -1)])
					);
				}
			}
		}
	}
}

ruMakeTreeProof(theorem : RuTheorem, math : RuMath) -> RuProofStep {
	ruDoMakeTreeProof(theorem.proof.steps, theorem.stat.hyps, math, length(theorem.proof.steps) - 1)
}

ruDoMakeTreeProof(steps : [RuStep], hyps : [RuHyp], math : RuMath, i : int) -> RuProofStep {
	step = steps[i];
	RuProofStep(
		lookupTreeDef(math.decls.assertions, step.assertion, ruNoAxiom),
		map(step.refs, \ref -> 
			switch (ref) {
				RuStepRef(j, __): ruDoMakeTreeProof(steps, hyps, math, j);
				RuHypRef(j, __): RuProofHyp(hyps[j], hyps[j].expr);
			}
		),
		step.expr
	)
}

RuProofTreeHyps(node : RuProofTree) -> Set<RuProofHyp> {
	ruDoProofNodeHyps(node, makeSet());	
}

ruDoProofNodeHyps(node : RuProofTree, acc : Set<RuProofHyp>) -> Set<RuProofHyp> {
	switch (node) {
		RuProofHyp(__,__): insertSet(acc, node);
		RuProofStep(__, children, __): {
			fold(children, acc, \ac, ch -> ruDoProofNodeHyps(ch, ac))
		}
	}
}

RuProofTree2s(node : RuProofTree, math : RuMath) -> string {
	switch (node) {
		RuProofStep(__,__,__): strGlue(map(ruMakeLinearProof(node), \step -> ru2s(step, math)), "\n");
		RuProofHyp(hyp, expr): "<proof hyp " + i2s(hyp.ind) + ", expr=" + ru2s(expr, math) + ">";
	}
}

ruUpdateProofNodeHyps(node : RuProofTree, update : Tree<RuHyp, RuHyp>) -> RuProofTree {
	switch (node) {
		RuProofHyp(hyp,__): 
			RuProofHyp(node with hyp = lookupTreeDef(update, hyp, hyp));
		RuProofStep(__, children, __):
			RuProofStep(node with children = map(children, \ch -> ruUpdateProofNodeHyps(ch, update)));
	}
}
