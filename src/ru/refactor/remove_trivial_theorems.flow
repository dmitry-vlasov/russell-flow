import command;
import script/value;

export {
	ruCommRemoveTrivialTheorems : RuComm;
}

ruCommRemoveTrivialTheorems = RuComm(
	RuCommDescr(
		"remove-trivial-theorems", "refactor", "self evident", "target", false, 
		[RuCommArg("target", true, "the target: a theorem, file or all", "all")]
	),
	ruRunRemoveTrivialTheorems
);

RuTrivialReplacement(
	trivial : RuTheorem,
	replacement: int,
	hypMapping : [int],
);

ruRemoveTrivialTheorem(repl : RuTrivialReplacement, math : RuMath, name2thms : Tree<int, Set<int>>, conf : RuConf) -> RuMath {
	uses = filtermap(
		set2array(lookupTreeDef(name2thms, repl.trivial.descr.id, makeSet())),
		\name -> maybeMap(lookupTree(math.assertions, name), \a -> cast(a : RuAssertion -> RuTheorem))
	);
	fold(uses, ruDeleteAssertion(repl.trivial, math, conf), \acc, th -> {
		if (ruVerbose(conf) > 2) {
			conf.onMessage("\t\treplacing trivial '" + id2s(repl.trivial.descr.id) + "' in theorem '" + id2s(th.descr.id) + "'");
		}
		new_proof = RuProof(th.proof with 
			steps = map(th.proof.steps, \step ->
				if (step.assertion != repl.trivial.descr.id) step else {
					if (ruVerbose(conf) > 3) {
						conf.onMessage("\t\t\treplacing step " + i2s(step.ind + 1) + " from '" + id2s(step.assertion) + "' to '" + id2s(repl.replacement) + "'");
					}
					RuStep(step with 
						assertion = repl.replacement,
						refs = map(repl.hypMapping, \i -> step.refs[i])
					);
				}
			)
		);
		if (ruVerbose(conf) > 2) {
			conf.onMessage("\t\tnew proof for '" + id2s(th.descr.id) + "':\n" + 
				strIndent(strIndent(ru2s(new_proof, math)))
			);
		}
		ruReplaceAssertion(RuTheorem(th with proof = new_proof), acc, conf);
	});
}

ruMakeTrivialReplacement(th : RuTheorem) -> Maybe<RuTrivialReplacement> {
	if (length(th.proof.steps) != 1) None() else {
		step = th.proof.steps[0];
		Some(RuTrivialReplacement(th, step.assertion,
			filtermap(step.refs, \href -> 
				switch (href) {
					RuHypRef(i,__): Some(i);
					default: None();
				}
			)
		));
	}
}

ruRunRemoveTrivialTheorems(task : ScTask, env : RuState) -> Maybe<RuState> {
	timer = ruMakeTimer();
	math = env.ruMath;
	conf = env.conf;
	trivial = filtermap(getTreeValues(ruMathTheorems(math)), ruMakeTrivialReplacement);
	name2thms = ruTheoremName2ReferringTheorems(math);
	ret = fold(trivial, math, \acc, t -> {
		if (ruVerbose(conf) > 1) {
			conf.onMessage("\tremoving trivial theorem '" + id2s(t.trivial.descr.id) + "'");
		}
		ruRemoveTrivialTheorem(t, acc, name2thms, conf)
	});
	if (ruVerbose(conf) > 0) {
		conf.onMessage("found and removed " + i2s(length(trivial)) + " trivial theorems in " + ruTimePassed2s(timer));
	}
	Some(RuState(env with 
		ruMath = ret,
		vars = setTree(env.vars, "remove-trivial-theorems.removed", ValInt(length(trivial)))
	));
}
