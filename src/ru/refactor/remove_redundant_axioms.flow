import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;
import apply_map;

export {
	ruCommRemoveRedundantAxioms : RuComm;
}

ruCommRemoveRedundantAxioms = RuComm(
	RuCommDescr(
		"remove-redundant-axioms", "refactor", "removes those axioms, which are proved independently", "target", false, false, 
		[
			RuCommArg("keep-axioms", true, "keep these axioms. Comma-separated list of  names", ""),
			RuCommArg("info", true, "show info about found redundant axioms. In this case math is not updated", ""),
			RuCommArg("save", true, "save the result. Default is 1", "1"),
			RuCommArg("target", true, "the target: a theorem, file or all", "all")
		], []
	),
	ruRunRemoveRedundantAxioms
);

ruRunRemoveRedundantAxioms(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	t0 = ruMakeTimer();
	if (ruVerbose(conf) > 0) {
		env.out.onMessage("starting removing redundant axioms ... ");
	}	
	assertionsIndex = ruInitGlobalAssertionsIndex(math);
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\t\tbuilding an assertion index: " + " in " + ruTimePassed2s(t0));
	}

	keep_axioms = mapSet(buildSet(filter(strSplit(lookupTreeDef(task.args, "keep-axioms", ""), ","), isNotSpace)), s2id);
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\tkeeping axioms:\n\t" + strGlue(map(set2array(keep_axioms), id2s), ","));
	}
	deps_timer = ruMakeTimer();
	dependencies = ruMathAssertionAxioms(math);
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\tdependencies are built in " + ruTimePassed2s(deps_timer));
	}
	axioms = ruMathAxioms(math);
	redundant = foldTree(axioms, makeTree(), \ax_id, ax, acc -> {
		if (ruVerbose(conf) >= 3) {
			env.out.onMessage("\t\tChecking for redundancy of: '" + id2s(ax_id) + "' ... ");
		}
		c_ax = ruConstAssertion(ax, math);
		more_general = filtermap(ruUnifyIndex(c_ax.const.stat.prop, assertionsIndex, makeTree(), math, env, 1.0), \unified ->
			if (ax_id == unified.data.descr.id || containsSet(keep_axioms, ax_id)) None() else {
				deps = lookupTreeDef(dependencies, unified.data.descr.id, makeSet());
				if (containsSet(deps, ax_id)) None() else {
					ruMatchAssertions(unified.data, ax, math, env);
				}
			}
		);
		if (more_general == []) acc else setTree(acc, ax_id, more_general);
	});
	info = lookupTreeDef(task.args, "info", "");
	if (info != "") {
		env.out.onMessage("Redundant axioms:\n---------------------\n" + 
			strIndent(strGlue(map(tree2pairs(redundant), \p -> 
				id2s(p.first) + " <= " + 
				strGlue(map(p.second, \match -> 
					id2s(match.more.descr.id) + (if (sizeTree(match.sub) == 0) "" else " (sub!)")
				), ", ")
			), "\n")) + "\n"
		);
		if (info == "2") {
			iter(tree2pairs(redundant), \p -> {
				env.out.onMessage("Axiom:\n" + 
					strIndent(ru2s(ruSetDeclComments(p.second[0].less, []), math)) + "\nis less general then:\n" +
					strIndent(strGlue(map(p.second, \match -> 
						ru2s(ruSetDeclComments(match.more, []), math) + "\nsub:\n" +  ruSubst2s(match.sub, math) + "\n" 
					), "\n")) + 
					"\n\n"
				);
			});
		}
	}

/*
	remove_predicate = \decl -> {
		switch (decl) {
			RuAxiom(descr,__): !containsSet(keep_axioms, id2s(descr.id));
			default: false; 
		}
	}
	redundant = ref 0;
	fn = RuApplyFn(
		RuFnDescr(
			"redundancy relation", 
			remove_predicate,
			\decl -> i2d(ruArity(cast(decl : RuDecl -> RuAssertion))),
			\ -> "redundant axioms: " + i2s(^redundant)
		),
		\decl, time_limit -> {
			ax = cast(decl : RuDecl -> RuAxiom);
			ax_name = ax.descr.id;
			if (ruVerbose(conf) >= 3) {
				env.out.onMessage("\t\tChecking for redundancy of: '" + id2s(ax_name) + "' ... ");
			}
			c_ax = ruConstAssertion(ax, math);
			more_general = filtermap(ruUnifyIndex(c_ax.const.stat.prop, assertionsIndex, makeTree(), math, env, 1.0), \unified ->
				if (ax_name == unified.data.descr.id) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ax, math, env), \match -> Some(more_general_ass));
				}
			);
			if (more_general != []) {
				if (ruVerbose(conf) >= 2) {
					env.out.onMessage("\tFor '" + id2s(ax_name) + "' found more general: " + strGlue(map(more_general, \gen -> id2s(gen.descr.id)), ", "));
				}
				atomicRefIntAddition(redundant, 1);
				setConcurrentHashMap(hash_relation, ax.descr.id, more_general);
			} else {
				if (ruVerbose(conf) >= 3) {
					env.out.onMessage("\t\tMore general is not found");
				}
			}
			true;
		}
	);
	ruApplyFnComm(unit, fn);*/
	Some(state);
}
