import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;
import apply_map;

export {
	ruCommRemoveRedundantAxioms : RuComm;
}

ruCommRemoveRedundantAxioms = RuComm(
	RuCommDescr(
		"remove-redundant-axioms", "refactor", "removes those axioms, which are proved independently", "target", false, false, 
		[
			RuCommArg("keep-axioms", true, "keep these axioms. Comma-separated list of  names", ""),
			RuCommArg("info", true, "show info about found redundant axioms. In this case math is not updated", ""),
			RuCommArg("save", true, "save the result. Default is 1", "1"),
			RuCommArg("target", true, "the target: a theorem, file or all", "all")
		], []
	),
	ruRunRemoveRedundantAxioms
);

ruRunRemoveRedundantAxioms(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	hash_relation = initConcurrentHashMap();
	t0 = ruMakeTimer();
	if (ruVerbose(conf) > 0) {
		env.out.onMessage("starting removing redundant axioms ... ");
	}	
	assertionsIndex = ruInitGlobalAssertionsIndex(math);
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\t\tbuilding an assertion index: " + " in " + ruTimePassed2s(t0));
	}
	keep_axioms = buildSet(strSplit(lookupTreeDef(task.args, "keep-axioms", ""), ","));
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\tkeeping axioms:\n\t" + strGlue(set2array(keep_axioms), ","));
	}
	axioms = ruMathAxioms(math);
	//redundant = foldTree(axioms, [], )


	remove_predicate = \decl -> {
		switch (decl) {
			RuAxiom(descr,__): !containsSet(keep_axioms, id2s(descr.id));
			default: false; 
		}
	}
	redundant = ref 0;
	fn = RuApplyFn(
		RuFnDescr(
			"redundancy relation", 
			remove_predicate,
			\decl -> i2d(ruArity(cast(decl : RuDecl -> RuAssertion))),
			\ -> "redundant axioms: " + i2s(^redundant)
		),
		\decl, time_limit -> {
			ax = cast(decl : RuDecl -> RuAxiom);
			ax_name = ax.descr.id;
			if (ruVerbose(conf) >= 3) {
				env.out.onMessage("\t\tChecking for redundancy of: '" + id2s(ax_name) + "' ... ");
			}
			c_ax = ruConstAssertion(ax, math);
			more_general = filtermap(ruUnifyIndex(c_ax.const.stat.prop, assertionsIndex, makeTree(), math, env, 1.0), \unified ->
				if (ax_name == unified.data.descr.id) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ax, math, env), \match -> Some(more_general_ass));
				}
			);
			if (more_general != []) {
				if (ruVerbose(conf) >= 2) {
					env.out.onMessage("\tFor '" + id2s(ax_name) + "' found more general: " + strGlue(map(more_general, \gen -> id2s(gen.descr.id)), ", "));
				}
				atomicRefIntAddition(redundant, 1);
				setConcurrentHashMap(hash_relation, ax.descr.id, more_general);
			} else {
				if (ruVerbose(conf) >= 3) {
					env.out.onMessage("\t\tMore general is not found");
				}
			}
			true;
		}
	);
	ruApplyFnComm(unit, fn);
	Some(state);
}
