import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;
import apply_map;

export {
	ruCommRefactorLessGeneral : RuComm;
}

ruCommRefactorLessGeneral = RuComm(
	RuCommDescr(
		"refactor-less-general", "refactor", "refactors (removes or annotates) assertions, which are less general then some others", "target", false, false, 
		[
			RuCommArg("affect-axioms", true, "find redundant axioms. Default is 1", "1"),
			RuCommArg("affect-generalized", true, "find those theorems, which were generalized with 'generalize' command. Default is 1", "1"),
			RuCommArg("affect-all", true, "find all assertions, which are less generall to some other. May cause problem with cyclic imports", ""),
			RuCommArg("only-preceeding", true, "find only strictly preceeding pairs of more-less general assertions.", "1"),
			RuCommArg("update-imports", true, "include a more general module, in case it is not imported.", ""),
			RuCommArg("info", true, "show info about less general theorems.", ""),
			RuCommArg("remove", true, "remove less general theorems and replace all references to them with more general.", ""),
			RuCommArg("annotate", true, "markup less general theorems with JSON annotations in comments.", ""),
			RuCommArg("save", true, "save the result. Default is 1", "1"),
			RuCommArg("target", true, "the target: a theorem, file or all", "all")
		], []
	),
	ruRunRefactorLessGeneral
);

ruRunRefactorLessGeneral(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	hash_relation = initConcurrentHashMap();
	t0 = ruMakeTimer();
	if (ruVerbose(conf) > 0) {
		env.out.onMessage("starting refactoring less general ... ");
	}
	assertionsIndex = ruInitGlobalAssertionsIndex(math);
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\t\tbuilding an assertion index: " + " in " + ruTimePassed2s(t0));
	}
	affect_axioms = lookupTreeDef(task.args, "affect-axioms", "") == "1";
	affect_generalized = lookupTreeDef(task.args, "affect-generalized", "") == "1";
	affect_all = lookupTreeDef(task.args, "affect-all", "") == "1";
	only_preceeding = lookupTreeDef(task.args, "only-preceeding", "") == "1";
	update_imports = lookupTreeDef(task.args, "update-imports", "") == "1";
	remove = lookupTreeDef(task.args, "remove", "") == "1";
	annotate = lookupTreeDef(task.args, "annotate", "") == "1";
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage(
			"\targuments:\n" +
			"\t\taffect-axioms: " + b2s(affect_axioms) + "\n" +
			"\t\taffect-generalized: " + b2s(affect_generalized) + "\n" +
			"\t\taffect-all: " + b2s(affect_all) + "\n"
			"\t\tonly-preceeding: " + b2s(only_preceeding) + "\n" + 
			"\t\ttarget: " + lookupTreeDef(task.args, "target", "<UNDEF>") + "\n" + 
			"\t\tremove: " + b2s(remove) + "\n" + 
			"\t\tannotate: " + b2s(annotate) + "\n"
		);
	}

	affected_predicate = \decl -> {
		switch (decl) {
			RuAxiom(__,__): 
				affect_all || affect_axioms;
			RuDef(__,__,__,__): 
				affect_all;
			RuTheorem(descr,__,__,__):
				affect_all || (affect_generalized && containsKeyTree(math.assertions, s2id(id2s(descr.id) + "_gen")));
			default: false; 
		}
	}

	fn = RuApplyFn(
		RuFnDescr(
			"generality relation", 
			affected_predicate,
			\decl -> i2d(ruArity(cast(decl : RuDecl -> RuAssertion))),
		),
		\decl, time_limit -> {
			ass = cast(decl : RuDecl -> RuAssertion);
			ass_id = ass.descr.id;
			if (ruVerbose(conf) >= 3) {
				env.out.onMessage("\t\tChecking for more general then: '" + id2s(ass_id) + "' ... ");
			}
			c_ass = ruConstAssertion(ass, math);
			more_general = filtermap(ruUnifyIndex(c_ass.const.stat.prop, assertionsIndex, makeTree(), math, env, 1.0), \unified ->
				if (ass_id == unified.data.descr.id) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ass, math, env), \match -> Some(more_general_ass));
				}
			);
			if (more_general != []) {
				if (ruVerbose(conf) >= 2) {
					env.out.onMessage("\tFor '" + id2s(ass_id) + "' found more general: " + strGlue(map(more_general, \gen -> id2s(gen.descr.id)), ", "));
				}
				setConcurrentHashMap(hash_relation, ass_id, Pair(ass, more_general));
			} else {
				if (ruVerbose(conf) >= 3) {
					env.out.onMessage("\t\tMore general is not found");
				}
			}
			true;
		}
	);
	
	t1 = ruMakeTimer();
	ruApplyFnComm(unit, fn);
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("\tRAW GEN REL: " + i2s(sizeConcurrentHashMap(hash_relation)) + " in " + ruTimePassed2s(t1));
		if (ruVerbose(conf) >= 3) {
			env.out.onMessage(strGlue(map(keysConcurrentHashMap(hash_relation), 
				\ass_id -> {
					more_general : [RuAssertion] = getConcurrentHashMap(hash_relation, ass_id, Pair(ruNoAxiom, [])).second;
					"\t\t" + id2s(ass_id) + " <= " + strGlue(map(more_general, \gen -> id2s(gen.descr.id)), ", ");
				}
			), "\n"));
		}
	}
	less2greater_all : Tree<int, Pair<RuAssertion, [RuAssertion]>> = ruConcurrentHashMap2Tree(hash_relation);

	t2 = ruMakeTimer();
	affected : Set<RuAssertion> = fold(getTreeValues(less2greater_all), makeSet(), \acc, pair -> 
		insertSet(fold(pair.second, acc, \ac, gen : RuAssertion -> insertSet(ac, gen)), pair.first)
	);
	affected_names = mapSet(affected, \gen -> gen.descr.id);
	affected_srcs = foldSet(affected, makeSet(), \acc, gen -> insertSet(acc, gen.descr.src));
	affected_inds = foldTree(math.sources, makeTree(), \id, src, acc ->
		if (!containsSet(affected_srcs, id)) acc else {
			foldi(src.decls, acc, \i, ac, decl ->
				if (!containsSet(affected_names, decl.descr.id)) ac else {
					setTree(ac, decl.descr.id, i);
				}
			);
		}
	);
	affected_deps = foldSet(affected, makeTree(), \acc, d : RuAssertion -> 
		if (containsKeyTree(acc, d.descr.id)) acc else {
			ruDoMathAssertionDependencies(d.descr.id, acc, math, env)
		}
	);
	imports_map = ruMathAllImported(math, env);
	preceeds = \a1 : RuAssertion, a2 : RuAssertion -> {
		ret = if (a1.descr.src == a2.descr.src) {
			lookupTreeDef(affected_inds, a1.descr.id, 0) < lookupTreeDef(affected_inds, a2.descr.id, 0);
		} else {
			containsSet(lookupTreeDef(imports_map, a2.descr.src, makeSet()), a1.descr.src);
		}
		if (ruVerbose(conf) >= 4) {
			env.out.onMessage(id2s(a1.descr.id) + " preceeds " + id2s(a2.descr.id) + ": " + b2s(ret) + "\n");
		}
 		ret;
	}
	depends = \a1 : RuAssertion, a2 : RuAssertion -> {
		containsSet(lookupTreeDef(affected_deps, a1.descr.id, makeSet()), a2.descr.id)
	}
	if (ruVerbose(conf) >= 3) {
		env.out.onMessage("Dependencies:\n" +
			strGlue(
				map(set2array(affected), \ass -> {
					all_deps = set2array(lookupTreeDef(affected_deps, ass.descr.id, makeSet()));
					deps = filter(all_deps, \dep -> containsSet(affected_names, dep));
					"\t" + id2s(ass.descr.id) + " depends on [" + strGlue(map(deps, id2s), ", ") + "]";
				}),
				"\n"
			)
		);
	}
	compare_gen = \a1, a2 -> {
		ret = if (!affected_predicate(a1) || depends(a2, a1)) None() else {
			maybeBind(ruMatchAssertions(a2, a1, math, env), \match ->
				if (isNone(ruMatchAssertions(a1, a2, math, env))) {
					if (only_preceeding) {
						if (preceeds(a2, a1)) Some(match) else None();
					} else {
						if (!preceeds(a1, a2)) Some(match) else None();
					}
				} else if (strlen(id2s(a1.descr.id)) > strlen(id2s(a2.descr.id))) {
					if (only_preceeding) {
						if (preceeds(a2, a1)) Some(match) else None();
					} else {
						if (!preceeds(a1, a2)) Some(match) else None();
					}
				} else None()
			);
		}
		if (ruVerbose(conf) >= 4) {
			env.out.onMessage(
				id2s(a1.descr.id) + " is less general then " + id2s(a2.descr.id) + ": " + b2s(isSome(ret)) + "\nfirst:\n" +
				ru2s(a1, math) + "\nsecond:\n" + ru2s(a1, math) + "\n"
			);
		}
		ret
	}
	less2greater_arr : Tree<RuAssertion, [Pair<RuAssertion, RuAssertionMatch>]> = filterTree(
		foldTree(
			less2greater_all, makeTree(), 
			\__, pair : Pair<RuAssertion, [RuAssertion]>, acc : Tree<RuAssertion, [Pair<RuAssertion, RuAssertionMatch>]> ->
			setTree(acc, pair.first,
				filtermap(pair.second, \greater : RuAssertion -> 
					maybeMap(compare_gen(pair.first, greater), \match -> Pair(greater, match))
				)
			)
		), 
		\__, arr -> length(arr) > 0
	);
	if (ruVerbose(conf) >= 2) {
		env.out.onMessage("\tless2greater_arr: " + i2s(sizeTree(less2greater_arr)));
	}
	less2greater : Tree<RuAssertion,  Pair<RuAssertion, RuAssertionMatch>> = mapTree(
		less2greater_arr, \arr ->
		fold(tail(arr), arr[0], \acc, greater -> 
			if (strlen(id2s(greater.first.descr.id)) < strlen(id2s(acc.first.descr.id))) greater else acc
		)
	);
	to_keep = set2array(foldTree(less2greater, makeSet(), \__, greater, acc -> insertSet(acc, id2s(greater.first.descr.id))));
	to_keep_non_gen = filter(to_keep, \ass -> !endsWith(ass, "_gen"));
	if (ruVerbose(conf) >= 2) {
		env.out.onMessage("\tless: " + i2s(sizeTree(less2greater)) + ", greater: " + i2s(length(to_keep)) + " in " + ruTimePassed2s(t2));
		env.out.onMessage("\tkept non-generalized: " + i2s(length(to_keep_non_gen)) + ": \n" + 
			strGlue(map(to_keep_non_gen, \ass -> "\t\t" + ass), "\n")
		);
		if (ruVerbose(conf) >= 3) {
			env.out.onMessage(strGlue(map(tree2pairs(less2greater), \p -> 
				"\t\t" + id2s(p.first.descr.id) + " <= " + id2s(p.second.first.descr.id)
			), "\n"));
		}
	}
	if (lookupTreeDef(task.args, "info", "") == "1") {
		env.out.onMessage("Less general replacements:\n" + 
			strGlue(map(tree2pairs(less2greater), \p -> "\t" + id2s(p.first.descr.id) + " => " + id2s(p.second.first.descr.id)), "\n")
		);
		Some(env);
	} else {
		ass2step = ruAssertionsProofSteps(buildSet(map(getTreeKeys(less2greater), \less -> less.descr.id)), math);
		new_math = if (remove) {
			m = foldTree(less2greater, math, \less, greater, acc ->
				if (!affected_predicate(less)) acc else 
				ruReplaceLessWithGreater(less, greater.first, greater.second, acc, env, ass2step, update_imports)
			);
			if (lookupTreeDef(task.args, "save", "") == "1") {
				modified_sources = fold(getTreeKeys(less2greater), makeSet(), \acc, less -> 
					fold(getTreeKeys(lookupTreeDef(ass2step, less.descr.id, makeTree())), insertSet(acc, less.descr.src), \ac, thm -> 
						eitherMap(lookupTree(math.assertions, thm), \th -> insertSet(ac, th.descr.src), ac)
					)
				);
				ruWriteRefactoredSources(modified_sources, m, ruDecVerboseEnv(env));
			}
			m
		} else if (annotate) {
			m = foldTree(less2greater_arr, math, \less, greater_arr, acc ->
				if (!affected_predicate(less)) acc else 
				ruAnnotateLessWithGreater(less, map(greater_arr, \greater -> greater.first), acc, env)
			);
			if (lookupTreeDef(task.args, "save", "") == "1") {
				ruWriteRefactoredSources(buildSet(map(getTreeKeys(less2greater), \less -> less.descr.src)), m, ruDecVerboseEnv(env));
			}
			m
		} else math;
		Some(RuState(state with ru = new_math.sources));
	}
}

ruAnnotateLessWithGreater(less : RuAssertion, greater : [RuAssertion], math : RuMath, env : RuEnv) -> RuMath {	
	annotated = cast(ruModifyAnnotation(less, \annotation ->
		JsonObject(concat(
			fold(annotation.members, [], \acc, pair -> 
				if (pair.first != "less-general-then") concat(acc, [pair]) else acc
			),
			[Pair("less-general-then", JsonArray(map(greater, \gr -> JsonString(id2s(gr.descr.id)))))]
		))
	) : RuDecl -> RuAssertion);
	ruReplaceAssertion(annotated, math, env);
}

ruReplaceLessWithGreater(less : RuAssertion, greater : RuAssertion, match : RuAssertionMatch, math : RuMath, env : RuEnv, ass2step : Tree<int, Tree<int, [int]>>, update_imports : bool) -> RuMath {
	match_inds = enumFromTo(0, sizeTree(match.hypsMap) - 1);
	if (ruVerbose(env.conf) >= 2) {
		env.out.onMessage("\tReplacing: " + id2s(less.descr.id) + " with " + id2s(greater.descr.id));
	}
	eitherMap(lookupTree(math.sources, less.descr.src), 
		\src -> {
			without_less = ruDeleteAssertion(less, math, env);
			occurences = lookupTreeDef(ass2step, less.descr.id, makeTree());
			foldTree(occurences, without_less, \th_id, inds, acc ->
				if (!containsKeyTree(acc.assertions, th_id)) acc else {
					inds_set = buildSet(inds);
					th = cast(lookupTreeDef(acc.assertions, th_id, ruNoAxiom) : RuAssertion -> RuTheorem);
					new_proof = RuProof(th.proof with 
						steps = mapi(th.proof.steps, \i, step -> 
							if (!containsSet(inds_set, i)) step else {
								if (ruVerbose(env.conf) >= 3) {
									env.out.onMessage("\t\treplaced in: " + id2s(th_id) + ", step: " + i2s(i));
								}
								RuStep(step with 
									assertion = greater.descr.id,
									refs = map(match_inds, \j -> step.refs[lookupTreeDef(match.hypsMap, j, -1)])
								);
							}
						)
					);
					with_greater = if (!update_imports) acc else eitherMap(lookupTree(acc.sources, th.descr.src),
						\s -> ruAddImportToSource(s, greater.descr.src, acc, env),
						acc
					);
					ruReplaceAssertion(RuTheorem(th with proof = new_proof), with_greater, env);
				}
			);
		}, math
	);
}
