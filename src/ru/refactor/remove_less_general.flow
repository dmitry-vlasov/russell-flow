import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv;
}

ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	hash_relation = initConcurrentHashMap();
	assertionsIndex = ruInitGlobalAssertionsIndex(math);
	all_deps = ruMathAssertionDependencies(math, conf);

	fn = RuApplyFn(
		"generality relation", 
		\decl -> switch (decl) {
			RuAssertion(): true;
			default: false; 
		},
		\decl -> i2d(length(cast(decl : RuDecl -> RuAssertion).hyps)),
		\decl, time_limit -> {
			ass = cast(decl : RuDecl -> RuAssertion);
			ass_name = ruDeclName(ass);
			if (conf.verbose >= 3) {
				conf.onMessage("Checking for more general then: " + ass_name + " ... ");
			}
			c_ass = ruConstAssertion(ass, math);
			more_general = filtermap(ruUnifyIndex(c_ass.const.prop, assertionsIndex, makeTree(), math, conf), \unified ->
				if (ass_name == ruDeclName(unified.data)) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ass, math, conf), \match ->
						if (containsSet(lookupTreeDef(all_deps, ruDeclName(more_general_ass), makeSet()), ass_name)) None() else 
						Some(Triple(ass, more_general_ass, match))
					);
				}
			);
			if (more_general != []) {
				if (conf.verbose >= 2) {
					conf.onMessage("Found more general: " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", "));
				}
				setConcurrentHashMap(hash_relation, ruDeclName(ass), more_general);
			} else {
				if (conf.verbose >= 3) {
					conf.onMessage("More general is not found");
				}
			}
			true;
		}
	);
	compare_gen = \a1, a2 ->
		maybeBind(ruMatchAssertions(a2, a1, math, conf), \match ->
			if (isNone(ruMatchAssertions(a1, a2, math, conf))) Some(match) else 
			if (strlen(a1.name) > strlen(a2.name)) Some(match) else None()
		);
	t1 = timestamp();
	ruApplyFnComm(task, env, fn);
	if (conf.verbose >= 1) {
		conf.onMessage("RAW GEN REL: " + i2s(sizeConcurrentHashMap(hash_relation)) + " in " + d2st((timestamp() - t1) / 1000.0, 3) + " s");
		if (conf.verbose >= 2) {
			conf.onMessage(strGlue(map(keysConcurrentHashMap(hash_relation), 
				\ass_name -> {
					more_general : [Triple<RuAssertion, RuAssertion, RuAssertionMatch>] = getConcurrentHashMap(hash_relation, ass_name, []);
					ass_name + " <= " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", ");
				}
			), "\n"));
		}
	}
	t2 = timestamp();
	relation : Tree<string, [Triple<RuAssertion, RuAssertion, RuAssertionMatch>]> = ruConcurrentHashMap2Tree(hash_relation);
	greater2less = filterTree(
		foldTree(relation, makeTree(), \name, gens, acc ->
			fold(concat([gens[0].first], map(gens, \tr -> tr.second)), acc, \ac, a ->
				if (containsKeyTree(ac, a)) ac else {
					switch (findInOrder(ac, \m, less -> maybeMap(compare_gen(a, m), \match -> Triple(m, less, match)))) {
						Some(triple): {
							max = triple.first;
							less = triple.second;
							match = triple.third;
							if (max.name == a.name) ac else
							if (exists(less, \p -> ruDeclName(p.first) == a.name)) ac else 
							setTree(ac, max, concat(less, [Pair(a, match)]));
						}
						None(): {
							switch (findInOrder(ac, \m, less -> maybeMap(compare_gen(m, a), \match -> Triple(m, less, match)))) {
								Some(triple): {
									prev_max = triple.first;
									less = triple.second;
									match = triple.third;
									setTree(removeFromTree(ac, prev_max), a, 
										if (prev_max.name == a.name) less else 
										if (exists(less, \p -> ruDeclName(p.first) == prev_max.name)) less else 
										concat(less, [Pair(prev_max, match)])
									);
								}
								None(): setTree(ac, a, []);
							}
						}
					}
				}
			)
		),
		\m, less -> length(less) > 0
	);
	to_remove = foldTree(greater2less, 0, \__, less, acc -> acc + length(less));
	if (conf.verbose >= 1) {
		conf.onMessage("GEN REL (1): " + i2s(sizeTree(greater2less)) + ", TO REMOVE: " + i2s(to_remove) + " in " + d2st((timestamp() - t2) / 1000.0, 3) + " s");
		if (conf.verbose >= 2) {
			conf.onMessage(strGlue(map(tree2pairs(greater2less), \p -> 
				p.first.name + " >= " + strGlue(map(p.second, \a -> a.first.name), ", ")
			), "\n"));
		}
		conf.onMessage("\n\n");
	}
	less2greater_arr = foldTree(greater2less, makeTree(), \greater, less, acc ->
		fold(less, acc, \ac, l -> 
			setTree(ac, l.first, concat(lookupTreeDef(ac, l.first, []), [Pair(greater, l.second)]))
		)
	);
	/*switch (findInOrder(less2greater_arr, \less, greater_arr -> if (length(greater_arr) > 1) Some(Pair(less, greater_arr)) else None())) {
		Some(p): {
			less = p.first;
			greater_arr = p.second;
			conf.onError("More then 1 more general " +  strGlue(map(greater_arr, \gr -> "'" + gr.first.name + "'"), ", ") +  " is found for less general '" + less.name + "'", []);
			env;
		} 
		None(): {*/
			less2greater = mapTree(less2greater_arr, \greater_arr -> 
				fold(tail(greater_arr), greater_arr[0], \acc, greater -> if (strlen(greater.first.name) < strlen(acc.first.name)) greater else acc)
			);
			to_leave = foldTree(less2greater, makeSet(), \__, greater, acc -> insertSet(acc, greater.first.name));
			if (conf.verbose >= 1) {
				conf.onMessage("GEN REL (2): " + i2s(sizeTree(less2greater)) + ", TO LEAVE: " + i2s(sizeSet(to_leave)) + " in " + d2st((timestamp() - t2) / 1000.0, 3) + " s");
				if (conf.verbose >= 2) {
					conf.onMessage(strGlue(map(tree2pairs(less2greater), \p -> p.first.name + " <= " + p.second.first.name), "\n"));
				}
				conf.onMessage("\n\nall done");
			}
			ass2step = ruAssertionsProofSteps(buildSet(map(getTreeKeys(less2greater), \less -> less.name)), math);
			new_math = foldTree(less2greater, env.ruMath, \less, greater, acc ->
				ruReplaceLessWithGreater(less, greater.first, greater.second, acc, conf, ass2step)
			);
			modified_sources = fold(getTreeKeys(less2greater), makeSet(), \acc, less -> insertSet(acc, less.src));
			if (conf.verbose > 0) {
				conf.onMessage("Saving generalized sources:\n" + 
					strGlue(map(set2array(modified_sources), \src -> "\t" + src), "\n")
				);
			}
			iterSet(modified_sources, \s -> 
				maybeApply(lookupTree(new_math.sources, s), \src ->
					ruWriteSource(src, new_math, conf)
				)
			);
			RuEnv(env with ruMath = new_math);
		//}
	//}
}

ruReplaceLessWithGreater(less : RuAssertion, greater : RuAssertion, match : RuAssertionMatch, math : RuMath, conf : RuConf, ass2step : Tree<string, Tree<string, [int]>>) -> RuMath {
	match_inds = enumFromTo(0, sizeTree(match.hypsMap) - 1);
	if (conf.verbose >= 2) {
		conf.onMessage("Replacing: " + less.name + " with " + greater.name);
	}
	eitherMap(lookupTree(math.sources, less.src), 
		\src -> {
			wo_less = ruDeleteAssertion(less, math, conf);
			occurences = lookupTreeDef(ass2step, less.name, makeTree());
			foldTree(occurences, wo_less, \th_name, inds, acc ->
				if (!containsKeyTree(acc.assertions, th_name)) acc else {
					inds_set = buildSet(inds);
					th = cast(lookupTreeDef(acc.assertions, th_name, ruNoAxiom) : RuAssertion -> RuTheorem);
					new_proof = RuProof(th.proof with 
						steps = mapi(th.proof.steps, \i, step -> 
							if (!containsSet(inds_set, i)) step else {
								RuStep(step with 
									assertion = greater.name,
									refs = map(match_inds, \j -> step.refs[lookupTreeDef(match.hypsMap, j, -1)])
								);
							}
						)
					);
					ruReplaceAssertion(RuTheorem(th with proof = new_proof), acc, conf);
				}
			);
		}, math
	);
}
