import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv;
}

ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	hash_relation = initConcurrentHashMap();
	assertionsIndex = ruInitGlobalAssertionsIndex(math);

	fn = RuApplyFn(
		"generality relation", 
		\decl -> switch (decl) {
			RuAssertion(): true;
			default: false; 
		},
		\decl -> i2d(length(cast(decl : RuDecl -> RuAssertion).hyps)),
		\decl, time_limit -> {
			ass = cast(decl : RuDecl -> RuAssertion);
			ass_name = ruDeclName(ass);
			if (conf.verbose >= 3) {
				conf.onMessage("\t\tChecking for more general then: " + ass_name + " ... ");
			}
			c_ass = ruConstAssertion(ass, math);
			more_general = filtermap(ruUnifyIndex(c_ass.const.prop, assertionsIndex, makeTree(), math, conf), \unified ->
				if (ass_name == ruDeclName(unified.data)) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ass, math, conf), \match -> Some(more_general_ass));
				}
			);
			if (more_general != []) {
				if (conf.verbose >= 2) {
					conf.onMessage("\tFor " + ass_name + " found more general: " + strGlue(map(more_general, \gen -> ruDeclName(gen)), ", "));
				}
				setConcurrentHashMap(hash_relation, ruDeclName(ass), concat([ass], more_general));
			} else {
				if (conf.verbose >= 3) {
					conf.onMessage("\t\tMore general is not found");
				}
			}
			true;
		}
	);
	
	t1 = timestamp();
	ruApplyFnComm(task, env, fn);
	if (conf.verbose >= 2) {
		conf.onMessage("\tRAW GEN REL: " + i2s(sizeConcurrentHashMap(hash_relation)) + " in " + d2st((timestamp() - t1) / 1000.0, 3) + " s");
		if (conf.verbose >= 3) {
			conf.onMessage(strGlue(map(keysConcurrentHashMap(hash_relation), 
				\ass_name -> {
					more_general : [RuAssertion] = getConcurrentHashMap(hash_relation, ass_name, []);
					"\t\t" + ass_name + " <= " + strGlue(map(more_general, \gen -> ruDeclName(gen)), ", ");
				}
			), "\n"));
		}
	}
	t2 = timestamp();
	affected = fold(valuesConcurrentHashMap(hash_relation), makeSet(), \acc, gens -> 
		fold(gens, acc, \ac, gen : RuAssertion -> insertSet(ac, gen))
	);
	affected_names = mapSet(affected, \gen -> ruDeclName(gen));
	affected_srcs = foldSet(affected, makeSet(), \acc, gen -> insertSet(acc, gen.src));
	affected_inds = foldTree(math.sources, makeTree(), \name, src, acc ->
		if (!containsSet(affected_srcs, name)) acc else {
			foldi(src.decls, acc, \i, ac, decl -> {
				switch (decl) {
					RuDecl(): {
						n = ruDeclName(decl);
						if (!containsSet(affected_names, n)) ac else {
							setTree(ac, n, i);
						}
					}
					default: ac;
				}
			});
		}
	);
	imports_map = ruMathAllImported(math);
	preceeds = \a1, a2 -> {
		if (a1.src == a2.src) {
			lookupTreeDef(affected_inds, a1.name, 0) < lookupTreeDef(affected_inds, a2.name, 0);
		} else {
			containsSet(lookupTreeDef(imports_map, a2.src, makeSet()), a1.src);
		}
	}
	compare_gen = \a1, a2 ->
		maybeBind(ruMatchAssertions(a2, a1, math, conf), \match ->
			if (isNone(ruMatchAssertions(a1, a2, math, conf))) {
				if (preceeds(a2, a1)) Some(match) else None();
			} else if (strlen(a1.name) > strlen(a2.name)) {
				if (preceeds(a2, a1)) Some(match) else None();
			} else None()
		);
	greater2less = filterTree(
		foldSet(affected, makeTree(), \ac, a ->
			if (containsKeyTree(ac, a)) ac else {
				switch (findInOrder(ac, \m, less -> maybeMap(compare_gen(a, m), \match -> Triple(m, less, match)))) {
					Some(triple): {
						max = triple.first;
						less = triple.second;
						match = triple.third;
						if (max.name == a.name) ac else
						if (exists(less, \p -> ruDeclName(p.first) == a.name)) ac else 
						setTree(ac, max, concat(less, [Pair(a, match)]));
					}
					None(): {
						switch (findInOrder(ac, \m, less -> maybeMap(compare_gen(m, a), \match -> Triple(m, less, match)))) {
							Some(triple): {
								prev_max = triple.first;
								less = triple.second;
								match = triple.third;
								setTree(removeFromTree(ac, prev_max), a, 
									if (prev_max.name == a.name) less else 
									if (exists(less, \p -> ruDeclName(p.first) == prev_max.name)) less else 
									concat(less, [Pair(prev_max, match)])
								);
							}
							None(): setTree(ac, a, []);
						}
					}
				}
			}
		),
		\m, less -> length(less) > 0
	);
	to_remove = foldTree(greater2less, 0, \__, less, acc -> acc + length(less));
	if (conf.verbose >= 2) {
		conf.onMessage("\tGEN REL (1): " + i2s(sizeTree(greater2less)) + ", TO REMOVE: " + i2s(to_remove) + " in " + d2st((timestamp() - t2) / 1000.0, 3) + " s");
		if (conf.verbose >= 3) {
			conf.onMessage(strGlue(map(tree2pairs(greater2less), \p -> 
				"\t\t" + p.first.name + " >= " + strGlue(map(p.second, \a -> a.first.name), ", ")
			), "\n"));
		}
	}
	less2greater_arr = foldTree(greater2less, makeTree(), \greater, less, acc ->
		fold(less, acc, \ac, l -> 
			setTree(ac, l.first, concat(lookupTreeDef(ac, l.first, []), [Pair(greater, l.second)]))
		)
	);
	less2greater = mapTree(less2greater_arr, \greater_arr -> 
		fold(tail(greater_arr), greater_arr[0], \acc, greater -> if (strlen(greater.first.name) < strlen(acc.first.name)) greater else acc)
	);
	to_leave = foldTree(less2greater, makeSet(), \__, greater, acc -> insertSet(acc, greater.first.name));
	if (conf.verbose >= 2) {
		conf.onMessage("\tGEN REL (2): " + i2s(sizeTree(less2greater)) + ", TO LEAVE: " + i2s(sizeSet(to_leave)) + " in " + d2st((timestamp() - t2) / 1000.0, 3) + " s");
		if (conf.verbose >= 3) {
			conf.onMessage(strGlue(map(tree2pairs(less2greater), \p -> 
				"\t\t" + p.first.name + " <= " + p.second.first.name
			), "\n"));
		}
		conf.onMessage("\tgeneralization relation: all done");
	}
	ass2step = ruAssertionsProofSteps(buildSet(map(getTreeKeys(less2greater), \less -> less.name)), math);
	new_math = foldTree(less2greater, env.ruMath, \less, greater, acc ->
		ruReplaceLessWithGreater(less, greater.first, greater.second, acc, conf, ass2step)
	);
	modified_sources = fold(getTreeKeys(less2greater), makeSet(), \acc, less -> 
		fold(getTreeKeys(lookupTreeDef(ass2step, less.name, makeTree())), insertSet(acc, less.src), \ac, thm -> 
			eitherMap(lookupTree(math.assertions, thm), \th -> insertSet(ac, th.src), ac)
		)
	);
	ruWriteRefactoredSources(modified_sources, new_math, conf);
	RuEnv(env with ruMath = new_math);
}

ruReplaceLessWithGreater(less : RuAssertion, greater : RuAssertion, match : RuAssertionMatch, math : RuMath, conf : RuConf, ass2step : Tree<string, Tree<string, [int]>>) -> RuMath {
	match_inds = enumFromTo(0, sizeTree(match.hypsMap) - 1);
	if (conf.verbose >= 2) {
		conf.onMessage("\tReplacing: " + less.name + " with " + greater.name);
	}
	eitherMap(lookupTree(math.sources, less.src), 
		\src -> {
			wo_less = ruDeleteAssertion(less, math, conf);
			occurences = lookupTreeDef(ass2step, less.name, makeTree());
			foldTree(occurences, wo_less, \th_name, inds, acc ->
				if (!containsKeyTree(acc.assertions, th_name)) acc else {
					inds_set = buildSet(inds);
					th = cast(lookupTreeDef(acc.assertions, th_name, ruNoAxiom) : RuAssertion -> RuTheorem);
					new_proof = RuProof(th.proof with 
						steps = mapi(th.proof.steps, \i, step -> 
							if (!containsSet(inds_set, i)) step else {
								if (conf.verbose >= 3) {
									conf.onMessage("\t\treplaced in: " + th_name + ", step: " + i2s(i));
								}
								RuStep(step with 
									assertion = greater.name,
									refs = map(match_inds, \j -> step.refs[lookupTreeDef(match.hypsMap, j, -1)])
								);
							}
						)
					);
					ruReplaceAssertion(RuTheorem(th with proof = new_proof), acc, conf);
				}
			);
		}, math
	);
}
