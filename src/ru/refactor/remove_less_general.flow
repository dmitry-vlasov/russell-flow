import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv;
}

ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	relation = initConcurrentHashMap();
	gen_level = s2i(lookupTreeDef(task.args, "level", "2"));
	assertionsIndex = ruInitGlobalAssertionsIndex(math);

	fn = RuApplyFn(
		"generality relation", 
		\decl -> switch (decl) {
			RuAssertion(): true;
			default: false; 
		},
		\decl -> i2d(length(cast(decl : RuDecl -> RuAssertion).hyps)),
		\decl, time_limit -> {
			ass = cast(decl : RuDecl -> RuAssertion);
			c_ass = ruConstAssertion(ass, math);
			more_general = filtermap(ruUnifyIndex(c_ass.const.prop, assertionsIndex, makeTree(), math, conf), \unified ->
				if (ruDeclName(ass) == ruDeclName(unified.data)) None() else {
					maybeMap(ruMatchAssertions(unified.data, c_ass.const, math, conf), \match ->
						Triple(ass, unified.data, match)
					);
				}
			);
			if (more_general != []) {
				setConcurrentHashMap(relation, ruDeclName(ass), more_general);
			}
			true;
		}
	);
	ruApplyFnComm(task, env, fn);
	conf.onMessage("GEN REL: " + i2s(sizeConcurrentHashMap(relation)));
	iter(keysConcurrentHashMap(relation), \ass_name -> {
		more_general : [Triple<RuAssertion, RuAssertion, RuAssertionMatch>] = getConcurrentHashMap(relation, ass_name, []);
		conf.onMessage(ass_name + " <= " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", "));
	});

	//ruInsertGeneralized(generalized, env);
	env;
}

/*
ruInsertGeneralized(generalized : native, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	gen_math = fold(valuesConcurrentHashMap(generalized), math, \acc, pair : Pair<RuTheorem, RuTheorem> -> {
		th = pair.first;
		gen = pair.second;
		eitherMap(lookupTree(acc.assertions, th.name), \item -> 
			eitherMap(lookupTree(acc.sources, item.source), \src -> {
					conf.onMessage("Adding generalized sources: " + gen.name);
					ind = ruIndexOfDecl(th.name, src);
					acc1 = ruAddAssertion(gen, ind, src, acc, conf);
					/*ruAddComment(
						RuComment(
							"", // ru2s(th, acc.rules), 
							JsonObject([
							Pair("refactor",
								JsonObject([
									Pair("generalize",
										JsonObject([
											Pair("less_general", JsonString(th.name)),
											Pair("more_general", JsonString(gen.name)),
										])
									)
								])
							)
						]), -1), 
						ind, src, acc1, conf
					);* /
					acc1
				}, acc
			), acc
		);
	});
	modified_sources = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
		eitherMap(lookupTree(gen_math.assertions, pair.first.name), \item -> insertSet(acc, item.source), acc)
	);
	gen_names = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
		insertSet(acc, pair.second.name)
	);
	if (conf.verbose > 0) {
		conf.onMessage("Saving generalized sources:\n" + 
			strGlue(map(set2array(modified_sources), \src -> "\t" + src), "\n")
		);
	}
	//conf.onMessage("GEN NAMES: " + strGlue(set2array(gen_names), ", "));
	iterSet(modified_sources, \s -> 
		maybeApply(lookupTree(gen_math.sources, s), \src ->
			ruWriteSource(src, gen_math, conf)
		)
	);
	//conf.onMessage("CONF VEBOSE: " + i2s(conf.verbose));
	RuEnv(env with ruMath = gen_math);
}
*/
