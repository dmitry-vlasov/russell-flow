import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv;
}

ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	relation = initConcurrentHashMap();
	assertionsIndex = ruInitGlobalAssertionsIndex(math);
	all_deps = ruMathAssertionDependencies(math, conf);

	fn = RuApplyFn(
		"generality relation", 
		\decl -> switch (decl) {
			RuAssertion(): true;
			default: false; 
		},
		\decl -> i2d(length(cast(decl : RuDecl -> RuAssertion).hyps)),
		\decl, time_limit -> {
			ass = cast(decl : RuDecl -> RuAssertion);
			ass_name = ruDeclName(ass);
			if (conf.verbose >= 2) {
				conf.onMessage("Checking for more general then: " + ass_name + " ... ");
			}
			c_ass = ruConstAssertion(ass, math);
			more_general = filtermap(ruUnifyIndex(c_ass.const.prop, assertionsIndex, makeTree(), math, conf), \unified ->
				if (ass_name == ruDeclName(unified.data)) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ass, math, conf), \match ->
						if (containsSet(lookupTreeDef(all_deps, ruDeclName(more_general_ass), makeSet()), ass_name)) None() else 
						Some(Triple(ass, more_general_ass, match))
					);
				}
			);
			if (more_general != []) {
				if (conf.verbose >= 1) {
					conf.onMessage("Found more general: " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", "));
				}
				setConcurrentHashMap(relation, ruDeclName(ass), more_general);
			} else {
				if (conf.verbose >= 2) {
					conf.onMessage("More general is not found");
				}
			}
			true;
		}
	);
	ruApplyFnComm(task, env, fn);
	conf.onMessage("GEN REL: " + i2s(sizeConcurrentHashMap(relation)));
	iter(keysConcurrentHashMap(relation), \ass_name -> {
		more_general : [Triple<RuAssertion, RuAssertion, RuAssertionMatch>] = getConcurrentHashMap(relation, ass_name, []);
		conf.onMessage(ass_name + " <= " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", "));
	});

	//ruInsertGeneralized(generalized, env);
	env;
}

/*
ruInsertGeneralized(generalized : native, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	gen_math = fold(valuesConcurrentHashMap(generalized), math, \acc, pair : Pair<RuTheorem, RuTheorem> -> {
		th = pair.first;
		gen = pair.second;
		eitherMap(lookupTree(acc.assertions, th.name), \item -> 
			eitherMap(lookupTree(acc.sources, item.source), \src -> {
					conf.onMessage("Adding generalized sources: " + gen.name);
					ind = ruIndexOfDecl(th.name, src);
					acc1 = ruAddAssertion(gen, ind, src, acc, conf);
					/*ruAddComment(
						RuComment(
							"", // ru2s(th, acc.rules), 
							JsonObject([
							Pair("refactor",
								JsonObject([
									Pair("generalize",
										JsonObject([
											Pair("less_general", JsonString(th.name)),
											Pair("more_general", JsonString(gen.name)),
										])
									)
								])
							)
						]), -1), 
						ind, src, acc1, conf
					);* /
					acc1
				}, acc
			), acc
		);
	});
	modified_sources = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
		eitherMap(lookupTree(gen_math.assertions, pair.first.name), \item -> insertSet(acc, item.source), acc)
	);
	gen_names = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
		insertSet(acc, pair.second.name)
	);
	if (conf.verbose > 0) {
		conf.onMessage("Saving generalized sources:\n" + 
			strGlue(map(set2array(modified_sources), \src -> "\t" + src), "\n")
		);
	}
	//conf.onMessage("GEN NAMES: " + strGlue(set2array(gen_names), ", "));
	iterSet(modified_sources, \s -> 
		maybeApply(lookupTree(gen_math.sources, s), \src ->
			ruWriteSource(src, gen_math, conf)
		)
	);
	//conf.onMessage("CONF VEBOSE: " + i2s(conf.verbose));
	RuEnv(env with ruMath = gen_math);
}
*/
