import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv;
}

ruCommRemoveLessGeneral(task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	hash_relation = initConcurrentHashMap();
	assertionsIndex = ruInitGlobalAssertionsIndex(math);
	all_deps = ruMathAssertionDependencies(math, conf);

	fn = RuApplyFn(
		"generality relation", 
		\decl -> switch (decl) {
			RuAssertion(): true;
			default: false; 
		},
		\decl -> i2d(length(cast(decl : RuDecl -> RuAssertion).hyps)),
		\decl, time_limit -> {
			ass = cast(decl : RuDecl -> RuAssertion);
			ass_name = ruDeclName(ass);
			if (conf.verbose >= 3) {
				conf.onMessage("Checking for more general then: " + ass_name + " ... ");
			}
			c_ass = ruConstAssertion(ass, math);
			more_general = filtermap(ruUnifyIndex(c_ass.const.prop, assertionsIndex, makeTree(), math, conf), \unified ->
				if (ass_name == ruDeclName(unified.data)) None() else {
					more_general_ass = unified.data;
					maybeBind(ruMatchAssertions(more_general_ass, ass, math, conf), \match ->
						if (containsSet(lookupTreeDef(all_deps, ruDeclName(more_general_ass), makeSet()), ass_name)) None() else 
						Some(Triple(ass, more_general_ass, match))
					);
				}
			);
			if (more_general != []) {
				if (conf.verbose >= 2) {
					conf.onMessage("Found more general: " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", "));
				}
				setConcurrentHashMap(hash_relation, ruDeclName(ass), more_general);
			} else {
				if (conf.verbose >= 3) {
					conf.onMessage("More general is not found");
				}
			}
			true;
		}
	);
	compare_gen = \a1, a2 ->
		maybeBind(ruMatchAssertions(a2, a1, math, conf), \match ->
			if (isNone(ruMatchAssertions(a1, a2, math, conf))) Some(match) else 
			if (strlen(a1.name) > strlen(a2.name)) Some(match) else None()
		);

		//if (isNone(ruMatchAssertions(a2, a1, math, conf))) false else {
		//	if (isNone(ruMatchAssertions(a1, a2, math, conf))) true else 
		//	strlen(a1.name) > strlen(a2.name);
		//}
	t1 = timestamp();
	ruApplyFnComm(task, env, fn);
	if (conf.verbose >= 1) {
		conf.onMessage("RAW GEN REL: " + i2s(sizeConcurrentHashMap(hash_relation)) + " in " + d2st((timestamp() - t1) / 1000.0, 3) + " s");
		if (conf.verbose >= 2) {
			conf.onMessage(strGlue(map(keysConcurrentHashMap(hash_relation), 
				\ass_name -> {
					more_general : [Triple<RuAssertion, RuAssertion, RuAssertionMatch>] = getConcurrentHashMap(hash_relation, ass_name, []);
					ass_name + " <= " + strGlue(map(more_general, \triple -> ruDeclName(triple.second)), ", ");
				}
			), "\n"));
		}
	}
	t2 = timestamp();
	relation : Tree<string, [Triple<RuAssertion, RuAssertion, RuAssertionMatch>]> = ruConcurrentHashMap2Tree(hash_relation);
	refactor = filterTree(
		foldTree(relation, makeTree(), \name, gens, acc ->
			fold(concat([gens[0].first], map(gens, \tr -> tr.second)), acc, \ac, a ->
				if (containsKeyTree(ac, a)) ac else {
					switch (findInOrder(ac, \m, less -> maybeMap(compare_gen(a, m), \match -> Triple(m, less, match)))) {
						Some(triple): {
							max = triple.first;
							less = triple.second;
							match = triple.third;
							if (max.name == a.name) ac else
							if (exists(less, \p -> ruDeclName(p.first) == a.name)) ac else 
							setTree(ac, max, concat(less, [Pair(a, match)]));
						}
						None(): {
							switch (findInOrder(ac, \m, less -> maybeMap(compare_gen(m, a), \match -> Triple(m, less, match)))) {
								Some(triple): {
									prev_max = triple.first;
									less = triple.second;
									match = triple.third;
									setTree(removeFromTree(ac, prev_max), a, 
										if (prev_max.name == a.name) less else 
										if (exists(less, \p -> ruDeclName(p.first) == prev_max.name)) less else 
										concat(less, [Pair(prev_max, match)])
									);
								}
								None(): setTree(ac, a, []);
							}
						}
					}
				}
			)
		),
		\m, less -> length(less) > 0
	);
	to_remove = foldTree(refactor, 0, \__, less, acc -> acc + length(less));
	if (conf.verbose >= 1) {
		conf.onMessage("GEN REL: " + i2s(sizeTree(refactor)) + ", TO REMOVE: " + i2s(to_remove) + " in " + d2st((timestamp() - t2) / 1000.0, 3) + " s");
		if (conf.verbose >= 2) {
			conf.onMessage(strGlue(map(tree2pairs(refactor), \p -> 
				p.first.name + " >= " + strGlue(map(p.second, \a -> a.first.name), ", ")
			), "\n"));
		}
	}
	new_math = foldTree(refactor, env.ruMath, \greater, less, acc ->
		fold(less, acc, \ac, p -> ruReplaceLessWithGreater(ac, greater, p.first, p.second))
	);
	//ruInsertGeneralized(generalized, env);
	RuEnv(env with ruMath = new_math);
}

ruReplaceLessWithGreater(math : RuMath, greater : RuAssertion, less : RuAssertion, match : RuAssertionMatch) {
	/*eitherMap(lookupTree(math.sources, less.), 
		\src ->
		math
	);*/
	math
}

/*
ruInsertGeneralized(generalized : native, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	gen_math = fold(valuesConcurrentHashMap(generalized), math, \acc, pair : Pair<RuTheorem, RuTheorem> -> {
		th = pair.first;
		gen = pair.second;
		eitherMap(lookupTree(acc.assertions, th.name), \item -> 
			eitherMap(lookupTree(acc.sources, item.source), \src -> {
					conf.onMessage("Adding generalized sources: " + gen.name);
					ind = ruIndexOfDecl(th.name, src);
					acc1 = ruAddAssertion(gen, ind, src, acc, conf);
					/*ruAddComment(
						RuComment(
							"", // ru2s(th, acc.rules), 
							JsonObject([
							Pair("refactor",
								JsonObject([
									Pair("generalize",
										JsonObject([
											Pair("less_general", JsonString(th.name)),
											Pair("more_general", JsonString(gen.name)),
										])
									)
								])
							)
						]), -1), 
						ind, src, acc1, conf
					);* /
					acc1
				}, acc
			), acc
		);
	});
	modified_sources = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
		eitherMap(lookupTree(gen_math.assertions, pair.first.name), \item -> insertSet(acc, item.source), acc)
	);
	gen_names = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
		insertSet(acc, pair.second.name)
	);
	if (conf.verbose > 0) {
		conf.onMessage("Saving generalized sources:\n" + 
			strGlue(map(set2array(modified_sources), \src -> "\t" + src), "\n")
		);
	}
	//conf.onMessage("GEN NAMES: " + strGlue(set2array(gen_names), ", "));
	iterSet(modified_sources, \s -> 
		maybeApply(lookupTree(gen_math.sources, s), \src ->
			ruWriteSource(src, gen_math, conf)
		)
	);
	//conf.onMessage("CONF VEBOSE: " + i2s(conf.verbose));
	RuEnv(env with ruMath = gen_math);
}
*/
