import comm;
import ru/update;

export {
	ruCommExtractDecls : [RuComm] = [
		ruCommExtractConstants,
		ruCommExtractTypes,
		ruCommExtractRules,
		ruCommExtractAxioms,
		ruCommExtractDefs
	];
}

ruCommExtractConstants = RuComm(
	RuCommDescr("extract-constants", "refactor", "place constants in separate files", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		Some(RuState(state with ru = 
			ruRunExtract(ruMakeMathFromSources(state.ru, env), env, "constants", \decl -> 
				switch (decl) {
					RuConst(__,__,__): true;
					default: false;
				}
			).sources
		))
	}
);

ruCommExtractTypes = RuComm(
	RuCommDescr("extract-types", "refactor", "place types in separate files", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		Some(RuState(state with ru = 
			ruRunExtract(ruMakeMathFromSources(state.ru, env), env, "types", \decl -> 
				switch (decl) {
					RuType(__,__): true;
					default: false;
				}
			).sources
		))
	}
);

ruCommExtractRules = RuComm(
	RuCommDescr("extract-rules", "refactor", "place rules in separate files", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		Some(RuState(state with ru = 
			ruRunExtract(ruMakeMathFromSources(state.ru, env), env, "rules", \decl -> 
				switch (decl) {
					RuRule(__,__,__): true;
					default: false;
				}
			).sources
		))
	}
);

ruCommExtractAxioms = RuComm(
	RuCommDescr("extract-axioms", "refactor", "place axioms in separate files", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		Some(RuState(state with ru = 
			ruRunExtract(ruMakeMathFromSources(state.ru, env), env, "axioms", \decl -> 
				switch (decl) {
					RuAxiom(__,__): true;
					default: false;
				}
			).sources
		))
	}
);

ruCommExtractDefs = RuComm(
	RuCommDescr("extract-defs", "refactor", "place definitions in separate files", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		Some(RuState(state with ru = 
			ruRunExtract(ruMakeMathFromSources(state.ru, env), env, "defs", \decl -> 
				switch (decl) {
					RuDef(__,__,__,__): true;
					default: false;
				}
			).sources
		))
	}
);

ruRunExtract(math : RuMath, env : RuEnv, what : string, pred : (RuDecl) -> bool) -> RuMath {
	timer = ruMakeTimer();
	no_pred = \decl -> !pred(decl);
	all_sources = getTreeValues(math.sources);
	sources_to_extract = filter(all_sources, \src -> exists(src.decls, pred) && exists(src.decls, no_pred)); 
	new_math = fold(sources_to_extract, math, \acc, src -> {
		module = src.info.module + "_" + what;
		ax_info = RuFileInfo(
			s2id(module),
			module,
			changeFileExt(src.info.path, "") + "_" + what + ".ru",
			0.0, ""
		);
		ax_src = RuSource(src with
			info = ax_info,
			decls = filter(src.decls, pred)
		);
		no_ax = RuSource(src with 
			imports = concat(src.imports, [RuImport(ax_info.id, -1)]),
			decls = filter(src.decls, no_pred)
		);
		if (ruVerbose(env.conf) > 1) {
			env.out.onMessage("\t" + what + " extracted from " + src.info.module);
		}
		new_acc = ruAddSource(ax_src, ruAddSource(no_ax, ruRemoveSource(src, acc, env), env), env);
		if (ruVerbose(env.conf) > 2) {
			env.out.onMessage("Extracted source:\n" + ru2s(ax_src, new_acc));
		}
		new_acc;
	});
	if (ruVerbose(env.conf) > 0) {
		env.out.onMessage("ru " + what + " extracted: " +i2s(length(sources_to_extract)) + " files in " + ruTimePassed2s(timer));
	}
	ruUpdateSourceNames(new_math);
}
