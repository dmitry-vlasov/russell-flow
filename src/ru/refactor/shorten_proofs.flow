import ru/refactor/remove_unused_steps;
import ru/verify;
import ru/prover/util;
import ru/unify/indexes;

export {
	//ruShortenTheorem(theorem : RuTheorem, math : RuMath, conf : RuConf) -> Maybe<RuTheorem>;
	ruCommShortenProofs : RuComm;
}

ruCommShortenProofs = RuComm(
	"shorten-proofs", "refactor", "try to make proofs shorter", "target",
	[RuCommArg("target", true, "the target: a theorem, file or all", "all")],
	ruRunShortenProofs
);

ruSubProofVolume(i : int, steps : [RuStep]) -> int {
	fold(steps[i].refs, 1, \acc, ref -> acc + ruRefVolume(ref, steps));
}

ruRefVolume(ref : RuRef, steps : [RuStep]) -> int {
	switch (ref) {
		RuHypRef(__,__): 0;
		RuStepRef(j, __): ruSubProofVolume(j, steps);
	}
}

ruRefsEq(r1 : RuRef, r2 : RuRef) -> bool {
	switch (r1) {
		RuHypRef(i, __): 
			switch (r2) {
				RuHypRef(j, __): i == j;
				RuStepRef(__, __): false;
			}
		RuStepRef(i, __):
			switch (r2) {
				RuHypRef(__, __): false;
				RuStepRef(j, __): i == j;
			}
	}
}

ruStepsEq(s1 : RuStep, s2 : RuStep) -> bool {
	s1.ind == s2.ind &&
	s1.assertion == s2.assertion && 
	s1.expr.nodes == s2.expr.nodes &&
	length(s1.refs) == length(s2.refs) &&
	forall(zipWith(s1.refs, s2.refs, \r1, r2 -> Pair(r1, r2)),
		\p -> ruRefsEq(p.first, p.second)
	);
}

RuShortenAcc(
	theorem : RuTheorem,
	optimized : [RuStep],
	assertions : RuIndex<RuAssertion>,
	premises : RuIndex<RuRef>,
	steps : [RuStep],
	math : RuMath,
	conf : RuConf,
	cenv : RuConstEnv,
	started : double, // time, in seconds
	limit : double    // time, in seconds
);

ruShortenTheorem(th : RuTheorem, math0 : RuMath, conf : RuConf, time_limit : double) -> Maybe<RuTheorem> {
	started = ruTime();
	cth = ruConstTheorem(th, math0);
	math = cth.env.math;
	
	if (conf.verbose > 1) {
		conf.onMessage("started shortening theorem " + th.descr.name + " with time limit: " + ruTime2s(time_limit) + " ...");
	}
	
	assertions = ruInitAssertionsIndex(th.descr.name, math, conf);
	initPremises = fold(cth.const.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, RuHypRef(hyp.ind, -1), acc));
	optimized = foldi(cth.const.proof.steps, 
		RuShortenAcc(th, [], assertions, initPremises, cth.const.proof.steps, math, conf, cth.env, started , time_limit), 
		\i, acc, step -> {
			time_left = acc.limit - (ruTime() - acc.started);
			step_time_limit = time_left / i2d(length(cth.const.proof.steps) - i);
			least = ruStepVariants(step.ind, cth.const.proof.steps, th, acc, step_time_limit);
			RuShortenAcc(acc with
				optimized = concat(acc.optimized, [least]),
				premises = ruSetIndex(step.expr, RuStepRef(step.ind, -1), acc.premises)
			);
		}
	).optimized;
	ret = ruRemoveTheoremUnusedSteps(RuTheorem(th with 
		proof = ruTransformProof(RuProof(th.proof with steps = optimized), cth.env.unconst)
	), conf);
	if (conf.verbose > 2) {
		conf.onMessage("finished shortening theorem " + th.descr.name + " ...");
	}
	time_taken = ruTime() - started;
	late_for = 100.0 * (time_taken - time_limit) / time_limit;
	if (late_for > 10.0) {
		println("*** " + th.descr.name + " was late for: " + d2st(late_for, 2) + "% (" + ruTime2s(time_taken - time_limit) + ")");
	}
	switch (ret) {
		Some(th_opt): {
			if (conf.verbose > 0) {
				shortened = length(th.proof.steps) - length(th_opt.proof.steps);
				conf.onMessage("theorem " + th.descr.name + " shortened by " + i2s(shortened) + " steps in " + ruTime2s(ruTime() - started));
			}
			if (isNone(ruVerifyTheorem(th_opt, math, conf))) {
				conf.onMessage("ERROR IN SHORTENING");
				conf.onMessage("optimized:");
				conf.onMessage(ru2s(th_opt, math.rules));
				conf.onMessage("original:");
				conf.onMessage(ru2s(th, math.rules));
				quit(-1);
			}
		}
		None(): 
			if (conf.verbose > 1) {
				conf.onMessage("theorem " + th.descr.name + " was not shortened in " + ruTime2s(ruTime() - started));
			}
	}
	ret
}

RuShortenLeast(
	step : RuStep, // Current least step
	vol  : int     // volume of current least step
);

RuShortenStepAcc(
	up : RuShortenAcc,
	assertion : string,
	sub : Tree<RuVar, RuExp>,
	refs : [RuRef],
	least : ref RuShortenLeast,
	vol : int,
	started : double,
	limit : double
);

ruStepVariants(i : int, steps : [RuStep], th : RuTheorem, acc : RuShortenAcc, time_limit : double) -> RuStep {
	step = acc.steps[i];
	if (ruTime() - acc.started < acc.limit) {
		least = ref RuShortenLeast(acc.steps[i], ruSubProofVolume(i, acc.steps));
		unified = ruUnifyIndex(step.expr, acc.assertions, makeTree(), acc.math, acc.conf, acc.limit / 10.0);
		ruStepVariantsIter(th, acc, time_limit / i2d(length(unified)), least, unified, 0);
		^least.step
	} else {
		step
	}
}

ruStepVariantsIter(
	th : RuTheorem, acc : RuShortenAcc, time_limit : double, 
	least : ref RuShortenLeast, unified : [RuUnified], j : int
) -> void {
	if (j < length(unified) && ruTime() - acc.started < acc.limit) {
		unif = unified[j];
		sub = ruTransformSubst(unif.sub, acc.cenv.unconst);
		ass : RuAssertion = unif.data;
		check_disj = \-> ruCheckDisjs(sub, ass.disjs);
		check_disj_inherent = \-> ruChechDisjsInherent(sub, ass.disjs, th.disjs);
		if (ass.hyps != [] && check_disj() && check_disj_inherent()) {
			stepAcc = RuShortenStepAcc(acc, ass.descr.name, unif.sub, [], least, 1, ruTime(), time_limit);
			ruRefsVariants(0, ass.hyps, stepAcc);
		}
		if (ruTime() - acc.started < acc.limit) {
			ruStepVariantsIter(th, acc, time_limit, least, unified, j + 1);
		}
	}
}

ruRefsVariants(j : int, hyps : [RuHyp], acc : RuShortenStepAcc) -> void {
	if (j == length(hyps)) {
		new_step = RuStep(^(acc.least).step with refs = acc.refs, assertion = acc.assertion);
		acc.least := RuShortenLeast(new_step, acc.vol);
	} else {
		if (ruTime() - acc.started < acc.limit) {
			unified = ruUnifyIndex(ruApplySubst(hyps[j].expr, acc.sub), acc.up.premises, acc.sub, acc.up.math, acc.up.conf, acc.limit / 10.0);
			sorted = mergeSort(unified, \u1, u2 -> ruRefVolume(u1.data, acc.up.steps) - ruRefVolume(u2.data, acc.up.steps));
			if (ruTime() - acc.started < acc.limit) {
				ruRefsVariantsIter(j, hyps, acc, sorted, 0);
			}
		}
	}
}

ruRefsVariantsIter(j : int, hyps : [RuHyp], acc : RuShortenStepAcc, sorted : [RuUnified], i : int) -> void {
	if (i < length(sorted) && ruTime() - acc.started < acc.limit) {
		un = sorted[i];
		vol = acc.vol + ruRefVolume(un.data, acc.up.steps);
		if (vol < ^(acc.least).vol) {
			ruRefsVariants(j + 1, hyps, RuShortenStepAcc(acc with 
				refs = concat(acc.refs, [un.data]),
				sub = un.sub,
				vol = vol
			))
		}
		if (ruTime() - acc.started < acc.limit) {
			ruRefsVariantsIter(j, hyps, acc, sorted, i + 1);
		}
	}
}

ruRunShortenProofs(task : ScTask, env : RuState) -> Maybe<RuState> {	
	math = env.ruMath;
	conf = env.conf;
	counter = ref 0;
	started = ruTime();
	global_time_limit = s2i(switch (lookupTree(task.args, "time-limit")) {
		Some(limit): limit;
		None(): lookupTreeDef(conf.opts, "time-limit", "300");
	});
	theorems_num = ruMathTheoremsNum(math);
	//conf.onMessage("Total number of theorems: " + i2s(theorems_num) + ", time limit: " + i2s(global_time_limit) + "s");
	measure = \d -> {
		switch (d) {
			RuTheorem(__,__,__,__,__,__,proof,__): i2d(length(proof.steps));
			default: 0.0;
		}
	}
	shortened = ref 0;
	new_env = ruMapFnComm(task, env,
		RuMapFn(
			RuFnDescr("shorten proofs", ruDeclIsTheorem, measure),
			\th, time_limit -> {
				switch (th) {
					RuTheorem(__,__,__,__,__,__,proof,__): {
						limit_per_step = time_limit / i2d(length(proof.steps));
						upd_conf = RuConf(conf with 
							opts = setTree(conf.opts, "max_time_per_step", d2s(limit_per_step)),
							onMessage = \msg -> 
								conf.onMessage(msg + ", " + 
									"progress: " + i2s(^counter) + " = " + d2st(100.0 * i2d(^counter) / i2d(theorems_num), 2) + "%, " + 
									"passed " + ruTime2s(ruTime() - started) + " " +
									"(" + d2st(100.0 * (ruTime() - started) / i2d(global_time_limit), 2) + "% of time limit) " +
									"time limit: " + ruTime2s(time_limit) + " " +
									"time limit per step: " + ruTime2s(limit_per_step) + " " +
									"steps: " + i2s(length(proof.steps))
								)
						);
						atomicRefIntAddition(counter, 1);
						ret = ruShortenTheorem(th, math, upd_conf, time_limit);
						if (isSome(ret)) {
							atomicRefIntAddition(shortened, 1);
						} else {
							1;
						}
						ret;
					}
					default: None();
				}
			}
		)
	);
	Some(RuState(new_env with 
		vars = setTree(env.vars, "shorten-proofs.shortened", ValInt(^shortened))
	));
}
