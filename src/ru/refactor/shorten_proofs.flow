import ru/refactor/remove_unused_steps;
import ru/verify/verify;
import ru/prover/util;
import ru/unify/prod;
import ru/util/target;

export {
	//ruShortenTheorem(theorem : RuTheorem, math : RuMath, conf : RuConf) -> Maybe<RuTheorem>;
	ruCommShortenProofs : RuComm;
}

ruCommShortenProofs = RuComm(
	"shorten-proofs", "refactor", "try to make proofs shorter", "target", false,
	[RuCommArg("target", true, "the target: a theorem, file or all", "all")],
	ruRunShortenProofs
);

ruSubProofVolume(i : int, steps : [RuStep]) -> int {
	fold(steps[i].refs, 1, \acc, ref -> acc + ruRefVolume(ref, steps));
}

ruRefVolume(ref : RuRef, steps : [RuStep]) -> int {
	switch (ref) {
		RuHypRef(__,__): 0;
		RuStepRef(j, __): ruSubProofVolume(j, steps);
	}
}

ruRefsEq(r1 : RuRef, r2 : RuRef) -> bool {
	switch (r1) {
		RuHypRef(i, __): 
			switch (r2) {
				RuHypRef(j, __): i == j;
				RuStepRef(__, __): false;
			}
		RuStepRef(i, __):
			switch (r2) {
				RuHypRef(__, __): false;
				RuStepRef(j, __): i == j;
			}
	}
}

ruStepsEq(s1 : RuStep, s2 : RuStep) -> bool {
	s1.ind == s2.ind &&
	s1.assertion == s2.assertion && 
	s1.expr.nodes == s2.expr.nodes &&
	length(s1.refs) == length(s2.refs) &&
	forall(zipWith(s1.refs, s2.refs, \r1, r2 -> Pair(r1, r2)),
		\p -> ruRefsEq(p.first, p.second)
	);
}

RuShortenEnv(
	assertions : RuIndex<RuAssertion>,
	imports : Tree<int, Set<int>>,
	math : RuMath,
	conf : RuConf
);

RuShortenAcc(
	env : RuShortenEnv,
	theorem : RuTheorem,
	optimized : [RuStep],
	premises : RuIndex<RuRef>,
	steps : [RuStep],
	cenv : RuConstEnv,
	timer : RuTimer
);

ccc = ref 0;

ruShortenTheorem(th : RuTheorem, time_limit : double, env : RuShortenEnv) -> Maybe<RuTheorem> {
	started = ruTime();
	math0 = env.math;
	conf = env.conf;
	cth = ruConstTheorem(th, math0);
	math = cth.env.math;
	
	if (ruVerbose(conf) > 1) {
		conf.onMessage("started shortening theorem '" + id2s(th.descr.id) + "' with time limit: " + ruTime2s(time_limit) + " ...");
	}

	initPremises = fold(cth.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, RuHypRef(hyp.ind, -1), acc));
	optimized = foldi(cth.const.proof.steps, 
		RuShortenAcc(env, th, [], initPremises, cth.const.proof.steps, cth.env, ruMakeLimitedTimer(time_limit)), 
		\i, acc, step -> {
			step_time_limit = ruTimeLeft(acc.timer) / i2d(length(cth.const.proof.steps) - i);
			least = ruStepMinVariant(step.ind, cth.const.proof.steps, th, acc, step_time_limit);
			RuShortenAcc(acc with
				optimized = concat(acc.optimized, [least]),
				premises = ruSetIndex(step.expr, RuStepRef(step.ind, -1), acc.premises)
			);
		}
	).optimized;
	ret = ruRemoveTheoremUnusedSteps(RuTheorem(th with 
		proof = ruTransformProof(RuProof(th.proof with steps = optimized), cth.env.unconst)
	), conf);
	if (ruVerbose(conf) > 2) {
		conf.onMessage("finished shortening theorem '" + id2s(th.descr.id) + "' ...");
	}
	time_taken = ruTime() - started;
	late_for = 100.0 * (time_taken - time_limit) / time_limit;
	if (late_for > 10.0) {
		println("*** " + id2s(th.descr.id) + " was late for: " + d2st(late_for, 2) + "% (" + ruTime2s(time_taken - time_limit) + ")");
	}
	if (late_for < 0.5) {
		//println("*** " + th.descr.name + " was UNDER late for: " + d2st(late_for, 2) + "% (limit: " + ruTime2s(time_limit) + ", taken: " + ruTime2s(time_taken) + ")");
	}
	switch (ret) {
		Some(th_opt): {
			if (ruVerbose(conf) > 0) {
				shortened = length(th.proof.steps) - length(th_opt.proof.steps);
				conf.onMessage("theorem '" + id2s(th.descr.id) + "' shortened by " + i2s(shortened) + " steps in " + ruTime2s(ruTime() - started));
			}
			res = ruVerifyTheorem(th_opt, math, conf);
			if (!ruIsVerified(res)) {
				conf.onMessage("ERROR IN SHORTENING");
				conf.onMessage("optimized:");
				conf.onMessage(ru2s(th_opt, math.rules));
				conf.onMessage("original:");
				conf.onMessage(ru2s(th, math.rules));
				ruOutputVerifyErrs(res, math, conf);
				quit(-1);
			}
		}
		None(): 
			if (ruVerbose(conf) > 1) {
				conf.onMessage("theorem '" + id2s(th.descr.id) + "' was not shortened in " + ruTime2s(ruTime() - started));
			}
	}
	ret
}

RuShortenLeast(
	step : RuStep, // Current least step
	vol  : int     // volume of current least step
);

RuShortenStepAcc(
	up : RuShortenAcc,
	assertion : string,
	sub : Tree<RuVar, RuExp>,
	refs : [RuRef],
	least : ref RuShortenLeast,
	vol : int,
	timer : RuTimer
);

ruStepMinVariant(i : int, steps : [RuStep], th : RuTheorem, acc : RuShortenAcc, time_limit : double) -> RuStep {
	step = acc.steps[i];
	if (ruTimeIsOver(acc.timer)) step else {
		step_timer = ruMakeLimitedTimer(time_limit);
		unify_limit = ruTimeLeft(step_timer) / 10.0;
		unified = filter(
			ruUnifyIndex(
				step.expr, acc.env.assertions, makeTree(), 
				acc.env.math, acc.env.conf, unify_limit
			),
			\unif -> ruDeclPreceeds(unif.data, th, acc.env.imports)
		);
		ruFold(unified, 
			RuShortenLeast(step, ruSubProofVolume(i, acc.steps)), 
			\least, unif -> {
				unconst_sub = \s -> ruTransformSubst(s, acc.cenv.unconst);
				ass : RuAssertion = unif.data;
				check_disj = \s -> {
					unc_s = unconst_sub(s);
					ruCheckDisjs(unc_s, ass.stat.disjs) && 
					ruCheckDisjsInherent(unc_s, ass.stat.disjs, th.stat.disjs);
				}
				if (ass.stat.hyps != [] && check_disj(unif.sub)) {
					hyps_prod = map(ass.stat.hyps, \h -> {
						hyp_unified = ruUnifyIndex(
							ruApplySubst(h.expr, unif.sub), acc.premises, unif.sub, 
							acc.env.math, acc.env.conf, unify_limit / i2d(ruArity(ass))
						);
						sorted = mergeSort(hyp_unified, \u1, u2 -> 
							ruRefVolume(u1.data, acc.steps) - ruRefVolume(u2.data, acc.steps)
						);
						map(sorted, \un -> RuSubData(un.sub, un.data));
					});
					sub_unified = ruUnifySubsProd(hyps_prod, \__-> true, \ -> ruTimeIsOver(step_timer), acc.env.math, acc.env.conf);
					ruFold(sub_unified, least, 
						\le, sd -> {
							st = RuStep(le.step with refs = sd.data, assertion = ass.descr.id);
							vol = ruSubProofVolume(st.ind, replace(acc.steps, st.ind, st));
							if (vol < le.vol && check_disj(sd.sub)) {
								RuShortenLeast(st, vol) 
							} else {
								le;
							}
						},
						step_timer
					);
				} else {
					least;
				}
			}, 
			step_timer
		).step;
	}
}

/*
ruStepVariants1(i : int, steps : [RuStep], th : RuTheorem, acc : RuShortenAcc, time_limit : double) -> RuStep {
	step = acc.steps[i];
	if (!ruTimeIsOver(acc.timer)) {
		step_timer = ruMakeLimitedTimer(time_limit);
		unify_limit = ruTimeLeft(step_timer) / 10.0;
		unified = filter(
			ruUnifyIndex(
				step.expr, acc.env.assertions, makeTree(), 
				acc.env.math, acc.env.conf, unify_limit
			),
			\unif -> ruDeclPreceeds(unif.data, th, acc.env.imports)
		);
		ruFold(unified, 
			RuShortenLeast(step, ruSubProofVolume(i, acc.steps)),
			\least, unif -> {
				unconst_sub = \s -> ruTransformSubst(s, acc.cenv.unconst);
				ass : RuAssertion = unif.data;
				check_disj = \s -> ruCheckDisjs(unconst_sub(s), ass.disjs);
				check_disj_inherent = \s -> ruChechDisjsInherent(unconst_sub(s), ass.disjs, th.disjs);
				if (ass.hyps == [] || !check_disj(unif.sub) || !check_disj_inherent(unif.sub)) least else {
					hyps_prod = CartProd(map(ass.hyps, \h -> {
						hyp_unified = ruUnifyIndex(
							ruApplySubst(h.expr, unif.sub), acc.premises, unif.sub, 
							acc.env.math, acc.env.conf, unify_limit / i2d(length(ass.hyps))
						);
						mergeSort(hyp_unified, \u1, u2 -> ruRefVolume(u1.data, acc.steps) - ruRefVolume(u2.data, acc.steps));
					}));
					ruFoldCartProd(hyps_prod, least,
						\le, hyps_unif  -> {
							refs = map(hyps_unif, \un -> un.data);
							st = RuStep(le.step with refs = refs, assertion = ass.descr.name);
							vol = ruSubProofVolume(st.ind, replace(acc.steps, st.ind, st));
							if (vol >= le.vol) le else {
								eitherMap(
									fold(map(hyps_unif, \un -> un.sub), Some(unif.sub), \ac, su ->
										maybeBind(ac, \s -> ruMergeSubst(s, su))
									),
									\s -> if (!check_disj(s) || !check_disj_inherent(s)) le else {
										RuShortenLeast(st, vol);
									},
									le
								);
							}
						},
						ruMakeLimitedTimer(acc.timer.limit)
					);
				}
			},
			step_timer
		).step;
	} else {
		step;
	}
}
*/

ruRunShortenProofs(task : ScTask, env : RuState) -> Maybe<RuState> {	
	math = env.ruMath;
	conf = env.conf;
	counter = ref 0;
	started = ruTime();
	switch (ruDetermineTarget(task, math, conf)) {
		Some(target): {
			global_time_limit = 1000 * s2i(switch (lookupTree(task.args, "time-limit")) {
				Some(limit): limit;
				None(): lookupTreeDef(conf.opts, "time-limit", "300");
			});
			theorems_num = ruMathTheoremsNum(math);
			//conf.onMessage("Total number of theorems: " + i2s(theorems_num) + ", time limit: " + i2s(global_time_limit) + "s");
			measure = \d -> {
				switch (d) {
					RuTheorem(__,__,__,proof): i2d(length(proof.steps));
					default: 0.0;
				}
			}
			shortened = ref 0;
			all_imported = ruMathAllImported(math, conf);
			index = switch (target) {
				RuTargetMath(): 
					ruInitGlobalAssertionsIndex(math);
				RuTargetSource(src): 
					ruInitSourceAssertionsIndex(src, math, conf);
				RuTargetAssertion(th): {
					switch (th) {
						RuTheorem(__,__,__,__): {
							ruInitTheoremAssertionsIndex(th, math, conf);
						}
						default: ruInitGlobalAssertionsIndex(math);
					}
				}
			}
			shorten_env = RuShortenEnv(index, all_imported, math, conf);
			upd_conf = \proof, time_limit -> {
				limit_per_step = time_limit / i2d(length(proof.steps));
				RuConf(conf with 
					opts = setTree(conf.opts, "max_time_per_step", d2s(limit_per_step)),
					onMessage = \msg -> 
						conf.onMessage(msg + ", " + 
							"progress: " + i2s(^counter) + " = " + d2st(100.0 * i2d(^counter) / i2d(theorems_num), 2) + "%, " + 
							"passed " + ruTime2s(ruTime() - started) + " " +
							"(" + d2st(100.0 * (ruTime() - started) / i2d(global_time_limit), 2) + "% of time limit) " +
							"time limit: " + ruTime2s(time_limit) + " " +
							"time limit per step: " + ruTime2s(limit_per_step) + " " +
							"steps: " + i2s(length(proof.steps))
						)
				);
			}
			shorten_fn = \th, time_limit -> {
				switch (th) {
					RuTheorem(__,__,__,proof): {
						atomicRefIntAddition(counter, 1);
						ret = ruShortenTheorem(th, time_limit, RuShortenEnv(shorten_env with conf = upd_conf(proof, time_limit)));
						if (isSome(ret)) {
							atomicRefIntAddition(shortened, 1);
						} else {
							1;
						}
						ret;
					}
					default: None();
				}
			}
			predicate = switch (target) {
				RuTargetMath(): 
					ruDeclIsTheorem;
				RuTargetSource(src): \decl ->
					switch (ruFindSource(decl.descr.id, math)) {
						Some(s): ruDeclIsTheorem(decl) && src == s;
						None(): false;
					}
				RuTargetAssertion(ass): 
					\decl -> ass.descr.id == decl.descr.id;
			}
			descr = RuFnDescr("shorten proofs", predicate, measure);
			new_env = ruMapFnComm(task, env,
				RuMapFn(
					descr,
					shorten_fn
				)
			);
			Some(RuState(new_env with 
				vars = setTree(env.vars, "shorten-proofs.shortened", ValInt(^shortened))
			));
		}
		None(): {
			conf.onMessage("no target for proof shortening");
			Some(env);
		}
	}
}
