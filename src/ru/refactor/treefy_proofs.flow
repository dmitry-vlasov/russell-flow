import comm;
import script/value;
import ru/util/target;
import apply_map;

export {
	ruCommTreefyProofs : RuComm;
}

ruCommTreefyProofs = RuComm(
	RuCommDescr(
		"treefy-proofs", "refactor", "unwrap linear proofs to hierarchical", "target", false, false, 
		[
			RuCommArg("target", true, "the target: a theorem, file or all", "all"),
			RuCommArg("max-len", true, "maximum steps number at one level", "10")
		], []
	),
	ruRunTreefyProofs
);

ruTreefyTheorem(th : RuTheorem, max_len : int, math : RuMath, env : RuEnv) -> RuTheorem {
	RuTheorem(th with
		proof = RuProof(th.proof with
			steps = ruTreefySteps(th.proof.steps, max_len, math, env)
		)
	);
}

RuLemma(
	step : RuStep,
	subproof : Set<RuStep>
);

ruExtractLemma(steps : [RuStep], i : int, math : RuMath, env : RuEnv) -> RuLemma {
	full_subproof1 = ruFindSubProof(steps, i, env);
	full_subproof = sortCustom(set2array(full_subproof1), \step -> step.ind, true);
	//println("ruTreefySteps1:\n" + ruSteps2s1(steps, math) + "\n");
	//println("i: " + i2s(i + 1));
	//println("full_subproof:\n" + ruSteps2s1(full_subproof, math) + "\n");
	other = set2array(differenceSets(buildSet(steps), buildSet(full_subproof)));
	//println("other:\n" + ruSteps2s1(other, math) + "\n");
	other_ref_inds = fold(other, makeSet(), \acc, step -> 
		fold(ruStep2StepRefs(step), acc,  \ac, rf -> insertSet(ac, rf.ind))
	);
	common_steps = filter(full_subproof, \step -> 
		step.ind != i && containsSet(other_ref_inds, step.ind)
	);
	//println("common_steps:\n" + ruSteps2s1(common_steps, math) + "\n");
	common_steps_ind = buildSet(map(common_steps, \step -> step.ind));
	transitive_common = for(buildSet(common_steps),
		\comm -> exists(set2array(comm), \step -> 
			exists(ruStep2StepRefs(step), \rf -> 
				!containsSet(comm, steps[rf.ind])
			)
		),
		\comm -> foldSet(comm, comm, \acc,step ->
			fold(ruStep2StepRefs(step), acc, \ac, rf ->
				insertSet(ac, steps[rf.ind])
			)
		)
	);
	//println("transitive_common:\n" + ruSteps2s1(set2array(transitive_common), math) + "\n");
	reduced_subproof = filter(full_subproof, \step -> !containsSet(transitive_common, step));
	subproof_hyp_premises = sortCustom(set2array(fold(reduced_subproof, makeSet(), \acc, step -> 
		fold(ruStep2HypRefs(step), acc, \ac, rf -> insertSet(ac, rf))
	)), \hyp -> hyp.ind, true);
	//println("reduced_subproof:\n" + ruSteps2s1(reduced_subproof, math) + "\n");
	//reduced_subproof_inds = buildSet(map(reduced_subproof, \step -> step.ind));

	other1 = set2array(differenceSets(buildSet(steps), buildSet(reduced_subproof)));
	other1_ref_inds = fold(other1, makeSet(), \acc, step -> 
		fold(ruStep2StepRefs(step), acc,  \ac, rf -> insertSet(ac, rf.ind))
	);

	subproof_step_premises = filter(full_subproof, \step -> 
		step.ind != i && containsSet(other1_ref_inds, step.ind)
	);

	lemma_reindex = ruMakeLemmaInnerReindex(
		reduced_subproof,
		subproof_step_premises,
		subproof_hyp_premises,
	);

	RuLemma(
		RuStep(steps[i] with
			ind = -1,
			assertion = -1,
			refs = concat(
				subproof_hyp_premises,
				map(subproof_step_premises, \st -> RuStepRef(st.ind))
			),
			proof = RuProof(makeTree(), makeSet(), 
				map(reduced_subproof, \st -> ruReindexStep(st, lemma_reindex)), -1
			),
			pos = -1
		),
		buildSet(reduced_subproof)
	);
}

ruReindexStep(step : RuStep, reindex : Tree<RuRef, RuRef>) -> RuStep {
	RuStep(step with 
		ind = lookupTreeDef(reindex, RuStepRef(step.ind), RuStepRef(step.ind)).ind,
		refs = map(step.refs, \rf -> lookupTreeDef(reindex, rf, rf))
	)
}

ruMakeLemmaInnerReindex(subproof : [RuStep], stepPremises : [RuStep], hypPremises : [RuHypRef]) -> Tree<RuRef, RuRef> {
	hypsReindex = fold(hypPremises, makeTree(), \acc, rf -> 
		setTree(acc, rf, RuHypRef(sizeTree(acc)))
	);
	premiseReindex = fold(stepPremises, hypsReindex, \acc, step -> 
		setTree(acc, RuStepRef(step.ind), RuHypRef(sizeTree(acc)))
	);
	stepReindex = fold(subproof, makeTree(), \acc, step -> 
		setTree(acc, RuStepRef(step.ind), RuStepRef(sizeTree(acc)))
	);
	mergeTree(premiseReindex, stepReindex);
}

ruMakeLemmaOuterReindex(steps : [RuStep], i : int, lemma : RuLemma) -> Tree<RuRef, RuRef> {
	fold(steps, makeTree(), \acc, step -> 
		if (step.ind != i && containsSet(lemma.subproof, step)) acc else
		setTree(acc, RuStepRef(step.ind), RuStepRef(sizeTree(acc)))
	);
}

ruTreefySteps(steps : [RuStep], max_len : int, math : RuMath, env : RuEnv) -> [RuStep] {
	if (length(steps) <= max_len) steps else {
		i = 3 + round(random() * i2d(length(steps) - 6));
		lemma = ruExtractLemma(steps, i, math, env);
		outer_reindex = ruMakeLemmaOuterReindex(steps, i, lemma);
		final_steps = fold(steps, [], \acc, step ->
			if (step.ind == i) {
				lemma_step = ruReindexStep(RuStep(lemma.step with ind = length(acc)), outer_reindex);
				concat(acc, [lemma_step]);
			} else if (!containsSet(lemma.subproof, step)) {
				concat(acc, [ruReindexStep(step, outer_reindex)])
			} else {
				acc;
			}
		);
		//println("final_steps:\n" + ruSteps2s1(final_steps, math) + "\n");
		final_steps;
	}
}

ruFindSubProof(steps : [RuStep], i : int, env : RuEnv) -> Set<RuStep> {
	fold(ruStep2StepRefs(steps[i]), makeSet1(steps[i]), \acc, rf -> 
		mergeSets(acc, ruFindSubProof(steps, rf.ind, env))
	);
}

ruRunTreefyProofs(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	timer = ruMakeTimer();
	math = ruMathFromSources(state.ru, env);
	target = ruDetermineTarget(task, math, env);
	max_len = s2i(lookupTreeDef(task.args, "max-len", "10"));
	treefyed_theorems = ref 0;
	treefy_fn = \decl, time_limit -> {
		th = cast(decl : RuDecl -> RuTheorem);
		treefied = ruTreefyTheorem(th, max_len, math, env);
		treefyed_theorems := ^treefyed_theorems + 1;
		if (ruVerbose(conf) > 1) {
			//env.out.onMessage("COUNTER: " + i2s(^treefyed_theorems) + "\n\toriginal theorem:\n" + strIndent(ru2s(th, math)));
			env.out.onMessage("\ttreefied theorem:\n" + strIndent(ru2s(treefied, math)));
		}
		verified = ruVerifyTheorem(treefied, math, env);
		if (verified.errs == []) {
			if (ruVerbose(conf) > 1) {
				env.out.onMessage("\ttreefied theorem: " + id2s(th.descr.id) + " is OK");
			}
			Some(verified.theorem);
		} else {
			if (ruVerbose(conf) > 1) {
				env.out.onMessage("\ttreefied theorem: " + id2s(th.descr.id) + " FAILED");
			}
			ruOutputVerifyErrs(verified, math, env);
			None();
		}
	}

	treefy_descr = RuFnDescr(
		"treefy proofs", 
		\decl -> switch (decl) {
			RuTheorem(__,__,__,proof): length(proof.steps) > max_len;
			default: false;
		},
		ruProofLengthMeasure, 
		\ -> "treefied: " + i2s(^treefyed_theorems) + " theorems"
	);
	new_state = ruMapFnComm(
		RuUnit(unit.task, state, env.out),
		RuMapFn(
			treefy_descr,
			treefy_fn
		)
	);
	Some(RuState(new_state with 
		vars = setTree(setTree(state.vars, 
			"treefy-proofs.treefied-theorems", ValInt(^treefyed_theorems)),
			"treefy-proofs.time", ValDouble(ruTimePassed(timer))
		)
	));
	

	/*theorems = filtermap(ruTargetAssertions(target, math, env), ruDecl2Theorem);
	ret = fold(theorems, math, \acc, th ->
		if (length(th.proof.steps) <= max_len) acc else {
			treefied = ruTreefyTheorem(th, max_len, math, env);
			treefy_counter := ^treefy_counter + 1;
			if (ruVerbose(conf) > 1) {
				//env.out.onMessage("COUNTER: " + i2s(^treefy_counter) + "\n\toriginal theorem:\n" + strIndent(ru2s(th, math)));
				env.out.onMessage("\ttreefied theorem:\n" + strIndent(ru2s(treefied, math)));
			}
			verified = ruVerifyTheorem(treefied, acc, env);
			if (verified.errs == []) {
				if (ruVerbose(conf) > 1) {
					env.out.onMessage("\ttreefied theorem: " + id2s(th.descr.id) + " is OK");
				}
				ruMathReplaceDecl(acc, verified.theorem, env);
			} else {
				if (ruVerbose(conf) > 1) {
					env.out.onMessage("\ttreefied theorem: " + id2s(th.descr.id) + " FAILED");
				}
				ruOutputVerifyErrs(verified, acc, env);
				acc;
			}
		}
	);
	Some(RuState(state with 
		ru = ret.sources,
		vars = setTree(state.vars,
			"treefy-proofs.time", ValDouble(ruTimePassed(timer))
		)
	));*/
}
