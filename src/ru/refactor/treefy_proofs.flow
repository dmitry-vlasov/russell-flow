import comm;
import script/value;
import ru/util/target;

export {
	ruCommTreefyProofs : RuComm;
}

ruCommTreefyProofs = RuComm(
	RuCommDescr(
		"treefy-proofs", "refactor", "unwrap linear proofs to hierarchical", "target", false, false, 
		[
			RuCommArg("target", true, "the target: a theorem, file or all", "all"),
			RuCommArg("degree", true, "maximum steps number at one level", "16")
		], []
	),
	ruRunTreefyProofs
);


ruTreefyTheorem(th : RuTheorem, degree : int, env : RuEnv) -> RuTheorem {
	ruNoTheorem
}

ruDoTreefyTheorem(th : RuTheorem, proof : [RuStep], degree : int, env : RuEnv) -> RuTheorem {
	ruNoTheorem
}

ruRunTreefyProofs(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	timer = ruMakeTimer();
	math = ruMathFromSources(state.ru, env);
	target = ruDetermineTarget(task, math, env);
	degree = s2i(lookupTreeDef(task.args, "degree", "16"));
	theorems = filtermap(ruTargetAssertions(target, math, env), ruDecl2Theorem);
	ret = fold(theorems, math, \acc, th -> {
		ruMathReplaceDecl(acc, ruTreefyTheorem(th, degree, env), env)
	});
	Some(RuState(state with 
		ru = ret.sources,
		vars = setTree(state.vars,
			"remove-unused-steps.time", ValDouble(ruTimePassed(timer))
		)
	));
	Some(state);
}
