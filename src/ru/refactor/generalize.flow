import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommGeneralize : RuComm;
}

ruCommGeneralize = RuComm(
	"generalize", "refactor", "automatically generalize theorems by proofs", "target",
	[
		RuCommArg("file", true, "input file", ""),
		RuCommArg("target", true, "the target: a theorem, file or all", "all"),
		RuCommArg("level", true, "min generalization level. Default is 0", "0"),
		RuCommArg("info", true, "show info about generalized theorems. In this case math is not updated", ""),
		RuCommArg("save", true, "save the result. Default is 1", "1"),
	],
	ruRunGeneralize
);

ruRunGeneralize(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.ruMath;
	conf = env.conf;
	generalized = initConcurrentHashMap();
	gen_level = s2i(lookupTreeDef(task.args, "level", "0"));
	if (conf.verbose > 0) {
		conf.onMessage("starting generalization ... ");
	}
	fn = RuApplyFn(
		RuFnDescr(
			"generalize", 
			\decl -> switch (decl) {
				RuTheorem(__,__,__,__): true;
				default: false; 
			},
			\decl -> i2d(length(cast(decl : RuDecl -> RuTheorem).proof.steps)),
		),
		\decl, time_limit -> {
			th = cast(decl : RuDecl -> RuTheorem);
			gen_name = id2s(th.descr.id) + "_gen";
			if (conf.verbose >= 3) {
				conf.onMessage("\t\ttrying to generalize '" + id2s(th.descr.id) + "'");
			}
			if (containsKeyTree(math.assertions, gen_name)) {
				if (conf.verbose >= 2) {
					conf.onMessage("\tseems that '" + id2s(th.descr.id) + "' is already generalized");
				}
				true;
			} else {
				start = timestamp();
				proof_graph = ruProofToDAG(th.proof);
				switch (ruProof2Theorem(gen_name, th.descr.src, proof_graph, math, conf, time_limit)) {
					Some(gen): {
						if (isNone(ruMatchAssertions(gen, th, math, conf))) {
							conf.onError("Generalization doesn't match !!!: " + id2s(th.descr.id), []);
							quit(-1);
						}
						if (isNone(ruMatchAssertions(th, gen, math, conf))) {
							maybeApply(ruMatchAssertions(gen, th, math, conf), \match ->
								if (ruSubstLevel(match.sub) >= gen_level) {
									setConcurrentHashMap(generalized, id2s(th.descr.id), Triple(th, gen, match));
									if (conf.verbose >= 2) {
										conf.onMessage(
											"\t" + i2s(sizeConcurrentHashMap(generalized)) + " theorem '" + id2s(th.descr.id) + "' was GENERALIZED " + 
											"in " + d2st((timestamp() - start) / 1000.0, 3) + "s, " + 
											"time limit: " + d2st(time_limit / 1000.0, 3)
										);
									}
								}
							);
						}
						true;
					}
					None(): {
						/*conf.onError(
							"theorem '" + th.descr.name + "' was NOT generalized in " + d2st((timestamp() - start) / 1000.0, 2) + "s\n" + 
							ru2s(th, math.rules) + "\n" +
							ruDAG2s(proof_graph, idfn), []
						);
						quit(-1);*/
						if (conf.verbose >= 2) {
							conf.onMessage(
								"\t" + i2s(sizeConcurrentHashMap(generalized)) + " theorem '" + id2s(th.descr.id) + "' was NOT generalized " + 
								"in " + d2st((timestamp() - start) / 1000.0, 3) + "s, " + 
								"time limit: " + d2st(time_limit / 1000.0, 3)
							);
						}
						false;
					}
				}
			}
		}
	);
	ruApplyFnComm(task, env, fn);
	ret = if (lookupTreeDef(task.args, "info", "") != "") {
		info_level = s2i(lookupTreeDef(task.args, "info", ""));
		generalized_tiples = sortCustom(
			valuesConcurrentHashMap(generalized), 
			\triple : Triple<RuTheorem, RuTheorem, RuAssertionMatch> -> ruSubstLevel(triple.third.sub), 
			false
		);
		conf.onMessage("Generalized theorems:\n" +
			strGlue(map(generalized_tiples, \triple -> 
				"\t" + id2s(triple.first.descr.id) + ", substitution level: " + i2s(ruSubstLevel(triple.third.sub)) +
				(if (info_level <= 1) "" else 
					"\n" + strIndent("original:\n" + 
						strIndent(ruDecl2s(triple.first, math.rules))
					 ) +
					"\n" + strIndent("generalized:\n" + 
					strIndent(ruDecl2s(triple.second, math.rules))
					 ) +
					"\n" + strIndent("substitution:\n" + 
					strIndent(ruSubst2s(triple.third.sub, math))
					 ) + "\n"
				)
			), "\n")
		);
		env;
	} else {
		ruInsertGeneralized(generalized, task, env);
	}
	if (conf.verbose > 0) {
		conf.onMessage("\tgeneralized: " + i2s(sizeConcurrentHashMap(generalized)) + " theorems");
	}
	Some(ret)
}

ruInsertGeneralized(generalized : native, task : ScTask, env : RuState) -> RuState {
	math = env.ruMath;
	conf = env.conf;
	gen_math = fold(valuesConcurrentHashMap(generalized), math, \acc, triple : Triple<RuTheorem, RuTheorem, RuAssertionMatch> -> {
		th = triple.first;
		gen = triple.second;
		eitherMap(lookupTree(acc.assertions, id2s(th.descr.id)), \ass -> 
			eitherMap(lookupTree(acc.sources, ass.descr.src), \src -> {
					if (conf.verbose >= 3) {
						conf.onMessage("\tru adding generalized sources: '" + id2s(gen.descr.id) + "'");
					}
					ind = ruIndexOfDecl(id2s(th.descr.id), src);
					ruAddAssertion(gen, ind, src, acc, conf);
				}, acc
			), acc
		);
	});
	if (lookupTreeDef(task.args, "save", "") == "1") {
		modified_sources = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, triple : Triple<RuTheorem, RuTheorem, RuAssertionMatch> ->
			eitherMap(lookupTree(gen_math.assertions, id2s(triple.first.descr.id)), \ass -> insertSet(acc, ass.descr.src), acc)
		);
		ruWriteRefactoredSources(modified_sources, gen_math, ruDecVerbose(conf));
	}
	RuState(env with ruMath = gen_math);
}
