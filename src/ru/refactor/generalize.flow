import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommGeneralize : RuComm;
}

ruCommGeneralize = RuComm(
	"generalize", "refactor", "automatically generalize theorems by proofs", "target",
	[
		RuCommArg("target", true, "the target: a theorem, file or all", "all"),
		RuCommArg("min-sub-level", true, "min generalization substitution level. Default is 0", "0"),
		RuCommArg("min-sub-len", true, "min generalization substitution length. Default is 0", "0"),
		RuCommArg("min-fitness", true, "min generalization fitness. Default is 0.0", "0.0"),
		RuCommArg("info", true, "show info about generalized theorems (number: 0,1,2). In this case math is not updated", "0"),
		RuCommArg("save", true, "save the result. Default is 1", "1"),
	],
	ruRunGeneralize
);

RuGeneralized(
	thm : RuTheorem,
	gen : RuTheorem,
	match : RuAssertionMatch
);

ruRunGeneralize(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.ruMath;
	conf = env.conf;
	gen_map = initConcurrentHashMap();
	gen_level = s2d(lookupTreeDef(task.args, "level", "0.0"));
	if (conf.verbose > 0) {
		conf.onMessage("starting generalization ... ");
	}
	min_sub_level = s2i(lookupTreeDef(task.args, "min-sub-level", "0"));
	min_sub_len = s2i(lookupTreeDef(task.args, "min-sub-len", "0"));
	min_fitness = s2d(lookupTreeDef(task.args, "min-fitness", "0.0"));
	fitness_func = \g : RuGeneralized -> {
		if (ruArity(g.gen) > 0) {
			i2d(ruSubstLen(g.match.sub)) / i2d(ruArity(g.gen));
		} else {
			100.0
		}
	}
	fn = RuApplyFn(
		RuFnDescr(
			"generalize", 
			ruDeclIsTheorem,
			\decl -> i2d(length(cast(decl : RuDecl -> RuTheorem).proof.steps)),
		),
		\decl, time_limit -> {
			th = cast(decl : RuDecl -> RuTheorem);
			gen_id = s2id(id2s(th.descr.id) + "_gen");
			if (conf.verbose >= 3) {
				conf.onMessage("\t\ttrying to generalize '" + id2s(th.descr.id) + "'");
			}
			if (containsKeyTree(math.assertions, gen_id)) {
				if (conf.verbose >= 2) {
					conf.onMessage("\tseems that '" + id2s(th.descr.id) + "' is already generalized");
				}
				true;
			} else {
				start = ruTime();
				proof_graph = ruProofToDAG(th.proof);
				switch (ruProof2Theorem(gen_id, th.descr.src, proof_graph, math, conf, time_limit)) {
					Some(gen): {
						if (length(gen.stat.hyps) > 3 * length(th.stat.hyps)) {
							if (conf.verbose > 1) {
								conf.onMessage("Generalized theorem '" + id2s(th.descr.id) + "' has too much hypothesis: " + i2s(length(gen.stat.hyps)) + " while original has: " + i2s(length(th.stat.hyps)));
							}
							true;
						} else {
							switch (ruMatchAssertions1(gen, th, math, conf)) {
								None(): {
									conf.onError(
										"Generalization doesn't match !!!: " + id2s(th.descr.id) + "\n" + 
										"theorem:\n" + ru2s(th, math.rules) + "\n" +
										"generalized:\n" + ru2s(gen, math.rules) + "\n"
										, []
									);
									vr = ruVerifyTheorem(gen, math, conf);
									iter(vr.errs, \err -> 
										conf.onError(ruVerifyErr2s(err, math, conf), [])
									);
									if (length(vr.errs) == 0) {
										conf.onMessage("Generalized is verified and is Ok\n" + ru2s(vr.theorem, math.rules));
									}
									quit(-1);
								}
								Some(match): {
									if (ruIsVarRenaming(match.sub)) {
										switch (ruMatchAssertions1(th, gen, math, conf)) {
											Some(m1): {
												//conf.onMessage("Not really a generalization...");
											}
											None(): {
												/*xxx = \s : Tree<RuVar, RuExp> -> {
													image_vars = buildSet(filtermap(getTreeValues(s), ruExp2Var));
													conf.onMessage(
														"sizeTree(s) == sizeSet(image_vars): " + i2s(sizeTree(s)) + " == " + i2s(sizeSet(image_vars))
													);
												};
												xxx(match.sub);*/
												conf.onError(
													"MUST BE SOME\n" +
													"substitution level: " + i2s(ruSubstLevel(match.sub)) + "\n" + 
													"substitution len: " + i2s(ruSubstLen(match.sub)) + "\n" + 
													"sub:\n" + ruSubst2s(match.sub, math) + "\n" + 
													"original:\n" + ruDecl2s(th, math.rules) +
													"generalized:\n" + ruDecl2s(gen, math.rules) + "\n\n"
												, []);
												quit(-1);
											}
										}
									} else {
										g = RuGeneralized(th, gen, match);
										sub_level = ruSubstLevel(match.sub);
										sub_len = ruSubstLen(match.sub);
										fitness = fitness_func(g);
										if (sub_level >= min_sub_level && sub_len>= min_sub_len && fitness >= min_fitness) {
											setConcurrentHashMap(gen_map, id2s(th.descr.id), g);
											if (conf.verbose >= 2) {
												conf.onMessage(
													"\t" + i2s(sizeConcurrentHashMap(gen_map)) + " theorem '" + id2s(th.descr.id) + "' was GENERALIZED " + 
													"in " + ruTime2s(ruTime() - start) + ", " + 
													"time limit: " + ruTime2s(time_limit) + ", " + 
													"substitution level: " + i2s(sub_level) + ", " + 
													"substitution len: " + i2s(sub_len) + ", " +
													"fitness: " + d2s(fitness) + 
													(if (conf.verbose < 3) "" else "\n" + 
														"sub:\n" + ruSubst2s(match.sub, math) + "\n" + 
														"original:\n" + ruDecl2s(th, math.rules) +
														"generalized:\n" + ruDecl2s(gen, math.rules) + "\n\n"
													)
												);
											}
										}
									}
								}
							}
							/*if (isNone(ruMatchAssertions1(th, gen, math, conf))) {
								maybeApply(ruMatchAssertions1(gen, th, math, conf), \match ->
									if (ruSubstLevel(match.sub) >= gen_level) {
										setConcurrentHashMap(generalized, id2s(th.descr.id), Triple(th, gen, match));
										if (conf.verbose >= 2) {
											conf.onMessage(
												"\t" + i2s(sizeConcurrentHashMap(generalized)) + " theorem '" + id2s(th.descr.id) + "' was GENERALIZED " + 
												"in " + ruTime2s(ruTime() - start) + ", " + 
												"time limit: " + ruTime2s(time_limit) + "\n" + 
												"substitution level: " + i2s(ruSubstLevel(match.sub)) + "\n" + 
												"substitution len: " + i2s(ruSubstLen(match.sub)) + "\n" + 
												"sub:\n" + ruSubst2s(match.sub, math) + "\n" + 
												"original:\n" + ru2s(th, math.rules) +
												"generalized:\n" + ru2s(gen, math.rules) + "\n\n"
											);
										}
									}
								);
							}*/
							//conf.onMessage("\t\theorem '" + id2s(th.descr.id) + "' was processed");
							true;
						}
					}
					None(): {
						passed = ruTime() - start;
						if (conf.verbose >= 2) {
							conf.onMessage(
								"\t" + i2s(sizeConcurrentHashMap(gen_map)) + " theorem '" + id2s(th.descr.id) + "' was NOT generalized " + 
								"in " + ruTime2s(ruTime() - start) + " " + 
								"time limit: " + ruTime2s(time_limit)
							);
							if (passed < time_limit) {
								conf.onError("theorem:\n" + ru2s(th, math.rules) + "\n" + ruProofDAG2s(proof_graph), []);
								quit(-1);
							}
						}
						false;
					}
				}
			}
		}
	);
	ruApplyFnComm(task, env, fn);
	ret = if (lookupTreeDef(task.args, "info", "") != "") {
		info_level = s2i(lookupTreeDef(task.args, "info", ""));
		generalized = sortCustom(
			valuesConcurrentHashMap(gen_map), 
			fitness_func, 
			false
		);
		conf.onMessage("Generalized theorems:\n" +
			strGlue(map(generalized, \g -> 
				"\t" + id2s(g.thm.descr.id) + ", " + 
				"sub level: " + i2s(ruSubstLevel(g.match.sub)) + ", " + 
				"sub len: " + i2s(ruSubstLen(g.match.sub)) + ", " +
				"fit: " + d2s(fitness_func(g)) + 
				(if (info_level <= 1) "" else 
					"\n" + strIndent("original:\n" + 
						strIndent(ruDecl2s(g.thm, math.rules))
					 ) +
					"\n" + strIndent("generalized:\n" + 
						strIndent(ruDecl2s(g.gen, math.rules))
					) +
					"\n" + strIndent("substitution:\n" + 
					strIndent(ruSubst2s(g.match.sub, math))
					 ) + "\n"
				)
			), "\n")
		);
		env;
	} else {
		ruInsertGeneralized(gen_map, task, env);
	}
	if (conf.verbose > 0) {
		conf.onMessage("\tgeneralized: " + i2s(sizeConcurrentHashMap(gen_map)) + " theorems");
	}
	Some(ret)
}

ruInsertGeneralized(generalized : native, task : ScTask, env : RuState) -> RuState {
	math = env.ruMath;
	conf = env.conf;
	gen_math = fold(valuesConcurrentHashMap(generalized), math, \acc, triple : Triple<RuTheorem, RuTheorem, RuAssertionMatch> -> {
		th = triple.first;
		gen = triple.second;
		eitherMap(lookupTree(acc.assertions, th.descr.id), \ass -> 
			eitherMap(lookupTree(acc.sources, ass.descr.src), \src -> {
					if (conf.verbose >= 3) {
						conf.onMessage("\tru adding generalized sources: '" + id2s(gen.descr.id) + "'");
					}
					ind = ruIndexOfDecl(th.descr.id, src);
					ruAddAssertion(gen, ind, src, acc, conf);
				}, acc
			), acc
		);
	});
	if (lookupTreeDef(task.args, "save", "") == "1") {
		modified_sources = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, triple : Triple<RuTheorem, RuTheorem, RuAssertionMatch> ->
			eitherMap(lookupTree(gen_math.assertions, triple.first.descr.id), \ass -> insertSet(acc, ass.descr.src), acc)
		);
		ruWriteRefactoredSources(modified_sources, gen_math, ruDecVerbose(conf));
	}
	RuState(env with ruMath = gen_math);
}
