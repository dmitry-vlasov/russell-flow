import ru/parse/write;
import ru/prover/stats;
import ru/prover/proof2theorem;
import ru/util/match_assertions;

export {
	ruCommGeneralize : RuComm;
}

ruCommGeneralize = RuComm(
	"generalize", "refactor", "automatically generalize theorems by proofs", "target",
	[
		RuCommArg("file", true, "input file", ""),
		RuCommArg("target", true, "the target: a theorem, file or all", ""),
		RuCommArg("level", true, "generalization level: 0, 1, 2. Default is 0", "0"),
		RuCommArg("save", true, "save the result. Default is 1", "1"),
	],
	ruRunGeneralize
);

ruRunGeneralize(task : RuTask, env : RuEnv) -> Maybe<RuEnv> {
	math = env.ruMath;
	conf = env.conf;
	generalized = initConcurrentHashMap();
	gen_level = s2i(lookupTreeDef(task.args, "level", "2"));
	if (conf.verbose > 0) {
		conf.onMessage("starting generalization ... ");
	}
	fn = RuApplyFn(
		"generalize", 
		\decl -> switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): true;
			default: false; 
		},
		\decl -> i2d(length(cast(decl : RuDecl -> RuTheorem).proof.steps)),
		\decl, time_limit -> {
			th = cast(decl : RuDecl -> RuTheorem);
			gen_name = th.descr.name + "_gen";
			if (conf.verbose >= 3) {
				conf.onMessage("\t\ttrying to generalize '" + th.descr.name + "'");
			}
			if (containsKeyTree(math.assertions, gen_name)) {
				if (conf.verbose >= 2) {
					conf.onMessage("\tseems that '" + th.descr.name + "' is already generalized");
				}
				true;
			} else {
				start = timestamp();
				proof_graph = ruProofToDAG(th.proof);
				switch (ruProof2Theorem(gen_name, th.descr.source, proof_graph, math, conf, time_limit)) {
					Some(gen): {
						if (isNone(ruMatchAssertions(gen, th, math, conf))) {
							conf.onError("Generalization doesn't match !!!: " + th.descr.name, []);
							quit(-1);
						}
						if (isNone(ruMatchAssertions(th, gen, math, conf))) {
							maybeApply(ruMatchAssertions(gen, th, math, conf), \match ->
								if (ruSubstLevel(match.sub) >= gen_level) {
									setConcurrentHashMap(generalized, th.descr.name, Pair(th, gen));
									if (conf.verbose >= 2) {
										conf.onMessage(
											"\t" + i2s(sizeConcurrentHashMap(generalized)) + " theorem '" + th.descr.name + "' was GENERALIZED " + 
											"in " + d2st((timestamp() - start) / 1000.0, 3) + "s, " + 
											"time limit: " + d2st(time_limit / 1000.0, 3)
										);
									}
								}
							);
						}
						true;
					}
					None(): {
						/*conf.onError(
							"theorem '" + th.descr.name + "' was NOT generalized in " + d2st((timestamp() - start) / 1000.0, 2) + "s\n" + 
							ru2s(th, math.rules) + "\n" +
							ruDAG2s(proof_graph, idfn), []
						);
						quit(-1);*/
						if (conf.verbose >= 2) {
							conf.onMessage(
								"\t" + i2s(sizeConcurrentHashMap(generalized)) + " theorem '" + th.descr.name + "' was NOT generalized " + 
								"in " + d2st((timestamp() - start) / 1000.0, 3) + "s, " + 
								"time limit: " + d2st(time_limit / 1000.0, 3)
							);
						}
						false;
					}
				}
			}
		}
	);
	ruApplyFnComm(task, env, fn);
	ret = ruInsertGeneralized(generalized, task, env);
	if (conf.verbose > 0) {
		conf.onMessage("\tgeneralized: " + i2s(sizeConcurrentHashMap(generalized)) + " theorems");
	}
	Some(ret)
}

ruInsertGeneralized(generalized : native, task : RuTask, env : RuEnv) -> RuEnv {
	math = env.ruMath;
	conf = env.conf;
	gen_math = fold(valuesConcurrentHashMap(generalized), math, \acc, pair : Pair<RuTheorem, RuTheorem> -> {
		th = pair.first;
		gen = pair.second;
		eitherMap(lookupTree(acc.assertions, th.descr.name), \ass -> 
			eitherMap(lookupTree(acc.sources, ass.descr.source), \src -> {
					if (conf.verbose >= 3) {
						conf.onMessage("\tru adding generalized sources: " + gen.descr.name);
					}
					ind = ruIndexOfDecl(th.descr.name, src);
					acc1 = ruAddAssertion(gen, ind, src, acc, conf);
					/*ruAddComment(
						RuComment(
							"", // ru2s(th, acc.rules), 
							JsonObject([
							Pair("refactor",
								JsonObject([
									Pair("generalize",
										JsonObject([
											Pair("less_general", JsonString(th.descr.name)),
											Pair("more_general", JsonString(gen.name)),
										])
									)
								])
							)
						]), -1), 
						ind, src, acc1, conf
					);*/
					acc1
				}, acc
			), acc
		);
	});
	//gen_names = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
	//	insertSet(acc, pair.second.name)
	//);
	//conf.onMessage("GEN NAMES: " + strGlue(set2array(gen_names), ", "));
	if (lookupTreeDef(task.args, "save", "") == "1") {
		modified_sources = fold(valuesConcurrentHashMap(generalized), makeSet(), \acc, pair : Pair<RuTheorem, RuTheorem> ->
			eitherMap(lookupTree(gen_math.assertions, pair.first.descr.name), \ass -> insertSet(acc, ass.descr.source), acc)
		);
		ruWriteRefactoredSources(modified_sources, gen_math, ruDecVerbose(conf));
	}
	RuEnv(env with ruMath = gen_math);
}
