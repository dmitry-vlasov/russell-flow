import comm;
import script/value;

export {
	RuTheoremReplacement(
		original : RuTheorem,
		replacement: int,
		hypMapping : [int],
	);
	ruReplaceTheorem(repl : RuTheoremReplacement, math : RuMath, name2thms : Tree<int, Set<int>>, env : RuEnv) -> RuMath;
}

ruReplaceTheorem(repl : RuTheoremReplacement, math : RuMath, name2thms : Tree<int, Set<int>>, env : RuEnv) -> RuMath {
	uses = filtermap(
		set2array(lookupTreeDef(name2thms, repl.original.descr.id, makeSet())),
		\name -> maybeMap(lookupTree(math.assertions, name), \a -> cast(a : RuAssertion -> RuTheorem))
	);
	fold(uses, ruDeleteAssertion(repl.original, math, env), \acc, th -> {
		if (ruVerbose(env.conf) > 2) {
			env.out.onMessage("\t\treplacing trivial '" + id2s(repl.original.descr.id) + "' in theorem '" + id2s(th.descr.id) + "'");
		}
		new_proof = RuProof(th.proof with 
			steps = map(th.proof.steps, \step ->
				if (step.assertion != repl.original.descr.id) step else {
					if (ruVerbose(env.conf) > 3) {
						env.out.onMessage("\t\t\treplacing step " + i2s(step.ind + 1) + " from '" + id2s(step.assertion) + "' to '" + id2s(repl.replacement) + "'");
					}
					RuStep(step with 
						assertion = repl.replacement,
						refs = map(repl.hypMapping, \i -> step.refs[i])
					);
				}
			)
		);
		if (ruVerbose(env.conf) > 2) {
			env.out.onMessage("\t\tnew proof for '" + id2s(th.descr.id) + "':\n" + 
				strIndent(strIndent(ru2s(new_proof, math)))
			);
		}
		ruReplaceAssertion(RuTheorem(th with proof = new_proof), acc, env);
	});
}
