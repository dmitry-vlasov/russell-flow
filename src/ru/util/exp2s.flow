import ru/lang;
import base/db;

export {
	ruTermExpType(e : RuTermExp) -> int;
	ruTermExp2s(e : RuTermExp, rules : Tree<int, RuRule>) -> string;

	ruExpType(exp : RuExp) -> int;
	ruExp2s(e : RuExp, rules : Tree<int, RuRule>) -> string;
	ruExp2Term(e : RuExp, rules : Tree<int, RuRule>) -> RuTerm;
	ruExp2Nodes(e : RuExp, rules : Tree<int, RuRule>) -> [RuExpNode];
	ruTerm2s(term : RuTerm) -> string;
	ruTypedTerm2s(term : RuTerm) -> string;
	ruExpRPN2s(exp : RuExp) -> string;
	ruExp2latex(e : RuExp, lang : RuLang, env : RuEnv) -> string;
	ruTerm2latex(term : RuTerm, lang : RuLang, env : RuEnv) -> string;
}

ruTermExpType(e : RuTermExp) -> int {
	switch (e) {
		RuExp(nodes,__): {
			if (length(nodes) > 0) nodes[0].type else {
				ruCrash("Empty expression");
				-1;
			}
		}
		RuTerm(type,__,__): type;
	}
}

ruTermExp2s(e : RuTermExp, rules : Tree<int, RuRule>) -> string {
	switch (e) {
		RuExp(nodes,__): {
			if (length(nodes) > 0) {
				ruTerm2s(ruExp2Term(e, rules))
			} else {
				ruCrash("Empty expression");
				"";
			}
		}
		RuTerm(type,__,__): {
			ruTerm2s(e);
		}
	}
}

ruExpType(e : RuExp) -> int {
	if (length(e.nodes) > 0) e.nodes[0].type else {
		ruCrash("Empty expression");
		-1;
	}
}

ruExp2s(e : RuExp, rules : Tree<int, RuRule>) -> string {
	if (length(e.nodes) > 0) {
		ruTerm2s(ruExp2Term(e, rules))
	} else {
		ruCrash("Empty expression");
		"";
	}
}

ruTerm2s(term : RuTerm) -> string {
	strGlue(map(term.nodes, \n -> id2s(n.id)), " ")
}

ruTypedTerm2s(term : RuTerm) -> string {
	strGlue(map(term.nodes, \n -> 
		switch (n) {
			RuConstRef(c): id2s(c);
			RuVar(v, t): id2s(v) + ":" + id2s(t);
		}
	), " ")
}

ruExpRPN2s(exp : RuExp) -> string {
	strGlue(map(exp.nodes, \n -> {
		switch (n) {
			RuRuleNode(rule, __,__, l): id2s(rule) + "-" + i2s(l);
			RuVar(id, __): id2s(id);
		}
	}), " ")
}

// This function is strict: crashes in case of errors
ruExp2Term(e : RuExp, rules : Tree<int, RuRule>) -> RuTerm {
	switch (foldr(e.nodes, None(), \acc, n -> ruExp2TermAccOperation(n, acc, rules, true))) {
		Some(stack): RuTerm(ruExpType(e), map(stack.nodes, \n -> n.first), e.pos);
		None(): {
			ruCrash("empty expression");
			ruNoTerm;
		}
	}
}

// This function permits errors: no rules/empty exprs as it is used with cached files
ruExp2Nodes(e : RuExp, rules : Tree<int, RuRule>) -> [RuExpNode] {
	switch (foldr(e.nodes, None(), \acc, n -> ruExp2TermAccOperation(n, acc, rules, false))) {
		Some(stack): map(stack.nodes, \n -> n.second);
		None(): [];
	}
}

RuExp2TermStack(
	parent : Maybe<RuExp2TermStack>,
	nodes : [Pair<RuTermNode, RuExpNode>]
);

ruExp2TermAccOperation(node : RuExpNode, stack : Maybe<RuExp2TermStack>, rules : Tree<int, RuRule>, crash : bool) -> Maybe<RuExp2TermStack> {
	switch (node) {
		RuVar(__,__): 
			Some(RuExp2TermStack(stack, [Pair(node, node)]));
		RuRuleNode(id, type_id, arity, len): {
			switch (lookupTree(rules, id)) {
				Some(rule): {
					Some(fold(rule.term.nodes, RuExp2TermStack(stack, []), 
						\acc, symb -> {
							switch (symb) {
								RuVar(__,__): {
									switch (acc.parent) {
										Some(st): RuExp2TermStack(st.parent, concat(acc.nodes, st.nodes));
										None(): {
											if (crash) {
												ruCrash("stack must not be empty");
											}
											acc
										}
									}
								}
								RuConstRef(__):
									RuExp2TermStack(acc.parent, concat(acc.nodes, [Pair(symb, node)]));
							}
						}
					));
				}
				None(): {
					if (crash) {
						ruCrash("rule '" + id2s(id) + "' is not found");
					}
					None();
				}
			}
		}
	}
}

ruExp2latex(e : RuExp, lang : RuLang, env : RuEnv) -> string {
	if (length(e.nodes) > 0) {
		ruTerm2latex(ruExp2Term(e, lang.rules), lang, env);
	} else {
		"";
	}
}

ruTerm2latex(term : RuTerm, lang : RuLang, env : RuEnv) -> string {
	vars_typesetting_json = getJsonArrayValue(ruGetDbItem(env.conf.project, ["vars_typesetting"]), []);
	vars_typesetting = fold(vars_typesetting_json, makeTree(), \acc, var_typesetting_json -> {
		members = getJsonObjectValue(var_typesetting_json, []);
		id_json = findDef(members, \p -> p.first == "ascii", Pair("", JsonNull())).second;
		id = s2id(getJsonStringValue(id_json, ""));
		latex_json = findDef(members, \p -> p.first == "latex", Pair("", JsonNull())).second;
		latex = getJsonStringValue(id_json, "");
		setTree(acc, id, latex);
	});
	nodes = map(term.nodes, \n -> 
		switch (n) {
			RuConstRef(id): {
				lookupTreeDef(lang.consts, id, ruNoConst).latex;
			}
			RuVar(id, type): {
				lookupTreeDef(vars_typesetting, id, id2s(id));
			}
		}
	);
	strGlue(nodes, " ");
}
