import ru/math;
import ru/util/src2s;

export {
	ruArity(a : RuAssertion) -> int;
	ruIsVar(e : RuExp) -> bool;
	ruIsConst(e : RuExp) -> bool;
	ruExp2Var(e : RuExp) -> Maybe<RuVar>;
	ruExp2Const(e : RuExp) -> Maybe<Pair<int, int>>;
	ruDeclKind(d : RuDecl) -> string;
	ruDeclIsAssertion(d : RuDecl) -> bool;
	ruDeclIsConst(d : RuDecl) -> bool;
	ruDeclIsType(d : RuDecl) -> bool;
	ruDeclIsRule(d : RuDecl) -> bool;
	ruDeclIsTheorem(d : RuDecl) -> bool;
	ruDeclIsAxiom(d : RuDecl) -> bool;
	ruDeclIsDef(d : RuDecl) -> bool;
	ruSetDeclPos(d : RuDecl, pos : int) -> RuDecl;
	ruDecl2Assertion(d : RuDecl) -> Maybe<RuAssertion>;
	ruAssertion2Theorem(a : RuAssertion) -> Maybe<RuTheorem>;
	ruAssertion2Axiom(a : RuAssertion) -> Maybe<RuAxiom>;
	ruAssertion2Def(a : RuAssertion) -> Maybe<RuDef>;
	ruProofQedStep(proof : RuProof) -> RuStep;

	ruExp2Vars(exp : RuExp) -> Set<RuVar>;
	ruExpContainsVar(exp : RuExp, v : RuVar) -> bool;
	ruAssertion2Vars(ass : RuAssertion) -> Set<RuVar>;
	ruProof2Vars(proof : RuProof) -> Set<RuVar>;
	
	ruIndexOfDecl(id : int, src : RuSource) -> int;

	// In case a declaration has comments before it, we take the start position of a first
	// comment right before the declaration. Otherwise the position of decl itself.
	ruStartPosition(decl : RuDecl) -> int;

	ruUpdateTheoremVars(theorem : RuTheorem) -> RuTheorem;
	ruUpdateProofVars(proof : RuProof, th_new : RuTheorem, th_old : RuTheorem) -> RuProof;

	ruSrc2Blocks(src : RuSource) -> [RuBlock];
	ruBclocks2Src(src : RuSource, blocks : [RuBlock]) -> RuSource;
	ruBlockId(block : RuBlock) -> int;

	ruSetDeclDescr(decl : RuDecl, descr : RuDescr) -> RuDecl;
	ruSetDeclComments(decl : RuDecl, comms : [RuComment]) -> RuDecl;
	ruModifyAnnotation(decl : RuDecl, modify : (JsonObject) -> JsonObject) -> RuDecl;

	ruSuperTypeName(super : int, infer : int) -> int;
	ruMakeSuperRule(super : int, infer : int, src : int, pos : int) -> RuRule;
	ruFixLeftRecursiveRule(r : RuRule) -> RuRule;

	ruDeclPreceeds(less : RuDecl, greater : RuDecl, imported_map : Tree<int, Set<int>>) -> bool;
	ruSourceTheorems(src : RuSource) -> [RuTheorem];

	ruDeclPlace(decl : RuDecl) -> RuPlace;
}

ruArity(a : RuAssertion) -> int {
	length(a.stat.hyps);
}

ruIsVar(e : RuExp) -> bool {
	length(e.nodes) == 1 && 
	switch (e.nodes[0]) { 
		RuVar(__,__): true; 
		default: false 
	}
}

ruExp2Var(e : RuExp) -> Maybe<RuVar> {
	if (length(e.nodes) != 1) None() else {
		n = e.nodes[0];
		switch (n) { 
			RuVar(__,__): Some(n); 
			default: None(); 
		}
	}
}

ruIsConst(e : RuExp) -> bool {
	length(e.nodes) == 1 && 
	switch (e.nodes[0]) { 
		RuVar(__,__): false; 
		RuRuleNode(id,__, arity, len): 
			arity == 0 && len == 1;
	}
}

ruExp2Const(e : RuExp) -> Maybe<Pair<int, int>> {
	if (length(e.nodes) != 1) None() else {
		switch (e.nodes[0]) { 
			RuVar(__,__): None(); 
			RuRuleNode(rule, type, arity, len): 
				if (arity == 0 && len == 1) Some(Pair(rule, type)) else None();
		}
	}
}

ruExp2Vars(exp : RuExp) -> Set<RuVar> {
	fold(exp.nodes, makeSet(), \acc, n ->
		switch (n) {
			RuRuleNode(__,__,__,__): acc;
			RuVar(__,__): insertSet(acc, n);
		}
	)
}

ruExpContainsVar(exp : RuExp, v : RuVar) -> bool {
	exists(exp.nodes, \n ->
		switch (n) {
			RuVar(__,__): n == v;
			default: false;
		}
	);
}

ruAssertion2Vars(ass : RuAssertion) -> Set<RuVar> {
	fold(ass.stat.hyps, ruExp2Vars(ass.stat.prop), \acc, h ->
		mergeSets(acc, ruExp2Vars(h.expr))
	)
}

ruProof2Vars(proof : RuProof) -> Set<RuVar> {
	fold(proof.steps, makeSet(), \acc, step ->
		mergeSets(acc, ruExp2Vars(step.expr))
	)
}

ruDeclKind(d : RuDecl) -> string {
	switch (d) {
		RuConst(__,__,__):      "const";
		RuType(__,__):          "type";
		RuRule(__,__,__):       "rule";
		RuAxiom(__,__):         "axiom";
		RuDef(__,__,__,__):     "def";
		RuTheorem(__,__,__,__): "theorem";
	}
}

ruDeclIsConst(d : RuDecl) -> bool {
	switch (d) {
		RuConst(__,__,__): true;
		default: false;
	}
}

ruDeclIsType(d : RuDecl) -> bool {
	switch (d) {
		RuType(__,__): true;
		default: false;
	}
}

ruDeclIsRule(d : RuDecl) -> bool {
	switch (d) {
		RuRule(__,__,__): true;
		default: false;
	}
}

ruDeclIsAssertion(d : RuDecl) -> bool {
	switch (d) {
		RuAssertion(): true;
		default: false;
	}
}

ruDeclIsTheorem(d : RuDecl) -> bool {
	switch (d) {
		RuTheorem(__,__,__,__): true;
		default: false;
	}
}

ruDeclIsAxiom(d : RuDecl) -> bool {
	switch (d) {
		RuAxiom(__,__): true;
		default: false;
	}
}

ruDeclIsDef(d : RuDecl) -> bool {
	switch (d) {
		RuDef(__,__,__,__): true;
		default: false;
	}
}

ruSetDeclPos(d : RuDecl, pos : int) -> RuDecl {
	switch (d) {
		RuConst(descr,__,__):      RuConst(d with descr = RuDescr(descr with pos = pos));
		RuType(descr,__):          RuType(d with descr = RuDescr(descr with pos = pos));
		RuRule(descr,__,__):       RuRule(d with descr = RuDescr(descr with pos = pos));
		RuAxiom(descr,__):         RuAxiom(d with descr = RuDescr(descr with pos = pos));
		RuDef(descr,__,__,__):     RuDef(d with descr = RuDescr(descr with pos = pos));
		RuTheorem(descr,__,__,__): RuTheorem(d with descr = RuDescr(descr with pos = pos));
	}
}

ruDecl2Assertion(d : RuDecl) -> Maybe<RuAssertion> {
	switch (d) {
		RuAxiom(__,__):         Some(d);
		RuDef(__,__,__,__):     Some(d);
		RuTheorem(__,__,__,__): Some(d);
		default: None()
	}
}

ruAssertion2Theorem(a : RuAssertion) -> Maybe<RuTheorem> {
	switch (a) {
		RuTheorem(__,__,__,__): Some(a);
		default: None()
	}
}

ruAssertion2Axiom(a : RuAssertion) -> Maybe<RuAxiom> {
	switch (a) {
		RuAxiom(__,__): Some(a);
		default: None()
	}
}

ruAssertion2Def(a : RuAssertion) -> Maybe<RuDef> {
	switch (a) {
		RuDef(__,__,__,__): Some(a);
		default: None()
	}
}

ruProofQedStep(proof : RuProof) -> RuStep {
	proof.steps[length(proof.steps) - 1];
}

ruIndexOfDecl(id : int, src : RuSource) -> int {
	findiDef(src.decls, 
		\decl -> switch (decl) {
			RuConst(d,__,__):      d.id == id;
			RuType(d,__):          d.id == id;
			RuRule(d,__,__):       d.id == id;
			RuAxiom(d,__):         d.id == id;
			RuTheorem(d,__,__,__): d.id == id;
			RuDef(d,__,__,__):     d.id == id;
		},
		-1
	)
}

ruStartPosition(decl : RuDecl) -> int {
	if (decl.descr.comments == []) decl.descr.pos else {
		lastElement(decl.descr.comments, ruNoComment).pos;
	}
}

ruUpdateProofVars(proof : RuProof, th_new : RuTheorem, th_old : RuTheorem) -> RuProof {
	proof_vars = ruProof2Vars(proof);
	RuProof(proof with
		vars = filterTree(
			mergeTree(proof.vars, th_old.stat.vars), 
			\__,v -> 
				containsSet(proof_vars, v) && 
				!containsKeyTree(th_new.stat.vars, v.id)
		),
		disjs = filterSet(
			mergeSets(proof.disjs, th_old.stat.disjs), 
			\d -> 
				containsSet(proof_vars, d.v1) && 
				containsSet(proof_vars, d.v2) &&
				!containsSet(th_new.stat.disjs, d)
		)
	);
}

ruUpdateTheoremVars(th_old : RuTheorem) -> RuTheorem {
	ass_vars = ruAssertion2Vars(th_old);
	th_new = RuTheorem(th_old with 
		stat = RuStatement(th_old.stat with
			vars = filterTree(th_old.stat.vars, \__,v -> containsSet(ass_vars, v)),
			disjs = filterSet(th_old.stat.disjs, \d -> containsSet(ass_vars, d.v1) && containsSet(ass_vars, d.v2))
		)
	);
	RuTheorem(th_new with
		proof = ruUpdateProofVars(th_new.proof, th_new, th_old)
	);
}

ruSrc2Blocks(src : RuSource) -> [RuBlock] {
	comms2blocks = \comms -> map(comms, \comm -> cast(comm : RuComment -> RuBlock));
	concat(
		comms2blocks(src.comments),
		fold(src.decls, [], \acc, decl ->
			concat3(acc, comms2blocks(decl.descr.comments), [cast(decl : RuDecl -> RuBlock)])
		)
	);
}

RuBclocks2SrcAcc(
	decls : [RuDecl],
	comms : [RuComment]
);

ruSetDeclComments(decl : RuDecl, comms : [RuComment]) -> RuDecl {
	switch (decl) {
		RuConst(__,__,__):
			RuConst(decl with descr = RuDescr(decl.descr with comments = comms));
		RuType(__,__):
			RuType(decl with descr = RuDescr(decl.descr with comments = comms));
		RuRule(__,__,__):
			RuRule(decl with descr = RuDescr(decl.descr with comments = comms));
		RuAxiom(__,__):
			RuAxiom(decl with descr = RuDescr(decl.descr with comments = comms));
		RuTheorem(__,__,__,__):
			RuTheorem(decl with descr = RuDescr(decl.descr with comments = comms));
		RuDef(__,__,__,__):
			RuDef(decl with descr = RuDescr(decl.descr with comments = comms));
	}
}

ruBclocks2Src(src : RuSource, blocks : [RuBlock]) -> RuSource {
	accum = fold(blocks, RuBclocks2SrcAcc([], []), \acc, block ->
		switch (block) {
			RuComment(__,__,__): 
				RuBclocks2SrcAcc(acc.decls, concat(acc.comms, [block]));
			RuDecl(): {
				RuBclocks2SrcAcc(
					concat(acc.decls, [ruSetDeclComments(block, acc.comms)]), 
					[]
				);
			}
		}
	);
	RuSource(src with 
		comments = accum.comms,
		decls = accum.decls
	);
}

ruBlockId(block : RuBlock) -> int {
	switch (block) {
		RuConst(d,__,__):      d.id;
		RuType(d,__):          d.id;
		RuRule(d,__,__):       d.id;
		RuAxiom(d,__):         d.id;
		RuDef(d,__,__,__):     d.id;
		RuTheorem(d,__,__,__): d.id;
		RuComment(text,__,__): s2id("<comment>");
	}
}

ruSetDeclDescr(decl : RuDecl, descr : RuDescr) -> RuDecl {
	switch (decl) {
		RuConst(__,__,__):      RuConst(decl with descr = descr);
		RuType(__,__):          RuType(decl with descr = descr);
		RuRule(__,__,__):       RuRule(decl with descr = descr);
		RuAxiom(__,__):         RuAxiom(decl with descr = descr);
		RuDef(__,__,__,__):     RuDef(decl with descr = descr);
		RuTheorem(__,__,__,__): RuTheorem(decl with descr = descr);
	}
}

ruModifyAnnotation(decl : RuDecl, modify : (JsonObject) -> JsonObject) -> RuDecl {
	old_annotation = JsonObject(fold(decl.descr.comments, [], \acc, comm -> concat(acc, comm.annotation.members)));
	new_annotation = modify(old_annotation);
	num_comments = length(decl.descr.comments);
	comments_modified = if (num_comments == 0) {
		if (new_annotation == JsonNull()) [] else
		[RuComment("", new_annotation, -1)];
	} else {
		mapi(decl.descr.comments, \i, comm ->
			if (i + 1 == num_comments) {
				RuComment(comm with annotation = new_annotation)
			} else {
				RuComment(comm with annotation = JsonObject([]))
			}
		);
	}
	ruSetDeclDescr(decl, RuDescr(decl.descr with comments = comments_modified));
}

ruSuperTypeName(super : int, infer : int) -> int {
	s2id(id2s(infer) + "-" + id2s(super));
}

ruMakeSuperRule(super : int, infer : int, src : int, pos : int) -> RuRule {
	id = ruSuperTypeName(super, infer);
	x = RuVar(s2id("x"), infer);
	RuRule(
		RuDescr(id, src, [], pos),
		makeTree1(x.id, x), 
		RuTerm(super, [x], pos)
	);
}

ruFixLeftRecursiveRule(r : RuRule) -> RuRule { 
	if (length(r.term.nodes) <= 1) r else {
		switch (r.term.nodes[0]) {
			RuVar(__,__):
				RuRule(r with term = RuTerm(r.term with nodes = 
					concat3([RuConstRef(s2id("("))], r.term.nodes, [RuConstRef(s2id(")"))])
				));
			default: r;
		}
	}
}

ruDeclPreceeds(less : RuDecl, greater : RuDecl, imported_map : Tree<int, Set<int>>) -> bool {
	if (less.descr.src == greater.descr.src) {
		less.descr.pos < greater.descr.pos;
	} else {
		containsSet(lookupTreeDef(imported_map, greater.descr.src, makeSet()), less.descr.src);
	}
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruDeclPlace(decl : RuDecl) -> RuPlace {
	RuPlace(id2s(decl.descr.src), decl.descr.pos);
}