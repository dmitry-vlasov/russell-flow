import base/util/bits;
import ru/lang;

// At each change of any source struct/union bump ruCacheVersion in ru/cache/disk.

export {
	ruMakeRuleNode(rule : int, type : int, arity : int, len : int) -> RuRuleNode;
	ruMakeRuleType(rule : int, type : int) -> int;
	ruMakeArityLen(arity : int, len : int) -> int;

	ruRuleType2RuleInd(rule_type : int) -> int;
	ruRuleType2TypeInd(rule_type : int) -> int;

	ruRuleType2Rule(rule_type : int) -> int;
	ruRuleType2Type(rule_type : int) -> int;
	ruArityLen2Arity(arity_len : int) -> int;
	ruArityLen2Len(arity_len : int) -> int;
}

ruMakeRuleNode(rule : int, type : int, arity : int, len : int) -> RuRuleNode {
	RuRuleNode(
		ruMakeRuleType(rule, type),
		ruMakeArityLen(arity, len)
	);
}

ruMakeRuleType(rule : int, type : int) -> int {
	rule + bitShl(type, 20);
	/*rule_type = rule + bitShl(type, 20);
	if (rule != ruRuleType2Rule(rule_type) || type != ruRuleType2Rule(type)) {
		fail("rule != ruRuleType2Rule(rule_type) || type != ruRuleType2Rule(type): rule=" + i2s(rule) + ", type=" + i2s(type));
	}
	rule_type;*/
}

ruMakeArityLen(arity : int, len : int) -> int {
	arity + bitShl(len, 16);
	/*arity_len = arity + bitShl(len, 16);
	if (arity != ruArityLen2Arity(arity_len) || len != ruArityLen2Len(arity_len)) {
		fail("arity != ruArityLen2Arity(arity_len) || len != ruArityLen2Len(arity_len): arity=" + i2s(arity) + ", len=" + i2s(len));
	}
	arity_len;*/
}

ruRuleType2RuleInd(rule_type : int) -> int {
	bitAnd(rule_type, 0xFFFFF);
}

ruRuleType2TypeInd(rule_type : int) -> int {
	bitUshr(rule_type, 20);
}

ruRuleType2Rule(rule_type : int) -> int {
	bitAnd(rule_type, 0xFFFFF);
}

ruRuleType2Type(rule_type : int) -> int {
	bitUshr(rule_type, 20);
}

ruArityLen2Arity(arity_len : int) -> int {
	bitAnd(arity_len, 0xFFFF);
}

ruArityLen2Len(arity_len : int) -> int {
	bitUshr(arity_len, 16);
}
