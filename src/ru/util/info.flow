import ru/cache/cache;

export {
	// Description of what is under a cursor at some position in source code
	RuCursor(
		act : string, // actual string
		type : int,   // type of what is under a cursor
		rule : int,   // grammar rule of construction under a cursor 
		def : int,    // definition of what is under a cursor
	);

	ruCursorHover(cursor : RuCursor, env : RuEnv) -> string;
	ruCursorMostSpecific(cursor : RuCursor, env : RuEnv) -> int;
	ruUnderACursor(lc : RuLineCol, env : RuEnv) -> RuCursor;
	ruFindPositioned(lc : RuLineCol, env : RuEnv) -> Maybe<[RuPositioned]>;
}

ruCursorHover(cursor : RuCursor, env : RuEnv) -> string {
	if (cursor.def != -1) {
		ruCachedDecl2s(cursor.def, env);
	} else if (cursor.rule != -1) {
		ruCachedDecl2s(cursor.rule, env);
	} else if (cursor.type != -1) {
		cursor.act + " : " + id2s(cursor.type);
	} else {
		ruCachedDecl2s(s2id_(cursor.act), env);
	}
}

ruCursorMostSpecific(cursor : RuCursor, env : RuEnv) -> int {
	if (cursor.def != -1) {
		cursor.def;
	} else if (cursor.rule != -1) {
		cursor.rule;
	} else {
		s2id_(cursor.act);
	}
}

ruFindPositioned(lc : RuLineCol, env : RuEnv) -> Maybe<[RuPositioned]> {
	module = ruFileId(lc.path, env.conf);
	code = ruCodeCacheGet(module, env).code;
	maybeBind(ruCacheGet(module, true, env), \src -> {
			resolver = makeLineResolver(code);
			pos = findLineIndex(resolver, lc.line, lc.col);
			posTree = ruPositionsTree(src);
			treeIntervalSearch(posTree, pos);
		}
	);
}

// Hierarchy of inclusions of positioned elements
/*	RuPositionedPath(
		source : RuSource,
		path : [RuPositioned]
	);*/
/*
ruFindPositionedPath(lc : RuLineCol, env : RuEnv) -> Maybe<RuPositionedPath> {
	module = ruFileId(lc.path, env.conf);
	code = ruCodeCacheGet(module, env).code;
	maybeBind(ruCacheGet(module, true, env), \src -> {
			resolver = makeLineResolver(code);
			pos = findLineIndex(resolver, lc.line, lc.col);
			posTree = ruPositionsTree(src);
			treeIntervalSearch(posTree, pos);
		}
	);
}

ruDoFindPositionedPath(pos : int, src : RuSource, path : RuPositionedPath, env : RuEnv) -> Maybe<RuPositionedPath> {
	module = ruFileId(lc.path, env.conf);
	code = ruCodeCacheGet(module, env).code;
	maybeBind(ruCacheGet(module, true, env), \src -> {
			resolver = makeLineResolver(code);
			pos = findLineIndex(resolver, lc.line, lc.col);
			posTree = ruPositionsTree(src);
			treeIntervalSearch(posTree, pos);
		}
	);
}
*/
ruUnderACursor(lc : RuLineCol, env : RuEnv) -> RuCursor {
	module = ruFileId(lc.path, env.conf);
	code = ruCodeCacheGet(module, env).code;
	act = ruNameByLineCol(lc.line, lc.col, code);
	switch (ruCacheGet(module, true, env)) {
		Some(src): {
			resolver = makeLineResolver(code);
			pos = findLineIndex(resolver, lc.line, lc.col);
			posTree = ruPositionsTree(src);
			switch (treeIntervalSearch(posTree, pos)) {
				Some(path): {
					if (length(path) == 0) {
						RuCursor(act, -1, -1, -1);
					} else {
						x = lastElement(path, ruNoAxiom);
						positions = getTreeKeys(posTree);
						curr = ruPos(x);
						ind = elemIndex(positions, curr, -1) + 1;
						next = if (ind == length(positions)) strlen(code) else positions[ind];
						switch (x) {
							RuExp(nodes, __): {
								expr = substring(code, curr, next - curr);
								exp_ind = ruIndexOfPosInsideExp(expr, pos - curr);
								exp_nodes = ruExp2Nodes(x, ruRuleCacheGet());
								if (exp_ind >= length(exp_nodes)) {
									RuCursor(act, -1, -1, -1);
								} else {
									switch (exp_nodes[exp_ind]) {
										RuVar(v, t): RuCursor(act, t, -1, -1);
										RuRuleNode(rule, type,__,__): {
											switch (ruDefCacheGetName(rule)) {
												Some(def): RuCursor(act, type, rule, def);
												None(): RuCursor(act, type, rule, -1);
											}
										}
									}
								}
							}
							RuTerm(type, nodes, __): RuCursor(act, -1, -1, -1);
							default: RuCursor(act, -1, -1, -1);
						}
					}
				}
				None(): RuCursor(act, -1, -1, -1);
			}
		}
		None(): RuCursor(act, -1, -1, -1);
	}
}

ruIndexOfPosInsideExp(expr : string, pos : int) -> int {
	ruDoIndexOfPosInsideExp(expr, pos, false, 0, 0);
}

ruDoIndexOfPosInsideExp(expr : string, pos : int, ws : bool, curr : int, acc : int) -> int {
	if (curr == pos) acc else {
		ch = getCharAt(expr, curr);
		ws1 = (ch == " " || ch == "\n" || ch == "\t" || ch == "\r");
		ruDoIndexOfPosInsideExp(
			expr, pos, ws1, curr + 1, 
			acc + (if (!ws && ws1) 1 else 0)
		);
	}
}
