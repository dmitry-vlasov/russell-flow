import ru/cache/cache;

export {
	// Description of what is under a cursor at some position in source code
	RuCursor(
		act  : string, // actual string
		type : int,    // type of what is under a cursor
		rule : int,    // grammar rule of construction under a cursor 
		def  : int,    // definition of what is under a cursor
		expr : RuTermExp // expression or term, in which scope the cursor lies
	);

	RuHover(
		lang : string, // 'russell' or 'latex'
		message : string
	);

	ruCursorHover(cursor : RuCursor, env : RuEnv) -> RuHover;
	ruCursorMostSpecificId(cursor : RuCursor, env : RuEnv) -> int;
	ruUnderACursor(lc : RuLineCol, env : RuEnv) -> RuCursor;
	ruFindPositioned(lc : RuLineCol, env : RuEnv) -> Maybe<[RuPositioned]>;
	ruHover2LspMarkupContent(hover : RuHover) -> LspMarkupContent;
}

ruCursorHover(cursor : RuCursor, env : RuEnv) -> RuHover {
	if (cursor.act == "|-" || cursor.act == "#") {
		expr = cursor.expr;
		RuHover("markdown", 
			if (expr == ruNoExp) "" else {
				switch (expr) {
					RuExp(__,__): {
						//"$$\n\\displaystyle\n" + 
						//ruExp2latex(expr, ruLangCacheGet(), env) + 
						//"\n$$"

						//"$$\n" + ruExp2latex(expr, ruLangCacheGet(), env) + "\n$";

						"$ " + ruExp2latex(expr, ruLangCacheGet(), env) + " $";
					}
					RuTerm(__,__,__): {
						//"$$\n\\displaystyle\n" +  
						//ruTerm2latex(expr, ruLangCacheGet(), env) + 
						//"\n$$";

						//"$$\n" +  ruTerm2latex(expr, ruLangCacheGet(), env) + "\n$";
						"$ " +  ruTerm2latex(expr, ruLangCacheGet(), env) + " $";
					}
				}
			}
		)
	} else if (cursor.def != -1) {
		RuHover("russell", ruCachedDecl2s(cursor.def, env));
	} else if (cursor.rule != -1) {
		RuHover("russell", ruCachedDecl2s(cursor.rule, env));
	} else if (cursor.type != -1) {
		RuHover("russell", cursor.act + " : " + id2s(cursor.type));
	} else {
		RuHover("russell", ruCachedDecl2s(s2id_(cursor.act), env));
	}
}

ruHover2LspMarkupContent(hover : RuHover) -> LspMarkupContent {
	LspMarkupContent(
		"markdown",
		"```" + hover.lang + "\n" +
		hover.message + "\n" +
		"```"
	);
}

ruCursorMostSpecificId(cursor : RuCursor, env : RuEnv) -> int {
	if (cursor.def != -1) {
		cursor.def;
	} else if (cursor.rule != -1) {
		cursor.rule;
	} else {
		s2id_(cursor.act);
	}
}

ruFindPositioned(lc : RuLineCol, env : RuEnv) -> Maybe<[RuPositioned]> {
	module = ruFileId(lc.path, env.conf);
	code = ruCodeCacheGet(module, env).code;
	maybeBind(ruCacheGet(module, true, env), \src -> {
			resolver = makeLineResolver(code);
			pos = findLineIndex(resolver, lc.line, lc.col);
			posTree = ruPositionsTree(src);
			treeIntervalSearch(posTree, pos);
		}
	);
}

ruUnderACursor(lc : RuLineCol, env : RuEnv) -> RuCursor {
	module = ruFileId(lc.path, env.conf);
	code = ruCodeCacheGet(module, env).code;
	resolver = makeLineResolver(code);
	pos0 = findLineIndex(resolver, lc.line, lc.col);
	act = ruNameByPos(pos0, code);
	pos = if (!(act == "|-" || act == "#")) pos0 else {
		// In this case find the first position of a real expression, which follows act:
		// hyp 1 : wff = |- ( X = ( BaseSet â€˜ U ) ) ;;
		//               ^  ^
		//             act  pos
		for(pos0 + 2, 
			\p -> isSpace(getCharAt(code, p)),
			\p -> p + 1
		);
	}
	switch (ruCacheGet(module, true, env)) {
		Some(src): {
			posTree = ruPositionsTree(src);
			switch (treeIntervalSearch(posTree, pos)) {
				Some(path): {
					if (length(path) == 0) {
						RuCursor(act, -1, -1, -1, ruNoExp);
					} else {
						x = lastElement(path, ruNoAxiom);
						positions = getTreeKeys(posTree);
						curr = ruPos(x);
						ind = elemIndex(positions, curr, -1) + 1;
						next = if (ind == length(positions)) strlen(code) else positions[ind];
						switch (x) {
							RuExp(nodes, __): {
								expr = substring(code, curr, next - curr);
								exp_ind = ruIndexOfPosInsideExp(expr, pos - curr);
								exp_nodes = ruExp2Nodes(x, ruLangCacheGet().rules);
								if (exp_ind >= length(exp_nodes)) {
									RuCursor(act, -1, -1, -1, x);
								} else {
									switch (exp_nodes[exp_ind]) {
										RuVar(v, t): RuCursor(act, t, -1, -1, x);
										RuRuleNode(rule, type,__,__): {
											switch (ruDefCacheGetName(rule)) {
												Some(def): RuCursor(act, type, rule, def, x);
												None(): RuCursor(act, type, rule, -1, x);
											}
										}
									}
								}
							}
							RuTerm(type, nodes, __): RuCursor(act, -1, -1, -1, x);
							default: RuCursor(act, -1, -1, -1, ruNoExp);
						}
					}
				}
				None(): RuCursor(act, -1, -1, -1, ruNoExp);
			}
		}
		None(): RuCursor(act, -1, -1, -1, ruNoExp);
	}
}

ruIndexOfPosInsideExp(expr : string, pos : int) -> int {
	ruDoIndexOfPosInsideExp(expr, pos, false, 0, 0);
}

ruDoIndexOfPosInsideExp(expr : string, pos : int, ws : bool, curr : int, acc : int) -> int {
	if (curr == pos) acc else {
		ch = getCharAt(expr, curr);
		ws1 = (ch == " " || ch == "\n" || ch == "\t" || ch == "\r");
		ruDoIndexOfPosInsideExp(
			expr, pos, ws1, curr + 1, 
			acc + (if (!ws && ws1) 1 else 0)
		);
	}
}

//ruNextNonWsLineCol(lc : )