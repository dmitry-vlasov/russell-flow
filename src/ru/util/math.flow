import ru/util/decls;
import ru/util/sources;
import ru/util/assertions;
import ru/math;

export {
	ruIdPlace(id : int, pos : int, math : RuMath) -> RuPlace;
	ruFindSource(id : int, math : RuMath) -> Maybe<RuSource>;

	ruMathStats(math : RuMath) -> string;
	ruMathStats1(math : RuMath) -> ValMap;

	ruMathMerge(m1 : RuMath, m2 : RuMath, env : RuEnv) -> RuMath;
	ruMathSetDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath;
	ruMathInsertDecl(math : RuMath, decl : RuDecl, ind : int, env : RuEnv) -> RuMath;
	ruMathAddDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath;
	ruMathReplaceDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath;
	ruMathRemoveDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath;

	ruMathAddSource(math : RuMath, src : RuSource, env : RuEnv) -> RuMath;
	ruMathRemoveSource(math : RuMath, src : RuSource, env : RuEnv) -> RuMath;
	ruMathFromSource(src : RuSource, env : RuEnv) -> RuMath;
	ruMathFromSources(srcs : Tree<int, RuSource>, env : RuEnv) -> RuMath;

	ruMathAddImportToSource(math : RuMath, src : RuSource, new_imp : int, env : RuEnv) -> RuMath;
	ruMathAddDeclToDecls(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath;
	//ruNameAllImported(id : int, math : RuMath) -> Set<RuSource>;
}

ruIdPlace(id : int, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, ruFindSourceId(id, math.decls), ruNoSource).info.module, pos
	);
}

ruFindSource(id : int, math : RuMath) -> Maybe<RuSource> {
	lookupTree(math.sources, ruFindSourceId(id, math.decls,));
}

ruMathStats(math : RuMath) -> string {
	"  sources:    " + i2s(sizeTree(math.sources)) + "\n" +
	ruDeclsStats(math.decls);
}

ruMathStats1(math : RuMath) -> ValMap {
	ValMap(mergeTree(
		makeTree1(ValString("sources"), ValInt(sizeTree(math.sources))),
		ruDeclsStats1(math.decls).map
	));
}

ruMathMerge(m1 : RuMath, m2 : RuMath, env : RuEnv) -> RuMath {
	RuMath(
		ruSourcesMerge(m1.sources, m2.sources, env),
		ruDeclsMerge(m1.decls, m2.decls, env)
	);
}

ruMathSetDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath {
	RuMath(
		ruSourcesSetDecl(math.sources, decl, env),
		ruDeclsSetDecl(math.decls, decl , env)
	);
}

ruMathAddDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath {
	RuMath(
		ruSourcesAddDecl(math.sources, decl, env),
		ruDeclsAddDecl(math.decls, decl , env)
	);
}

ruMathInsertDecl(math : RuMath, decl : RuDecl, ind : int, env : RuEnv) -> RuMath {
	RuMath(
		ruSourcesInsertDecl(math.sources, decl, ind, env),
		ruDeclsAddDecl(math.decls, decl , env)
	);
}

ruMathRemoveDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath {
	RuMath(
		ruSourcesRemoveDecl(math.sources, decl, env),
		ruDeclsRemoveDecl(math.decls, decl , env)
	);
}

ruMathReplaceDecl(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath {
	RuMath(
		ruSourcesReplaceDecl(math.sources, decl, env),
		ruDeclsReplaceDecl(math.decls, decl , env)
	);
}

ruMathAddSource(math : RuMath, src : RuSource, env : RuEnv) -> RuMath {
	RuMath(
		setTree(math.sources, src.info.id, src),
		ruDeclsAddSource(math.decls, src, env)
	);
}

ruMathRemoveSource(math : RuMath, src : RuSource, env : RuEnv) -> RuMath {
	if (!containsKeyTree(math.sources, src.info.id)) {
		env.out.onError("source: '" + id2s(src.info.id) + "' is absent in math", []);
		math 
	} else {
		RuMath(
			removeFromTree(math.sources, src.info.id),
			ruDeclsRemoveSource(math.decls, src, env)
		);
	}
}

ruMathFromSource(src : RuSource, env : RuEnv) -> RuMath {
	RuMath(
		makeTree1(src.info.id, src),
		ruDeclsFromSource(src, env)
	);
}

ruMathFromSources(sources : Tree<int, RuSource>, env : RuEnv) -> RuMath {
	RuMath(sources, ruDeclsFromSources(sources, env));
}

ruMathAddImportToSource(math : RuMath, src : RuSource, new_imp : int, env : RuEnv) -> RuMath {
	if (exists(src.imports, \imp -> imp.id == new_imp)) math else {
		RuMath(math with 
			sources = setTree(math.sources, src.info.id, RuSource(src with
				imports = concat(src.imports, [RuImport(new_imp, -1)])
			))
		);
	}
}

ruMathAddDeclToDecls(math : RuMath, decl : RuDecl, env : RuEnv) -> RuMath {
	RuMath(math with
		decls = ruDeclsAddDecl(math.decls, decl , env)
	);
}

/*ruAddSourceAssertionsToDecls(src : RuSource, d : RuDecls) -> RuDecls {
	module = src.info.module;
	RuMath(m with 
		fold(src.decls, m.assertions,
			\acc, decl -> {
				switch (decl) {
					RuAxiom(descr,__):         setTree(acc, descr.id, decl);
					RuTheorem(descr,__,__,__): setTree(acc, descr.id, decl);
					RuDef(descr,__,__,__):     setTree(acc, descr.id, decl);
					default: acc;
				}
			}
		)
	);
}

ruAddSourceAssertionsToMath(src : RuSource, m : RuMath) -> RuMath {
	module = src.info.module;
	RuMath(m with 
		assertions = fold(src.decls, m.assertions,
			\acc, decl -> {
				switch (decl) {
					RuAxiom(descr,__):         setTree(acc, descr.id, decl);
					RuTheorem(descr,__,__,__): setTree(acc, descr.id, decl);
					RuDef(descr,__,__,__):     setTree(acc, descr.id, decl);
					default: acc;
				}
			}
		)
	);
}

ruReplaceSource(src : RuSource, m : RuMath, env : RuEnv) -> RuMath {
	ruAddSource(src, ruRemoveSource(src, m, env), env);
}*/


//ruNameAllImported(id : int, math : RuMath) -> Set<RuSource> {
//	ruSourceAllImported(id, ruFindSourceId(id, math.decls), math);
//}

/*
ruMathReplaceDecl(d : RuDecl, math : RuMath, env : RuEnv) -> RuMath {
	//name = ruDeclName(a);
	switch (ruFindSource(d.descr.id, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(d.descr.id, src), d)
			);
			//ruToCache(updated_src, env);
			RuMath(
				assertions = setTree(math.assertions, a.descr.id, a),
				sources = setTree(math.sources, src.info.id, updated_src),

			);
		}
		None(): math;
	}
}*/
