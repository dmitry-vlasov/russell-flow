import ru/unify/index;
import ru/prover/util;
import ru/unify/prod;

export {
	RuAssertionMatch(
		less : RuAssertion, // The less general assertion
		more : RuAssertion, // The more general assertion
		sub : Tree<RuVar, RuExp>, // Substitution, which makes a less general from more general
		//hypsMap : Tree<int, int>  // The hypothesis map: the number and order of hypotheses may differ.
		hypsMap : [int]   // The hypothesis map: for each more hypothesis the index of corresponding less hyp.
	);
	ruMatchAssertions(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch>;

	// Replace all occurrences of less with more general
	ruReplaceMatch(match : RuAssertionMatch, math : RuMath, name2thms : Tree<int, Set<int>>, env : RuEnv) -> RuMath;
}

ruMatchAssertions(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch> {
	a2c = ruConstAssertion(a2, math);
	a2_hyps = fold(a2c.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, hyp, acc));
	a1_hyps = sortCustom(a1.stat.hyps, \hyp -> sizeSet(ruExp2Vars(hyp.expr)), false);
	time_limit = 10000.0;
	timer = ruMakeLimitedTimer(time_limit);
	check_disj = \s -> {
		unc_s = ruTransformSubst(s, a2c.env.unconst);
		switch (ruComputeDisjs(unc_s, a1.stat.disjs, RuDisjsInherent(makeSet()))) {
			RuDisjsInherent(disjs): ruIsSubset(disjs, a2.stat.disjs);
			RuDisjViolation(__,__): false;
		}
	}
	ret = maybeMap(
		maybeBind(ruUnifyExps([a1.stat.prop, a2c.const.stat.prop], makeTree(), math, env),
			\sub -> {
				if (length(a1.stat.hyps) == 0) Some(RuAssertionMatch(a2, a1, sub, [])) else {
					hyps_prod = map(a1.stat.hyps, \h -> {
						hyp_unified = ruUnifyIndex(
							ruApplySubst(h.expr, sub), a2_hyps, sub, 
							math, env, time_limit / i2d(ruArity(a1))
						);
						map(hyp_unified, \un -> RuSubData(un.sub, un.data));
					});
					sub_unified = ruUnifySubsProd(hyps_prod, \__-> true, timer, math, env);
					findmap(sub_unified, \sd -> {
						if (!check_disj(sd.sub)) {
							None();
						} else {
							Some(RuAssertionMatch(a2, a1, sd.sub, 
								mapi(a1.stat.hyps, \i,__ -> sd.data[i].ind)
								//foldi(a1.stat.hyps, makeTree(), \i, acc, __ -> 
								//	setTree(acc, i, sd.data[i].ind)
								//)
							))
						}
					});
				}
			}
		),
		\match -> {
			match_sub = ruTransformSubst(match.sub, a2c.env.unconst);
			RuAssertionMatch(match with sub = ruReduceSubst(match_sub));
		}
	);
	maybeMap(ret, \match -> ruCheckAssertionsMatch(match, math, env));
	ret
}
/*
ruMatchAssertions1(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch> {
	a2c = ruConstAssertion(a2, math);
	a2_hyps = fold(a2c.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, hyp, acc));
	a1_hyps = sortCustom(a1.stat.hyps, \hyp -> sizeSet(ruExp2Vars(hyp.expr)), false);
	ret = maybeBind(
		maybeBind(ruUnifyExps([a1.stat.prop, a2c.const.stat.prop], makeTree(), math, env),
			\theta -> ruMatchAssertionHyps(a1_hyps, a2_hyps, 0, RuAssertionMatch(a2, a1, theta, makeTree()), a2c.env.math, env)
		),
		\match -> {
			match_sub = ruTransformSubst(match.sub, a2c.env.unconst);
			switch (ruComputeDisjs(match_sub, a1.stat.disjs, RuDisjsInherent(makeSet()))) {
				RuDisjsInherent(disjs): {
					if (!ruIsSubset(disjs, a2.stat.disjs)) None() else 
					Some(RuAssertionMatch(match with sub = ruReduceSubst(match_sub)));
				}
				RuDisjViolation(__,__): {
					None();
				}
			}
		}
	);
	maybeMap(ret, \match -> ruCheckAssertionsMatch(match, math, env));
	ret
}

ruMatchAssertionHyps(
	a1_hyps : [RuHyp], 
	a2_hyps : RuIndex<RuHyp>, 
	i : int, 
	match : RuAssertionMatch, 
	math : RuMath, 
	env : RuEnv
) -> Maybe<RuAssertionMatch> {
	if (i == length(a1_hyps)) Some(match) else {
		fold(
			ruUnifyIndex(a1_hyps[i].expr, a2_hyps, match.sub, math, env, 1.0), 
			None(), \m, unif ->
			if (isSome(m)) m else {
				ruMatchAssertionHyps(
					a1_hyps, a2_hyps, i + 1, 
					RuAssertionMatch(
						match.less, match.more, unif.sub, 
						setTree(match.hypsMap, a1_hyps[i].ind, unif.data.ind)
					), 
					math, env
				);
			}
		);
	}
}
*/
ruAssertionsMatch2s(match : RuAssertionMatch, math : RuMath) -> string {
	"sub:\n" + ruSubst2s(match.sub, math) + "\n" +
	"hyps map: [" + strGlue(map(match.hypsMap, i2s), ", ") + "]";
}

ruCheckAssertionsMatch(match : RuAssertionMatch, math : RuMath, env : RuEnv) -> void {
	a1 = match.more;
	a2 = match.less; 
	check_exps_are_eq = \e1, e2 -> {
		e1_prime = ruApplySubst(e1, match.sub);
		if (e2.nodes != e1_prime.nodes) {
			ruCrash(
				"Error: matched propositions doesn't coincide:\n" +
				ru2s(e2, math) + "\n" +
				ru2s(e1_prime, math) + "\n" +
				ruExpRPN2s(e2) + "\n" +
				ruExpRPN2s(e1_prime) + "\n"
			);
		}
	}
	if (length(match.hypsMap) != ruArity(a1)) {
		ruCrash("Error: matched hyps lentgh doesn't match: " + i2s(length(match.hypsMap)) + " != " + i2s(ruArity(a1)));
	}
	check_exps_are_eq(a1.stat.prop, a2.stat.prop);
	iteri(a1.stat.hyps, \i, hyp ->
		check_exps_are_eq(hyp.expr, a2.stat.hyps[match.hypsMap[i]].expr)
	);
}

ruReplaceMatch(match : RuAssertionMatch, math : RuMath, name2uses : Tree<int, Set<int>>, env : RuEnv) -> RuMath {
	uses = filtermap(
		set2array(lookupTreeDef(name2uses, match.less.descr.id, makeSet())),
		\id -> maybeBind(lookupTree(math.decls.assertions, id), ruDecl2Theorem)
	);
	fold(uses, math, \acc, th -> {
		if (ruVerbose(env.conf) > 2) {
			env.out.onMessage("\t\treplacing less general '" + id2s(match.less.descr.id) + "' in theorem '" + id2s(th.descr.id) + "'");
		}
		new_proof = RuProof(th.proof with 
			steps = map(th.proof.steps, \step ->
				if (step.assertion != match.less.descr.id) step else {
					if (ruVerbose(env.conf) > 3) {
						env.out.onMessage("\t\t\treplacing step " + i2s(step.ind + 1) + " from '" + id2s(step.assertion) + "' to '" + id2s(match.more.descr.id) + "'");
					}
					RuStep(step with 
						assertion = match.more.descr.id,
						refs = map(match.hypsMap, \i -> step.refs[i])
					);
				}
			)
		);
		if (ruVerbose(env.conf) > 2) {
			env.out.onMessage("\t\tnew proof for '" + id2s(th.descr.id) + "':\n" + 
				strIndent(strIndent(ru2s(new_proof, math)))
			);
		}
		ruMathReplaceDecl(acc, RuTheorem(th with proof = new_proof), env);
	});
}
