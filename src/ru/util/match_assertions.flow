import ru/unify/index;
import ru/prover/util;
import ru/unify/prod;

export {
	RuAssertionMatch(
		sub : Tree<RuVar, RuExp>,
		hypsMap : Tree<int, int>
	);
	ruMatchAssertions(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, conf : RuConf) -> Maybe<RuAssertionMatch>;
	ruMatchAssertions1(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, conf : RuConf) -> Maybe<RuAssertionMatch>;
}

ruMatchAssertions1(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, conf : RuConf) -> Maybe<RuAssertionMatch> {
	a2c = ruConstAssertion(a2, math);
	a2_hyps = fold(a2c.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, hyp, acc));
	a1_hyps = sortCustom(a1.stat.hyps, \hyp -> sizeSet(ruExp2Vars(hyp.expr)), false);
	time_limit = 10000.0;
	timer = ruMakeLimitedTimer(time_limit);
	check_disj = \s -> {
		unc_s = ruTransformSubst(s, a2c.env.unconst);
		switch (ruComputeDisjs(unc_s, a1.stat.disjs, RuDisjsInherent(makeSet()))) {
			RuDisjsInherent(disjs): ruIsSubset(disjs, a2.stat.disjs);
			RuDisjViolation(__,__): false;
		}
	}
	ret = maybeMap(
		maybeBind(ruUnifyExps([a1.stat.prop, a2c.const.stat.prop], makeTree(), math, conf),
			\sub -> {
				if (length(a1.stat.hyps) == 0) Some(RuAssertionMatch(sub, makeTree())) else {
					hyps_prod = map(a1.stat.hyps, \h -> {
						hyp_unified = ruUnifyIndex(
							ruApplySubst(h.expr, sub), a2_hyps, sub, 
							math, conf, time_limit / i2d(ruArity(a1))
						);
						map(hyp_unified, \un -> RuSubData(un.sub, un.data));
					});
					sub_unified = ruUnifySubsProd(hyps_prod, \__-> true, timer, math, conf);
					findmap(sub_unified, \sd -> {
						if (!check_disj(sd.sub)) {
							None();
						} else {
							Some(RuAssertionMatch(
								sd.sub, 
								foldi(a1.stat.hyps, makeTree(), \i, acc, __ -> 
									setTree(acc, i, sd.data[i].ind)
								)
							))
						}
					});
				}
			}
		),
		\match -> {
			match_sub = ruTransformSubst(match.sub, a2c.env.unconst);
			RuAssertionMatch(match with sub = match_sub);
		}
	);
	maybeMap(ret, \map -> ruCheckAssertionsMatch(a1, a2, map, math, conf));
	ret
}

ruMatchAssertions(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, conf : RuConf) -> Maybe<RuAssertionMatch> {
	a2c = ruConstAssertion(a2, math);
	a2_hyps = fold(a2c.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, hyp, acc));
	a1_hyps = sortCustom(a1.stat.hyps, \hyp -> sizeSet(ruExp2Vars(hyp.expr)), false);
	ret = maybeBind(
		maybeBind(ruUnifyExps([a1.stat.prop, a2c.const.stat.prop], makeTree(), math, conf),
			\theta -> ruMatchAssertionHyps(a1_hyps, a2_hyps, 0, RuAssertionMatch(theta, makeTree()), a2c.env.math, conf)
		),
		\match -> {
			match_sub = ruTransformSubst(match.sub, a2c.env.unconst);
			switch (ruComputeDisjs(match_sub, a1.stat.disjs, RuDisjsInherent(makeSet()))) {
				RuDisjsInherent(disjs): {
					if (!ruIsSubset(disjs, a2.stat.disjs)) None() else 
					Some(RuAssertionMatch(match with sub = match_sub));
				}
				RuDisjViolation(__,__): {
					conf.onMessage("RuDisjViolation(__,__)");
					None();
				}
			}
		}
	);
	maybeMap(ret, \map -> ruCheckAssertionsMatch(a1, a2, map, math, conf));
	ret
}

ruMatchAssertionHyps(
	a1_hyps : [RuHyp], 
	a2_hyps : RuIndex<RuHyp>, 
	i : int, 
	match : RuAssertionMatch, 
	math : RuMath, 
	conf : RuConf
) -> Maybe<RuAssertionMatch> {
	if (i == length(a1_hyps)) Some(match) else {
		fold(
			ruUnifyIndex(a1_hyps[i].expr, a2_hyps, match.sub, math, conf, 1.0), 
			None(), \m, unif ->
			if (isSome(m)) m else {
				ruMatchAssertionHyps(
					a1_hyps, a2_hyps, i + 1, 
					RuAssertionMatch(unif.sub, setTree(match.hypsMap, a1_hyps[i].ind, unif.data.ind)), 
					math, conf
				);
			}
		);
	}
}

ruAssertionsMatch2s(match : RuAssertionMatch, math : RuMath) -> string {
	"sub:\n" + ruSubst2s(match.sub, math) + "\n" +
	"hyps map: " + strGlue(map(tree2pairs(match.hypsMap), \p -> i2s(p.first) + " => " + i2s(p.second)), ", ");
}

ruCheckAssertionsMatch(a1 : RuAssertion, a2 : RuAssertion, match : RuAssertionMatch, math : RuMath, conf : RuConf) -> void {
	check_exps_are_eq = \e1, e2 -> {
		e1_prime = ruApplySubst(e1, match.sub);
		if (e2.nodes != e1_prime.nodes) {
			conf.onError("Error: matched propositions doesn't coincide:", []);
			conf.onError(ru2s(e2, math), []);
			conf.onError(ru2s(e1_prime, math), []);
			conf.onError(ruExpRPN2s(e2), []);
			conf.onError(ruExpRPN2s(e1_prime), []);
			quit(-1);
		}
	}
	if (sizeTree(match.hypsMap) != ruArity(a1)) {
		conf.onError("Error: matched hyps lentgh doesn't match: " + i2s(sizeTree(match.hypsMap)) + " != " + i2s(ruArity(a1)), []);
		quit(-1);
	}
	check_exps_are_eq(a1.stat.prop, a2.stat.prop);
	iteri(a1.stat.hyps, \i, hyp ->
		check_exps_are_eq(hyp.expr, a2.stat.hyps[lookupTreeDef(match.hypsMap, i, -1)].expr)
	);
}
