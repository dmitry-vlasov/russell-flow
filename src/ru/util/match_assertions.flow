import ru/unify/index;
import ru/prover/util;
import ru/unify/prod;

export {
	RuAssertionMatch(
		less : RuAssertion, // The less general assertion
		more : RuAssertion, // The more general assertion
		sub : Tree<RuVar, RuExp>, // Substitution, which makes a less general from more general
		hypsMap : Tree<int, int>  // The hypothesis map: the number and order of hypotheses may differ.
	);
	ruMatchAssertions(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch>;
	ruMatchAssertions1(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch>;
}

ruMatchAssertions1(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch> {
	a2c = ruConstAssertion(a2, math);
	a2_hyps = fold(a2c.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, hyp, acc));
	a1_hyps = sortCustom(a1.stat.hyps, \hyp -> sizeSet(ruExp2Vars(hyp.expr)), false);
	time_limit = 10000.0;
	timer = ruMakeLimitedTimer(time_limit);
	check_disj = \s -> {
		unc_s = ruTransformSubst(s, a2c.env.unconst);
		switch (ruComputeDisjs(unc_s, a1.stat.disjs, RuDisjsInherent(makeSet()))) {
			RuDisjsInherent(disjs): ruIsSubset(disjs, a2.stat.disjs);
			RuDisjViolation(__,__): false;
		}
	}
	ret = maybeMap(
		maybeBind(ruUnifyExps([a1.stat.prop, a2c.const.stat.prop], makeTree(), math, env),
			\sub -> {
				if (length(a1.stat.hyps) == 0) Some(RuAssertionMatch(a2, a1, sub, makeTree())) else {
					hyps_prod = map(a1.stat.hyps, \h -> {
						hyp_unified = ruUnifyIndex(
							ruApplySubst(h.expr, sub), a2_hyps, sub, 
							math, env, time_limit / i2d(ruArity(a1))
						);
						map(hyp_unified, \un -> RuSubData(un.sub, un.data));
					});
					sub_unified = ruUnifySubsProd(hyps_prod, \__-> true, timer, math, env);
					findmap(sub_unified, \sd -> {
						if (!check_disj(sd.sub)) {
							None();
						} else {
							Some(RuAssertionMatch(a2, a1, sd.sub, 
								foldi(a1.stat.hyps, makeTree(), \i, acc, __ -> 
									setTree(acc, i, sd.data[i].ind)
								)
							))
						}
					});
				}
			}
		),
		\match -> {
			match_sub = ruTransformSubst(match.sub, a2c.env.unconst);
			RuAssertionMatch(match with sub = match_sub);
		}
	);
	maybeMap(ret, \match -> ruCheckAssertionsMatch(match, math, env));
	ret
}

ruMatchAssertions(a1 : RuAssertion, a2 : RuAssertion, math : RuMath, env : RuEnv) -> Maybe<RuAssertionMatch> {
	a2c = ruConstAssertion(a2, math);
	a2_hyps = fold(a2c.const.stat.hyps, ruMakeIndex(), \acc, hyp -> ruSetIndex(hyp.expr, hyp, acc));
	a1_hyps = sortCustom(a1.stat.hyps, \hyp -> sizeSet(ruExp2Vars(hyp.expr)), false);
	ret = maybeBind(
		maybeBind(ruUnifyExps([a1.stat.prop, a2c.const.stat.prop], makeTree(), math, env),
			\theta -> ruMatchAssertionHyps(a1_hyps, a2_hyps, 0, RuAssertionMatch(a2, a1, theta, makeTree()), a2c.env.math, env)
		),
		\match -> {
			match_sub = ruTransformSubst(match.sub, a2c.env.unconst);
			switch (ruComputeDisjs(match_sub, a1.stat.disjs, RuDisjsInherent(makeSet()))) {
				RuDisjsInherent(disjs): {
					if (!ruIsSubset(disjs, a2.stat.disjs)) None() else 
					Some(RuAssertionMatch(match with sub = match_sub));
				}
				RuDisjViolation(__,__): {
					env.out.onMessage("RuDisjViolation(__,__)");
					None();
				}
			}
		}
	);
	maybeMap(ret, \match -> ruCheckAssertionsMatch(match, math, env));
	ret
}

ruMatchAssertionHyps(
	a1_hyps : [RuHyp], 
	a2_hyps : RuIndex<RuHyp>, 
	i : int, 
	match : RuAssertionMatch, 
	math : RuMath, 
	env : RuEnv
) -> Maybe<RuAssertionMatch> {
	if (i == length(a1_hyps)) Some(match) else {
		fold(
			ruUnifyIndex(a1_hyps[i].expr, a2_hyps, match.sub, math, env, 1.0), 
			None(), \m, unif ->
			if (isSome(m)) m else {
				ruMatchAssertionHyps(
					a1_hyps, a2_hyps, i + 1, 
					RuAssertionMatch(
						match.less, match.more, unif.sub, 
						setTree(match.hypsMap, a1_hyps[i].ind, unif.data.ind)
					), 
					math, env
				);
			}
		);
	}
}

ruAssertionsMatch2s(match : RuAssertionMatch, math : RuMath) -> string {
	"sub:\n" + ruSubst2s(match.sub, math) + "\n" +
	"hyps map: " + strGlue(map(tree2pairs(match.hypsMap), \p -> i2s(p.first) + " => " + i2s(p.second)), ", ");
}

ruCheckAssertionsMatch(match : RuAssertionMatch, math : RuMath, env : RuEnv) -> void {
	a1 = match.more;
	a2 = match.less; 
	check_exps_are_eq = \e1, e2 -> {
		e1_prime = ruApplySubst(e1, match.sub);
		if (e2.nodes != e1_prime.nodes) {
			env.out.onError("Error: matched propositions doesn't coincide:", []);
			env.out.onError(ru2s(e2, math), []);
			env.out.onError(ru2s(e1_prime, math), []);
			env.out.onError(ruExpRPN2s(e2), []);
			env.out.onError(ruExpRPN2s(e1_prime), []);
			quit(-1);
		}
	}
	if (sizeTree(match.hypsMap) != ruArity(a1)) {
		env.out.onError("Error: matched hyps lentgh doesn't match: " + i2s(sizeTree(match.hypsMap)) + " != " + i2s(ruArity(a1)), []);
		quit(-1);
	}
	check_exps_are_eq(a1.stat.prop, a2.stat.prop);
	iteri(a1.stat.hyps, \i, hyp ->
		check_exps_are_eq(hyp.expr, a2.stat.hyps[lookupTreeDef(match.hypsMap, i, -1)].expr)
	);
}
