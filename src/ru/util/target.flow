import ru/math;
import ru/util/src;
import script/script;

export {
	RuTarget ::= RuTargetMath, RuTargetSource, RuTargetAssertion, RuTargetNone;
		RuTargetNone();
		RuTargetMath();
		RuTargetSource(source : RuSource);
		RuTargetAssertion(assertion : RuAssertion);
	
	ruDetermineTarget(task : ScTask, math : RuMath, env : RuEnv) -> RuTarget;
	ruTargetAssertions(target : RuTarget, math : RuMath, env : RuEnv) -> [RuAssertion];

	ruTargetPredicate(target : RuTarget) -> (RuDecl) -> bool;

	ruProofLengthMeasure(decl : RuDecl) -> double;
	ruProofExpSizeMeasure(decl : RuDecl) -> double;
}

ruDetermineTarget(task : ScTask, math : RuMath, env : RuEnv) -> RuTarget {
	target0 = lookupTreeDef(task.args, "target", "");
	if (target0 == "") RuTargetNone() else {
		target = ruTrimPath(target0, env.conf, ".ru");
		if (ruVerbose(env.conf) > 2) {
			env.out.onMessage("determining target: '" + target + "'");
		}
		if (target == "all" || target == "1" || target == "math") {
			RuTargetMath();
		} else {
			target_id = s2id(target);
			switch (lookupTree(math.sources, target_id)) {
				Some(src): RuTargetSource(src);
				None(): 
					switch (lookupTree(math.decls.assertions, target_id)) {
						Some(ass): RuTargetAssertion(ass);
						None(): RuTargetNone();
					}
			}
		}
	}
}

ruTargetAssertions(target : RuTarget, math : RuMath, env : RuEnv) -> [RuAssertion] {
	switch (target) {
		RuTargetNone(): [];
		RuTargetMath(): getTreeValues(math.decls.assertions);
		RuTargetSource(source): filtermap(source.decls, ruDecl2Assertion);
		RuTargetAssertion(assertion): [assertion];
	}
}
ruTargetPredicate(target : RuTarget) -> (RuDecl) -> bool {
	switch (target) {
		RuTargetMath(): 
			ruDeclIsTheorem;
		RuTargetSource(src): 
			\decl -> ruDeclIsTheorem(decl) && decl.descr.src == src.info.id;
		RuTargetAssertion(ass): 
			\decl -> ass.descr.id == decl.descr.id;
		RuTargetNone():
			\decl -> false;
	}
}

ruProofLengthMeasure(decl : RuDecl) -> double {
	switch (decl) {
		RuTheorem(__,__,__,proof): i2d(length(proof.steps));
		default: 0.0;
	}
}

ruProofExpSizeMeasure(decl : RuDecl) -> double {
	switch (decl) {
		RuTheorem(__,__,__,proof): ruDoProofExpSizeMeasure(proof);
		default: 0.0;
	}
}

ruDoProofExpSizeMeasure(proof : RuProof) -> double {
	fold(proof.steps, 0.0, \acc, step ->
		acc + i2d(length(step.expr.nodes)) + ruDoProofExpSizeMeasure(step.proof)
	);
}
