import ru/src;

export {
	ruAssertionsDepths(assertions : Tree<int, RuAssertion>) -> Tree<int, int>;
	ruAssertionsAxioms(assertions : Tree<int, RuAssertion>) -> Tree<int, Set<int>>;
	ruAssertionsDependencies(assertions : Tree<int, RuAssertion>, env : RuEnv) -> Tree<int, Set<int>>;
	ruDoAssertionsDependencies(as_name : int, acc : Tree<int, Set<int>>, assertions : Tree<int, RuAssertion>, env : RuEnv) -> Tree<int, Set<int>>;
	ruAssertionsProofSteps(as : Set<int>, assertions : Tree<int, RuAssertion>) -> Tree<int, Tree<int, [int]>>;
	ruAssertionsUses(assertions : Tree<int, RuAssertion>) -> Tree<int, Set<int>>;

	ruAssertionDepth(ass : int, assertions : Tree<int, RuAssertion>) -> int;
	ruAssertionAxioms(ass : int, assertions : Tree<int, RuAssertion>) -> Set<int>;
	ruAssertionDependencies(ass : int, assertions : Tree<int, RuAssertion>, env : RuEnv) -> Set<int>;

	ruAssertionsMerge(as1 : Tree<int, RuAssertion>, as2 : Tree<int, RuAssertion>, env : RuEnv) -> Tree<int, RuAssertion>;
}

ruAssertionsDepths(assertions : Tree<int, RuAssertion>) -> Tree<int, int> {
	foldTree(assertions, makeTree(), \id, __, acc -> ruDoAssertionsDepths(assertions, id, acc));
}

ruDoAssertionsDepths(assertions : Tree<int, RuAssertion>, as_name : int, acc : Tree<int, int>) -> Tree<int, int> {
	switch (lookupTree(assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(info,__,__,proof): {
					switch (lookupTree(acc, info.id)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoAssertionsDepths(assertions, step.assertion, ac));
							max_depth = fold(proof.steps, 0, \ac, step -> max(ac, lookupTreeDef(acc1, step.assertion, 0)));
							setTree(acc1, info.id, max_depth + 1);
						}
					}
				}
				RuAxiom(info,__):     setTree(acc, info.id, 0);
				RuDef(info,__,__,__): setTree(acc, info.id, 0);
			}
		}
		None(): acc;
	}
}

ruAssertionsAxioms(assertions : Tree<int, RuAssertion>) -> Tree<int, Set<int>> {
	foldTree(assertions, makeTree(), \id, __, acc -> ruDoAssertionsAxioms(assertions, id, acc));
}

ruDoAssertionsAxioms(assertions : Tree<int, RuAssertion>, as_name : int, acc : Tree<int, Set<int>>) -> Tree<int, Set<int>> {
	switch (lookupTree(assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(info,__,__,proof): {
					switch (lookupTree(acc, info.id)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoAssertionsAxioms(assertions, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, info.id, axioms);
						}
					}
				}
				RuAxiom(info,__):     setTree(acc, info.id, makeSet1(info.id));
				RuDef(info,__,__,__): setTree(acc, info.id, makeSet());
			}
		}
		None(): acc;
	}
}

ruAssertionsDependencies(assertions : Tree<int, RuAssertion>, env : RuEnv) -> Tree<int, Set<int>> {
	foldTree(assertions, makeTree(), \id, __, acc -> ruDoAssertionsDependencies(id, acc, assertions, env));
}

ruDoAssertionsDependencies(as_name : int, acc : Tree<int, Set<int>>, assertions : Tree<int, RuAssertion>, env : RuEnv) -> Tree<int, Set<int>> {
	if (containsKeyTree(acc, as_name)) {
		acc; 
	} else { 
		switch (lookupTree(assertions, as_name)) {
			Some(a): {
				switch (a) {
					RuTheorem(info,__,__,proof): {
						switch (lookupTree(acc, info.id)) {
							Some(v): acc;
							None(): {
								acc1 = fold(proof.steps, acc, \ac, step -> ruDoAssertionsDependencies(step.assertion, ac, assertions, env));
								deps = fold(proof.steps, 
									buildSet(map(proof.steps, \step -> step.assertion)), 
									\ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet()))
								);
								setTree(acc1, info.id, deps);
							}
						}
					}
					RuAxiom(info,__):     setTree(acc, info.id, makeSet());
					RuDef(info,__,__,__): setTree(acc, info.id, makeSet());
				}
			}
			None(): acc;
		}
	}
}

ruAssertionDepth(ass : int, assertions : Tree<int, RuAssertion>) -> int {
	switch (lookupTree(assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,proof): {
					1 + fold(proof.steps, 0, \acc, step -> max(acc, ruAssertionDepth(step.assertion, assertions)));
				}
				RuAxiom(__,__):     0;
				RuDef(__,__,__,__): 0;
			}
		}
		None(): -1;
	}
}

ruAssertionAxioms(ass : int, assertions : Tree<int, RuAssertion>) -> Set<int> {
	switch (lookupTree(assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,proof): {
					fold(proof.steps, makeSet(), \acc, step -> mergeSets(acc, ruAssertionAxioms(step.assertion, assertions)));
				}
				RuAxiom(info,__):     makeSet1(info.id);
				RuDef(info,__,__,__): makeSet();
			}
		}
		None(): makeSet();
	}
}

ruAssertionDependencies(ass : int, assertions : Tree<int, RuAssertion>, env : RuEnv) -> Set<int> {
	lookupTreeDef(ruDoAssertionsDependencies(ass, makeTree(), assertions, env), ass, makeSet());
}

ruAssertionsProofSteps(as : Set<int>, assertions : Tree<int, RuAssertion>) -> Tree<int, Tree<int, [int]>> {
	foldTree(assertions, makeTree(), \__, ass, acc ->
		switch (ass) {
			RuTheorem(info,__,__,proof):
				foldi(proof.steps, acc, \i, a, step ->
					if (!containsSet(as, step.assertion)) a else {
						tr = lookupTreeDef(a, step.assertion, makeTree());
						setTree(a, step.assertion,
							setTree(tr, info.id, 
								concat(lookupTreeDef(tr, info.id, []), [i])	
							)
						);
					}
				);
			default: acc;
		}
	);	
}

ruAssertionsUses(assertions : Tree<int, RuAssertion>) -> Tree<int, Set<int>> {
	foldTree(assertions, makeTree(), \name, ass, acc ->
		switch (ass) {
			RuTheorem(info,__,__,proof): 
				fold(proof.steps, acc, \ac, step ->
					setTree(ac, step.assertion, 
						insertSet(lookupTreeDef(ac, step.assertion, makeSet()), info.id)
					)
				);
			default: acc;
		}
	);
}

ruAssertionsMerge(as1 : Tree<int, RuAssertion>, as2 : Tree<int, RuAssertion>, env : RuEnv) -> Tree<int, RuAssertion> {
	mergeTreeCustom(as1, as2, \id, a1, a2 -> { env.out.onError("duplicate assertion: " + id2s(id), []); a1 })
}