import ru/math;

export {
	ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp;
	ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath, conf : RuConf) -> Maybe<Tree<RuVar, RuExp>>;
	ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string;
	ruSubstRPN2s(s : Tree<RuVar, RuExp>) -> string;
	ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp) -> Maybe<Tree<RuVar, RuExp>>;
	ruAdd2Subst1(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp, math : RuMath, conf : RuConf) -> Maybe<Tree<RuVar, RuExp>>;
	ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool;
	ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>>;

	ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;
	ruUnsafeCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Tree<RuVar, RuExp>;

	ruSubsAreEq(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> bool;
	ruSubsAreSim(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>>;

	ruSubComplexity(s : Tree<RuVar, RuExp>) -> int;

	ruSubst2Renaming(s : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuVar>>;
	ruRenaming2Subst(r : Tree<RuVar, RuVar>) -> Tree<RuVar, RuExp>;
	ruRenaming2s(r : Tree<RuVar, RuVar>) -> string;
	ruApplyRenaming2Theorem(r : Tree<RuVar, RuVar>, th : RuTheorem) -> RuTheorem;
	ruApplyRenaming2Decl(r : Tree<RuVar, RuVar>, decl : RuDecl) -> RuDecl;

	ruTransformSubst(s: Tree<RuVar, RuExp>, f : (RuExp) -> RuExp) -> Tree<RuVar, RuExp>;
	// Level of a substitution.
	// 0 - variable renaming,
	// 1 - mapping of variables onto variables and constants
	// 2 - general form of a substitution.
	ruSubstLevel(s: Tree<RuVar, RuExp>) -> int;

	ruSubstSatisfies(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>) -> bool;
	ruComputeDisjs(s : Tree<RuVar, RuExp>, acc : Set<RuDisj>, disjs : Set<RuDisj>, on_violation : (RuDisj, Set<RuVar>) -> void) -> Maybe<Set<RuDisj>>;
}

ruMergeSubst(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	conflict = ref false;
	s0 = mergeTreeCustom(s1, s2, \__, e1, e2 -> if (e1.nodes == e2.nodes) e1 else { conflict := true; e1 });
	if (^conflict) None() else Some(s0);
}

ruSubst2s(s : Tree<RuVar, RuExp>, math : RuMath) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExp2s(p.second, math.rules)) 
	, "\n")
}

ruSubstRPN2s(s : Tree<RuVar, RuExp>) -> string {
	strGlue(map(tree2pairs(s), \p -> p.first.name + " => " + ruExpRPN2s(p.second.nodes)) 
	, "\n")
}

ruAdd2Subst1(s : Tree<RuVar, RuExp>, v : RuVar, e : RuExp, math : RuMath, conf : RuConf) -> Maybe<Tree<RuVar, RuExp>> {
	if (e.nodes[0].type == v.type) ruAdd2Subst(s, v, e) else 
	maybeBind(ruSuperRule(e.nodes[0].type, v.type, math, conf), \super ->
		ruAdd2Subst(s, v, RuExp(concat([RuRuleRef(super.name, v.type, 1, 1)], e.nodes), e.pos))
	)
}

ruAdd2Subst(s : Tree<RuVar, RuExp>, v : RuVar, e0 : RuExp) -> Maybe<Tree<RuVar, RuExp>> {
	t = timestamp();
	e = ruApplySubst(e0, s);
	ret = if (e.nodes == [v]) Some(s) else {
		//e_vars = ruExp2Vars(e.nodes);
		if (ruExpContainsVar(e.nodes, v)) None() else {
			switch (lookupTree(s, v)) {
				Some(e1): if (e.nodes == e1.nodes) Some(s) else None();
				None(): {
					e_vars = ruExp2Vars(e.nodes);
					p = foldSet(e_vars, Pair(true, None()), \acc, e_v ->
						if (!acc.first) acc else {
							switch (lookupTree(s, e_v)) {
								Some(e2): {
									//e2_vars = ruExp2Vars(e2.nodes);
									if (!ruExpContainsVar(e2.nodes, e_v)) acc else {
										Pair(e2.nodes == [v] && e.nodes == [e_v], Some(e_v));
									}
								}
								None(): acc;
							}
						}
					);
					if (!p.first) None() else {
						switch (p.second) {
							Some(w): Some(removeFromTree(s, w));
							None():  {
								theta = makeTree1(v, e);
								Some(setTree(mapTree(s, \x -> ruApplySubst(x, theta)), v, e));
							}
						}
					}
				}
			}
		}
	}
	time = timestamp() - t;
	stats = RuStatsRow("", 
		pairs2tree([
			Pair("size", i2d(sizeTree(s))), 
			Pair("time", time),
			Pair("cplx", i2d(ruSubComplexity(s)))
		])
	);
	ruAddStats("ruAdd2Subst", stats);
	ret
}

ruSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s1, Some(makeTree()), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2Subst(s, v1, ruApplySubst(e1, s2)))
	);
	/*if (sizeTree(s1) < 64 && sizeTree(s2) < 64) {
		ruDoSemiCompose(s1, s2);
	} else {
		dom1 = buildSet(getTreeKeys(s1));
		dom2 = buildSet(getTreeKeys(s2));
		im1 = foldTree(s1, makeSet(), \__, e, acc -> mergeSets(acc, ruExp2Vars(e.nodes)));
		im2 = foldTree(s2, makeSet(), \__, e, acc -> mergeSets(acc, ruExp2Vars(e.nodes)));
		splited = foldTree(s2,
			foldTree(s1, Triple(makeTree(), makeTree(), makeTree()), 
				\v, e, acc -> {
					vs = insertSet(ruExp2Vars(e.nodes), v);
					if (ruSetsIntersect(vs, dom2) || containsSet(im2, v)) {
						Triple(acc.first, setTree(acc.second, v, e), acc.third);
					} else {
						Triple(setTree(acc.first, v, e), acc.second, acc.third);
					}
				}
			),
			\v, e, acc -> {
				vs = insertSet(ruExp2Vars(e.nodes), v);
				if (ruSetsIntersect(vs, dom1) || containsSet(im1, v)) {
					Triple(acc.first, acc.second, setTree(acc.third, v, e));
				} else {
					Triple(setTree(acc.first, v, e), acc.second, acc.third);
				}
			}
		);
		maybeMap(
			ruDoSemiCompose(splited.second, splited.third),
			\s -> mergeTree(splited.first, s)
		);
	}*/
}

ruDoSemiCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s1, Some(makeTree()), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2Subst(s, v1, ruApplySubst(e1, s2)))
	);
}

ruDoCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	foldTree(s2, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1, v2)) Some(s) else ruAdd2Subst(s, v2, e2))
	);
}

ruCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	t= timestamp();
	ret = foldTree(s2, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1, v2)) Some(s) else ruAdd2Subst(s, v2, e2))
	);
	stats = RuStatsRow("", 
		pairs2tree([
			Pair("size", i2d(sizeTree(s1) + sizeTree(s2))), 
			Pair("time", timestamp() - t),
			Pair("cplx", i2d(ruSubComplexity(s1) + ruSubComplexity(s2)))
		])
	);
	ruAddStats("ruCompose", stats);
	ret
	
	
	/*if (sizeTree(s1) < 64 && sizeTree(s2) < 64) {
		ruDoCompose(s1, s2);
	} else {
		dom1 = buildSet(getTreeKeys(s1));
		dom2 = buildSet(getTreeKeys(s2));
		im1 = foldTree(s1, makeSet(), \__, e, acc -> mergeSets(acc, ruExp2Vars(e.nodes)));
		im2 = foldTree(s2, makeSet(), \__, e, acc -> mergeSets(acc, ruExp2Vars(e.nodes)));
		splited = foldTree(s2,
			foldTree(s1, Triple(makeTree(), makeTree(), makeTree()), 
				\v, e, acc -> {
					vs = insertSet(ruExp2Vars(e.nodes), v);
					if (ruSetsIntersect(vs, dom2) || containsSet(im2, v)) {
						Triple(acc.first, setTree(acc.second, v, e), acc.third);
					} else {
						Triple(setTree(acc.first, v, e), acc.second, acc.third);
					}
				}
			),
			\v, e, acc -> {
				vs = insertSet(ruExp2Vars(e.nodes), v);
				if (ruSetsIntersect(vs, dom1) || containsSet(im1, v)) {
					Triple(acc.first, acc.second, setTree(acc.third, v, e));
				} else {
					Triple(setTree(acc.first, v, e), acc.second, acc.third);
				}
			}
		);
		maybeMap(
			foldTree(splited.third, ruDoSemiCompose(splited.second, splited.third), \v2, e2, acc ->
				maybeBind(acc, \s -> if (containsKeyTree(s1, v2)) Some(s) else ruAdd2Subst(s, v2, e2))
			),
			\s -> mergeTree(splited.first, s)
		);
	}*/
}

ruUnsafeCompose(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Tree<RuVar, RuExp> {
	foldTree(s2, 
		foldTree(s1, makeTree(), \v1, e1, acc -> setTree(acc, v1, ruApplySubst(e1, s2))), 
		\v2, e2, acc -> if (containsKeyTree(acc, v2)) acc else setTree(acc, v2, e2)
	);
}

ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath, conf : RuConf) -> Maybe<Tree<RuVar, RuExp>> {
	add2s = \i, p : Pair<Tree<RuVar, RuExp>, int>, v, ex ->
		switch (lookupTree(p.first, v)) {
			Some(e1): if (ex.nodes == e1.nodes) Some(Pair(p.first, p.second + i)) else None();
			None(): Some(Pair(setTree(p.first, v, ex), p.second + i));
		}
	addVar = \i, t1, t2, n1, p, ec -> 
		if (t1 == t2) {
			add2s(i, p, n1, ec());
		} else {
			maybeBind(ruSuperRule(t2, t1, math, conf), \super ->
				add2s(i, p, n1, RuExp(concat([RuRuleRef(super.name, t1, 1, 1)], ec().nodes), e.pos))
			)
		}
	maybeMap(fold(pattern.nodes, Some(Pair(makeTree(), 0)), \acc, n1 ->
		maybeBind(acc, \p ->
			switch (n1) {
				RuRuleRef(r1,__,__,__): {
					switch (e.nodes[p.second]) {
						RuRuleRef(r2,__,__,__): 
							if (r1 != r2) None() else Some(Pair(p.first, p.second + 1));
						RuVar(__,__): None();
					}
				}
				RuVar(v1, t1): {
					n2 = e.nodes[p.second];
					switch (n2) {
						RuRuleRef(r2, t2, __, len):
							addVar(len + 1, t1, t2, n1, p, \-> RuExp(subrange(e.nodes, p.second, len + 1), e.pos));
						RuVar(v2, t2):
							addVar(1, t1, t2, n1, p, \-> RuExp([n2], e.pos));
					}
				}
			}
		)
	), \p -> p.first);
}

RuApplyStack(
	parent : Maybe<RuApplyStack>,
	len : int
);

ruApplyComputeLen(arity : int, stack_len : Pair<RuApplyStack, int>) -> Pair<RuApplyStack, int> {
	if (arity == 0) stack_len else {
		switch (stack_len.first.parent) {
			Some(p): 
				ruApplyComputeLen(
					arity - 1, 
					Pair(p, stack_len.first.len + stack_len.second)
				);
			None(): {
				ruPrintln("empty stack pop at ruApplyComputeLen");
				quit(-1);
				stack_len;
			}
		}
	}
}

RuApplyAcc(
	nodes : [RuExpNode],
	stack : RuApplyStack
);

ruApplySubst(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp {
	tm1 = timestamp();
	ret1 = RuExp(foldr(e.nodes, RuApplyAcc([], RuApplyStack(None(), 0)), 
		\acc, n -> {
			switch (n) {
				RuRuleRef(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						concat([RuRuleRef(r, t, a, st_len.second)], acc.nodes),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(v, t): {
					switch (lookupTree(s, n)) {
						Some(x):
							RuApplyAcc(
								concat(x.nodes, acc.nodes),
								RuApplyStack(Some(acc.stack), length(x.nodes))
							);
						None(): 
							RuApplyAcc(
								concat([n], acc.nodes),
								RuApplyStack(Some(acc.stack), 1)
							);
					}
				}
			}
		}).nodes, e.pos
	);
	ruAddTime("ruApplySubst", cast(timestamp() - tm1 : double -> int));
	//ret2 = ruApplySubst2(e, s);
	ret1;
	//ruApplySubst2(e, s);
}

RuApplyAcc2(
	nodes : List<RuExpNode>,
	stack : RuApplyStack
);

ruApplySubst2(e : RuExp, s : Tree<RuVar, RuExp>) -> RuExp {
	tm1 = timestamp();
	ret = RuExp(reverseA(list2array(foldr(e.nodes, RuApplyAcc2(makeList(), RuApplyStack(None(), 0)), 
		\acc, n -> {
			switch (n) {
				RuRuleRef(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc2(
						Cons(RuRuleRef(r, t, a, st_len.second), acc.nodes),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(v, t): {
					switch (lookupTree(s, n)) {
						Some(x):
							RuApplyAcc2(
								concatList(array2list(reverseA(x.nodes)), acc.nodes),
								RuApplyStack(Some(acc.stack), length(x.nodes))
							);
						None(): 
							RuApplyAcc2(
								Cons(n, acc.nodes),
								RuApplyStack(Some(acc.stack), 1)
							);
					}
				}
			}
		}).nodes)), e.pos
	);
	ruAddTime("ruApplySubst2", cast(timestamp() - tm1 : double -> int));
	ret;
}





















ruSubstIsVarRenaming(s : Tree<RuVar, RuExp>) -> bool {
	forall(getTreeValues(s), ruIsVar)
}

ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>> {
	if (length(e.nodes) != length(pattern.nodes)) None() else {
		foldi(e.nodes, Some(makeTree()), \i, acc, v1 ->
			maybeBind(acc, \s -> {
				switch (v1) {
					RuRuleRef(r1,__,__,__): {
						switch (pattern.nodes[i]) {
							RuRuleRef(r2,__,__,__): if (r1 != r2) None() else Some(s);
							RuVar(__,__): None();
						}
					}
					RuVar(__, __): {
						v2 = pattern.nodes[i];
						switch (v2) {
							RuRuleRef(r2,__,__,__): None();
							RuVar(__,__):
								if (v1.type != v2.type) None() else {
									switch (lookupTree(s, v2)) {
										Some(w1): if (v1 == w1) Some(s) else None();
										None(): Some(setTree(s, v2, v1));
									}
								}
						}
					}
				}
			})
		)
	}
}

ruSubsAreEq(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> bool {
	if (sizeTree(s1) != sizeTree(s2)) false else {
		forall(tree2pairs(s1), \p ->
			switch (lookupTree(s2, p.first)) {
				Some(e2): p.second.nodes == e2.nodes;
				None(): false;
			}
		);
	}
}

ruSubsAreSim(s1 : Tree<RuVar, RuExp>, s2 : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuExp>> {
	if (sizeTree(s1) != sizeTree(s2)) None() else {
		theta = foldTree(s1, makeTree(), \v1, e1, acc ->
			switch (lookupTree(s2, v1)) {
				Some(__): acc;
				None(): {
					if (length(e1.nodes) != 1) acc else {
						v2 = e1.nodes[0];
						switch (v2) {
							RuVar(__,__): setTree(acc, v2, RuExp([v1], -1));
							default: acc;
						}
					}
				}
			}
		);
		maybeBind(ruCompose(s1, theta), \s -> if (ruSubsAreEq(s2, s)) Some(theta) else None());
	}
}

ruSubComplexity(s : Tree<RuVar, RuExp>) -> int {
	foldTree(s, 0, \v, e, acc -> acc + length(e.nodes));
}

ruSubst2Renaming(s : Tree<RuVar, RuExp>) -> Maybe<Tree<RuVar, RuVar>> {
	foldTree(s, Some(makeTree()), \v, e, acc -> 
		switch (acc) {
			Some(r): {
				switch (ruExp2Var(e)) {
					Some(w): Some(setTree(r, v, w));
					None(): None();
				}
			}
			None(): None();
		}
	);
}

ruRenaming2Subst(r : Tree<RuVar, RuVar>) -> Tree<RuVar, RuExp> {
	mapTree(r, \v -> RuExp([v], -1));
}

ruRenaming2s(r : Tree<RuVar, RuVar>) -> string {
	strGlue(map(tree2pairs(r), \p -> p.first.name + " => " + p.second.name), "\n");
}

ruApplyRenaming2Vars(r : Tree<RuVar, RuVar>, vars : Tree<string, RuVar>) -> Tree<string, RuVar> {
	foldTree(vars, makeTree(), \__, v, acc ->
		eitherMap(
			lookupTree(r, v),
			\w -> setTree(acc, w.name, w),
			setTree(acc, v.name, v)
		)
	);
}

ruApplyRenaming2Disjs(r : Tree<RuVar, RuVar>, disjs : Set<RuDisj>) -> Set<RuDisj> {
	mapSet(disjs, \disj ->
		RuDisj(
			lookupTreeDef(r, disj.v1, disj.v1),
			lookupTreeDef(r, disj.v2, disj.v2)
		)
	);
}

ruApplyRenaming2Term(r : Tree<RuVar, RuVar>, term : RuTerm) -> RuTerm {
	RuTerm(term with
		expr = map(term.expr, \n -> 
			switch (n) {
				RuVar(__,__): lookupTreeDef(r, n, n);
				default: n;
			}
		)
	);
}

ruApplyRenaming2Exp(r : Tree<RuVar, RuVar>, expr : RuExp) -> RuExp {
	RuExp(expr with 
		nodes = map(expr.nodes, \n -> 
			switch (n) {
				RuVar(__,__): lookupTreeDef(r, n, n);
				default: n;
			}
		)
	);
}

ruApplyRenaming2Proof(r : Tree<RuVar, RuVar>, proof : RuProof) -> RuProof {
	RuProof(proof with
		vars = ruApplyRenaming2Vars(r, proof.vars),
		disjs = ruApplyRenaming2Disjs(r, proof.disjs),
		steps = map(proof.steps, \s -> RuStep(s with expr = ruApplyRenaming2Exp(r, s.expr)))
	);
}

ruApplyRenaming2Theorem(r : Tree<RuVar, RuVar>, th : RuTheorem) -> RuTheorem {
	RuTheorem(th with
		vars = ruApplyRenaming2Vars(r, th.vars),
		disjs = ruApplyRenaming2Disjs(r, th.disjs),
		meta = mapSet(th.meta, \x -> foldTree(r, x, \v, w, acc -> if (v.name == x) w.name else acc)),
		hyps = map(th.hyps, \h -> RuHyp(h with expr = ruApplyRenaming2Exp(r, h.expr))),
		prop = ruApplyRenaming2Exp(r, th.prop),
		proof = ruApplyRenaming2Proof(r, th.proof)
	);
}

ruApplyRenaming2Decl(r : Tree<RuVar, RuVar>, decl : RuDecl) -> RuDecl	{
	switch (decl) {
		RuConst(__,__,__,__): decl;
		RuType(__,__,__): decl;
		RuRule(__,vars,term,__):
			RuRule(decl with
				vars = ruApplyRenaming2Vars(r, vars),
				term = ruApplyRenaming2Term(r, term)
			);
		RuAxiom(__, vars, disjs, hyps, prop, __):
		    RuAxiom(decl with
				vars = ruApplyRenaming2Vars(r, vars),
				disjs = ruApplyRenaming2Disjs(r, disjs),
				hyps = map(hyps, \h -> RuHyp(h with expr = ruApplyRenaming2Exp(r, h.expr))),
				prop = ruApplyRenaming2Exp(r, prop)
			);
		RuDef(__,vars, disjs, hyps, defm, defs, prop,__): 
			RuDef(decl with
				vars = ruApplyRenaming2Vars(r, vars),
				disjs = ruApplyRenaming2Disjs(r, disjs),
				hyps = map(hyps, \h -> RuHyp(h with expr = ruApplyRenaming2Exp(r, h.expr))),
				defm = ruApplyRenaming2Exp(r, defm),
				defs = ruApplyRenaming2Exp(r, defs),
				prop = ruApplyRenaming2Exp(r, prop)
			);
		RuTheorem(__,vars, disjs, meta, hyps, prop, proof,__):
			RuTheorem(decl with
				vars = ruApplyRenaming2Vars(r, vars),
				disjs = ruApplyRenaming2Disjs(r, disjs),
				meta = mapSet(meta, \x -> foldTree(r, x, \v, w, acc -> if (v.name == x) w.name else acc)),
				hyps = map(hyps, \h -> RuHyp(h with expr = ruApplyRenaming2Exp(r, h.expr))),
				prop = ruApplyRenaming2Exp(r, prop),
				proof = ruApplyRenaming2Proof(r, proof)
			);
	}
}

ruTransformSubst(s: Tree<RuVar, RuExp>, f : (RuExp) -> RuExp) -> Tree<RuVar, RuExp> {
	mapTree(s, f);
}

// Level of a substitution.
// 0 - variable renaming,
// 1 - mapping of variables onto variables and constants
// 2 - general form of a substitution.
ruSubstLevel(s: Tree<RuVar, RuExp>) -> int {
	foldTree(s, 0, \v, e, acc ->
		max(acc, if (ruIsVar(e)) 0 else if (ruIsConst(e)) 1 else 2)
	);
}

ruSubstSatisfies(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>) -> bool {
	foldSet(disjs, true, \acc, disj -> 
		if (!acc) acc else {
			e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], -1));
			e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], -1));
			e1_vars = ruExp2Vars(e1.nodes);
			e2_vars = ruExp2Vars(e2.nodes);
			common_vars = intersectSets(e1_vars, e2_vars);
			isEmptySet(common_vars);
		}
	)
}

ruComputeDisjs(s : Tree<RuVar, RuExp>, acc : Set<RuDisj>, disjs : Set<RuDisj>, on_violation : (RuDisj, Set<RuVar>) -> void) -> Maybe<Set<RuDisj>> {
	foldSet(disjs, Some(acc), \ac, disj -> 
		maybeBind(ac, \dsj -> {
			e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], -1));
			e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], -1));
			e1_vars = ruExp2Vars(e1.nodes);
			e2_vars = ruExp2Vars(e2.nodes);
			common_vars = intersectSets(e1_vars, e2_vars);
			if (!isEmptySet(common_vars)) {
				on_violation(disj, common_vars);
				None();
			} else {
				Some(foldSet(e1_vars, dsj, \ac1, v1 ->
					foldSet(e2_vars, ac1, \a, v2 ->
						if (v1.name < v2.name) insertSet(a, RuDisj(v1, v2)) else
						if (v2.name < v1.name) insertSet(a, RuDisj(v2, v1)) else a
					)
				));
			}
		})
	)
}
