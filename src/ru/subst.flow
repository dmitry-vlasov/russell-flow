import base/util/timer;
import base/util/util;
import ru/util/math;

export {
	RuSubst(map : Tree<RuVar, RuSubExpr>);
	ruEmptySubst = RuSubst(makeTree());

	ruLookupSubst(s : RuSubst, v : RuVar) -> Maybe<RuExp>;
	ruLookupSubstDef(s : RuSubst, v : RuVar) -> RuExp;
	ruApplySubst(e : RuExp, s : RuSubst) -> RuExp;
	ruApplySubstVars(e : RuSubExpr, s : RuSubst) -> RuSubExpr;
	ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath, env : RuEnv) -> Maybe<RuSubst>;
	ruMergeSubst(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst>;
	ruSubst2s(s : RuSubst, math : RuMath) -> string;
	ruSubstRPN2s(s : RuSubst) -> string;
	ruAdd2Subst(s : RuSubst, v : RuVar, e : RuExp) -> Maybe<RuSubst>;
	ruAdd2SubstVars(s : RuSubst, v : RuVar, e : RuSubExpr) -> Maybe<RuSubst>;
	ruAdd2Subst1(s : RuSubst, v : RuVar, e : RuExp, math : RuMath, env : RuEnv) -> Maybe<RuSubst>;
	ruIsVarRenaming(s : RuSubst) -> bool;
	ruReverseVarRenaming(s : RuSubst) -> RuSubst;
	ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>>;

	ruCompose(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst>;
	ruUnsafeCompose(s1 : RuSubst, s2 : RuSubst) -> RuSubst;

	ruSubsAreEq(s1 : RuSubst, s2 : RuSubst) -> bool;
	ruSubsAreSim(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst>;

	ruSubComplexity(s : RuSubst) -> int;

	ruSubst2Renaming(s : RuSubst) -> Maybe<Tree<RuVar, RuVar>>;
	ruRenaming2Subst(r : Tree<RuVar, RuVar>) -> RuSubst;
	ruRenaming2s(r : Tree<RuVar, RuVar>) -> string;
	ruApplyRenaming2Theorem(r : Tree<RuVar, RuVar>, th : RuTheorem) -> RuTheorem;
	ruApplyRenaming2Decl(r : Tree<RuVar, RuVar>, decl : RuDecl) -> RuDecl;
	ruApplyRenaming2Statement(r : Tree<RuVar, RuVar>, stat : RuStatement) -> RuStatement;

	ruTransformSubst(s: RuSubst, f : (RuExp) -> RuExp) -> RuSubst;
	// Level of a substitution.
	// 0 - variable renaming,
	// 1 - mapping of variables onto variables and constants
	// >= 2 - general form of a substitution.
	ruSubstLevel(s: RuSubst) -> int;
	ruSubstLen(s: RuSubst) -> int;

	// remove identical v -> v entries
	ruReduceSubst(s: RuSubst) -> RuSubst;

	ruMakeFresherSubst(vars : [RuVar], fresher : (RuVar) -> RuVar) -> RuSubst;
}

RuSubExpr(exp : RuExp, vars : Set<RuVar>);

ruLookupSubst(s : RuSubst, v : RuVar) -> Maybe<RuExp> {
	maybeMap(lookupTree(s.map, v), \e -> e.exp);
}

ruLookupSubstDef(s : RuSubst, v : RuVar) -> RuExp {
	switch (lookupTree(s.map, v)) {
		Some(ev): {
			ev.exp;
		}
		None(): {
			ruVar2Exp(v);
		}
	}
}

ruMergeSubst(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst> {
	conflict = ref false;
	m0 = mergeTreeCustom(s1.map, s2.map, \__, e1, e2 -> 
		if (e1.exp.nodes == e2.exp.nodes) e1 else { 
			conflict := true; 
			e1 
		}
	);
	if (^conflict) None() else Some(RuSubst(m0));
}

ruSubst2s(s : RuSubst, math : RuMath) -> string {
	strGlue(map(tree2pairs(s.map), \p -> 
		id2s(p.first.id) + " => " + ruExp2s(p.second.exp, math.decls.lang.rules)
	), "\n")
}

ruSubstRPN2s(s : RuSubst) -> string {
	strGlue(map(tree2pairs(s.map), \p -> 
		id2s(p.first.id) + " => " + ruExpRPN2s(p.second.exp)
	), "\n")
}

ruAdd2Subst1(s : RuSubst, v : RuVar, e : RuExp, math : RuMath, env : RuEnv) -> Maybe<RuSubst> {
	if (e.nodes[0].type == v.type) ruAdd2Subst(s, v, e) else 
	maybeBind(ruSuperRule(e.nodes[0].type, v.type, math.decls.lang, env), \super ->
		ruAdd2Subst(s, v, 
			RuExp(
				concat([RuRuleNode(super.info.id, v.type, 1, 1)], e.nodes), 
				e.pos
			)
		)
	)
}

ruAdd2Subst(s : RuSubst, v : RuVar, e0 : RuExp) -> Maybe<RuSubst> {
	e = ruApplySubst(e0, s);
	if (e.nodes == [v]) Some(s) else {
		if (ruExpContainsVar(e, v)) None() else {
			switch (lookupTree(s.map, v)) {
				Some(e1): if (e.nodes == e1.exp.nodes) Some(s) else None();
				None(): {
					e_vars = ruExp2Vars(e);
					p = foldSet(e_vars, Pair(true, None()), \acc, e_v ->
						if (!acc.first) acc else {
							switch (lookupTree(s.map, e_v)) {
								Some(e2): {
									if (!ruExpContainsVar(e2.exp, e_v)) acc else {
										Pair(e2.exp.nodes == [v] && e.nodes == [e_v], Some(e_v));
									}
								}
								None(): acc;
							}
						}
					);
					if (!p.first) None() else {
						switch (p.second) {
							Some(w): Some(RuSubst(removeFromTree(s.map, w)));
							None():  {
								//theta = makeTree1(v, e);
								//tau = mapTree(s, \x -> ruApplySubst(x, theta));
								//tau = mapTree(s, \x -> ruReplaceVarByExp(x, v, e));
								affected_vars = filterTree(s.map, \w, x -> 
									ruExpContainsVar(x.exp, v)
								);
								tau = foldTree(affected_vars, s.map, \w, x, acc ->
									setTree(acc, w, ruReplaceVarByExp(x, v, e))
								);
								ev = RuSubExpr(e, ruExp2Vars(e));
								Some(RuSubst(setTree(tau, v, ev)));
							}
						}
					}
				}
			}
		}
	}
}

ruAdd2SubstVarsFold(s : RuSubst, v : RuVar, e : RuSubExpr, e_vars : [RuVar], i : int, acc : Pair<bool, Maybe<RuVar>>) -> Pair<bool, Maybe<RuVar>> {
	if (!acc.first || i == length(e_vars)) acc else {
		e_v = e_vars[i];
		switch (lookupTree(s.map, e_v)) {
			Some(e2): {
				if (!containsSet(e2.vars, e_v)) {
					ruAdd2SubstVarsFold(s, v, e, e_vars, i + 1, acc); 
				} else {
					new_acc = Pair(e2.exp.nodes == [v] && e.exp.nodes == [e_v], Some(e_v));
					ruAdd2SubstVarsFold(s, v, e, e_vars, i + 1, new_acc);
				}
			}
			None(): {
				ruAdd2SubstVarsFold(s, v, e, e_vars, i + 1, acc);
			}
		}
	}
}

ruAdd2SubstVars(s : RuSubst, v : RuVar, e0 : RuSubExpr) -> Maybe<RuSubst> {
	e = ruApplySubstVars(e0, s);
	if (e.exp.nodes == [v]) Some(s) else {
		if (containsSet(e.vars, v)) None() else {
			switch (lookupTree(s.map, v)) {
				Some(e1): if (e.exp.nodes == e1.exp.nodes) Some(s) else None();
				None(): {
					p = ruAdd2SubstVarsFold(s, v, e, set2array(e.vars), 0, Pair(true, None()));
					if (!p.first) None() else {
						switch (p.second) {
							Some(w): Some(RuSubst(removeFromTree(s.map, w)));
							None():  {
								//theta = makeTree1(v, e);
								//tau = mapTree(s, \x -> ruApplySubst(x, theta));
								//tau = mapTree(s, \x -> ruReplaceVarByExp(x, v, e));
								affected_vars = filterTree(s.map, \w, x -> 
									containsSet(x.vars, v)
								);
								tau = foldTree(affected_vars, s.map, \w, x, acc ->
									setTree(acc, w, ruReplaceVarByExpVars(x, v, e))
								);
								Some(RuSubst(setTree(tau, v, e)));
							}
						}
					}
				}
			}
		}
	}
}

ruSemiCompose(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst> {
	foldTree(s1.map, Some(RuSubst(makeTree())), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2SubstVars(s, v1, ruApplySubstVars(e1, s2)))
	);
}

ruDoSemiCompose(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst> {
	foldTree(s1.map, Some(RuSubst(makeTree())), \v1, e1, acc ->
		maybeBind(acc, \s -> ruAdd2SubstVars(s, v1, ruApplySubstVars(e1, s2)))
	);
}

ruDoCompose(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst> {
	foldTree(s2.map, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1.map, v2)) Some(s) else ruAdd2SubstVars(s, v2, e2))
	);
}

ruCompose(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst> {
	foldTree(s2.map, ruSemiCompose(s1, s2), \v2, e2, acc ->
		maybeBind(acc, \s -> if (containsKeyTree(s1.map, v2)) Some(s) else ruAdd2SubstVars(s, v2, e2))
	);
}

ruUnsafeCompose(s1 : RuSubst, s2 : RuSubst) -> RuSubst {
	RuSubst(foldTree(s2.map, 
		foldTree(s1.map, makeTree(), \v1, e1, acc -> 
			setTree(acc, v1, ruApplySubstVars(e1, s2))
		), 
		\v2, e2, acc -> 
			if (containsKeyTree(acc, v2)) acc else {
				setTree(acc, v2, e2);
			}
	));
}

ruMatchExp(e : RuExp, pattern : RuExp, math : RuMath, env : RuEnv) -> Maybe<RuSubst> {
	add2s = \i, p : Pair<Tree<RuVar, RuExp>, int>, v, ex ->
		switch (lookupTree(p.first, v)) {
			Some(e1): if (ex.nodes == e1.nodes) Some(Pair(p.first, p.second + i)) else None();
			None(): Some(Pair(setTree(p.first, v, ex), p.second + i));
		}
	addVar = \i, t1, t2, n1, p, ec -> 
		if (t1 == t2) { 
			add2s(i, p, n1, ec());
		} else {
			maybeBind(ruSuperRule(t2, t1, math.decls.lang, env), \super ->
				add2s(i, p, n1, 
					RuExp(
						concat([RuRuleNode(super.info.id, t1, 1, 1)], ec().nodes), 
						e.pos
					)
				)
			)
		}
	maybeMap(fold(pattern.nodes, Some(Pair(makeTree(), 0)), \acc, n1 ->
		maybeBind(acc, \p ->
			switch (n1) {
				RuRuleNode(r1,__,__,__): {
					switch (e.nodes[p.second]) {
						RuRuleNode(r2,__,__,__): 
							if (r1 != r2) None() else Some(Pair(p.first, p.second + 1));
						RuVar(__,__): None();
					}
				}
				RuVar(__,t1): {
					n2 = e.nodes[p.second];
					switch (n2) {
						RuRuleNode(r2, t2,__, len):
							addVar(len + 1, t1, t2, n1, p, \-> RuExp(subrange(e.nodes, p.second, len + 1), e.pos));
						RuVar(__,t2):
							addVar(1, t1, t2, n1, p, \-> RuExp([n2], e.pos));
					}
				}
			}
		)), 
		\p -> RuSubst(mapTree(p.first, \e1 -> RuSubExpr(e1, ruExp2Vars(e1))))
	);
}


RuApplyStack(
	parent : Maybe<RuApplyStack>,
	len : int
);

ruApplyComputeLen(arity : int, stack_len : Pair<RuApplyStack, int>) -> Pair<RuApplyStack, int> {
	if (arity == 0) stack_len else {
		switch (stack_len.first.parent) {
			Some(p): 
				ruApplyComputeLen(
					arity - 1, 
					Pair(p, stack_len.first.len + stack_len.second)
				);
			None(): {
				ruCrash("empty stack pop at ruApplyComputeLen");
				stack_len;
			}
		}
	}
}

RuApplyAcc(
	nodes : [RuExpNode],
	stack : RuApplyStack
);

ruApplySubst(e : RuExp, s : RuSubst) -> RuExp {
	if (!ruSubstAffectsExp(e, s)) e else {
		ruDoApplySubst(e, s);
	}
}

ruApplySubstVars(e : RuSubExpr, s : RuSubst) -> RuSubExpr {
	if (!exists(set2array(e.vars), \v -> containsKeyTree(s.map, v))) e else {
		e1 = ruDoApplySubst(e.exp, s);
		RuSubExpr(e1, ruExp2Vars(e1));
	}
}

RuApplyAcc(
	nodes : List<[RuExpNode]>,
	stack : RuApplyStack
);

ruSubstAffectsExp(e : RuExp, s : RuSubst) -> bool {
	exists(e.nodes, \n -> 
		switch (n) { 
			RuRuleNode(__,__,__,__): false; 
			RuVar(__,__): containsKeyTree(s.map, n);
		}
	);
}

ruDoApplySubst(e : RuExp, s : RuSubst) -> RuExp {
	nodes_list = foldr(e.nodes, RuApplyAcc(makeList(), RuApplyStack(None(), 0)),
		\acc, n -> {
			switch (n) {
				RuRuleNode(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						Cons([RuRuleNode(r, t, a, st_len.second)], acc.nodes),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(__,__): {
					switch (lookupTree(s.map, n)) {
						Some(x):
							RuApplyAcc(
								Cons(x.exp.nodes, acc.nodes),
								RuApplyStack(Some(acc.stack), length(x.exp.nodes))
							);
						None():
							RuApplyAcc(
								Cons([n], acc.nodes),
								RuApplyStack(Some(acc.stack), 1)
							);
					}
				}
			}
		}
	).nodes;
	nodes_arr = list2array(nodes_list);
	applied_nodes = ruConcatAr(nodes_arr);
	RuExp(applied_nodes, e.pos);
}

ruReplaceVarByExp(e : RuSubExpr, v : RuVar, by : RuExp) -> RuSubExpr {
	nodes_list = foldr(e.exp.nodes, 
		RuApplyAcc(makeList(), RuApplyStack(None(), 0)), \acc, n -> {
			switch (n) {
				RuRuleNode(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						Cons([RuRuleNode(r, t, a, st_len.second)], acc.nodes),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(id,__): {
					if (id == v.id) {
						RuApplyAcc(
							Cons(by.nodes, acc.nodes),
							RuApplyStack(Some(acc.stack), length(by.nodes))
						);
					} else {
						RuApplyAcc(
							Cons([n], acc.nodes),
							RuApplyStack(Some(acc.stack), 1)
						);
					}
				}
			}
		}
	).nodes;
	nodes_arr = list2array(nodes_list);
	applied_nodes = ruConcatAr(nodes_arr);
	e1 = RuExp(applied_nodes, e.exp.pos);
	RuSubExpr(e1, ruExp2Vars(e1));
}

ruReplaceVarByExpVars(e : RuSubExpr, v : RuVar, by : RuSubExpr) -> RuSubExpr {
	nodes_list = foldr(e.exp.nodes, 
		RuApplyAcc(makeList(), RuApplyStack(None(), 0)), \acc, n -> {
			switch (n) {
				RuRuleNode(r, t, a, l): {
					st_len = ruApplyComputeLen(a, Pair(acc.stack, 0));
					RuApplyAcc(
						Cons([RuRuleNode(r, t, a, st_len.second)], acc.nodes),
						RuApplyStack(Some(st_len.first), st_len.second + 1)
					);
				}
				RuVar(id,__): {
					if (id == v.id) {
						RuApplyAcc(
							Cons(by.exp.nodes, acc.nodes),
							RuApplyStack(Some(acc.stack), length(by.exp.nodes))
						);
					} else {
						RuApplyAcc(
							Cons([n], acc.nodes),
							RuApplyStack(Some(acc.stack), 1)
						);
					}
				}
			}
		}
	).nodes;
	nodes_arr = list2array(nodes_list);
	applied_nodes = ruConcatAr(nodes_arr);
	e1 = RuExp(applied_nodes, e.exp.pos);
	RuSubExpr(e1, mergeSets(removeSet(e.vars, v), by.vars));
}


ruIsVarRenaming(s : RuSubst) -> bool {
	image_vars = buildSet(filtermap(getTreeValues(s.map), \x -> ruExp2Var(x.exp)));
	sizeTree(s.map) == sizeSet(image_vars);
}

ruReverseVarRenaming(s : RuSubst) -> RuSubst {
	RuSubst(foldTree(s.map, makeTree(), \v, e, acc -> {
		w = e.exp.nodes[0];
		switch (w) {
			RuVar(id,__): setTree(acc, w, RuSubExpr(RuExp([v], -1), makeSet1(w)));
			default: acc;
		}
	}));
}

ruMatchExpExactly(e : RuExp, pattern : RuExp) -> Maybe<Tree<RuVar, RuVar>> {
	if (length(e.nodes) != length(pattern.nodes)) None() else {
		foldi(e.nodes, Some(makeTree()), \i, acc, v1 ->
			maybeBind(acc, \s -> {
				switch (v1) {
					RuRuleNode(r1,__,__,__): {
						switch (pattern.nodes[i]) {
							RuRuleNode(r2,__,__,__): if (r1 != r2) None() else Some(s);
							RuVar(__,__): None();
						}
					}
					RuVar(__,__): {
						v2 = pattern.nodes[i];
						switch (v2) {
							RuRuleNode(__, __,__,__): None();
							RuVar(__,__):
								if (v1.type != v2.type) None() else {
									switch (lookupTree(s, v2)) {
										Some(w1): if (v1 == w1) Some(s) else None();
										None(): Some(setTree(s, v2, v1));
									}
								}
						}
					}
				}
			})
		)
	}
}

ruSubsAreEq(s1 : RuSubst, s2 : RuSubst) -> bool {
	if (sizeTree(s1.map) != sizeTree(s2.map)) false else {
		forall(tree2pairs(s1.map), \p ->
			switch (lookupTree(s2.map, p.first)) {
				Some(e2): p.second.exp.nodes == e2.exp.nodes;
				None(): false;
			}
		);
	}
}

ruSubsAreSim(s1 : RuSubst, s2 : RuSubst) -> Maybe<RuSubst> {
	if (sizeTree(s1.map) != sizeTree(s2.map)) None() else {
		theta = foldTree(s1.map, RuSubst(makeTree()), \v1, e1, acc ->
			switch (lookupTree(s2.map, v1)) {
				Some(__): acc;
				None(): {
					if (length(e1.exp.nodes) != 1) acc else {
						v2 = e1.exp.nodes[0];
						switch (v2) {
							RuVar(__,__): RuSubst(setTree(acc.map, v2, 
								RuSubExpr(RuExp([v1], -1), makeSet1(v1))
							));
							default: acc;
						}
					}
				}
			}
		);
		maybeBind(ruCompose(s1, theta), \s -> if (ruSubsAreEq(s2, s)) Some(theta) else None());
	}
}

ruSubComplexity(s : RuSubst) -> int {
	foldTree(s.map, 0, \v, e, acc -> acc + length(e.exp.nodes));
}

ruSubst2Renaming(s : RuSubst) -> Maybe<Tree<RuVar, RuVar>> {
	foldTree(s.map, Some(makeTree()), \v, e, acc -> 
		switch (acc) {
			Some(r): {
				switch (ruExp2Var(e.exp)) {
					Some(w): Some(setTree(r, v, w));
					None(): None();
				}
			}
			None(): None();
		}
	);
}

ruRenaming2Subst(r : Tree<RuVar, RuVar>) -> RuSubst {
	RuSubst(mapTree(r, \v -> 
		RuSubExpr(RuExp([v], -1), makeSet1(v))
	));
}

ruRenaming2s(r : Tree<RuVar, RuVar>) -> string {
	strGlue(map(tree2pairs(r), \p -> id2s(p.first.id) + " => " + id2s(p.second.id)), "\n");
}

ruApplyRenaming2Vars(r : Tree<RuVar, RuVar>, vars : Tree<int, RuVar>) -> Tree<int, RuVar> {
	foldTree(vars, makeTree(), \__, v, acc ->
		eitherMap(
			lookupTree(r, v),
			\w -> setTree(acc, w.id, w),
			setTree(acc, v.id, v)
		)
	);
}

ruApplyRenaming2Disjs(r : Tree<RuVar, RuVar>, disjs : Set<RuDisj>) -> Set<RuDisj> {
	mapSet(disjs, \disj ->
		RuDisj(
			lookupTreeDef(r, disj.v1, disj.v1),
			lookupTreeDef(r, disj.v2, disj.v2)
		)
	);
}

ruApplyRenaming2Term(r : Tree<RuVar, RuVar>, term : RuTerm) -> RuTerm {
	RuTerm(term with
		nodes = map(term.nodes, \n -> 
			switch (n) {
				RuVar(__,__): lookupTreeDef(r, n, n);
				default: n;
			}
		)
	);
}

ruApplyRenaming2Exp(r : Tree<RuVar, RuVar>, expr : RuExp) -> RuExp {
	RuExp(expr with 
		nodes = map(expr.nodes, \n -> 
			switch (n) {
				RuVar(__,__): lookupTreeDef(r, n, n);
				default: n;
			}
		)
	);
}

ruApplyRenaming2Proof(r : Tree<RuVar, RuVar>, proof : RuProof) -> RuProof {
	RuProof(proof with
		vars = RuVarsDisjs(proof.vars with
			vars = ruApplyRenaming2Vars(r, proof.vars.vars),
			disjs = ruApplyRenaming2Disjs(r, proof.vars.disjs),
		),
		steps = map(proof.steps, \s -> RuStep(s with expr = ruApplyRenaming2Exp(r, s.expr)))
	);
}

ruApplyRenaming2Theorem(r : Tree<RuVar, RuVar>, th : RuTheorem) -> RuTheorem {
	RuTheorem(th with
		stat = ruApplyRenaming2Statement(r, th.stat),
		meta = mapSet(th.meta, \x -> foldTree(r, x, \v, w, acc -> if (v.id == x) w.id else acc)),
		proof = ruApplyRenaming2Proof(r, th.proof)
	);
}

ruApplyRenaming2Statement(r : Tree<RuVar, RuVar>, stat : RuStatement) -> RuStatement {
	RuStatement(stat with
		vars = RuVarsDisjs(stat.vars with
			vars = ruApplyRenaming2Vars(r, stat.vars.vars),
			disjs = ruApplyRenaming2Disjs(r, stat.vars.disjs),
		),
		hyps = map(stat.hyps, \h -> RuHyp(h with expr = ruApplyRenaming2Exp(r, h.expr))),
		prop = ruApplyRenaming2Exp(r, stat.prop)
	);
}

ruApplyRenaming2Decl(r : Tree<RuVar, RuVar>, decl : RuDecl) -> RuDecl	{
	switch (decl) {
		RuConst(__,__,__): decl;
		RuType(__,__): decl;
		RuRule(__,vars,term):
			RuRule(decl with
				vars = ruApplyRenaming2Vars(r, vars),
				term = ruApplyRenaming2Term(r, term)
			);
		RuAxiom(__, stat):
		    RuAxiom(decl with
				stat = ruApplyRenaming2Statement(r, stat)
			);
		RuDef(__, stat, defm, defs): 
			RuDef(decl with
				stat = ruApplyRenaming2Statement(r, stat),
				defm = ruApplyRenaming2Exp(r, defm),
				defs = ruApplyRenaming2Exp(r, defs)
			);
		RuTheorem(__, stat, meta, proof):
			ruApplyRenaming2Theorem(r, decl);
	}
}

ruTransformSubst(s: RuSubst, f : (RuExp) -> RuExp) -> RuSubst {
	RuSubst(mapTree(s.map, \e -> {
		fe = f(e.exp);
		RuSubExpr(fe, ruExp2Vars(fe))
	}));
}

ruSubstLevel(s: RuSubst) -> int {
	foldTree(s.map, 0, \v, e, acc ->
		max(acc, if (ruIsVar(e.exp)) 0 else length(e.exp.nodes))
	);
}

ruSubstLen(s: RuSubst) -> int {
	foldTree(s.map, 0, \v, e, acc ->
		acc + length(e.exp.nodes) - 1
	);
}

ruReduceSubst(s: RuSubst) -> RuSubst {
	RuSubst(filterTree(s.map, \v, e -> length(e.exp.nodes) > 1 || e.exp.nodes[0] != v));
}

ruMakeFresherSubst(vars : [RuVar], fresher : (RuVar) -> RuVar) -> RuSubst {
	RuSubst(fold(vars, makeTree(), \acc, v -> 
		setTree(acc, v, RuSubExpr(RuExp([fresher(v)], -1), makeSet1(v)))
	));
}