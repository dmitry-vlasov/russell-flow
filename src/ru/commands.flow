import ru/parse/commands;
import ru/prover/commands;
import ru/refactor/commands;
import ru/verify;
import ru/info;
import ru/to_mm;

export {
	ruCommands() -> [RuComm];
}

ruCommands() -> [RuComm] {
	concatA([
		[
			RuComm(
				"verify", "", "verify entity",
				[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
				ruCommVerify
			),
			ruApplyToProjectRoots(RuComm(
				"ru-to-mm", "translate", "translate Russell to Metamath", 
				[RuCommArg("file", false, "input file", "")],
				\task, env -> RuEnv(env with mmMath = ru2mm(env.ruMath, env.conf))
			)),
			RuComm(
				"actions", "", "available actions at the given position",
				[
					RuCommArg("file", false, "input file", ""), 
					RuCommArg("line", false, "clear", ""), 
					RuCommArg("col", false, "clear", "")
				], 
				ruCommActions
			),
			/*RuComm(
				"generalize-write", "", "combination of generalization and write",
				[
					RuCommArg("file", false, "input file", ""), 
					RuCommArg("line", false, "clear", ""), 
					RuCommArg("col", false, "clear", "")
				], 
				ruCommActions
			),*/
		],
		ruIoCommands(),
		ruRefactorCommands(),
		ruProverCommands(),
		ruInfoCommands()
    ]);
}

ruCommActions(task : RuTask, env : RuEnv) -> RuEnv {
	actions = ["verify", "prove", "reprove", "generalize"];
	file = lookupTreeDef(task.args, "file", "");
	line = s2i(lookupTreeDef(task.args, "line", "-1"));
	col = s2i(lookupTreeDef(task.args, "col", "-1"));
	name = ruNameByLineCol(line, col, getFileContent(file));
	json = if (name == "") JsonArray([]) else {
		JsonArray(map(actions, \action -> 
			lspCodeAction2Json(LspCodeAction(
				action + " " + name, action, [], false, None(),
				Some(LspCommand(
					action + " " + name,
					"command",
					map(["file=" + file, "read", ";", action, "target=" + name], 
						\arg -> JsonString(arg)
					)
				))
			))
		));
	}
	env.conf.onMessage(json2string(json));
	env;
}
