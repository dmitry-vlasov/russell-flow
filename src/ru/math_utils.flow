import base/stats;
import ru/math;
import ru/cache;

export {
	ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace;
	ruFindSourceId(name : string, math : RuMath) -> int;
	ruFindSource(name : string, math : RuMath) -> Maybe<RuSource>;
	ruMathAxioms(math : RuMath) -> Tree<string, RuAxiom>;
	ruMathTheorems(math : RuMath) -> Tree<string, RuTheorem>;
	ruMathProofs(math : RuMath) -> Tree<string, RuProof>;
	ruMathDefs(math : RuMath) -> Tree<string, RuDef>;
	ruMathAxiomsNum(math : RuMath) -> int;
	ruMathTheoremsNum(math : RuMath) -> int;
	ruMathDefsNum(math : RuMath) -> int;
	ruMathStepsNum(math : RuMath) -> int;
	ruMathAllDecls(math : RuMath) -> Tree<string, RuDecl>;
	ruMathSrcDecls(math : RuMath) -> Tree<string, RuDecl>;
	ruMathSupers(math : RuMath) -> Tree<string, RuRule>;
	ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule>;

	ruMathStats(math : RuMath) -> string;
	ruMathInfo(math : RuMath) -> string;

	ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath;
	ruRemoveSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruRemoveDecl(decl : RuDecl, m : RuMath, conf : RuConf) -> RuMath;
	ruAddDecl(decl : RuDecl, m : RuMath, conf : RuConf) -> RuMath;
	ruFindDecl(name : string, m : RuMath, conf : RuConf) -> Maybe<RuDecl>;
	ruAddImportToSource(src : RuSource, id : int, math : RuMath, conf : RuConf) -> RuMath;
	ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruMakeMathFromSource(src : RuSource, conf : RuConf) -> RuMath;
	ruMakeMathFromSources(srcs : Tree<int, RuSource>, conf : RuConf) -> RuMath;
	ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath;
	ruMath2SingleSource(math : RuMath, file : string, conf : RuConf) -> RuSource;

	ruNameAllImported(name : string, math : RuMath) -> Set<RuSource>;
	ruSourceAllImported(id : int, math : RuMath) -> Set<RuSource>;
	ruMathAllImported(math : RuMath, conf : RuConf) -> Tree<int, Set<int>>;

	ruOrderSources(math : RuMath) -> [RuSource];
	ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;
	ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;

	ruReplaceDecl(d : RuDecl, math : RuMath, conf : RuConf) -> RuMath;

	ruSourceTheorems(src : RuSource) -> [RuTheorem];
	ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem;

	ruMathAssertionDepths(math : RuMath) -> Tree<string, int>;
	ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>>;
	ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<string, Set<string>>;
	ruMathAssertionProofSteps(math : RuMath) -> Tree<string, Tree<string, [int]>>;
	ruDoMathAssertionDependencies(name : string, acc : Tree<string, Set<string>>, math : RuMath, conf : RuConf) -> Tree<string, Set<string>>;

	ruAssertionDepth(ass : string, math : RuMath) -> int;
	ruAssertionAxioms(ass : string, math : RuMath) -> Set<string>;
	ruAssertionDependencies(ass : string, math : RuMath, conf : RuConf) -> Set<string>;
	ruAssertionDependendsOn(ass : string,  dep : string, math : RuMath, conf : RuConf) -> bool;
	ruAssertionCyclicDependency(ass : string,  math : RuMath, conf : RuConf) -> bool;
	ruAssertionsProofSteps(as : Set<string>, math : RuMath) -> Tree<string, Tree<string, [int]>>;

	ruSourceDeclNames(src : int, acc : Set<string>, math : RuMath, conf : RuConf) -> Set<string>;

	// Find a source, which imports all other sources
	ruProjectRootSource(math : RuMath) -> Maybe<RuSource>;

	// less preceeds greater in module system (via import or by position in a common module)
	ruDeclPreceeds(less : RuDecl, greater : RuDecl, imported_map : Tree<int, Set<int>>) -> bool;

	ruTheoremName2ReferringTheorems(math : RuMath) -> Tree<string, Set<string>>;

	ruAddType(type : RuType, m : RuMath, conf : RuConf) -> RuMath;
}

ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, ruFindSourceId(name, math), ruNoSource).info.module, pos
	);
}

ruFindSourceId(name : string, math : RuMath) -> int {
	switch (lookupTree(math.assertions, name)) {
		Some(a): a.descr.src;
		None(): {
			switch (lookupTree(math.consts, name)) {
				Some(c): c.descr.src;
				None(): {
					switch (lookupTree(math.types, name)) {
						Some(t): t.descr.src;
						None(): {
							switch (lookupTree(math.rules, name)) {
								Some(r): r.descr.src;
								None(): -1;
							}
						}
					}
				}
			}
		}
	}
}

ruFindSource(name : string, math : RuMath) -> Maybe<RuSource> {
	lookupTree(math.sources, ruFindSourceId(name, math));
}

ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuAxiom(__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuTheorem(__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathProofs(math : RuMath) ->Tree<string, RuProof> {
	mapTree(ruMathTheorems(math), \th -> th.proof);
}

ruMathDefs(math : RuMath) ->Tree<string, RuDef> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuDef(__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathAxiomsNum(math : RuMath) -> int {
	foldTree(math.assertions, 0, \__,a, acc -> 
		if (ruDeclIsAxiom(a)) acc + 1 else acc
	);
}

ruMathTheoremsNum(math : RuMath) -> int {
	foldTree(math.assertions, 0, \__,a, acc -> 
		if (ruDeclIsTheorem(a)) acc + 1 else acc
	);
}

ruMathDefsNum(math : RuMath) -> int {
	foldTree(math.assertions, 0, \__,a, acc -> 
		if (ruDeclIsDef(a)) acc + 1 else acc
	);
}

ruMathStepsNum(math : RuMath) -> int {
	foldTree(ruMathProofs(math), 0, \__, proof, acc -> 
		acc + length(proof.steps)
	);
}

ruMathAllDecls(math : RuMath) ->Tree<string, RuDecl> {
	foldTree(math.assertions, 
		foldTree(math.rules, 
			foldTree(math.types, math.consts,
				\name, type, acc -> setTree(acc, name, type)
			),
			\name, rule, acc -> setTree(acc, name, rule)
		),
		\name, ass, acc -> setTree(acc, name, ass)
	);
}

ruMathSrcDecls(math : RuMath) ->Tree<string, RuDecl> {
	foldTree(math.sources, makeTree(), \__, src, acc -> 
		fold(src.decls, acc, \ac, decl -> 
			setTree(ac, ruDeclName(decl), decl)
		)
	);
}

ruMathSupers(math : RuMath) -> Tree<string, RuRule> {
	foldTree(math.types, makeTree(),
		\name, type, acc -> 
			fold(type.supers, makeTree(), \ac, super ->
				switch (lookupTree(math.rules, ruSuperTypeName(type.descr.name, super))) {
					Some(rule): setTree(ac, rule.descr.name, rule);
					None(): ac;
				}
			)
	);
}

ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule> {
	lookupTree(math.rules, ruSuperTypeName(super, infer));
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"sources:    " + i2s(sizeTree(math.sources)),
		"consts:     " + i2s(sizeTree(math.consts)),
		"types:      " + i2s(sizeTree(math.types)),
		"rules:      " + i2s(sizeTree(math.rules)),
		"assertions: " + i2s(sizeTree(math.assertions)),
		"  axioms:   " + i2s(ruMathAxiomsNum(math)),
		"  theorems: " + i2s(ruMathTheoremsNum(math)),
		"  defs:     " + i2s(ruMathDefsNum(math)),
		"  steps:    " + i2s(ruMathStepsNum(math))
	], "\n")
}

ruMathInfo(math : RuMath) -> string {
	strGlue([
		"sources:    " + strGlue(map(getTreeKeys(math.sources), id2s), ", "),
		"consts:     " + strGlue(getTreeKeys(math.consts), ", "),
		"types:      " + strGlue(getTreeKeys(math.types), ", "),
		"rules:      " + strGlue(getTreeKeys(math.rules), ", "),
		"assertions: " + strGlue(getTreeKeys(math.assertions), ", "),
	], "\n")
}

ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath {
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \id, s1, s2 -> { conf.onError("duplicate source: " + id2s(id), []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \name, c1, c2 -> { conf.onError("duplicate constant: " + name, []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \name, t1, t2 -> { conf.onError("duplicate type: " + name, []); t1 }),
		mergeTreeCustom(m1.rules, m2.rules, \name, r1, r2 -> { conf.onError("duplicate rule: " + name, []); r1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \name, a1, a2 -> { conf.onError("duplicate assertion: " + name, []); quit(0); a1 })
	);
}

ruRemoveSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	if (!containsKeyTree(m.sources, src.info.id)) m else {
		fold(src.decls, 
			RuMath(m with sources = removeFromTree(m.sources, src.info.id)), 
			\acc, decl -> {
				switch (decl) {
					RuConst(descr,__,__):
						RuMath(acc with consts = removeFromTree(acc.consts, descr.name));
					RuType(descr,__,__):
						RuMath(acc with types = removeFromTree(acc.types, descr.name));
					RuRule(descr, __,__):
						RuMath(acc with rules = removeFromTree(acc.rules, descr.name));
					RuAxiom(descr,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.name));
					RuTheorem(descr,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.name));
					RuDef(descr,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.name));
				}
			}
		);
	}
}

ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	fold(src.decls, 
		RuMath(m with sources = setTree(m.sources, src.info.id, src)), 
		\acc, decl -> {
			switch (decl) {
				RuConst(descr,__,__):
					RuMath(acc with consts = setTree(acc.consts, descr.name, decl));
				RuType(descr,__,__):
					RuMath(acc with types = setTree(acc.types, descr.name, decl));
				RuRule(descr, __,__):
					RuMath(acc with rules = setTree(acc.rules, descr.name, decl));
				RuAxiom(descr,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuTheorem(descr,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuDef(descr,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
			}
		}
	);
}

ruRemoveDecl(decl : RuDecl, m : RuMath, conf : RuConf) -> RuMath {
	eitherMap(
		lookupTree(m.sources, decl.descr.src), 
		\src -> {
			name = ruDeclName(decl);
			m1 = switch (decl) {
				RuConst(__,__,__):
					RuMath(m with consts = removeFromTree(m.consts, name));
				RuType(__,__,__):
					RuMath(m with types = removeFromTree(m.types, name));
				RuRule(__,__,__):
					RuMath(m with rules = removeFromTree(m.rules, name));
				RuAxiom(__,__):
					RuMath(m with assertions = removeFromTree(m.assertions, name));
				RuDef(__,__,__,__):
					RuMath(m with assertions = removeFromTree(m.assertions, name));
				RuTheorem(__,__,__,__):
					RuMath(m with assertions = removeFromTree(m.assertions, name));
			}
			removed_decls = removeIndex(src.decls, ruIndexOfDecl(name, src));
			RuMath(m1 with
				sources = setTree(m1.sources, decl.descr.src, RuSource(src with decls = removed_decls));
			);
		},
		m
	);
}

ruAddImportToSource(src : RuSource, id : int, math : RuMath, conf : RuConf) -> RuMath {
	if (exists(src.imports, \imp -> imp.id == id)) math else {
		RuMath(math with 
			sources = setTree(math.sources, src.info.id, RuSource(src with
				imports = concat(src.imports, [RuImport(id, -1)])
			))
		);
	}
}

ruMakeMathFromSource(src : RuSource, conf : RuConf) -> RuMath {
	fold(src.decls, 
		RuMath(ruEmptyMath with sources = makeTree1(src.info.id, src)), 
		\acc, decl -> {
			switch (decl) {
				RuConst(descr,__,__):
					RuMath(acc with consts = setTree(acc.consts, descr.name, decl));
				RuType(descr,__,__): 
					ruAddType(decl, acc, conf);
				RuRule(descr,__,__):
					RuMath(acc with rules = setTree(acc.rules, descr.name, decl));
				RuAxiom(descr,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuTheorem(descr,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuDef(descr,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
			}
		}
	);
}

ruMakeMathFromSources(srcs : Tree<int, RuSource>, conf : RuConf) -> RuMath {
	stuff = foldTree(srcs, ruEmptyMath, \src_name, src, acc -> 
		ruMergeMath(acc, ruMakeMathFromSource(src, conf), conf)
	);
	RuMath(stuff with sources = srcs);
}

ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath {
	module = src.info.module;
	RuMath(m with 
		assertions = fold(src.decls, m.assertions,
			\acc, decl -> {
				switch (decl) {
					RuAxiom(descr,__):         setTree(acc, descr.name, decl);
					RuTheorem(descr,__,__,__): setTree(acc, descr.name, decl);
					RuDef(descr,__,__,__):     setTree(acc, descr.name, decl);
					default: acc;
				}
			}
		)
	);
}

ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	ruAddSource(src, ruRemoveSource(src, m, conf), conf);
}

ruMath2SingleSource(math : RuMath, path : string, conf : RuConf) -> RuSource {
	module = ruTrimPath(path, conf, ".ru");
	created = timestamp();
	RuSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			ruMathCollectSource(src, math, acc)
		).first,
		foldTree(math.sources, [], \__,src, acc ->
			concat(acc, src.comments)
		),
		ruNewFileInfo(module, conf, ".ru")
	);
}

ruMathCollectSource(src : RuSource, math : RuMath, acc : Pair<[RuDecl], Set<string>>) -> Pair<[RuDecl], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.id)) {
					Some(inc_src): ruMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

ruNameAllImported(name : string, math : RuMath) -> Set<RuSource> {
	ruSourceAllImported(ruFindSourceId(name, math), math);
}

ruSourceAllImported(id : int, math : RuMath) -> Set<RuSource> {
	switch (lookupTree(math.sources, id)) {
		Some(src): ruDoSourceAllImported(src, math, makeSet());
		None(): makeSet();
	}
}

ruDoSourceAllImported(src : RuSource, math : RuMath, acc : Set<RuSource>) -> Set<RuSource> {
	if (containsSet(acc, src)) acc else {
		fold(src.imports, insertSet(acc, src), 
			\ac, imp -> ruDoSourceAllImported(lookupTreeDef(math.sources, imp.id, ruNoSource), math, ac)
		);
	}
}

ruMathAllImported(math : RuMath, conf : RuConf) -> Tree<int, Set<int>> {
	fold(ruOrderSources(math), makeTree(), \acc, src ->
		setTree(acc, src.info.id, 
			fold(src.imports, makeSet(), \ac, imp -> {
				if (!containsKeyTree(acc, imp.id)) {
					println("MISSING IMPORT!!! " + id2s(imp.id) + " in module " + id2s(src.info.id));
					quit(0);
				}
				mergeSets(ac, insertSet(lookupTreeDef(acc, imp.id, makeSet()), imp.id))
			})
		)
	);
}

ruOrderSources(math : RuMath) -> [RuSource] {
	ruDoOrderSources(getTreeValues(math.sources), [], makeSet());
}

ruDoOrderSources(srcs : [RuSource], acc : [RuSource], visited: Set<int>) -> [RuSource] {
	new_level = filter(srcs, \src -> forall(src.imports, \imp -> containsSet(visited, imp.id)));
	level_names = buildSet(map(new_level, \src -> src.info.id));
	if (new_level == []) {
		if (length(srcs) == 0) acc else {
			println("Cycilc imports detected:\n" + strIndent(strGlue(map(srcs, \src -> id2s(src.info.id)), "\n")));
			[]
		};
	} else {
		new_srcs = filter(srcs, \src -> !containsSet(level_names, src.info.id));
		ruDoOrderSources(new_srcs, concat(acc, new_level), mergeSets(visited, level_names));
	}
}

ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruFindSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(name, src), a)
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = setTree(math.assertions, name, a),
				sources = setTree(math.sources, src.info.id, updated_src)
			);
		}
		None(): math;
	}
}

ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	updated_src = RuSource(src with decls = insertArray(src.decls, i, a));
	//ruToCache(updated_src, conf);
	RuMath(math with 
		assertions = setTree(math.assertions, name, a),
		sources = setTree(math.sources, src.info.id, updated_src)
	);
}

ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruFindSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				removeIndex(src.decls, ruIndexOfDecl(name, src))
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = removeFromTree(math.assertions, name),
				sources = setTree(math.sources, src.info.id, updated_src)
			);
		}
		None(): math;
	}
}

ruReplaceDecl(d : RuDecl, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(d);
	switch (ruFindSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(name, src), d)
			);
			math1 = switch (d) {
				RuConst(__,__,__): 
					RuMath(math with consts = setTree(math.consts, name, d));
				RuType(__,__,__):
					RuMath(math with types = setTree(math.types, name, d));
				RuRule(__,__,__):
					RuMath(math with rules = setTree(math.rules, name, d));
				RuAssertion(): 
					RuMath(math with assertions = setTree(math.assertions, name, d));
			}
			RuMath(math1 with 
				sources = setTree(math.sources, src.info.id, updated_src)
			);
		}
		None(): math;
	}
}

ruAddDecl(decl : RuDecl, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(decl);
	switch (decl) {
		RuConst(__,__,__): 
			RuMath(math with consts = setTree(math.consts, name, decl));
		RuType(__,__,__):
			ruAddType(decl, math, conf);
		RuRule(__,__,__):
			RuMath(math with rules = setTree(math.rules, name, decl));
		RuAssertion(): 
			RuMath(math with assertions = setTree(math.assertions, name, decl));
	}
}

ruFindDecl(name : string, math : RuMath, conf : RuConf) -> Maybe<RuDecl> {
	switch (lookupTree(math.assertions, name)) {
		Some(decl): Some(decl);
		None(): {
			switch (lookupTree(math.consts, name)) {
				Some(decl): Some(decl);
				None(): {
					switch (lookupTree(math.rules, name)) {
						Some(decl): Some(decl);
						None(): lookupTree(math.types, name);
					}
				}
			}
		}
	}
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem {
	switch (lookupTree(math.assertions, name)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(__,__,__,__): ass;
				default: {
					conf.onError("theorem " + name + " is not found", []);
					ruNoTheorem;
				}
			}
		}
		None(): {
			conf.onError("theorem " + name + " is not found", []);
			ruNoTheorem;
		}
	}
}

ruMathAssertionDepths(math : RuMath) -> Tree<string, int> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDepths(math, name, acc));
}

ruDoMathAssertionDepths(math : RuMath, as_name : string, acc : Tree<string, int>) -> Tree<string, int> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(descr,__,__,proof): {
					switch (lookupTree(acc, descr.name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDepths(math, step.assertion, ac));
							max_depth = fold(proof.steps, 0, \ac, step -> max(ac, lookupTreeDef(acc1, step.assertion, 0)));
							setTree(acc1, descr.name, max_depth + 1);
						}
					}
				}
				RuAxiom(descr,__):     setTree(acc, descr.name, 0);
				RuDef(descr,__,__,__): setTree(acc, descr.name, 0);
			}
		}
		None(): acc;
	}
}

ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionAxioms(math, name, acc));
}

ruDoMathAssertionAxioms(math : RuMath, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(descr,__,__,proof): {
					switch (lookupTree(acc, descr.name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionAxioms(math, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, descr.name, axioms);
						}
					}
				}
				RuAxiom(descr,__):     setTree(acc, descr.name, makeSet1(descr.name));
				RuDef(descr,__,__,__): setTree(acc, descr.name, makeSet());
			}
		}
		None(): acc;
	}
}

ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDependencies(name, acc, math, conf));
}

ruDoMathAssertionDependencies(as_name : string, acc : Tree<string, Set<string>>, math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	if(containsKeyTree(acc, as_name)) {
		acc; 
	} else { 
		switch (lookupTree(math.assertions, as_name)) {
			Some(a): {
				switch (a) {
					RuTheorem(descr,__,__,proof): {
						switch (lookupTree(acc, descr.name)) {
							Some(v): acc;
							None(): {
								acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDependencies(step.assertion, ac, math, conf));
								deps = fold(proof.steps, 
									buildSet(map(proof.steps, \step -> step.assertion)), 
									\ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet()))
								);
								setTree(acc1, descr.name, deps);
							}
						}
					}
					RuAxiom(descr,__):     setTree(acc, descr.name, makeSet());
					RuDef(descr,__,__,__): setTree(acc, descr.name, makeSet());
				}
			}
			None(): acc;
		}
	}
}

ruMathAssertionProofSteps(math : RuMath) -> Tree<string, Tree<string, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(descr,__,__,proof):
					foldi(proof.steps, ac, \i, a, step -> {
						tr = lookupTreeDef(a, step.assertion, makeTree());
						setTree(a, step.assertion,
							setTree(tr, descr.name, 
								concat(lookupTreeDef(tr, descr.name, []), [i])	
							)
						);
					});
				default: ac;
			}
		)
	);	
}

ruAssertionDepth(ass : string, math : RuMath) -> int {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,proof): {
					1 + fold(proof.steps, 0, \acc, step -> max(acc, ruAssertionDepth(step.assertion, math)));
				}
				RuAxiom(__,__):              0;
				RuDef(__,__,__,__): 0;
			}
		}
		None(): -1;
	}
}

ruAssertionAxioms(ass : string, math : RuMath) -> Set<string> {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,proof): {
					fold(proof.steps, makeSet(), \acc, step -> mergeSets(acc, ruAssertionAxioms(step.assertion, math)));
				}
				RuAxiom(descr,__):              makeSet1(descr.name);
				RuDef(descr,__,__,__): makeSet();
			}
		}
		None(): makeSet();
	}
}

ruAssertionDependencies(ass : string, math : RuMath, conf : RuConf) -> Set<string> {
	lookupTreeDef(ruDoMathAssertionDependencies(ass, makeTree(), math, conf), ass, makeSet());
}

ruAssertionDependendsOn(ass : string, dep : string, math : RuMath, conf : RuConf) -> bool {
	containsSet(ruAssertionDependencies(ass, math, conf), dep);
}

ruAssertionCyclicDependency(ass : string, math : RuMath, conf : RuConf) -> bool {
	ruAssertionDependendsOn(ass, ass, math, conf);
}

ruAssertionsProofSteps(as : Set<string>, math : RuMath) -> Tree<string, Tree<string, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(descr,__,__,proof):
					foldi(proof.steps, ac, \i, a, step ->
						if (!containsSet(as, step.assertion)) a else {
							tr = lookupTreeDef(a, step.assertion, makeTree());
							setTree(a, step.assertion,
								setTree(tr, descr.name, 
									concat(lookupTreeDef(tr, descr.name, []), [i])	
								)
							);
						}
					);
				default: ac;
			}
		)
	);	
}

ruSourceDeclNames(src : int, acc : Set<string>, math : RuMath, conf : RuConf) -> Set<string> {
	ruDoSourceDeclNames(src, Pair(acc, makeSet()), math, conf).first;
}

ruDoSourceDeclNames(src : int, acc : Pair<Set<string>, Set<int>>, math : RuMath, conf : RuConf) -> Pair<Set<string>, Set<int>> {
	if (containsSet(acc.second, src)) acc else {
		eitherMap(lookupTree(math.sources, src), 
			\s -> fold(s.imports, 
				fold(s.decls, 
					Pair(acc.first, insertSet(acc.second, src)), 
					\ac, decl -> Pair(insertSet(ac.first, ruDeclName(decl)), ac.second)
				),
				\ac, imp -> ruDoSourceDeclNames(imp.id, ac, math, conf)
			),
			acc
		);
	}
}

ruProjectRootSource(math : RuMath) -> Maybe<RuSource> {
	all_sources = buildSet(getTreeKeys(math.sources));
	only_imports = filtermap(getTreeValues(math.sources), \src -> 
		if (src.decls != [] || src.imports == []) None() else {
			Some(Pair(src, buildSet(map(src.imports, \imp -> imp.id))));
		}
	);
	maybeMap(
		find(only_imports, \pair ->
			equalSet(pair.second, removeSet(all_sources, pair.first.info.id))
		),
		\pair -> pair.first
	);
}

ruDeclPreceeds(less : RuDecl, greater : RuDecl, imported_map : Tree<int, Set<int>>) -> bool {
	less_d = ruDeclDescr(less);
	greater_d = ruDeclDescr(greater);
	if (less_d.src == greater_d.src) {
		ruDeclPos(less) < ruDeclPos(greater);
	} else {
		containsSet(lookupTreeDef(imported_map, greater_d.src, makeSet()), less_d.src);
	}
}

ruTheoremName2ReferringTheorems(math : RuMath) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, ass, acc ->
		switch (ass) {
			RuTheorem(descr,__,__,proof): 
				fold(proof.steps, acc, \ac, step ->
					setTree(ac, step.assertion, 
						insertSet(lookupTreeDef(ac, step.assertion, makeSet()), descr.name)
					)
				);
			default: acc;
		}
	);
}

ruAddType(type : RuType, m : RuMath, conf : RuConf) -> RuMath {
	RuMath(m with 
		types = setTree(m.types, type.descr.name, type),
		rules = fold(type.supers, m.rules, \a, super ->
			setTree(a,
				ruSuperTypeName(super, type.descr.name), 
				ruMakeSuperRule(super, type.descr.name, type.descr.src, type.descr.pos)
			)
		)
	);
}
