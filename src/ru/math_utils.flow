import base/stats;
import ru/math;
import ru/cache;
import script/value;

export {
	ruMakePlace(id : int, pos : int, math : RuMath) -> RuPlace;
	ruFindSourceId(id : int, math : RuMath) -> int;
	ruFindSource(id : int, math : RuMath) -> Maybe<RuSource>;
	ruMathAxioms(math : RuMath) -> Tree<int, RuAxiom>;
	ruMathTheorems(math : RuMath) -> Tree<int, RuTheorem>;
	ruMathProofs(math : RuMath) -> Tree<int, RuProof>;
	ruMathDefs(math : RuMath) -> Tree<int, RuDef>;
	ruMathAxiomsNum(math : RuMath) -> int;
	ruMathTheoremsNum(math : RuMath) -> int;
	ruMathDefsNum(math : RuMath) -> int;
	ruMathStepsNum(math : RuMath) -> int;
	ruMathAllDecls(math : RuMath) -> Tree<int, RuDecl>;
	ruMathSrcDecls(math : RuMath) -> Tree<int, RuDecl>;
	ruSuperRule(infer : int, super : int, math : RuMath, conf : RuConf) -> Maybe<RuRule>;

	ruMathStats(math : RuMath) -> string;
	ruMathStats1(math : RuMath) -> ValMap;

	ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath;
	ruRemoveSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruRemoveDecl(decl : RuDecl, m : RuMath, conf : RuConf) -> RuMath;
	ruAddDecl(decl : RuDecl, m : RuMath, conf : RuConf) -> RuMath;
	ruFindDecl(id : int, m : RuMath, conf : RuConf) -> Maybe<RuDecl>;
	ruAddImportToSource(src : RuSource, id : int, math : RuMath, conf : RuConf) -> RuMath;
	ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruMakeMathFromSource(src : RuSource, conf : RuConf) -> RuMath;
	ruMakeMathFromSources(srcs : Tree<int, RuSource>, conf : RuConf) -> RuMath;
	ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath;
	ruSources2SingleSource(sources : Tree<int, RuSource>, path : string, conf : RuConf) -> RuSource;

	ruNameAllImported(id : int, math : RuMath) -> Set<RuSource>;
	ruSourceAllImported(id : int, math : RuMath) -> Set<RuSource>;
	ruMathAllImported(math : RuMath, conf : RuConf) -> Tree<int, Set<int>>;

	ruOrderSources(sources : Tree<int, RuSource>) -> [RuSource];
	ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;
	ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;

	ruReplaceDecl(d : RuDecl, math : RuMath, conf : RuConf) -> RuMath;

	ruSourceTheorems(src : RuSource) -> [RuTheorem];
	ruTheorem(id : int, math : RuMath, conf : RuConf) -> RuTheorem;

	ruMathAssertionDepths(math : RuMath) -> Tree<int, int>;
	ruMathAssertionAxioms(math : RuMath) -> Tree<int, Set<int>>;
	ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<int, Set<int>>;
	ruMathAssertionProofSteps(math : RuMath) -> Tree<int, Tree<int, [int]>>;
	ruDoMathAssertionDependencies(id : int, acc : Tree<int, Set<int>>, math : RuMath, conf : RuConf) -> Tree<int, Set<int>>;

	ruAssertionDepth(ass : int, math : RuMath) -> int;
	ruAssertionAxioms(ass : int, math : RuMath) -> Set<int>;
	ruAssertionDependencies(ass : int, math : RuMath, conf : RuConf) -> Set<int>;
	ruAssertionDependendsOn(ass : int,  dep : int, math : RuMath, conf : RuConf) -> bool;
	ruAssertionCyclicDependency(ass : int,  math : RuMath, conf : RuConf) -> bool;
	ruAssertionsProofSteps(as : Set<int>, math : RuMath) -> Tree<int, Tree<int, [int]>>;

	ruSourceDeclNames(src : int, acc : Set<int>, math : RuMath, conf : RuConf) -> Set<int>;

	// Find a source, which imports all other sources
	ruProjectRootSource(math : RuMath) -> Maybe<RuSource>;

	// less preceeds greater in module system (via import or by position in a common module)
	ruDeclPreceeds(less : RuDecl, greater : RuDecl, imported_map : Tree<int, Set<int>>) -> bool;

	ruTheoremName2ReferringTheorems(math : RuMath) -> Tree<int, Set<int>>;

	ruAddType(type : RuType, m : RuMath, conf : RuConf) -> RuMath;
}

ruMakePlace(id : int, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, ruFindSourceId(id, math), ruNoSource).info.module, pos
	);
}

ruFindSourceId(id : int, math : RuMath) -> int {
	switch (lookupTree(math.assertions, id)) {
		Some(a): a.descr.src;
		None(): {
			switch (lookupTree(math.consts, id)) {
				Some(c): c.descr.src;
				None(): {
					switch (lookupTree(math.types, id)) {
						Some(t): t.descr.src;
						None(): {
							switch (lookupTree(math.rules, id)) {
								Some(r): r.descr.src;
								None(): -1;
							}
						}
					}
				}
			}
		}
	}
}

ruFindSource(id : int, math : RuMath) -> Maybe<RuSource> {
	lookupTree(math.sources, ruFindSourceId(id, math));
}

ruMathAxioms(math : RuMath) ->Tree<int, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\id, ass, acc -> {
			switch (ass) { 
				RuAxiom(__,__): setTree(acc, id, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathTheorems(math : RuMath) ->Tree<int, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\id, ass, acc -> {
			switch (ass) { 
				RuTheorem(__,__,__,__): setTree(acc, id, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathProofs(math : RuMath) ->Tree<int, RuProof> {
	mapTree(ruMathTheorems(math), \th -> th.proof);
}

ruMathDefs(math : RuMath) ->Tree<int, RuDef> {
	foldTree(math.assertions, makeTree(),
		\id, ass, acc -> {
			switch (ass) { 
				RuDef(__,__,__,__): setTree(acc, id, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathAxiomsNum(math : RuMath) -> int {
	foldTree(math.assertions, 0, \__,a, acc -> 
		if (ruDeclIsAxiom(a)) acc + 1 else acc
	);
}

ruMathTheoremsNum(math : RuMath) -> int {
	foldTree(math.assertions, 0, \__,a, acc -> 
		if (ruDeclIsTheorem(a)) acc + 1 else acc
	);
}

ruMathDefsNum(math : RuMath) -> int {
	foldTree(math.assertions, 0, \__,a, acc -> 
		if (ruDeclIsDef(a)) acc + 1 else acc
	);
}

ruMathStepsNum(math : RuMath) -> int {
	foldTree(ruMathProofs(math), 0, \__, proof, acc -> 
		acc + length(proof.steps)
	);
}

ruMathAllDecls(math : RuMath) ->Tree<int, RuDecl> {
	foldTree(math.assertions, 
		foldTree(math.rules, 
			foldTree(math.types, 
				foldTree(math.consts, makeTree(), 
					\id, type, acc -> setTree(acc, id, type)
				),
				\id, type, acc -> setTree(acc, id, type)
			),
			\id, rule, acc -> setTree(acc, id, rule)
		),
		\id, ass, acc -> setTree(acc, id, ass)
	);
}

ruMathSrcDecls(math : RuMath) ->Tree<int, RuDecl> {
	foldTree(math.sources, makeTree(), \__, src, acc -> 
		fold(src.decls, acc, \ac, decl -> 
			setTree(ac, decl.descr.id, decl)
		)
	);
}

ruSuperRule(infer : int, super : int, math : RuMath, conf : RuConf) -> Maybe<RuRule> {
	id = ruSuperTypeName(super, infer);
	lookupTree(math.rules, id);
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"  sources:    " + i2s(sizeTree(math.sources)),
		"  consts:     " + i2s(sizeTree(math.consts)),
		"  types:      " + i2s(sizeTree(math.types)),
		"  rules:      " + i2s(sizeTree(math.rules)),
		"  assertions: " + i2s(sizeTree(math.assertions)),
		"    axioms:   " + i2s(ruMathAxiomsNum(math)),
		"    theorems: " + i2s(ruMathTheoremsNum(math)),
		"    defs:     " + i2s(ruMathDefsNum(math)),
		"    steps:    " + i2s(ruMathStepsNum(math))
	], "\n")
}

ruMathStats1(math : RuMath) -> ValMap {
	ValMap(pairs2tree([
		Pair("sources", ValInt(sizeTree(math.sources))),
		Pair("consts", ValInt(sizeTree(math.consts))),
		Pair("types", ValInt(sizeTree(math.types))),
		Pair("rules", ValInt(sizeTree(math.rules))),
		Pair("assertions", ValArray([
			ValInt(sizeTree(math.assertions)),
			ValMap(pairs2tree([
				Pair("axioms", ValInt(ruMathAxiomsNum(math))),
				Pair("theorems", ValInt(ruMathTheoremsNum(math))),
				Pair("defs", ValInt(ruMathDefsNum(math))),
				Pair("steps", ValInt(ruMathStepsNum(math)))
			]))
		]))
	]));
}


ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath {
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \id, s1, s2 -> { conf.onError("duplicate source: " + id2s(id), []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \id, c1, c2 -> { conf.onError("duplicate constant: " + id2s(id), []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \id, t1, t2 -> { conf.onError("duplicate type: " + id2s(id), []); t1 }),
		mergeTreeCustom(m1.rules, m2.rules, \id, r1, r2 -> { conf.onError("duplicate rule: " + id2s(id), []); r1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \id, a1, a2 -> { conf.onError("duplicate assertion: " + id2s(id), []); quit(0); a1 })
	);
}

ruRemoveSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	if (!containsKeyTree(m.sources, src.info.id)) m else {
		fold(src.decls, 
			RuMath(m with sources = removeFromTree(m.sources, src.info.id)), 
			\acc, decl -> {
				switch (decl) {
					RuConst(descr,__,__):
						RuMath(acc with consts = removeFromTree(acc.consts, descr.id));
					RuType(descr,__):
						RuMath(acc with types = removeFromTree(acc.types, descr.id));
					RuRule(descr, __,__):
						RuMath(acc with rules = removeFromTree(acc.rules, descr.id));
					RuAxiom(descr,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.id));
					RuTheorem(descr,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.id));
					RuDef(descr,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.id));
				}
			}
		);
	}
}

ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	fold(src.decls, 
		RuMath(m with sources = setTree(m.sources, src.info.id, src)), 
		\acc, decl -> {
			switch (decl) {
				RuConst(descr,__,__):
					RuMath(acc with consts = setTree(acc.consts, descr.id, decl));
				RuType(descr,__):
					RuMath(acc with types = setTree(acc.types, descr.id, decl));
				RuRule(descr, __,__):
					RuMath(acc with rules = setTree(acc.rules, descr.id, decl));
				RuAxiom(descr,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.id, decl));
				RuTheorem(descr,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.id, decl));
				RuDef(descr,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.id, decl));
			}
		}
	);
}

ruRemoveDecl(decl : RuDecl, m : RuMath, conf : RuConf) -> RuMath {
	eitherMap(
		lookupTree(m.sources, decl.descr.src), 
		\src -> {
			id = decl.descr.id;
			m1 = switch (decl) {
				RuConst(__,__,__):
					RuMath(m with consts = removeFromTree(m.consts, id));
				RuType(__,__):
					RuMath(m with types = removeFromTree(m.types, id));
				RuRule(__,__,__):
					RuMath(m with rules = removeFromTree(m.rules, id));
				RuAxiom(__,__):
					RuMath(m with assertions = removeFromTree(m.assertions, id));
				RuDef(__,__,__,__):
					RuMath(m with assertions = removeFromTree(m.assertions, id));
				RuTheorem(__,__,__,__):
					RuMath(m with assertions = removeFromTree(m.assertions, id));
			}
			removed_decls = removeIndex(src.decls, ruIndexOfDecl(id, src));
			RuMath(m1 with
				sources = setTree(m1.sources, decl.descr.src, RuSource(src with decls = removed_decls));
			);
		},
		m
	);
}

ruAddImportToSource(src : RuSource, id : int, math : RuMath, conf : RuConf) -> RuMath {
	if (exists(src.imports, \imp -> imp.id == id)) math else {
		RuMath(math with 
			sources = setTree(math.sources, src.info.id, RuSource(src with
				imports = concat(src.imports, [RuImport(id, -1)])
			))
		);
	}
}

ruMakeMathFromSource(src : RuSource, conf : RuConf) -> RuMath {
	fold(src.decls, 
		RuMath(ruEmptyMath with sources = makeTree1(src.info.id, src)), 
		\acc, decl -> {
			id = decl.descr.id;
			switch (decl) {
				RuConst(__,__,__):
					RuMath(acc with consts = setTree(acc.consts, id, decl));
				RuType(__,__): 
					ruAddType(decl, acc, conf);
				RuRule(__,__,__):
					RuMath(acc with rules = setTree(acc.rules, id, decl));
				RuAxiom(__,__):
					RuMath(acc with assertions = setTree(acc.assertions, id, decl));
				RuTheorem(__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, id, decl));
				RuDef(__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, id, decl));
			}
		}
	);
}

ruMakeMathFromSources(srcs : Tree<int, RuSource>, conf : RuConf) -> RuMath {
	stuff = foldTree(srcs, ruEmptyMath, \src_name, src, acc -> 
		ruMergeMath(acc, ruMakeMathFromSource(src, conf), conf)
	);
	RuMath(stuff with sources = srcs);
}

ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath {
	module = src.info.module;
	RuMath(m with 
		assertions = fold(src.decls, m.assertions,
			\acc, decl -> {
				switch (decl) {
					RuAxiom(descr,__):         setTree(acc, descr.id, decl);
					RuTheorem(descr,__,__,__): setTree(acc, descr.id, decl);
					RuDef(descr,__,__,__):     setTree(acc, descr.id, decl);
					default: acc;
				}
			}
		)
	);
}

ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	ruAddSource(src, ruRemoveSource(src, m, conf), conf);
}

ruSources2SingleSource(sources : Tree<int, RuSource>, path : string, conf : RuConf) -> RuSource {
	module = ruTrimPath(path, conf, ".ru");
	RuSource([],
		concatA(foldTree(sources, Pair([], makeSet()), \__,src, acc ->
			ruDoSources2SingleSource(src, sources, acc)
		).first),
		foldTree(sources, [], \__,src, acc ->
			concat(acc, src.comments)
		),
		ruNewFileInfo(module, conf, ".ru")
	);
}

ruDoSources2SingleSource(src : RuSource, sources : Tree<int, RuSource>, acc : Pair<[[RuDecl]], Set<int>>) -> Pair<[[RuDecl]], Set<int>> {
	if (containsSet(acc.second, src.info.id)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.id)), 
			\ac, imp -> {
				switch (lookupTree(sources, imp.id)) {
					Some(inc_src): ruDoSources2SingleSource(inc_src, sources, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, [src.decls]), acc1.second)
	}
}

ruNameAllImported(id : int, math : RuMath) -> Set<RuSource> {
	ruSourceAllImported(ruFindSourceId(id, math), math);
}

ruSourceAllImported(id : int, math : RuMath) -> Set<RuSource> {
	switch (lookupTree(math.sources, id)) {
		Some(src): ruDoSourceAllImported(src, math, makeSet());
		None(): makeSet();
	}
}

ruDoSourceAllImported(src : RuSource, math : RuMath, acc : Set<RuSource>) -> Set<RuSource> {
	if (containsSet(acc, src)) acc else {
		fold(src.imports, insertSet(acc, src), 
			\ac, imp -> ruDoSourceAllImported(lookupTreeDef(math.sources, imp.id, ruNoSource), math, ac)
		);
	}
}

ruMathAllImported(math : RuMath, conf : RuConf) -> Tree<int, Set<int>> {
	fold(ruOrderSources(math.sources), makeTree(), \acc, src ->
		setTree(acc, src.info.id, 
			fold(src.imports, makeSet(), \ac, imp -> {
				if (!containsKeyTree(acc, imp.id)) {
					println("MISSING IMPORT!!! " + id2s(imp.id) + " in module " + id2s(src.info.id));
					quit(0);
				}
				mergeSets(ac, insertSet(lookupTreeDef(acc, imp.id, makeSet()), imp.id))
			})
		)
	);
}

ruOrderSources(sources : Tree<int, RuSource>) -> [RuSource] {
	ruDoOrderSources(getTreeValues(sources), [], makeSet());
}

ruDoOrderSources(srcs : [RuSource], acc : [RuSource], visited: Set<int>) -> [RuSource] {
	new_level = filter(srcs, \src -> forall(src.imports, \imp -> containsSet(visited, imp.id)));
	level_names = buildSet(map(new_level, \src -> src.info.id));
	if (new_level == []) {
		if (length(srcs) == 0) acc else {
			println("Cycilc imports detected:\n" + strIndent(strGlue(map(srcs, \src -> id2s(src.info.id)), "\n")));
			[]
		};
	} else {
		new_srcs = filter(srcs, \src -> !containsSet(level_names, src.info.id));
		ruDoOrderSources(new_srcs, concat(acc, new_level), mergeSets(visited, level_names));
	}
}

ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	//name = ruDeclName(a);
	switch (ruFindSource(a.descr.id, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(a.descr.id, src), a)
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = setTree(math.assertions, a.descr.id, a),
				sources = setTree(math.sources, src.info.id, updated_src)
			);
		}
		None(): math;
	}
}

ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	//name = ruDeclName(a);
	updated_src = RuSource(src with decls = insertArray(src.decls, i, a));
	//ruToCache(updated_src, conf);
	RuMath(math with 
		assertions = setTree(math.assertions, a.descr.id, a),
		sources = setTree(math.sources, src.info.id, updated_src)
	);
}

ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	//name = ruDeclName(a);
	switch (ruFindSource(a.descr.id, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				removeIndex(src.decls, ruIndexOfDecl(a.descr.id, src))
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = removeFromTree(math.assertions, a.descr.id),
				sources = setTree(math.sources, src.info.id, updated_src)
			);
		}
		None(): math;
	}
}

ruReplaceDecl(d : RuDecl, math : RuMath, conf : RuConf) -> RuMath {
	//name = ruDeclName(d);
	id = d.descr.id;
	switch (ruFindSource(id, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(id, src), d)
			);
			math1 = switch (d) {
				RuConst(__,__,__): 
					RuMath(math with consts = setTree(math.consts, id, d));
				RuType(__,__):
					RuMath(math with types = setTree(math.types, id, d));
				RuRule(__,__,__):
					RuMath(math with rules = setTree(math.rules, id, d));
				RuAssertion(): 
					RuMath(math with assertions = setTree(math.assertions, id, d));
			}
			RuMath(math1 with 
				sources = setTree(math.sources, src.info.id, updated_src)
			);
		}
		None(): math;
	}
}

ruAddDecl(decl : RuDecl, math : RuMath, conf : RuConf) -> RuMath {
	id = decl.descr.id;
	switch (decl) {
		RuConst(__,__,__): 
			RuMath(math with consts = setTree(math.consts, id, decl));
		RuType(__,__):
			ruAddType(decl, math, conf);
		RuRule(__,__,__):
			RuMath(math with rules = setTree(math.rules, id, decl));
		RuAssertion(): 
			RuMath(math with assertions = setTree(math.assertions, id, decl));
	}
}

ruFindDecl(id : int, math : RuMath, conf : RuConf) -> Maybe<RuDecl> {
	switch (lookupTree(math.assertions, id)) {
		Some(decl): Some(decl);
		None(): {
			switch (lookupTree(math.consts, id)) {
				Some(decl): Some(decl);
				None(): {
					switch (lookupTree(math.rules, id)) {
						Some(decl): Some(decl);
						None(): lookupTree(math.types, id);
					}
				}
			}
		}
	}
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruTheorem(id : int, math : RuMath, conf : RuConf) -> RuTheorem {
	switch (lookupTree(math.assertions, id)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(__,__,__,__): ass;
				default: {
					conf.onError("'" + id2s(id) + "' is not a theorem", []);
					ruNoTheorem;
				}
			}
		}
		None(): {
			conf.onError("theorem '" + id2s(id) + "' is not found", []);
			ruNoTheorem;
		}
	}
}

ruMathAssertionDepths(math : RuMath) -> Tree<int, int> {
	foldTree(math.assertions, makeTree(), \id, __, acc -> ruDoMathAssertionDepths(math, id, acc));
}

ruDoMathAssertionDepths(math : RuMath, as_name : int, acc : Tree<int, int>) -> Tree<int, int> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(descr,__,__,proof): {
					switch (lookupTree(acc, descr.id)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDepths(math, step.assertion, ac));
							max_depth = fold(proof.steps, 0, \ac, step -> max(ac, lookupTreeDef(acc1, step.assertion, 0)));
							setTree(acc1, descr.id, max_depth + 1);
						}
					}
				}
				RuAxiom(descr,__):     setTree(acc, descr.id, 0);
				RuDef(descr,__,__,__): setTree(acc, descr.id, 0);
			}
		}
		None(): acc;
	}
}

ruMathAssertionAxioms(math : RuMath) -> Tree<int, Set<int>> {
	foldTree(math.assertions, makeTree(), \id, __, acc -> ruDoMathAssertionAxioms(math, id, acc));
}

ruDoMathAssertionAxioms(math : RuMath, as_name : int, acc : Tree<int, Set<int>>) -> Tree<int, Set<int>> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(descr,__,__,proof): {
					switch (lookupTree(acc, descr.id)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionAxioms(math, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, descr.id, axioms);
						}
					}
				}
				RuAxiom(descr,__):     setTree(acc, descr.id, makeSet1(descr.id));
				RuDef(descr,__,__,__): setTree(acc, descr.id, makeSet());
			}
		}
		None(): acc;
	}
}

ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<int, Set<int>> {
	foldTree(math.assertions, makeTree(), \id, __, acc -> ruDoMathAssertionDependencies(id, acc, math, conf));
}

ruDoMathAssertionDependencies(as_name : int, acc : Tree<int, Set<int>>, math : RuMath, conf : RuConf) -> Tree<int, Set<int>> {
	if(containsKeyTree(acc, as_name)) {
		acc; 
	} else { 
		switch (lookupTree(math.assertions, as_name)) {
			Some(a): {
				switch (a) {
					RuTheorem(descr,__,__,proof): {
						switch (lookupTree(acc, descr.id)) {
							Some(v): acc;
							None(): {
								acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDependencies(step.assertion, ac, math, conf));
								deps = fold(proof.steps, 
									buildSet(map(proof.steps, \step -> step.assertion)), 
									\ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet()))
								);
								setTree(acc1, descr.id, deps);
							}
						}
					}
					RuAxiom(descr,__):     setTree(acc, descr.id, makeSet());
					RuDef(descr,__,__,__): setTree(acc, descr.id, makeSet());
				}
			}
			None(): acc;
		}
	}
}

ruMathAssertionProofSteps(math : RuMath) -> Tree<int, Tree<int, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(descr,__,__,proof):
					foldi(proof.steps, ac, \i, a, step -> {
						tr = lookupTreeDef(a, step.assertion, makeTree());
						setTree(a, step.assertion,
							setTree(tr, descr.id, 
								concat(lookupTreeDef(tr, descr.id, []), [i])	
							)
						);
					});
				default: ac;
			}
		)
	);	
}

ruAssertionDepth(ass : int, math : RuMath) -> int {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,proof): {
					1 + fold(proof.steps, 0, \acc, step -> max(acc, ruAssertionDepth(step.assertion, math)));
				}
				RuAxiom(__,__):     0;
				RuDef(__,__,__,__): 0;
			}
		}
		None(): -1;
	}
}

ruAssertionAxioms(ass : int, math : RuMath) -> Set<int> {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,proof): {
					fold(proof.steps, makeSet(), \acc, step -> mergeSets(acc, ruAssertionAxioms(step.assertion, math)));
				}
				RuAxiom(descr,__):     makeSet1(descr.id);
				RuDef(descr,__,__,__): makeSet();
			}
		}
		None(): makeSet();
	}
}

ruAssertionDependencies(ass : int, math : RuMath, conf : RuConf) -> Set<int> {
	lookupTreeDef(ruDoMathAssertionDependencies(ass, makeTree(), math, conf), ass, makeSet());
}

ruAssertionDependendsOn(ass : int, dep : int, math : RuMath, conf : RuConf) -> bool {
	containsSet(ruAssertionDependencies(ass, math, conf), dep);
}

ruAssertionCyclicDependency(ass : int, math : RuMath, conf : RuConf) -> bool {
	ruAssertionDependendsOn(ass, ass, math, conf);
}

ruAssertionsProofSteps(as : Set<int>, math : RuMath) -> Tree<int, Tree<int, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(descr,__,__,proof):
					foldi(proof.steps, ac, \i, a, step ->
						if (!containsSet(as, step.assertion)) a else {
							tr = lookupTreeDef(a, step.assertion, makeTree());
							setTree(a, step.assertion,
								setTree(tr, descr.id, 
									concat(lookupTreeDef(tr, descr.id, []), [i])	
								)
							);
						}
					);
				default: ac;
			}
		)
	);	
}

ruSourceDeclNames(src : int, acc : Set<int>, math : RuMath, conf : RuConf) -> Set<int> {
	ruDoSourceDeclNames(src, Pair(acc, makeSet()), math, conf).first;
}

ruDoSourceDeclNames(src : int, acc : Pair<Set<int>, Set<int>>, math : RuMath, conf : RuConf) -> Pair<Set<int>, Set<int>> {
	if (containsSet(acc.second, src)) acc else {
		eitherMap(lookupTree(math.sources, src), 
			\s -> fold(s.imports, 
				fold(s.decls, 
					Pair(acc.first, insertSet(acc.second, src)), 
					\ac, decl -> Pair(insertSet(ac.first, decl.descr.id), ac.second)
				),
				\ac, imp -> ruDoSourceDeclNames(imp.id, ac, math, conf)
			),
			acc
		);
	}
}

ruProjectRootSource(math : RuMath) -> Maybe<RuSource> {
	all_sources = buildSet(getTreeKeys(math.sources));
	only_imports = filtermap(getTreeValues(math.sources), \src -> 
		if (src.decls != [] || src.imports == []) None() else {
			Some(Pair(src, buildSet(map(src.imports, \imp -> imp.id))));
		}
	);
	maybeMap(
		find(only_imports, \pair ->
			equalSet(pair.second, removeSet(all_sources, pair.first.info.id))
		),
		\pair -> pair.first
	);
}

ruDeclPreceeds(less : RuDecl, greater : RuDecl, imported_map : Tree<int, Set<int>>) -> bool {
	if (less.descr.src == greater.descr.src) {
		less.descr.pos < greater.descr.pos;
	} else {
		containsSet(lookupTreeDef(imported_map, greater.descr.src, makeSet()), less.descr.src);
	}
}

ruTheoremName2ReferringTheorems(math : RuMath) -> Tree<int, Set<int>> {
	foldTree(math.assertions, makeTree(), \name, ass, acc ->
		switch (ass) {
			RuTheorem(descr,__,__,proof): 
				fold(proof.steps, acc, \ac, step ->
					setTree(ac, step.assertion, 
						insertSet(lookupTreeDef(ac, step.assertion, makeSet()), descr.id)
					)
				);
			default: acc;
		}
	);
}

ruAddType(type : RuType, m : RuMath, conf : RuConf) -> RuMath {
	RuMath(m with 
		types = setTree(m.types, type.descr.id, type),
		rules = fold(type.supers, m.rules, \a, super -> {
			rule = ruMakeSuperRule(super, type.descr.id, type.descr.src, type.descr.pos);
			setTree(a, rule.descr.id, rule);
		})
	);
}
