import ru/verify/verify;
import ru/math;
import mm/src;

export {
	ruCommRu2Mm : RuComm;
}

ruCommRu2Mm = RuComm(
	"ru-to-mm", "translate", "translate Russell to Metamath", "file",
	[RuCommArg("file", false, "input file", "")],
	\task, env -> Some(RuState(env with mmMath = ru2mm(env.ruMath, env.conf)))
);

ru2mm(math : RuMath, conf : RuConf) -> MmMath {
	start = timestamp();
	srcs = foldTree(math.sources, makeTree(), \id, src, acc -> 
		setTree(acc, id2s(id), ruSource2mm(src, math, conf))
	);
	add_hyps = \acc, hs -> fold(hs, acc, \ac, h : MmHyp -> setTree(ac, h.label, h));
	labeled_consts = foldTree(srcs, Pair(makeTree(), makeSet()), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				MmAssertion(__, hyps, inner, stat):
					Pair(
						add_hyps(add_hyps(setTree(ac.first, stat.label, decl), hyps), inner),
						ac.second
					);
				MmConst(symbs): {
					Pair(ac.first, mergeSets(ac.second, buildSet(symbs)))
				}
				default: ac;
			}
		)
	);
	mm = ruAddTurnstile(math, MmMath(srcs, labeled_consts.first, labeled_consts.second), conf);
	if (conf.verbose > 0) {
		conf.onMessage("ru translated in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	mm;
}

ruAddTurnstile(ru_math : RuMath, mm_math : MmMath, conf : RuConf) -> MmMath {
	leaf_srcs = mmFindLeafSources(mm_math);
	common_dir = ruPath2s(ruCommonDir(map(leaf_srcs, \src -> ruSplitPath(src.info.path))));
	turnstile = ruMakeTurnstile(ru_math);
	path = common_dir + "turnstile.mm";
	module = ruTrimPath(path, conf, ".mm");
	turnstile_src = MmSource([], [MmConst([turnstile])], RuFileInfo(s2id(module), module, path, 0.0, ""));
	acc1 = MmMath(mm_math with sources = setTree(mm_math.sources, module, turnstile_src));
	fold(leaf_srcs, acc1, \acc, src ->
		MmMath(acc with 
			sources = setTree(acc.sources, src.info.module, 
				MmSource([MmImport(module)], src.decls, src.info)
			)
		)
	)
}

ruFindLeafSources(math : RuMath) -> [RuSource] {
	filter(getTreeValues(math.sources), \src -> src.imports == [])
}

ruMakeTurnstile(math : RuMath) -> string {
	ascii_consts = buildSet(map(getTreeValues(math.consts), \c -> id2s(c.ascii)));
	ruDoMakeTurnstile("|-", ascii_consts)
}

ruDoMakeTurnstile(turnstile : string, consts : Set<string>) -> string {
	if (!containsSet(consts, turnstile)) turnstile else {
		ruDoMakeTurnstile("|" + turnstile, consts)
	}
}

ruSource2mm(src : RuSource, math : RuMath, conf : RuConf) -> MmSource {
	turnstile = ruMakeTurnstile(math);
	start = timestamp();
	ret = MmSource(
		map(src.imports, \imp -> MmImport(id2s(imp.id))),
		concatA(ruConcurrent(map(src.decls, \decl -> \ -> ruDecl2mm(decl, turnstile, math, conf)))),
		ruNewFileInfo(src.info.module, conf, ".mm")
	);
	if (conf.verbose > 1) {
		conf.onMessage("\tru translated: '" + src.info.module + "' in " + d2st((timestamp() - start)/ 1000.0, 4) + " s");
	}
	ret
}

ruVar2mm(th : string, var : string) -> string {
	// Mm labels must be: "Only letters, digits, "_", "-", and "." are allowed in labels."
	// Replace all characters not falling into these classes with those, who fall. 
	var1 = fold(
		map(s2a(var), \i -> 
			if (i == 45 || i == 46 || i == 95) i else
			if (48 <= i  && i <= 57) i else 
			if (65 <= i  && i <= 90) i else
			if (97 <= i  && i <= 122) i else {
				if (i < 48) i + 32 else
				if (i < 65) i + 23 else 
				if (i < 97) i + 7 else i - 4
			}
		),
		"",
		\ac, i -> ac + fromCharCode(i)
	);
	th + "_" + var1
}

ruDecl2mm(decl : RuDecl, turnstile : string, math : RuMath, conf : RuConf) -> [MmDecl] {
	const2mm = \c -> if (c.ascii != -1) id2s(c.ascii) else c.descr.name;
	term2mm = \t -> map(t.nodes, 
		\s -> switch (s) {
			RuVar(v,__,__): 
				MmSymb(v, true);
			RuConstRef(c, id):
				MmSymb(const2mm(lookupTreeDef(math.consts, id, ruNoConst)), false);
		}
	);
	tvars2mm = \n, t -> fold(t.nodes, [],
		\acc, s -> switch (s) {
			RuVar(var,__, type_id): 
				concat(acc, [MmFloating(ruVar2mm(n, var), id2s(type_id), var)]);
			RuConstRef(c, id):
				acc;
		}
	);
	expr2mm = \ex -> MmExp(concat([MmSymb(turnstile, false)], term2mm(ruExp2Term(ex, math.rules))));
	disj2mm = \disjs -> map(ruDisjs2Array(disjs), \ds -> MmDisj(map(set2array(ds), \d -> d.name)));
	vars2mm = \n, vs -> map(getTreeValues(vs), \v -> MmFloating(ruVar2mm(n, v.name), id2s(v.type_id), v.name));
	hyps2mm = \n, hs -> mapi(hs, \i, h -> MmEssential(n + "_" + i2s(i), expr2mm(h.expr)));
	comm2mm = \t -> {
		t0 = trim2(t, " \t\n\r");
		t1 = if (startsWith(t0, "/*") || startsWith(t0, "//")) strRight(t0, 2) else t0;
		if (endsWith(t1, "*/")) strLeft(t1, strlen(t1) - 2) else t1;
	}
	add_comments = \descr, arr -> {
		concat(map(descr.comments, \comm -> 
			MmComment(comm2mm(
				if (comm.annotation == JsonNull()) {
					comm.text 
				} else {
					json2string(comm.annotation) + "\n-----\n" + comm.text
				}
			))
		), arr);
	}
	switch (decl) {
		RuConst(descr, ascii,__):
			add_comments(descr, [MmConst([const2mm(decl)])]);
		RuType(descr, supers):
			add_comments(descr, concat(
				[MmConst([descr.name])], 
				concatA(filtermap(supers, \super -> 
					maybeMap(
						lookupTree(math.rules, id2s(ruSuperTypeName(super, descr.id))),
						\r -> ruDecl2mm(r, turnstile, math, conf)
					)
				))
			));
		RuRule(descr, vars, term):
			add_comments(descr, [MmAssertion(
				[], 
				tvars2mm(descr.name, term), [],
				MmAxiomatic(descr.name, MmExp(concat([MmSymb(id2s(term.type_id), false)], term2mm(term))))
			)]);
		RuAxiom(descr, stat):
			add_comments(descr, [MmAssertion(
				disj2mm(stat.disjs),
				concat(vars2mm(descr.name, stat.vars), hyps2mm(descr.name, stat.hyps)), [],
				MmAxiomatic(descr.name, expr2mm(stat.prop))
			)]);
		RuTheorem(descr, stat, __, proof):
			add_comments(descr, [MmAssertion(
				disj2mm(mergeSets(stat.disjs, proof.disjs)),
				concat(vars2mm(descr.name, stat.vars), hyps2mm(descr.name, stat.hyps)),
				vars2mm(descr.name, proof.vars),
				MmProvable(descr.name, expr2mm(stat.prop), MmNormalProof(ruProof2mm(lastElement(proof.steps, ruNoStep), decl, math, conf)))
			)]);
		RuDef(descr, stat,__,__):
			add_comments(descr, [MmAssertion(
				disj2mm(stat.disjs),
				concat(vars2mm(descr.name, stat.vars), hyps2mm(descr.name, stat.hyps)), [],
				MmAxiomatic(descr.name, expr2mm(stat.prop))
			)]);
	}
}

ruProofExp2mm(i : int, nodes : [RuExpNode], name : string) -> Pair<[string], int> {
	switch (nodes[i]) {
		RuRuleNode(rule, id,__,arity, len): {
			args = fold(enumFromTo(1, arity), Pair([], i + 1), \acc, __ -> {
				arg = ruProofExp2mm(acc.second, nodes, name);
				Pair(concat(acc.first, arg.first), arg.second);
			});
			Pair(concat(args.first, [rule]), args.second);
		}
		RuVar(var,__,__): Pair([ruVar2mm(name, var)], i + 1);
	}
}

ruProof2mm(step : RuStep, th : RuTheorem, math : RuMath, conf : RuConf) -> [string] {
	switch (ruMatchStep(step, th, math, conf)) {
		RuMatchedStep(ass, sub, ___): {
			subs = fold(getTreeValues(ass.stat.vars), [], \acc, v ->
				switch (lookupTree(sub, RuVar(v.name, s2id(v.name), v.type_id))) {
					None(): acc;
					Some(ex): concat(acc, ruProofExp2mm(0, ex.nodes, th.descr.name).first);
				}
			)
			refs = fold(step.refs, [], \acc, ref ->
				switch (ref) {
					RuHypRef(ind,__): concat(acc, [th.descr.name + "_" + i2s(ind)]);
					RuStepRef(ind,__): concat(acc, ruProof2mm(th.proof.steps[ind], th, math, conf));
				}
			);
			concat3(subs, refs, [ass.descr.name]);
		}
		RuVerifyErr(): [];
	}
}
