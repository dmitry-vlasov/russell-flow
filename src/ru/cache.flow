import text/binary;
import formats/lsp;
import base/util/concurrent;
import base/log;
import ru/util/utils;
import ru/cache/code;
import ru/cache/rule;

export {
	RuCachedSource(
		source : RuSource, 
		dependencyChanged : () -> bool, 
		version : int
	);

	RuCachedDecl(
		decl : RuDecl,
		info : RuFileInfo
	);

	ruToMemCache(src : RuSource, env : RuEnv) -> void;
	ruToDiskCache(src : RuSource, env : RuEnv) -> void;

	ruFromCache(file : int, env : RuEnv) -> Maybe<RuCachedSource>;
	ruLoadToMemCache(file : string, env : RuEnv) -> void;
	ruRemoveFromCache(file : string, env : RuEnv) -> void;
	ruLoadMemCacheFromDisk(env : RuEnv) -> void;

	ruClearCache(env : RuEnv) -> void;
	ruClearMemCache() -> void;
	ruClearDiskCache(env : RuEnv) -> void;

	ruSaveCache(env : RuEnv) -> void;
	ruSaveCacheFile(file : string, env : RuEnv) -> void;
	ruSourcesCache() -> [RuSource];
	
	ruMakeCacheDir(env : RuEnv) -> void;

	ruCachedDecl(name : string) -> [RuCachedDecl];
	ruCachedDecl2s(name : string, env : RuEnv) -> string;
	ruCachedDecls() -> [RuCachedDecl];
	ruCachedAssertoins() -> Tree<string, RuAssertion>;
	ruCachedTheoremAxioms() -> Tree<string, Set<string>>;

	ruCachedDecl2LspSymbolInfos(name : string, env : RuEnv) -> [LspSymbolInformation];

	// Shows cache statistics
	ruCacheInfo(full : bool) -> string;
	// Declaration statistics
	ruDeclInfo(mode : [string], env : RuEnv) -> string;

}

ruCacheVersion = 5;

ruSourceCache = initConcurrentHashMap();
ruNameCache = initConcurrentHashMap();
ruDefCache = initConcurrentHashMap();  // Definitions

ruClearCache(env : RuEnv) -> void {
	ruClearMemCache();
	ruClearDiskCache(env);
}

ruClearMemCache() -> void {
	clearConcurrentHashMap(ruSourceCache);
	clearConcurrentHashMap(ruNameCache);
	ruClearSourceCodeCache();
	ruRuleCacheClear();
	clearConcurrentHashMap(ruDefCache);
}

ruClearDiskCache(env : RuEnv) -> void {
	cache_dir = ruCacheDir(env.conf);
	to_remove = readDirectory(cache_dir);
	iter(readDirectory(cache_dir), \file -> 
		if (endsWith(file, ".cache")) {
			del = deleteFile(cache_dir + "/" + file);
			if (del != "") {
				env.out.onError("while deleting a cache file '" + file + "' happened: '" + del + "'", []);
			}
		}
	);
}

ruSourcesCache() -> [RuSource] {
	filtermap(valuesConcurrentHashMap(ruSourceCache), idfn);
}

ruMakeCacheDir(env : RuEnv) -> void {
	err = ensureDirectoryExists(ruCacheDir(env.conf));
	if (err != "") {
		env.out.onMessage(err);
	}
}

RuCachedFileSource(
	source : RuSource,
	version : int
);

ruDepChangedCallback(src : RuSource, env : RuEnv) -> () -> bool {
	\ -> {
		check = 
			ruFileChanged(src.info) || 
			exists(src.imports, \imp ->
				switch (ruFromCache(imp.id, env)) {
					Some(cached): cached.dependencyChanged();
					None(): true; 
					//{
					//	env.out.onError("a module '" + imp.module + "' must be already in cache, but is not there", []); true; 
					//}
				}
			);
		setConcurrentHashMap(ruSourceCache, src.info.module, Some(RuCachedSource(src, \ -> check, ruCacheVersion)));
		check
	}
}

ruUpdateNameCache(src : RuSource, env : RuEnv) -> void {
	//ruDebugLog1("ruUpdateNameCache: started " + src.info.file);
	iter(src.decls, \decl ->
		setConcurrentHashMap(ruNameCache, id2s(decl.descr.id), Some(RuCachedDecl(decl, src.info)))
	);
	//ruDebugLog1("ruUpdateNameCache: finished " + src.info.file);
}

ruUpdateDefCache(src : RuSource, env : RuEnv) -> void {
	//ruDebugLog1("ruUpdateDefCache: started " + src.info.file);
	iter(src.decls, \decl -> 
		switch (decl) {
			RuDef(__,__,defm, __): {
				switch (defm.nodes[0]) {
					RuRuleNode(rule_id,__,__,__): {
						switch (getConcurrentHashMap(ruNameCache, id2s(rule_id), None())) {
							Some(cached_rule): {
								rule = cast(cached_rule.decl : RuDecl -> RuRule);
								non_bracket_consts = filtermap(rule.term.nodes, \n ->
									switch (n) {
										RuConstRef(id): {
											name = id2s(id);
											if (name == "(" || name == ")" || name == "," || name == ":") None() else {
												if (containsConcurrentHashMap(ruDefCache, name)) None() else {
													Some(name);
												}
											};
										}
										RuVar(__,__): None(); 
									}
								);
								//ruDebugLog1("DEFIENDUM: " + ruExpRPN2s(defm.nodes));
								//ruDebugLog1("TERM: " + ruTerm2s(rule.term.expr));

								iter(non_bracket_consts, \defiendum_const ->
									setConcurrentHashMap(ruDefCache, defiendum_const, 
										concat(
											getConcurrentHashMap(ruDefCache, defiendum_const, []),
											[RuCachedDecl(decl, src.info)]
										)
									)
								);
							}
							None(): env.out.onError("Rule '" + id2s(rule_id) + "' is not found in cache", []);
						}
					}
					default: { 
						//ruDebugLog1("not a rule ref: " + ruExpRPN2s(defm));
					}
				}
			}
			default: { }
		}
	);
	//ruDebugLog1("ruUpdateDefCache: finished " + src.info.file);
}

ruSaveCache(env : RuEnv) -> void {
	iter(filtermap(valuesConcurrentHashMap(ruSourceCache), idfn), 
		\cached : RuCachedSource -> ruSaveCacheSource(cached.source, env)
	);
}

ruSaveCacheFile(file : string, env : RuEnv) -> void {
	switch (getConcurrentHashMap(ruSourceCache, file, None())) {
		Some(cached): ruSaveCacheSource(cached.source, env);
		None(): { }
	}
}

ruSaveCacheSource(src : RuSource, env : RuEnv) -> void {
	binary = toBinary(RuCachedFileSource(src, ruCacheVersion));
	if (!setFileContent(ruCachedPath(src.info.module, env.conf), binary)) {
		env.out.onError("cannot save cached source '" + src.info.module + "'", []);
	}
	if (ruVerbose(env.conf) > 1) {
		env.out.onMessage("\tsaved to cache: '" + src.info.module + "'");
	}
}

ruToMemCache(s : RuSource, env : RuEnv) -> void {
	if (lookupTreeDef(env.conf.opts, "caching", "") != "0" && lookupTreeDef(env.conf.opts, "mem-caching", "") != "0") {
		src = RuSource(s with info = ruUpdateFileInfo(s.info, env.conf.workingDir));
		cached = RuCachedSource(src, ruDepChangedCallback(src, env), ruCacheVersion);
		setConcurrentHashMap(ruSourceCache, src.info.module, Some(cached));
		ruRuleCacheAdd(src, env);
		ruUpdateNameCache(src, env);
		ruUpdateDefCache(src, env);
	}
}

ruToDiskCache(s : RuSource, env : RuEnv) -> void {
	if (lookupTreeDef(env.conf.opts, "caching", "") != "0" && lookupTreeDef(env.conf.opts, "disk-caching", "") != "0") {
		src = RuSource(s with info = ruUpdateFileInfo(s.info, env.conf.workingDir));
		ruSaveCacheSource(src, env);
	}
}

ruFromCache(id : int, env : RuEnv) -> Maybe<RuCachedSource> {
	ret = if (lookupTreeDef(env.conf.opts, "caching", "") == "0") None() else {
		file = ruTrimPath(id2s(id), env.conf, ".ru");
		switch (ruFromMemoryCache(file, env)) {
			Some(cached): {
				Some(cached);
			}
			None(): {
				path = ruCachedPath(file, env.conf);
				cached = ruFromDiskCache(file, path, env);
				ruCheckCachedIntegrity(file, cached, env);
			}
		}
		
	}
	/*switch (ret) {
		Some(cached): println("LOADED from cache: " + cached.source.info.path);
		None(): println("NOT loaded from cache: " + file0);
	}*/
	ret
}

ruCheckCachedIntegrity(file : string, mcached : Maybe<RuCachedSource>, env : RuEnv) -> Maybe<RuCachedSource> {
	del_from_cache = \cached -> {
		//ruServerLog("ABOUT TO DELETE: " + cached.source.info.path, env.conf);
		//ruServerLog(ruFileChangedMessage(cached.source.info), env.conf);
		ruDeleteFromCache(file, ruCachedPath(file, env.conf), env);
		None();
	}
	maybeBind(mcached, \cached -> {
		if (ruFileChanged(cached.source.info)) {
			if (ruVerbose(env.conf) > 1) {
				env.out.onMessage("\t" + ruFileChangedMessage(cached.source.info));
			}
			del_from_cache(cached);
		} else if (cached.dependencyChanged()) {
			if (ruVerbose(env.conf) > 1) {
				env.out.onMessage("\tdependency of file: '" + file + "' has changed");
			}
			del_from_cache(cached);
		} else {
			if (ruVerbose(env.conf) > 1) {
				env.out.onMessage("\tloaded from cache: '" + file + "'");
			}
			setConcurrentHashMap(ruSourceCache, file, Some(cached));
			ruUpdateNameCache(cached.source, env);
			if (lookupTreeDef(env.conf.opts, "disk-caching", "") != "0" && !fileExists(ruCachedPath(file, env.conf))) {
				ruSaveCacheSource(cached.source, env);
			}
			Some(cached);
		}
	});
}

ruFromDiskCache(file : string, path : string, env : RuEnv) -> Maybe<RuCachedSource> {
	if (lookupTreeDef(env.conf.opts, "disk-caching", "") == "0") None() else {
		if (!fileExists(path)) None() else {
			serialized = getFileContent(path);
			deserialized = deserializeBinary(serialized, IllegalStruct());
			if (deserialized == IllegalStruct()) {
				env.out.onError("WARNING: Illegal structure of cache file for '" + file + "'. Incremental file deleted.\n\n" + serialized + "\n\n", []);
				ruDeleteFromCache(file, path, env);
				None();
			} else {
				cached_file = cast(deserialized : flow -> RuCachedFileSource);
				if (cached_file.version == ruCacheVersion) {
					ruToMemCache(cached_file.source, env);
					Some(RuCachedSource(cached_file.source, ruDepChangedCallback(cached_file.source, env), cached_file.version));
				} else {
					if (ruVerbose(env.conf) > 1) {
						env.out.onMessage("\tcached file " + file + " has outdated version " + i2s(cached_file.version) + " while current version is " + i2s(ruCacheVersion));
						ruDeleteFromCache(file, path, env);
					}
					None();
				}
			}
		}
	}
}

ruFromMemoryCache(file : string, env : RuEnv) -> Maybe<RuCachedSource> {
	if (lookupTreeDef(env.conf.opts, "mem-caching", "") == "0") None() else {
		if (containsConcurrentHashMap(ruSourceCache, file)) {
			getConcurrentHashMap(ruSourceCache, file, None());
		} else {
			None();
		}
	}
}

ruLoadToMemCache(file : string,  env : RuEnv) -> void {
	if (!containsConcurrentHashMap(ruSourceCache, file)) {
		module = ruTrimPath(file, env.conf, ".ru");
		//ruServerLog("ruLoadToCache: started file: " + file + ", module: " + module, env.conf);
		sources = ruDoLoadToCache(s2id(module), env, [], makeSet()).first;
		//ruDebugLog1("ruLoadToCache: sources are loaded " + file);
		iter(sources, \src -> ruUpdateDefCache(src, env));
		//ruDebugLog1("ruLoadToCache: finished " + file);
	}
}

ruDoLoadToCache(module : int,  env : RuEnv, acc : [RuSource], visited : Set<int>) -> Pair<[RuSource], Set<int>> {
	if (containsSet(visited, module)) Pair(acc, visited) else {
		new_visited = insertSet(visited, module);
		switch (ruFromCache(module, env)) {
			Some(cached): {
				fold(
					cached.source.imports,
					Pair(concat(acc, [cached.source]), new_visited), 
					\ac, imp -> ruDoLoadToCache(imp.id, env, ac.first, ac.second)
				);
			}
			None(): {
				//ruServerLog("MODULE: " + module + " is not cached", env.conf);
				Pair(acc, new_visited);
			}
		}
	}
}

ruLoadMemCacheFromDisk(env : RuEnv) -> void {
	cached_files = filter(ruDirFiles(ruCacheDir(env.conf)), \file -> endsWith(file, ".cache"));
	ruConcurrentVoid(map(cached_files, \f-> \ -> {
		path = ruResolveRelativePath(f, env.conf.workingDir);
		file = ruCachedFile(path, env.conf);
		if (file == "") {
			env.out.onError("Cache path '" + path + "' was not converted to a cached module name", []);
		} else {
			maybeApply(ruFromDiskCache(file, path, env), \cached -> 
				ruToMemCache(cached.source, env)
			);
		}
	}));
}

ruRemoveFromCache(file : string, env : RuEnv) -> void {
	path = ruCachedPath(file, env.conf);
	ruDeleteFromCache(file, path, env);
}

ruDeleteFromCache(file : string, path : string, env : RuEnv) -> void {
	if (lookupTreeDef(env.conf.opts, "caching", "") != "0") {
		if (ruVerbose(env.conf) > 1) {
			env.out.onMessage("\tDeleting cached " + file);
		}
		// Remove from the source code (string) cache
		ruRemoveFileSourceCode(file);
		// Remove from the source (RuSource) cache
		if (lookupTreeDef(env.conf.opts, "mem-caching", "") != "0") {
			removeConcurrentHashMap(ruSourceCache, file);
		}
		// Remove from the disk cache (serialized RuSource)
		if (lookupTreeDef(env.conf.opts, "disk-caching", "") != "0") {
			err = deleteFile(path);
			if (err != "") {
				if (fileExists(path)) {
					env.out.onError("Could not delete " + path + ": " + err, []);
				}
			}
		}
	}
}

ruCachedDecl(name : string) -> [RuCachedDecl] {
	defs = getConcurrentHashMap(ruDefCache, name, []);
	switch (getConcurrentHashMap(ruNameCache, name, None())) {
		Some(cached): concat(defs, [cached]);
		None(): defs;
	}
}

ruCachedDecls() -> [RuCachedDecl] {
	filtermap(valuesConcurrentHashMap(ruNameCache), idfn);
}

ruCachedAssertoins() -> Tree<string, RuAssertion> {
	pairs2tree(
		filtermap(ruCachedDecls(), \cached : RuCachedDecl -> {
			decl  = cached.decl;
			id = decl.descr.id;
			switch (decl) {
				RuConst(__,__,__):      None();
				RuType(__,__):          None();
				RuRule(__,__,__):       None();
				RuAxiom(__,__):         Some(Pair(id2s(id), decl));
				RuDef(__,__,__,__):     Some(Pair(id2s(id), decl));
				RuTheorem(__,__,__,__): Some(Pair(id2s(id), decl));
			}
		})
	);
}

ruCachedDecl2s(name : string, env : RuEnv) -> string {
	strGlue(
		filtermap(ruCachedDecl(name), \d -> 
			maybeMap(ruFromCache(d.info.id, env), \cached -> ruDeclCode(d.decl, cached.source))
		), "\n"
	);
}

ruCachedDecl2LspSymbolInfos(name : string, env : RuEnv) -> [LspSymbolInformation] {
	filtermap(ruCachedDecl(name), \d -> 
		maybeMap(ruFromCache(d.info.id, env), \cached -> {
			range = ruDeclRange(d.decl, cached.source);
			path = cached.source.info.path;
			location = ruRange2LspLocation(range, path, ruFileSourceCode(path));
			LspSymbolInformation(name, ruDecl2LspSymbolKind(d.decl), false, location, "");
		})
	)
}

ruCacheInfo(full : bool) -> string {
	ret = 
	"cached sources: " + i2s(sizeConcurrentHashMap(ruSourceCache)) + "\n" +
	"cached names: " + i2s(sizeConcurrentHashMap(ruNameCache)) + "\n" +
	//"cached source texts: " + i2s(sizeConcurrentHashMap(ruTextCache)) + "\n" +
	ruSourceCodeCacheInfo(false) + "\n" +
	"cached definitions: " + i2s(sizeConcurrentHashMap(ruDefCache)) + "\n" +
	if (!full) "" else {
		"cached sources:\n" + strGlue(map(keysConcurrentHashMap(ruSourceCache), \n -> "\t" + n), "\n") + "\n" + 
		//"cached source texts:\n" + strGlue(map(keysConcurrentHashMap(ruTextCache), \n -> "\t" + n),"\n") + "\n"
		ruSourceCodeCacheInfo(true) + "\n" +
		"cached definitions:\n" + strGlue(map(keysConcurrentHashMap(ruDefCache), \n -> "\t" + n),"\n")
	};
	//ruDebugLog1("ruCacheInfo:\n" + ret);
	ret
}

RuDeclInfoAcc(
	consts   : [RuConst],
	types    : [RuType],
	rules    : [RuRule],
	axioms   : [RuAxiom],
	defs     : [RuDef],
	theorems : [RuTheorem]
);

ruDeclInfo(mode : [string], env : RuEnv) -> string {
	opts = buildSet(mode);
	info_acc = fold(
		filtermap(valuesConcurrentHashMap(ruNameCache), idfn), 
		RuDeclInfoAcc([], [], [], [], [], []),
		\acc, cached -> {
			decl = cached.decl;
			source = cached.info.module;
			switch (decl) {
				RuConst(__,__,__):      RuDeclInfoAcc(acc with consts = concat(acc.consts, [decl]));
				RuType(__,__):          RuDeclInfoAcc(acc with types  = concat(acc.types,  [decl]));
				RuRule(__,__,__):       RuDeclInfoAcc(acc with rules  = concat(acc.rules,  [decl]));
				RuAxiom(__,__):         RuDeclInfoAcc(acc with axioms = concat(acc.axioms, [decl]));
				RuDef(__,__,__,__):     RuDeclInfoAcc(acc with defs   = concat(acc.defs,   [decl]));
				RuTheorem(__,__,__,__): RuDeclInfoAcc(acc with theorems = concat(acc.theorems, [decl]));
			}
		}
	);
	rules = fold(info_acc.rules, makeTree(), \acc, r -> setTree(acc, r.descr.id, r));
	math = RuMath(ruEmptyMath with decls = RuDecls(ruEmptyDecls with rules = rules));
	"consts:   " + i2s(length(info_acc.consts)) + "\n" + 
	"types:    " + i2s(length(info_acc.types)) + "\n" + 
	"rules:    " + i2s(length(info_acc.rules)) + "\n" + 
	"axioms:   " + i2s(length(info_acc.axioms)) + "\n" + 
	"defs:     " + i2s(length(info_acc.defs)) + "\n" + 
	"theorems: " + i2s(length(info_acc.theorems)) + "\n" + 
	(if (containsSet(opts, "consts") || containsSet(opts, "all")) {
		"consts:\n" + strGlue(map(info_acc.consts, \c -> "\t" + id2s(c.descr.id)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "types") || containsSet(opts, "all")) {
		"types:\n" + strGlue(map(info_acc.types, \t -> "\t" + ru2s(t, math)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "rules") || containsSet(opts, "all")) {
		"rules:\n" + strGlue(map(info_acc.rules, \r -> "\t" + ru2s(r, math)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "axioms") || containsSet(opts, "all")) {
		"axioms:\n" + strGlue(map(info_acc.axioms, \a -> "\t" + id2s(a.descr.id)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "defs") || containsSet(opts, "all")) {
		"defs:\n" + strGlue(map(info_acc.defs, \d -> "\t" + id2s(d.descr.id)), "\n") + "\n"
	} else "");
}

/*
ruDeclRange(d : RuDecl, src : RuSource) -> RuRange {
	ind = ruIndexOfDecl(d.descr.id, src);
	if (ind < 0) RuRange(-1, -1) else {
		text = ruFileSource(src.info.path);
		start = ruStartPosition(d);
		end = if (ind + 1 < length(src.decls)) {
			src.decls[ind + 1].descr.pos;
		} else {
			strlen(text);
		}
		switch (d) {
			RuTheorem(__,__,__,__):
				RuRange(start, strRangeIndexOf(text, "proof {", start, end));
			default: RuRange(start, end);
		}
	}
}
*/
ruCachedTheoremAxioms() -> Tree<string, Set<string>> {
	assertions = ruCachedAssertoins();
	foldTree(assertions, makeTree(), \name, __, acc -> ruDoCachedTheoremAxioms(assertions, name, acc));
}

ruDoCachedTheoremAxioms(assertions : Tree<string, RuAssertion>, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(assertions, as_name)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(descr,__,__,proof): {
					switch (lookupTree(acc, id2s(descr.id))) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoCachedTheoremAxioms(assertions, id2s(step.assertion), ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, id2s(step.assertion), makeSet())));
							setTree(acc1, id2s(descr.id), axioms);
						}
					}
				}
				RuAxiom(descr,__):     setTree(acc, id2s(descr.id), makeSet1(id2s(descr.id)));
				RuDef(descr,__,__,__): setTree(acc, id2s(descr.id), makeSet());
			}
		}
		None(): acc;
	}
}
