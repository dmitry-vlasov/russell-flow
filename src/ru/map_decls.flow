import comm;
import base/util/progress;
import ru/util/target;

export {
	// A struct describing a general function, which operates on decls.
	// pred - the predicate, which selects decls to process.
	// measure - the function, which return the relative 'size' of the decl. Used to balance time limits.
	// message - the function, which is used to indicate the progress of applying of a function.
	RuMapFnInfo(
		name : string, 
		pred : (RuDecl) -> bool, 
		measure : (RuDecl) -> double, 
		message : () -> string
	);

	RuMappedDecl(
		decl : RuDecl,
		fail : bool,
		replace : bool
	);

	// Mapping function: transforms (possibly) a decl. If None is returned, old one is kept.
	RuMapFn(
		info : RuMapFnInfo,
		func : (RuDecl, double, RuEnv) -> RuMappedDecl
	);

	RuMappedMath(
		math : RuMath,
		successes : Set<int>,
		fails : Set<int>
	);

	// Map 'f.func' to the decls from 'target' task option. 
	// Selects decls to process with 'fn.info.pred' parameter.
	// Balances the time limit between all admitted decls
	// proportionally to the 'fn.info.measure'.
	ruMapFnComm(unit : RuUnit, f : RuMapFn) -> RuState;
}

ruDecls2Measures(decls : [RuDecl], f : RuMapFn) -> [double] {
	map(decls, \d -> f.info.measure(d));
}

ruCalcTimeLimit(decls : [RuDecl], f : RuMapFn, task : ScTask, conf : RuConf) -> double {
	opt = switch (lookupTree(task.args, "time-limit")) {
		Some(limit): limit;
		None(): lookupTreeDef(conf.opts, "time-limit", "300s");
	}
	if (opt == "auto") {
		// By default we set 3 ms per one measure unit
		measures = ruDecls2Measures(decls, f);
		ruSumDoublesFromArray(measures) * 3.0;
	} else if (opt == "no") doubleMax else {
		ruParseTime(opt);
	}
}

RuMapFnStats(
	progress    : RuProgress,
	failed      : ref int,
	replaced    : ref int,
	max_time    : ref double,
	max_time_id : ref int
);

ruMakeMapFnStats(time_limit : double, total : int, delta, info : RuMapFnInfo, out : RuOut) -> RuMapFnStats {
	progress = ruMakeProgress(time_limit, total, delta);
	RuMapFnStats(
		RuProgress(progress with inform = \-> {
			msg = info.message();
			out.onMessage("\t" + ruProgressMessage(progress) + if (msg == "") "" else " " + msg);
		}),
		ref 0, ref 0, ref 0.0, ref -1
	);
}

ruWrapFnWithProgress(f : RuMapFn, stats : RuMapFnStats) -> (RuDecl, double, RuEnv) -> RuMappedDecl {
	\decl, time_limit, env -> {
		if (ruVerbose(env.conf) >= 3) {
			env.out.onMessage("\t\tTime limit on decl '" + id2s(decl.info.id) + "': " + ruTime2s(time_limit));
		}
		timer = ruMakeTimer();
		ret = f.func(decl, time_limit, env);
		atomicRefIntAddition(stats.progress.counter, 1);
		if (ret.fail) {
			atomicRefIntAddition(stats.failed, 1); {}
		} 
		if (ret.replace) {
			atomicRefIntAddition(stats.replaced, 1); {}
		} 
		time = ruTimePassed(timer);
		if (time > ^(stats.max_time)) {
			stats.max_time := time;
			stats.max_time_id := decl.info.id;
		}
		ret;
	}
}

ruAddMappedDecl2MappedMath(acc : RuMappedMath, mapped : RuMappedDecl, env : RuEnv) -> RuMappedMath {
	if (!mapped.fail) {
		acc1 = RuMappedMath(acc with successes = insertSet(acc.successes, mapped.decl.info.id));
		if (mapped.replace) {
			RuMappedMath(acc1 with math = ruMathReplaceDecl(acc.math, mapped.decl, env));
		} else {
			acc1;
		}
	} else {
		RuMappedMath(acc with fails = insertSet(acc.fails, mapped.decl.info.id));
	}
}

ruMapDeclsSequentially(decls : [RuDecl], f : RuMapFn, time_limit : double, timer : RuTimer, mapped_math : RuMappedMath, env : RuEnv) -> RuMappedMath {
	measures = ruDecls2Measures(decls, f);
	sum_measure = ruSumDoublesFromArray(measures);
	foldi(decls, mapped_math, \i, acc, d -> {
		mapped = f.func(d, time_limit * measures[i] / sum_measure, env);
		ruAddMappedDecl2MappedMath(acc, mapped, env);
	});
}

ruMapDeclsConcurrently(decls : [RuDecl], f : RuMapFn, time_limit : double, timer : RuTimer, mapped_math : RuMappedMath, env : RuEnv) -> RuMappedMath {
	split_by = lookupTreeDef(env.conf.opts, "decls-split-num", "");
	if (split_by == "") {
		ruMapDeclsConcurrentlyAll(decls, f, time_limit, timer, mapped_math, env);
	} else {
		chunks = splitByNumber(decls, s2i(split_by));
		ruMapDeclsConcurrentlyByChunks(chunks, f, time_limit, timer, mapped_math, env);
	}
}

ruMapDeclsConcurrentlyAll(decls : [RuDecl], f : RuMapFn, time_limit : double, timer : RuTimer, mapped_math : RuMappedMath, env : RuEnv) -> RuMappedMath {
	measures = ruDecls2Measures(decls, f);
	sum_measure = ruSumDoublesFromArray(measures);
	mapped = filtermap(ruConcurrent(mapi(decls, \i, d -> \env1 -> {
		if (ruTimeLeft(timer) <= 0.0) None() else {
			Some(f.func(d, time_limit * i2d(availableProcessors()) * measures[i] / sum_measure, env1))
		}
	}), env), idfn);
	fold(mapped, mapped_math, \acc, m -> ruAddMappedDecl2MappedMath(acc, m, env));
}

ruMapDeclsConcurrentlyByChunks(chunks : [[RuDecl]], f : RuMapFn, time_limit : double, timer : RuTimer, mapped_math : RuMappedMath, env : RuEnv) -> RuMappedMath {
	chunk_measures = map(chunks, \chunk -> ruDecls2Measures(chunk, f));
	sum_chunk_measures = map(chunk_measures, ruSumDoublesFromArray);
	total_measure = ruSumDoublesFromArray(sum_chunk_measures);
	planned_times = map(sum_chunk_measures, \m -> 
		time_limit * m / total_measure
	);
	planned_passed = mapi(sum_chunk_measures, \i,__ -> 
		ruSumDoublesFromArray(map(enumFromTo(0, i - 1), \j -> planned_times[j]))
	);
	planned_left = map(planned_passed, \passed -> time_limit - passed);
	foldi(chunks, mapped_math, \n, acc, chunk -> {
		left_time = ruTimeLeft(timer);
		if (left_time <= 0.0) acc else {
			time_planned_on_chunk = time_limit * sum_chunk_measures[n] / total_measure;
			time_left_on_chunk = time_planned_on_chunk * left_time / planned_left[n];
			scaled_time_limit_on_chunk = time_left_on_chunk * i2d(availableProcessors());
			mapped = ruConcurrent(mapi(chunk, \i, decl -> 
				\env1 -> f.func(decl, scaled_time_limit_on_chunk * chunk_measures[n][i] / sum_chunk_measures[n], env1)
			), env);
			fold(mapped, acc, \ac, d -> ruAddMappedDecl2MappedMath(acc, d, env))
		}
	});
}

ruMapFnComm(unit : RuUnit, f : RuMapFn) -> RuState {
	task = unit.task;
	state = unit.state;
	out = unit.out;
	file = lookupTreeDef(task.args, "file", "");
	conf = state.conf;
	env = RuEnv(conf, out);
	math = ruMathFromSources(state.ru, env);
	if (ruVerbose(conf) >= 3) {
		out.onMessage("\t\tMap '" + f.info.name + "' task: " + ruTask2s(task));
	}
	target = ruDetermineTarget(task, math, env);
	decls = filter(ruTargetDecls(target, math, env), f.info.pred);
	time_limit = ruCalcTimeLimit(decls, f, task, conf);
	stats = ruMakeMapFnStats(time_limit, length(decls), ruProgressUpdateMs(task, conf), f.info, out);
	prog_f = RuMapFn(f with func = ruWrapFnWithProgress(f, stats));
	ruMapDeclsStartMessage(decls, time_limit, env);
	if (ruVerbose(conf) > 0) {
		ruTrackProgress(stats.progress);
	}
	timer = ruMakeTimer();
	initial = ref true;
	proc_cycle = \mapped_math0 -> {
		initial := false;
		to_proc = filter(decls, \d -> !containsSet(mapped_math0.successes, d.info.id));
		mapped_math = RuMappedMath(mapped_math0 with fails = makeSet());
		stats.failed := 0;
		new_time_limit = time_limit - ruTimePassed(timer);
		if (length(to_proc) != length(decls)) {
			out.onMessage("Another try to process " + i2s(length(to_proc)) + " failed decls, time limit: " + ruTime2s(new_time_limit));
		}
		if (!ruTargetIsConcurrent(target) || length(to_proc) == 1) {
			ruMapDeclsSequentially(to_proc, prog_f, new_time_limit, stats.progress.timer, mapped_math, env);
		} else {
			ruMapDeclsConcurrently(to_proc, prog_f, new_time_limit, stats.progress.timer, mapped_math, env);
		}
	}
	mapped = for(
		RuMappedMath(math, makeSet(), makeSet()), 
		\mm -> (
			(time_limit - ruTimePassed(timer)) >= 0.0 && 
			(sizeSet(mm.fails) > 0 || ^initial)
		), 
		proc_cycle
	);
	failed = set2array(mapped.fails);
	if (length(failed) > 0) {
		head = map(take(failed, 128), id2s);
		failed_ids = if (length(failed) <= 128) head else concat(head, ["..."]);
		out.onMessage("Failed " + i2s(length(failed)) + ":\n" + 
			strIndent(concatStrings(map(failed_ids, \s -> "\t" + s + "\n")))
		);
	} else if (conf.verbose > 0) {
		out.onMessage("All " + i2s(length(decls)) + " declarations are mapped successfully");
	}
	stats.progress.isOn := false;
	ruMapDeclsEndMessage(stats, f.info.name, ruTarget2s(target), decls, env);
	ruMapDeclsResult(state, mapped.math.sources, f.info.name, stats);
}

ruMapDeclsResult(state : RuState, mapped : Tree<int, RuSource>, f_name : string, stats : RuMapFnStats) -> RuState {
	RuState(state with 
		ru = mapped,
		vars = mergeTree(state.vars, pairs2tree([
			Pair(f_name + ".counter", ValInt(^(stats.progress.counter))),
			Pair(f_name + ".total", ValInt(stats.progress.total)),
			Pair(f_name + ".failed", ValInt(^(stats.failed))),
			Pair(f_name + ".replaced", ValInt(^(stats.replaced))),
			Pair(f_name + ".max_time", ValDouble(^(stats.max_time))),
			Pair(f_name + ".max_time_id", ValString(id2s(^(stats.max_time_id)))),
			Pair(f_name + ".time", ValDouble(ruTimePassed(stats.progress.timer)))
		]))
	);
}

ruMapDeclsStartMessage(decls : [RuDecl], time_limit : double, env : RuEnv) -> void {
	conf = env.conf;
	out = env.out;
	if (ruVerbose(conf) > 0) {
		out.onMessage(
			"\tgoing to process " + i2s(length(decls)) + " declarations\n" +
			"\ttime limit: " + ruTime2s(time_limit) + " (" + d2st(time_limit / 1000.0, 2) + "s)" +
			(if (ruVerbose(conf) >= 2) "\n\ttime limit per unit: " + ruTime2s(time_limit / i2d(length(decls))) else "")
		);
		if (ruVerbose(conf) > 2) {
			out.onMessage("\tdecls:\n" + 
				strGlue(map(decls, \d -> "\t" + id2s(d.info.id)), "\n") + "\n\n"
			);
		}
	}
}

ruMapDeclsEndMessage(stats : RuMapFnStats, f_name : string, target : string, decls : [RuDecl], env : RuEnv) -> void {
	conf = env.conf;
	out = env.out;
	if (ruVerbose(conf) > 0 && length(decls) > 0) {
		msg = if (length(decls) == 1) { 
			"ru mapped '" + f_name + "' to '" + target + "' in " + ruTime2s(ruTimePassed(stats.progress.timer));
		} else {
			"ru mapped '" + f_name + "' to '" + target + "'" + 
				"\n\ttotal time:   " + ruTime2s(ruTimePassed(stats.progress.timer)) +
				"\n\tavg time:     " + ruTime2s(ruTimePassed(stats.progress.timer) / i2d(length(decls))) +
				"\n\tmax time:     " + ruTime2s(^(stats.max_time)) +
				"\n\tmax time id:  " + id2s(^(stats.max_time_id)) +
				"\n\twas failed:   " + i2s(^(stats.failed)) +
				"\n\tnot replaced: " + i2s(^(stats.replaced)) + 
				"\n\t%processed:   " + d2st(100.0 * i2d(^(stats.progress.counter)) / i2d(length(decls)), 2);
		}
		out.onMessage(msg);
	}
}
