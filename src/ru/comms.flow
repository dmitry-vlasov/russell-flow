import ru/parse/comms;
import ru/prover/comms;
import ru/refactor/comms;
import ru/verify/verify;
import ru/info;
import ru/ru2mm;

export {
	ruCommands : [RuComm];
}

ruCommands = concatA([
	[
		ruCommVerify,
		ruCommCyclicDeps,
		ruCommCyclicImports,
		ruApplyToProjectRoots(ruCommRu2Mm),
		ruCommActions,
		ruCommOrderSources
	],
	ruIoCommands,
	ruRefactorCommands,
	ruProverCommands,
	ruInfoCommands
]);

ruCommActions = RuComm(
	RuCommDescr(
		"actions", "misc", "available actions at the given position", "", false, false, 
		[
			RuCommArg("file", false, "input file", ""), 
			RuCommArg("line", false, "clear", ""), 
			RuCommArg("col", false, "clear", "")
		], []
	), 
	ruRunActions
);

ruRunActions(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	task = unit.task;
	actions = ["verify", "prove", "reprove", "generalize"];
	file = lookupTreeDef(task.args, "file", "");
	line = s2i(lookupTreeDef(task.args, "line", "-1"));
	col = s2i(lookupTreeDef(task.args, "col", "-1"));
	name = ruNameByLineCol(line, col, getFileContent(file));
	json = if (name == "") JsonArray([]) else {
		JsonArray(map(actions, \action -> 
			lspCodeAction2Json(LspCodeAction(
				action + " " + name, action, [], false, None(),
				Some(LspCommand(
					action + " " + name,
					"command",
					map(["file=" + file, "read", ";", action, "target=" + name], 
						\arg -> JsonString(arg)
					)
				))
			))
		));
	}
	env.out.onMessage(json2string(json));
	Some(state);
}

ruCommCyclicDeps = RuComm(
	RuCommDescr(
		"cyclic-deps", "misc", "check on cyclic dependencies", "target", false, false, 
		[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "all")], []
	),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		if (ruHasCyclicDependencies(ruMakeMathFromSources(state.ru, env), env)) None() else Some(state);
	}
);

ruHasCyclicDependencies(math : RuMath, env : RuEnv) -> bool {
	all_deps = ruMathAssertionDependencies(math, env);
	ret = foldTree(math.assertions, false, 
		\id, __, acc -> {
			deps = lookupTreeDef(all_deps, id, makeSet());
			ret = if (containsSet(deps, id)) {
				env.out.onMessage("Cyclic dependency found: " + id2s(id) + " dependes on: " + strGlue(map(set2array(deps), id2s), ", "));
				true;
			} else {
				if (ruVerbose(env.conf) >= 2) {
					details = if (ruVerbose(env.conf) >= 3) ": " + strGlue(map(set2array(deps), id2s), ", ") else ", ";
					env.out.onMessage("Assertion " + id2s(id) + " has " + i2s(sizeSet(deps)) + " dependencies" + details + "yet no cyclic are found");
				}
				false;
			}
			ret || acc;
		}
	)
	if (ruVerbose(env.conf) > 0 && !ret) {
		env.out.onMessage("No cyclic dependencies are found in " + i2s(sizeTree(math.assertions)) + " assertions");
	}
	ret;
}

ruCommCyclicImports = RuComm(
	RuCommDescr(
		"cyclic-imports", "misc", "check on cyclic imports", "target", false, false, 
		[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "all")], []
	),
	\unit -> {
		env = ruUnitEnv(unit);
		state = unit.state;
		if (ruHasCyclicImports(ruMakeMathFromSources(state.ru, env), env)) None() else Some(state);
	}
);

ruHasCyclicImports(math : RuMath, env : RuEnv) -> bool {
	all_deps = ruMathAllImported(math, env);
	if (ruVerbose(env.conf) >= 3) {
		env.out.onMessage("\t\timports data collected");
	}
	ret = foldTree(math.sources, false, 
		\id, __, acc -> {
			deps = lookupTreeDef(all_deps, id, makeSet());
			ret = if (containsSet(deps, id)) {
				env.out.onMessage("Cyclic import is found: '" + id2s(id) + "' imports on:\n" + strIndent(strGlue(map(set2array(deps), id2s), "\n")));
				true;
			} else {
				if (ruVerbose(env.conf) >= 2) {
					details = if (ruVerbose(env.conf) >= 3) ": " + strGlue(map(set2array(deps), id2s), ", ") else ", ";
					env.out.onMessage("Module '" + id2s(id) + "' has " + i2s(sizeSet(deps)) + " imports" + details + "yet no cyclic are found");
				}
				false;
			}
			ret || acc;
		}
	)
	if (ruVerbose(env.conf) > 0 && !ret) {
		env.out.onMessage("No cyclic imports are found in " + i2s(sizeTree(math.sources)) + " modules");
	}
	ret;
}

ruCommOrderSources = RuComm(
	RuCommDescr("order-sources", "misc", "show the toposort of sources", "", false, false, [], []),
	\unit -> {
		env = ruUnitEnv(unit);
		order = ruOrderSources(unit.state.ru);
		env.out.onMessage("order of sources:\n" + strIndent(strGlue(map(order, \s -> s.info.module), "\n")));
		Some(unit.state);
	}
);