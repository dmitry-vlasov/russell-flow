import ru/parse/comms;
import ru/prover/comms;
import ru/refactor/comms;
import ru/verify;
import ru/info;
import ru/to_mm;

export {
	ruCommands : [RuComm];
}

ruCommands = concatA([
	[
		ruCommVerify,
		ruCommCyclicDeps,
		ruCommCyclicImports,
		ruApplyToProjectRoots(ruCommRu2Mm),
		ruCommActions
	],
	ruIoCommands,
	ruRefactorCommands,
	ruProverCommands,
	ruInfoCommands
]);

ruCommActions = RuComm(
	"actions", "misc", "available actions at the given position", "",
	[
		RuCommArg("file", false, "input file", ""), 
		RuCommArg("line", false, "clear", ""), 
		RuCommArg("col", false, "clear", "")
	], 
	ruRunActions
);

ruRunActions(task : ScTask, env : RuState) -> Maybe<RuState> {
	actions = ["verify", "prove", "reprove", "generalize"];
	file = lookupTreeDef(task.args, "file", "");
	line = s2i(lookupTreeDef(task.args, "line", "-1"));
	col = s2i(lookupTreeDef(task.args, "col", "-1"));
	name = ruNameByLineCol(line, col, getFileContent(file));
	json = if (name == "") JsonArray([]) else {
		JsonArray(map(actions, \action -> 
			lspCodeAction2Json(LspCodeAction(
				action + " " + name, action, [], false, None(),
				Some(LspCommand(
					action + " " + name,
					"command",
					map(["file=" + file, "read", ";", action, "target=" + name], 
						\arg -> JsonString(arg)
					)
				))
			))
		));
	}
	env.conf.onMessage(json2string(json));
	Some(env);
}

ruCommCyclicDeps = RuComm(
	"cyclic-deps", "misc", "check on cyclic dependencies", "target",
	[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
	\task, env -> if (ruHasCyclicDependencies(env.ruMath, env.conf)) None() else Some(env));

ruHasCyclicDependencies(math : RuMath, conf : RuConf) -> bool {
	start = timestamp();
	all_deps = ruMathAssertionDependencies(math, conf);

	ret = foldTree(math.assertions, false, 
		\name, __, acc -> {
			deps = lookupTreeDef(all_deps, name, makeSet());
			ret = if (containsSet(deps, name)) {
				conf.onMessage("Cyclic dependency found: " + name + " dependes on: " + strGlue(set2array(deps), ", "));
				true;
			} else {
				if (conf.verbose >= 2) {
					details = if (conf.verbose >= 3) ": " + strGlue(set2array(deps), ", ") else ", ";
					conf.onMessage("Assertion " + name + " has " + i2s(sizeSet(deps)) + " dependencies" + details + "yet no cyclic are found");
				}
				false;
			}
			ret || acc;
		}
	)
	if (conf.verbose > 0 && !ret) {
		conf.onMessage("No cyclic dependencies are found in " + i2s(sizeTree(math.assertions)) + " assertions");
	}
	ret;
}

ruCommCyclicImports = RuComm(
	"cyclic-imports", "misc", "check on cyclic imports", "target",
	[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "")],
	\task, env -> if (ruHasCyclicImports(env.ruMath, env.conf)) None() else Some(env)
);

ruHasCyclicImports(math : RuMath, conf : RuConf) -> bool {
	start = timestamp();
	all_deps = ruMathAllImported(math, conf);
	if (conf.verbose >= 3) {
		conf.onMessage("\t\timports data collected");
	}

	ret = foldTree(math.sources, false, 
		\name, __, acc -> {
			deps = lookupTreeDef(all_deps, name, makeSet());
			ret = if (containsSet(deps, name)) {
				conf.onMessage("Cyclic import is found: " + name + " imports on: " + strGlue(set2array(deps), ", "));
				true;
			} else {
				if (conf.verbose >= 2) {
					details = if (conf.verbose >= 3) ": " + strGlue(set2array(deps), ", ") else ", ";
					conf.onMessage("Module " + name + " has " + i2s(sizeSet(deps)) + " imports" + details + "yet no cyclic are found");
				}
				false;
			}
			ret || acc;
		}
	)
	if (conf.verbose > 0 && !ret) {
		conf.onMessage("No cyclic imports are found in " + i2s(sizeTree(math.sources)) + " modules");
	}
	ret;
}
