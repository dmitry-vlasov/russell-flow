import base/util/concurrent;
import ru/util/utils;

export {
	ruRuleCacheClear() -> void;
	ruRuleCacheAdd(src : RuSource, env : RuEnv) -> void;
	ruRuleCacheGet() -> Tree<int, RuRule>;
	ruRuleCacheInfo(full : bool) -> string;
}

ruRuleCache : ref Tree<int, RuRule> = ref makeTree();

ruRuleCacheClear() -> void {
	ruRuleCache := makeTree();
}

ruRuleCaheSet = ruMakeAtomicSetTree(ruRuleCache);

ruRuleCacheAdd(src : RuSource, env : RuEnv) -> void {
	iter(src.decls, \decl ->
		switch (decl) {
			RuRule(descr,__,__): {
				ruRuleCaheSet(descr.id, decl);
				{}
			}
			RuType(descr,supers): {
				iter(supers, \super -> {
					rule = ruMakeSuperRule(super, descr.id, descr.src, descr.pos);
					ruRuleCaheSet(rule.descr.id, rule); {}
				});
			}
			default: {}
		}
	);
}

ruRuleCacheGet() -> Tree<int, RuRule> {
	^ruRuleCache;
}

ruRuleCacheInfo(full : bool) -> string {
	"rules in cache: " + i2s(sizeTree(^ruRuleCache)) + 
	if (!full) "" else {
		"\n" + strIndent(strGlue(map(getTreeKeys(^ruRuleCache), id2s), "\n"))
	}
}