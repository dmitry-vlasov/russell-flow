import ru/util/utils;

export {
	// Cached source code.
	RuCachedSourceCode(
		code : string,
		modified : double
	);

	ruClearSourceCodeCache() -> void;
	// Lookups a cached file source, if not found - loads and stores.
	ruFileSourceCode(path : string) -> string;
	// Stores a certain string as a source for some path.
	ruSetFileSourceCode(path : string, src : string) -> void;
	// Loads file source from filesystem. May be used to undo fcSetFileSource function.
	ruLoadFileSourceCode(path : string) -> void;
	// Remove a file source code from cache
	ruRemoveFileSourceCode(path : string) -> void;

	// Shows cache statistics
	ruSourceCodeCacheInfo(full : bool) -> string;

	// Range of a declaration in a source code
	ruDeclRange(d : RuDecl, src : RuSource) -> RuRange;

	// A fragment of source code, containing decl
	ruDeclCode(d : RuDecl, src : RuSource) -> string;
}

ruSourceCodeCache = initConcurrentHashMap();

ruClearSourceCodeCache() -> void {
	clearConcurrentHashMap(ruSourceCodeCache);
}

ruFileSourceCode(path : string) -> string {
	if (!containsConcurrentHashMap(ruSourceCodeCache, path)) {
		setConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode(getFileContent(path), fileModified(path)));
	}
	cached = getConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode("", 0.0));
	modified = fileModified(path);
	if (cached.modified != modified) {
		// Reload outdated source.
		text = getFileContent(path);
		setConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode(text, modified));
		text;
	} else {
		cached.code;
	}
}

ruSetFileSourceCode(path : string, text : string) -> void {
	if (!containsConcurrentHashMap(ruSourceCodeCache, path)) {
		setConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode(text, fileModified(path)));
	} else {
		cached = getConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode("", 0.0));
		setConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode(text, cached.modified));
	}
}

ruLoadFileSourceCode(path : string) -> void {
	setConcurrentHashMap(ruSourceCodeCache, path, RuCachedSourceCode(getFileContent(path), fileModified(path)));
}

ruRemoveFileSourceCode(path : string) -> void {
	removeConcurrentHashMap(ruSourceCodeCache, path);
}

ruSourceCodeCacheInfo(full : bool) -> string {
	if (full) {
		"cached source code texts:\n" + strGlue(map(keysConcurrentHashMap(ruSourceCodeCache), \n -> "\t" + n),"\n")
	} else {
		"cached source code texts: " + i2s(sizeConcurrentHashMap(ruSourceCodeCache))
	}
}

ruDeclRange(d : RuDecl, src : RuSource) -> RuRange {
	ind = ruIndexOfDecl(d.descr.id, src);
	if (ind < 0) RuRange(-1, -1) else {
		text = ruFileSourceCode(src.info.path);
		start = ruStartPosition(d);
		end = if (ind + 1 < length(src.decls)) {
			src.decls[ind + 1].descr.pos;
		} else {
			strlen(text);
		}
		switch (d) {
			RuTheorem(__,__,__,__):
				RuRange(start, strRangeIndexOf(text, "proof {", start, end));
			default: RuRange(start, end);
		}
	}
}

ruDeclCode(decl : RuDecl, src : RuSource) -> string {
	range = ruDeclRange(decl, src);
	code = ruFileSourceCode(src.info.path);
	ruTrimAll(substring(code, range.start, range.end - range.start));
}