import ru/util/utils;

export {
	// Cached source code.
	RuCode(
		code : string,
		modified : double
	);
	ruNoCode = RuCode("", 0.0);

	ruCodeCacheClear() -> void;
	// Lookups a cached file source, if not found - loads and stores.
	ruCodeCacheGet(id : int, env : RuEnv) -> RuCode;
	// Stores a certain string as a source for some path.
	ruCodeCacheSet(id : int, src : string, env : RuEnv) -> void;
	// Loads file source from filesystem. May be used to undo fcSetFileSource function.
	ruCodeCacheLoad(id : int, env : RuEnv) -> void;
	// Remove a file source code from cache
	ruCodeCacheRemove(id : int, env : RuEnv) -> void;

	// Shows cache statistics
	ruCodeCacheInfo(full : bool) -> string;

	// Range of a declaration in a source code
	ruDeclRange(d : RuDecl, src : RuSource, env : RuEnv) -> RuRange;

	// A fragment of source code, containing decl
	ruDeclCode(d : RuDecl, src : RuSource, env : RuEnv) -> string;
}

ruCodeCache = initConcurrentHashMap();

ruCodeCacheClear() -> void {
	clearConcurrentHashMap(ruCodeCache);
}

ruCodeCacheGet(id : int, env : RuEnv) -> RuCode {
	file = id2s(id);
	path = ruFindPath(file, env.conf, ".ru");
	if (!fileExists(path)) {
		env.out.onMessage("source file: '" + file + "' doesn't exist");
	}
	if (!containsConcurrentHashMap(ruCodeCache, id)) {
		if (!fileExists(path)) ruNoCode else {
			code = RuCode(getFileContent(path), fileModified(path));
			setConcurrentHashMap(ruCodeCache, path, code);
			code;
		}
	} else {
		cached = getConcurrentHashMap(ruCodeCache, id, ruNoCode);
		modified = fileModified(path);
		if (cached.modified != modified) {
			// Reload outdated source.
			text = getFileContent(path);
			code = RuCode(text, modified);
			setConcurrentHashMap(ruCodeCache, path, code);
			code;
		} else {
			cached;
		}
	}
}

ruCodeCacheSet(id : int, code : string, env : RuEnv) -> void {
	setConcurrentHashMap(ruCodeCache, id, RuCode(code, timestamp()));
}

ruCodeCacheLoad(id : int, env : RuEnv) -> void {
	file = id2s(id);
	path = ruFindPath(file, env.conf, ".ru");
	if (!fileExists(path)) {
		env.out.onMessage("source file: '" + file + "' doesn't exist");
		removeConcurrentHashMap(ruCodeCache, id);
	} else {
		code = RuCode(getFileContent(path), fileModified(path));
		setConcurrentHashMap(ruCodeCache, path, code);
	}
}

ruCodeCacheRemove(id : int, env : RuEnv) -> void {
	removeConcurrentHashMap(ruCodeCache, id);
}

ruCodeCacheInfo(full : bool) -> string {
	if (full) {
		"cached source code texts:\n" + strGlue(map(keysConcurrentHashMap(ruCodeCache), \n -> "\t" + n),"\n")
	} else {
		"cached source code texts: " + i2s(sizeConcurrentHashMap(ruCodeCache))
	}
}

ruDeclRange(d : RuDecl, src : RuSource, env : RuEnv) -> RuRange {
	ind = ruIndexOfDecl(d.descr.id, src);
	if (ind < 0) RuRange(-1, -1) else {
		code = ruCodeCacheGet(src.info.id, env).code;
		start = ruStartPosition(d);
		end = if (ind + 1 < length(src.decls)) {
			src.decls[ind + 1].descr.pos;
		} else {
			strlen(code);
		}
		switch (d) {
			RuTheorem(__,__,__,__):
				RuRange(start, strRangeIndexOf(code, "proof {", start, end));
			default: RuRange(start, end);
		}
	}
}

ruDeclCode(decl : RuDecl, src : RuSource, env : RuEnv) -> string {
	range = ruDeclRange(decl, src, env);
	code = ruCodeCacheGet(decl.descr.src, env).code;
	ruTrimAll(substring(code, range.start, range.end - range.start));
}