import ru/cache/code;

export {
	ruSourceCacheClear() -> void;
	ruSourceCacheAdd(src : RuSource, env : RuEnv) -> void;
	ruSourceCacheRemove(id : int, env : RuEnv) -> void;
	ruSourceCacheGet(id : int, env : RuEnv) -> Maybe<RuSource>;
	ruSourceCacheContains(id : int, env : RuEnv) -> bool;
	ruSourceCacheAll(env : RuEnv) -> [RuSource];

	ruSourceCacheInfo(full : bool) -> string;
}

ruSourceCache = initConcurrentHashMap();

ruSourceCacheClear() -> void {
	clearConcurrentHashMap(ruSourceCache);
}

ruSourceCacheAdd(src : RuSource, env : RuEnv) -> void {
	setConcurrentHashMap(ruSourceCache, src.info.id, Some(src));
}

ruSourceCacheRemove(id : int, env : RuEnv) -> void {
	removeConcurrentHashMap(ruSourceCache, id);
}

ruSourceCacheGet(id : int, env : RuEnv) -> Maybe<RuSource> {
	switch (getConcurrentHashMap(ruSourceCache, id, None())) {
		Some(cached): {
			code = ruCodeCacheGet(id, env);
			if (code.modified == cached.info.modified) Some(cached) else {
				removeConcurrentHashMap(ruSourceCache, id);
				None();
			}
		}
		None(): None();
	}
}

ruSourceCacheContains(id : int, env : RuEnv) -> bool {
	containsConcurrentHashMap(ruSourceCache, id);
}

ruSourceCacheAll(env : RuEnv) -> [RuSource] {
	filtermap(
		map(keysConcurrentHashMap(ruSourceCache), \id -> ruSourceCacheGet(id, env)), 
		idfn
	);
}

ruSourceCacheInfo(full : bool) -> string { 
	if (!full) {
		"cached sources: " + i2s(sizeConcurrentHashMap(ruSourceCache));
	} else {
		"cached sources:\n" + strGlue(map(keysConcurrentHashMap(ruSourceCache), \id -> "\t" + id2s(id)), "\n");
	};
}
