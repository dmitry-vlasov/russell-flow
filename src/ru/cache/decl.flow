/*import text/binary;
import formats/lsp;
import base/util/concurrent;
import base/log;*/
//import ru/cache/code;
//import ru/cache/def;
import ru/util/src;

export {
	ruDeclCacheClear() -> void;
	ruDeclCacheAdd(src : RuSource, env : RuEnv) -> void;
	ruDeclCacheRemove(src : RuSource, env : RuEnv) -> void;
	ruDeclCacheGet(id : int) -> Maybe<RuDecl>;
	//ruDefDeclCacheGet(id : int) -> Maybe<RuDecl>;
	ruDeclCacheAll() -> [RuDecl];
	ruDeclCacheAssertions() -> Tree<string, RuAssertion>;
	ruDeclCacheTheoremAxioms() -> Tree<string, Set<string>>;

	// Shows cache statistics
	ruDeclCacheInfo(full : bool) -> string;
	// Declaration statistics
	ruDeclCacheStats(mode : [string], env : RuEnv) -> string;

	//ruDeclRange(d : RuDecl, src : RuSource) -> RuRange;
	//ruDeclCacheTheoremAxioms() -> Tree<string, Set<string>>;
}

ruDeclCache = initConcurrentHashMap();

ruDeclCacheClear() -> void {
	clearConcurrentHashMap(ruDeclCache);
}

ruDeclCacheAdd(src : RuSource, env : RuEnv) -> void {
	iter(src.decls, \decl ->
		setConcurrentHashMap(ruDeclCache, decl.descr.id, Some(decl))
	);
}

ruDeclCacheRemove(src : RuSource, env : RuEnv) -> void {
	iter(src.decls, \decl ->
		removeConcurrentHashMap(ruDeclCache, id2s(decl.descr.id))
	);
}

ruDeclCacheGet(id : int) -> Maybe<RuDecl> {
	getConcurrentHashMap(ruDeclCache, id, None());
}

/*ruDefDeclCacheGet(id : int) -> Maybe<RuDecl> {
	switch (ruDefCacheGet(id)) {
		Some(def): Some(def);
		None(): getConcurrentHashMap(ruDeclCache, id, None());
	}
}*/

ruDeclCacheAll() -> [RuDecl] {
	filtermap(valuesConcurrentHashMap(ruDeclCache), idfn);
}

ruDeclCacheAssertions() -> Tree<string, RuAssertion> {
	pairs2tree(
		filtermap(ruDeclCacheAll(), \decl : RuDecl -> {
			id = decl.descr.id;
			switch (decl) {
				RuConst(__,__,__):      None();
				RuType(__,__):          None();
				RuRule(__,__,__):       None();
				RuAxiom(__,__):         Some(Pair(id2s(id), decl));
				RuDef(__,__,__,__):     Some(Pair(id2s(id), decl));
				RuTheorem(__,__,__,__): Some(Pair(id2s(id), decl));
			}
		})
	);
}
/*
ruDeclCacheId2s(id : int, env : RuEnv) -> string {
	switch (ruDeclCacheGet(id)) {
		Some(decl): {
			range = ruDeclRange(decl, cached.source);
			code = ruFileSourceCode(dcached.source.info.path);
			ruTrimAll(substring(text, range.start, range.end - range.start));
		}
		None(): "";
	}
	strGlue(
		filtermap(ruDeclCacheAll(name), \decl -> {
			range = ruDeclRange(d.decl, cached.source);
			text = ruFileSource(cached.source.info.path);
			ruTrimAll(substring(text, range.start, range.end - range.start));
		}), "\n"
	);
}

ruCachedDecl2LspSymbolInfos(name : string, env : RuEnv) -> [LspSymbolInformation] {
	filtermap(ruCachedDecl(name), \d -> 
		maybeMap(ruFromCache(d.info.id, env), \cached -> {
			range = ruDeclRange(d.decl, cached.source);
			location = ruRange2LspLocation(range, cached.source.info.path);
			LspSymbolInformation(name, ruDecl2LspSymbolKind(d.decl), false, location, "");
		})
	)
}*/

ruDeclCacheInfo(full : bool) -> string {
	"cached declarations: " + i2s(sizeConcurrentHashMap(ruDeclCache));
}

RuDeclInfoAcc(
	consts   : [RuConst],
	types    : [RuType],
	rules    : [RuRule],
	axioms   : [RuAxiom],
	defs     : [RuDef],
	theorems : [RuTheorem]
);

ruDeclCacheStats(mode : [string], env : RuEnv) -> string {
	opts = buildSet(mode);
	info_acc = fold(
		filtermap(valuesConcurrentHashMap(ruDeclCache), idfn), 
		RuDeclInfoAcc([], [], [], [], [], []),
		\acc, decl -> {
			switch (decl) {
				RuConst(__,__,__):      RuDeclInfoAcc(acc with consts = concat(acc.consts, [decl]));
				RuType(__,__):          RuDeclInfoAcc(acc with types  = concat(acc.types,  [decl]));
				RuRule(__,__,__):       RuDeclInfoAcc(acc with rules  = concat(acc.rules,  [decl]));
				RuAxiom(__,__):         RuDeclInfoAcc(acc with axioms = concat(acc.axioms, [decl]));
				RuDef(__,__,__,__):     RuDeclInfoAcc(acc with defs   = concat(acc.defs,   [decl]));
				RuTheorem(__,__,__,__): RuDeclInfoAcc(acc with theorems = concat(acc.theorems, [decl]));
			}
		}
	);
	rules = fold(info_acc.rules, makeTree(), \acc, r -> setTree(acc, r.descr.id, r));
	math = RuMath(ruEmptyMath with decls = RuDecls(ruEmptyDecls with rules = rules));
	"consts:   " + i2s(length(info_acc.consts)) + "\n" + 
	"types:    " + i2s(length(info_acc.types)) + "\n" + 
	"rules:    " + i2s(length(info_acc.rules)) + "\n" + 
	"axioms:   " + i2s(length(info_acc.axioms)) + "\n" + 
	"defs:     " + i2s(length(info_acc.defs)) + "\n" + 
	"theorems: " + i2s(length(info_acc.theorems)) + "\n" + 
	(if (containsSet(opts, "consts") || containsSet(opts, "all")) {
		"consts:\n" + strGlue(map(info_acc.consts, \c -> "\t" + id2s(c.descr.id)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "types") || containsSet(opts, "all")) {
		"types:\n" + strGlue(map(info_acc.types, \t -> "\t" + ru2s(t, math)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "rules") || containsSet(opts, "all")) {
		"rules:\n" + strGlue(map(info_acc.rules, \r -> "\t" + ru2s(r, math)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "axioms") || containsSet(opts, "all")) {
		"axioms:\n" + strGlue(map(info_acc.axioms, \a -> "\t" + id2s(a.descr.id)), "\n") + "\n"
	} else "") +
	(if (containsSet(opts, "defs") || containsSet(opts, "all")) {
		"defs:\n" + strGlue(map(info_acc.defs, \d -> "\t" + id2s(d.descr.id)), "\n") + "\n"
	} else "");
}

ruDeclCacheTheoremAxioms() -> Tree<string, Set<string>> {
	assertions = ruDeclCacheAssertions();
	foldTree(assertions, makeTree(), \name, __, acc -> ruDoCachedTheoremAxioms(assertions, name, acc));
}

ruDoCachedTheoremAxioms(assertions : Tree<string, RuAssertion>, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(assertions, as_name)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(descr,__,__,proof): {
					switch (lookupTree(acc, id2s(descr.id))) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoCachedTheoremAxioms(assertions, id2s(step.assertion), ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, id2s(step.assertion), makeSet())));
							setTree(acc1, id2s(descr.id), axioms);
						}
					}
				}
				RuAxiom(descr,__):     setTree(acc, id2s(descr.id), makeSet1(id2s(descr.id)));
				RuDef(descr,__,__,__): setTree(acc, id2s(descr.id), makeSet());
			}
		}
		None(): acc;
	}
}
