import ru/subst;
import base/util/math;
import base/stats;

export {
	ruUnifyExps(es : [RuExp], sub : RuSubst, math : RuMath, env : RuEnv) -> Maybe<RuSubst>;
	ruUnifySubs(subs : [RuSubst], math : RuMath, env : RuEnv) -> Maybe<RuSubst>;
}

ruUnifyExps(es : [RuExp], sub : RuSubst, math : RuMath, env : RuEnv) -> Maybe<RuSubst> {
	if (length(es) <= 1) Some(sub) else {
		ruDoUnifyExps(es, RuUnifyAcc(sub, map(es, \__ -> 0), math, env))
	}
}

RuUnifyAcc(
	sub : RuSubst,
	inds : [int],
	math : RuMath,
	env : RuEnv
);

RuUnifyStepAcc(
	shift : Vector<int>,
	vars  : Vector<RuVar>,
	exprs : Vector<RuExp>,
	rule_id : int,
	type_id : int,
	ok    : bool,
	all_rules : bool
);

ruUnifyStepVar(step : RuUnifyStepAcc, math : RuMath, env : RuEnv) -> Maybe<RuVar> {
	v0 = getVectorUnsafe(step.vars, 0);
	maybeBind(
		foldiVector(step.vars, Some(v0), \i, acc, v -> {
			if (i == 0) acc else 
			maybeBind(acc, \t -> 
				if (v.type == t.type || isSome(ruSuperRule(v.type, t.type, math.decls.lang, env))) Some(v) else
				if (v.type == t.type || isSome(ruSuperRule(t.type, v.type, math.decls.lang, env))) Some(t) else None()
			)
		}),
		\v -> if (step.type_id == -1 || v.type == step.type_id || isSome(ruSuperRule(v.type, step.type_id, math.decls.lang, env))) Some(v) else None()
	);
}

ruDoUnifyStep(es : [RuExp], acc : RuUnifyAcc) -> RuUnifyStepAcc {
	size = length(es);
	foldi(
		mapi(es, \i, e -> e.nodes[acc.inds[i]]), 
		RuUnifyStepAcc(makeVector(size), makeVector(size), makeVector(size), -1, -1, true, true), 
		\i, ac, n ->
		switch (n) {
			RuVar(__,__): {
				switch (ruLookupSubst(acc.sub, n)) {
					None(): {
						pushVector(ac.shift, 1);
						pushVector(ac.vars, n);
						RuUnifyStepAcc(ac with
							all_rules = false
						)
					}
					Some(ex): {
						m = ex.nodes[0];
						switch (m) {
							RuRuleNode(rule_id, type_id, __,len): {
								pushVector(ac.shift, 1);
								pushVector(ac.exprs, ex);
								RuUnifyStepAcc(ac with 
									rule_id = rule_id,
									type_id = type_id,
									ok = ac.ok && (ac.rule_id == -1 || rule_id == ac.rule_id),
									all_rules = false
								);
							}
							RuVar(__,__): {
								pushVector(ac.shift, 1);
								pushVector(ac.vars, m);
								RuUnifyStepAcc(ac with 
									all_rules = false
								)
							}
						}
					}
				}
			}
			RuRuleNode(rule_id, type_id,__, len): {
				pushVector(ac.shift, len + 1);
				pushVector(ac.exprs, RuExp(subrange(es[i].nodes, acc.inds[i], len + 1), es[i].pos));
				RuUnifyStepAcc(ac with 
					rule_id = rule_id, 
					type_id = type_id, 
					ok = ac.ok && (ac.rule_id == -1 || rule_id == ac.rule_id), 
				);
			}
		}
	);
}

ruDoUnifyExps(es : [RuExp], acc : RuUnifyAcc) -> Maybe<RuSubst> {
	if (all(mapi(acc.inds, \i, n -> n == length(es[i].nodes)))) {
		Some(acc.sub) 
	} else {
		step = ruDoUnifyStep(es, acc);
		if (!step.ok) None() else {
			new_inds = \-> mapi(acc.inds, \j, i -> i + getVectorUnsafe(step.shift, j));
			if (step.rule_id != -1) {
				if (!step.all_rules) {
					step_exprs = vector2array(step.exprs);
					maybeBind(ruUnifyExps(step_exprs, acc.sub, acc.math, acc.env), \s -> {
						ex = ruApplySubst(step_exprs[0], s);
						maybeBind(
							foldVector(step.vars, Some(s), \ac, v -> 
								maybeBind(ac, \s1 -> ruAdd2Subst1(s1, v, ex, acc.math, acc.env))
							),
							\s1 -> ruDoUnifyExps(es, 
								RuUnifyAcc(acc with 
									sub = s1,
									inds = new_inds()
								)
							)
						);
					});
				} else {
					ruDoUnifyExps(es, RuUnifyAcc(acc with inds = map(acc.inds, \i -> i + 1)));
				}
			} else {
				maybeBind(ruUnifyStepVar(step, acc.math, acc.env), \w -> {
					ex = RuExp([w], -1);
					maybeBind(
						foldVector(step.vars, Some(acc.sub), \ac, v -> 
							maybeBind(ac, \s1 -> ruAdd2Subst1(s1, v, ex, acc.math, acc.env))
						),
						\s1 -> ruDoUnifyExps(es, 
							RuUnifyAcc(acc with
								sub = s1,
								inds = new_inds()
							)
						)
					);
				});
			}
		}
	}
}

ruUnifySubs(subs : [RuSubst], math : RuMath, env : RuEnv) -> Maybe<RuSubst> {
	t1 = ruMakeTimer();
	splited = ruSplitSubs(subs);
	if (lookupTreeDef(env.conf.opts, "reprove-stats", "") == "1") {
		stats = RuStatsRow("", 
			pairs2tree([
				Pair("size", i2d(fold(subs, 0, \acc, sub -> acc + ruSubstSize(sub)))), 
				Pair("time", ruTimePassed(t1)), 
				//Pair("rets", length(rets)),
				Pair("cplx", i2d(fold(subs, 0, \acc, sub -> acc + ruSubComplexity(sub))))
			])
		);
		ruAddStats("ruUnifySubs-split", stats);
	}
	t2 = ruMakeTimer();
	ret1 = maybeMap(
		ruDoUnifySubs(splited.depend, math, env),
		\sub -> ruMergeSubsUnsafe(splited.indep, sub) //RuSubst(mergeTree(splited.indep, sub.map))
	);
	if (lookupTreeDef(env.conf.opts, "reprove-stats", "") == "1") {
		stats = RuStatsRow("", 
			pairs2tree([
				Pair("size", i2d(fold(splited.depend, 0, \acc, sub -> acc + ruSubstSize(sub)))), 
				Pair("time", ruTimePassed(t2)), 
				//Pair("rets", ruSubComplexity(splited.second)),
				Pair("cplx", i2d(fold(splited.depend, 0, \acc, sub -> acc + ruSubComplexity(sub))))
			])
		);
		ruAddStats("ruUnifySubs-ruDoUnifySubs", stats);
	}
	ret1
}

ruDoUnifySubs(subs : [RuSubst], math : RuMath, env : RuEnv) -> Maybe<RuSubst> {
	foldSet(
		fold(subs, makeSet(), \acc, s -> 
			mergeSets(acc, buildSet(ruSubstVars(s)))
		),
		Some(ruMakeSubst()), 
		\acc, v ->
			maybeBind(acc, \sub -> {
				exprs = filtermap(subs, \s -> 
					maybeMap(ruLookupSubst(s, v), \e -> ruApplySubst(e, sub))
				);
				maybeBind(ruUnifyExps(exprs, sub, math, env), \sub1 -> {
					e1 = ruApplySubst(exprs[0], sub1);
					switch (ruLookupSubst(sub, v)) {
						None(): ruAdd2Subst1(sub1, v, e1, math, env);
						Some(e2):
							maybeBind(ruUnifyExps([e1, e2], sub1, math, env), \unif -> 
								ruCompose(sub1, unif)
							);
					}
				});
			})
	);
}
