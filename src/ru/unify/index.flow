import ds/list;
import ru/index;
import ru/unify/exps;

export {
	RuUnified(
		sub : Tree<RuVar, RuExp>,
		data : ?,
		expr : RuExp
	);
	ruUnifyIndex(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, conf : RuConf, time_limit : double) -> [RuUnified<?>];
}

ruUnifyIndex(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, conf : RuConf, time_limit : double) -> [RuUnified<?>] {
	list2array(
		ruDoUnifyIndex(
			0, index, math, conf, 
			RuUnifyIndexAcc(e, sub, ruMakeTimer(time_limit))
		)
	);
}

RuUnifyIndexAcc(
	expr : RuExp,
	sub : Tree<RuVar, RuExp>,
	timer : RuTimer
);

ruDoUnifyIndex(i : int, index : RuIndex<?>, math : RuMath, conf : RuConf, env : RuUnifyIndexAcc) -> List<RuUnified<?>> {
	if (ruTimeIsOver(env.timer)) makeList() else {
		unify_step = \j, var, end, ex -> {
			switch (lookupTree(env.sub, var)) {
				Some(ex1): {
					switch (ruUnifyExps([ex1, ex], env.sub, math, conf)) {
						Some(s): ruDoUnifyIndexNode(j, end, math, conf, RuUnifyIndexAcc(env with sub = s));
						None(): makeList();
					}
				}
				None():
					switch (ruAdd2Subst(env.sub, var, ex)) {
						Some(s): ruDoUnifyIndexNode(j, end, math, conf, RuUnifyIndexAcc(env with sub = s));
						None(): makeList();
					}
			}
		}
		unify_var = \j, var, ex_type, end, e ->
			if (ex_type == var.type) unify_step(j, var, end, e())
			else {
				switch (ruSuperRule(var.type, ex_type, math, conf)) {
					Some(sr): {
						ex = RuExp(concat([RuRuleRef(sr.descr.name, var.type, 1, 1)], e().nodes), -1);
						unify_step(j, var, end, ex);
					}
					None(): makeList()
				}
			}
		if (i < length(env.expr.nodes)) {
			switch (env.expr.nodes[i]) {
				RuRuleRef(name, type, arity, len): {
					unified_1 = switch (lookupTree(index.rules, name)) {
						Some(n): ruDoUnifyIndexNode(i, n, math, conf, env);
						None(): makeList();
					}
					ruFoldTree(index.vars, unified_1, \v, n, acc -> 
						concatList(acc,
							unify_var(i + len, RuVar(n.name, n.type), type, n, 
								\-> RuExp(subrange(env.expr.nodes, i, len + 1), -1)
							)
						),
						env.timer
					);
				}
				RuVar(name, type): {
					unfied_1 = ruFoldTree(index.rules, makeList(), \nm, n, acc ->
						ruFoldSet(n.ends, acc, \ac, e -> {
							end = ^(index.nodes)[e];
							concatList(ac,
								unify_var(i, RuVar(name, type), n.type, end, 
									\-> ruIndexSubexpr(n, end)
								)
							);
						}, env.timer),
						env.timer
					);
					ruFoldTree(index.vars, unfied_1, \v, n, acc -> 
						concatList(acc,
							unify_var(i, RuVar(n.name, n.type), type, n, 
								\-> RuExp([RuVar(name, type)], -1)
							)
						), env.timer
					);
				}
			}
		} else {
			makeList();
		}
	}
}

ruDoUnifyIndexNode(i : int, node : RuIndexNode<?>, math : RuMath, conf : RuConf, env : RuUnifyIndexAcc) -> List<RuUnified<?>> {
	if (ruTimeIsOver(env.timer)) makeList() else  {
		new_unified = if (i + 1 == length(env.expr.nodes)) {
			ruFold(node.data, makeList(), \acc, d -> 
				Cons(RuUnified(env.sub, d, ruApplySubst(env.expr, env.sub)), acc), env.timer
			);
		} else {
			makeList();
		}
		concatList(new_unified, 
			ruDoUnifyIndex(i + 1, node.index, math, conf, env)
		);
	}
}
