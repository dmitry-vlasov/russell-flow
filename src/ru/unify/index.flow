import ds/dlist;
import ds/list;
import ds/vector;
import base/util/timed;
import ru/index;
import ru/unify/exps;

export {
	RuUnified(
		sub : Tree<RuVar, RuExp>,
		data : ?,
		expr : RuExp
	);
	ruUnifyIndex(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, env : RuEnv, time_limit : double) -> [RuUnified<?>];
	ruUnifyIndex1(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, env : RuEnv, time_limit : double) -> [RuUnified<?>];
}


ruUnifyIndex2(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, env : RuEnv, time_limit : double) -> [RuUnified<?>] {
	vector2array(
		ruDoUnifyIndex2(
			0, index, math, env, 
			RuUnifyIndexAcc(e, sub, ruMakeLimitedTimer(time_limit))
		)
	);
}

ruDoUnifyIndex2(i : int, index : RuIndex<?>, math : RuMath, env : RuEnv, acc : RuUnifyIndexAcc) -> Vector<RuUnified<?>> {
	if (ruTimeIsOver(acc.timer)) {
		makeVector(0);
	} else {
		unify_step = \j, var, end, ex -> {
			switch (lookupTree(acc.sub, var)) {
				Some(ex1): {
					switch (ruUnifyExps([ex1, ex], acc.sub, math, env)) {
						Some(s): ruDoUnifyIndexNode2(j, end, math, env, RuUnifyIndexAcc(acc with sub = s));
						None(): makeVector(0);
					}
				}
				None():
					switch (ruAdd2Subst(acc.sub, var, ex)) {
						Some(s): ruDoUnifyIndexNode2(j, end, math, env, RuUnifyIndexAcc(acc with sub = s));
						None(): makeVector(0);
					}
			}
		}
		unify_var = \j, var, ex_type, end, e ->
			if (ex_type == var.type) unify_step(j, var, end, e())
			else {
				switch (ruSuperRule(var.type, ex_type, math.decls.lang, env)) {
					Some(sr): {
						ex = RuExp(concat([RuRuleNode(sr.info.id, var.type, 1, 1)], e().nodes), -1);
						unify_step(j, var, end, ex);
					}
					None(): makeVector(0);
				}
			}
		if (i < length(acc.expr.nodes)) {
			switch (acc.expr.nodes[i]) {
				RuRuleNode(rule, type, arity, len): {
					unified = switch (lookupTree(index.rules, rule)) {
						Some(n): {
							ruDoUnifyIndexNode2(i, n, math, env, acc);
						}
						None(): {
							makeVector(0);
						}
					}
					ruIterTree(index.vars, \v, n ->
						appendVector(unified,
							unify_var(i + len, RuVar(n.name_id, n.type_id), type, n, 
								\-> RuExp(subrange(acc.expr.nodes, i, len + 1), -1)
							)
						), acc.timer
					);
					unified;
				}
				RuVar(id, type): {
					unified = makeVector(0);
					ruIterTree(index.rules, \nm, n ->
						ruIterSet(n.ends, \e -> {
							end = getVectorUnsafe(index.nodes, e);
							appendVector(unified,
								unify_var(i, RuVar(id, type), n.type_id, end, 
									\-> ruIndexSubexpr(n, end)
								)
							);
						}, acc.timer),
						acc.timer
					);
					ruIterTree(index.vars, \v, n ->
						appendVector(unified,
							unify_var(i, RuVar(n.name_id, n.type_id), type, n, 
								\-> RuExp([RuVar(id, type)], -1)
							)
						), acc.timer
					);
					unified;
				}
			}
		} else {
			makeVector(0);
		}
	}
}

ruDoUnifyIndexNode2(i : int, node : RuIndexNode<?>, math : RuMath, env : RuEnv, acc : RuUnifyIndexAcc) -> Vector<RuUnified<?>> {
	if (ruTimeIsOver(acc.timer)) {
		makeVector(0);
	} else  {
		if (i + 1 == length(acc.expr.nodes)) {
			unified = makeVector(length(acc.expr.nodes));
			ruIter(node.data, \d -> 
				pushVector(unified, RuUnified(acc.sub, d, ruApplySubst(acc.expr, acc.sub))), acc.timer
			);
			unified;
		} else {
			ruDoUnifyIndex2(i + 1, node.index, math, env, acc);
		}
	}
}

ruUnifyIndex1(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, env : RuEnv, time_limit : double) -> [RuUnified<?>] {
	dList2array(
		ruDoUnifyIndex1(
			0, index, math, env, 
			RuUnifyIndexAcc(e, sub, ruMakeLimitedTimer(time_limit))
		)
	);
}

ruDoUnifyIndex1(i : int, index : RuIndex<?>, math : RuMath, env : RuEnv, acc : RuUnifyIndexAcc) -> DList<RuUnified<?>> {
	//println("entered ruDoUnifyIndex1, i = " + i2s(i));
	ret1 = if (ruTimeIsOver(acc.timer)) {
		//println("time is over: ruDoUnifyIndex1");
		makeDList();
	} else {
		unify_step = \j, var, end, ex -> {
			switch (lookupTree(acc.sub, var)) {
				Some(ex1): {
					switch (ruUnifyExps([ex1, ex], acc.sub, math, env)) {
						Some(s): ruDoUnifyIndexNode1(j, end, math, env, RuUnifyIndexAcc(acc with sub = s));
						None(): makeDList();
					}
				}
				None():
					switch (ruAdd2Subst(acc.sub, var, ex)) {
						Some(s): ruDoUnifyIndexNode1(j, end, math, env, RuUnifyIndexAcc(acc with sub = s));
						None(): makeDList();
					}
			}
		}
		unify_var = \j, var, ex_type, end, e ->
			if (ex_type == var.type) unify_step(j, var, end, e())
			else {
				switch (ruSuperRule(var.type, ex_type, math.decls.lang, env)) {
					Some(sr): {
						ex = RuExp(concat([RuRuleNode(sr.info.id, var.type, 1, 1)], e().nodes), -1);
						unify_step(j, var, end, ex);
					}
					None(): makeDList()
				}
			}
		if (i < length(acc.expr.nodes)) {
			switch (acc.expr.nodes[i]) {
				RuRuleNode(rule, type, arity, len): {
					unified = switch (lookupTree(index.rules, rule)) {
						Some(n): {
							//println("lookupTree(index.rules, rule) != None(), id: " + id2s(n.id));
							ruDoUnifyIndexNode1(i, n, math, env, acc);
						}
						None(): {
							//println("lookupTree(index.rules, rule) == None()");
							makeDList();
						}
					}
					//println("unified");
					ruIterTree(index.vars, \v, n -> {
							//println("index.vars(1), v: " + id2s(v));
							concatDList(unified,
								unify_var(i + len, RuVar(n.name_id, n.type_id), type, n, 
									\-> RuExp(subrange(acc.expr.nodes, i, len + 1), -1)
								)
							)
						},
						acc.timer
					);
					unified;
				}
				RuVar(id, type): {
					unified = makeDList();
					ruIterTree(index.rules, \nm, n -> {
						//println("index.rules(2), r: " + id2s(nm));
						ruIterSet(n.ends, \e -> {
							end = getVectorUnsafe(index.nodes, e);
							concatDList(unified,
								unify_var(i, RuVar(id, type), n.type_id, end, 
									\-> ruIndexSubexpr(n, end)
								)
							);
						}, acc.timer
						)},
						acc.timer
					);
					ruIterTree(index.vars, \v, n -> {
						//println("index.vars(2), v: " + id2s(v));
						concatDList(unified,
							unify_var(i, RuVar(n.name_id, n.type_id), type, n, 
								\-> RuExp([RuVar(id, type)], -1)
							)
						)}, acc.timer
					);
					//println("RuVar(id, type): " + id2s(id) + ", unified.size: " + i2s(lengthDList(unified)) + "\n" + 
					//	ruIndex2s(index, toString, math)
					//);
					unified;
				}
			}
		} else {
			//println("i >= length(acc.expr.nodes)");
			makeDList();
		}
	}
	/*ret = ruDoUnifyIndex(i, index, math, env, acc);
	if (dList2list(ret1) != ret) {
		ruCrash("ret != re1 (ruDoUnifyIndex):\n" +
			"i: " + i2s(i) + "\n" + 
			"ret:\n" + strIndent(ruDebugUnifiedList(ret, math)) + "\n\n" +
			"ret1:\n" + strIndent(ruDebugUnifiedDList(ret1, math)) + "\n\n" +
		);
	}*/
	ret1;
}

ruDebugUnifiedDList(unified : DList<RuUnified<?>>, math : RuMath) -> string {
	superglue(dList2array(unified), \un : RuUnified<?> -> ru2s(un.expr, math) + " -> " + toString(un.data), "\n");
}

ruDebugUnifiedList(unified : List<RuUnified<?>>, math : RuMath) -> string {
	superglue(list2array(unified), \un -> ru2s(un.expr, math) + " -> " + toString(un.data), "\n");
}

ruDoUnifyIndexNode1(i : int, node : RuIndexNode<?>, math : RuMath, env : RuEnv, acc : RuUnifyIndexAcc) -> DList<RuUnified<?>> {
	//println("entered ruDoUnifyIndexNode1, i = " + i2s(i));
	if (ruTimeIsOver(acc.timer)) {
		//println("time is over: ruDoUnifyIndexNode1");
		makeDList();
	} else  {
		ret1 = makeDList();
		if (i + 1 == length(acc.expr.nodes)) {
			ruIter(node.data, \d -> {
					pushDList(ret1, RuUnified(acc.sub, d, ruApplySubst(acc.expr, acc.sub)));
					//println("pushDList: " + ru2s(acc.expr, math));
					{};
				}, acc.timer
			);
		}
		concatDList(ret1, 
			ruDoUnifyIndex1(i + 1, node.index, math, env, acc)
		);
		/*ret = ruDoUnifyIndexNode(i, node, math, env, acc);
		println("ruDoUnifyIndexNode1: ret1: " + ruDebugUnifiedDList(ret1, math));
		if (dList2list(ret1) != ret) {
			ruCrash("ret != ret1 (ruDoUnifyIndexNode1):\n" +
				"ret:\n" + strIndent(ruDebugUnifiedList(ret, math)) + "\n\n" +
				"ret1:\n" + strIndent(ruDebugUnifiedDList(ret1, math)) + "\n\n" +
			);
		}*/
		ret1;
	}
}


ruUnifyIndex(e : RuExp, index : RuIndex<?>, sub : Tree<RuVar, RuExp>, math : RuMath, env : RuEnv, time_limit : double) -> [RuUnified<?>] {
	ret1 = ruUnifyIndex2(e, index, sub, math, env, time_limit);
	/*ret = list2array(
		ruDoUnifyIndex(
			0, index, math, env,
			RuUnifyIndexAcc(e, sub, ruMakeLimitedTimer(time_limit))
		)
	);*/
	/*if (ret != ret1) {
		ruCrash("ret != re1:\n" +
			"ret:\n" + strIndent(superglue(ret, \un -> ru2s(un.expr, math) + " -> " + toString(un.data), "\n")) + "\n\n" +
			"ret1:\n" + strIndent(superglue(ret1, \un -> ru2s(un.expr, math) + " -> " + toString(un.data), "\n")) + "\n\n" +
		);
	}*/
	ret1;
}

RuUnifyIndexAcc(
	expr : RuExp,
	sub : Tree<RuVar, RuExp>,
	timer : RuTimer
);

ruDoUnifyIndex(i : int, index : RuIndex<?>, math : RuMath, env : RuEnv, acc : RuUnifyIndexAcc) -> List<RuUnified<?>> {
	if (ruTimeIsOver(acc.timer)) {
		makeList();
	} else {
		unify_step = \j, var, end, ex -> {
			switch (lookupTree(acc.sub, var)) {
				Some(ex1): {
					switch (ruUnifyExps([ex1, ex], acc.sub, math, env)) {
						Some(s): ruDoUnifyIndexNode(j, end, math, env, RuUnifyIndexAcc(acc with sub = s));
						None(): makeList();
					}
				}
				None():
					switch (ruAdd2Subst(acc.sub, var, ex)) {
						Some(s): ruDoUnifyIndexNode(j, end, math, env, RuUnifyIndexAcc(acc with sub = s));
						None(): makeList();
					}
			}
		}
		unify_var = \j, var, ex_type, end, e ->
			if (ex_type == var.type) unify_step(j, var, end, e())
			else {
				switch (ruSuperRule(var.type, ex_type, math.decls.lang, env)) {
					Some(sr): {
						ex = RuExp(concat([RuRuleNode(sr.info.id, var.type, 1, 1)], e().nodes), -1);
						unify_step(j, var, end, ex);
					}
					None(): makeList()
				}
			}
		if (i < length(acc.expr.nodes)) {
			switch (acc.expr.nodes[i]) {
				RuRuleNode(rule, type, arity, len): {
					unified_1 = switch (lookupTree(index.rules, rule)) {
						Some(n): ruDoUnifyIndexNode(i, n, math, env, acc);
						None(): makeList();
					}
					ruFoldTree(index.vars, unified_1, \v, n, ac ->
						concatList(ac,
							unify_var(i + len, RuVar(n.name_id, n.type_id), type, n,
								\-> RuExp(subrange(acc.expr.nodes, i, len + 1), -1)
							)
						),
						acc.timer
					);
				}
				RuVar(id, type): {
					unfied_1 = ruFoldTree(index.rules, makeList(), \nm, n, ac ->
						ruFoldSet(n.ends, ac, \a, e -> {
							end = getVectorUnsafe(index.nodes, e);
							concatList(a,
								unify_var(i, RuVar(id, type), n.type_id, end,
									\-> ruIndexSubexpr(n, end)
								)
							);
						}, acc.timer),
						acc.timer
					);
					ruFoldTree(index.vars, unfied_1, \v, n, ac ->
						concatList(ac,
							unify_var(i, RuVar(n.name_id, n.type_id), type, n,
								\-> RuExp([RuVar(id, type)], -1)
							)
						), acc.timer
					);
				}
			}
		} else {
			makeList();
		}
	}
}

ruDoUnifyIndexNode(i : int, node : RuIndexNode<?>, math : RuMath, env : RuEnv, acc : RuUnifyIndexAcc) -> List<RuUnified<?>> {
	if (ruTimeIsOver(acc.timer)) {
		makeList();
	} else  {
		new_unified = if (i + 1 == length(acc.expr.nodes)) {
			ruFold(node.data, makeList(), \ac, d -> {
					println("Cons: " + ru2s(acc.expr, math));
					Cons(RuUnified(acc.sub, d, ruApplySubst(acc.expr, acc.sub)), ac)
				}, 
				acc.timer
			);
		} else {
			makeList();
		}
		concatList(new_unified,
			ruDoUnifyIndex(i + 1, node.index, math, env, acc)
		);
	}
}
