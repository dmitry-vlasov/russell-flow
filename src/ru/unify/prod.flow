import ru/prover/util;
import ru/unify/indexes;

export {
	RuSubData(
		sub : RuSubst,
		data: ?
	);
	ruUnifySubsProd(
		prod : [[RuSubData<?>]], 
		admitExp : (RuExp) -> bool, 
		timer : RuTaskTimer, 
		math : RuMath, 
		env : RuEnv
	) -> [RuSubData<[?]>];
}

RuSubsColumn(
	var : RuVar,
	rows : [RuIndex<int>]
);

RuSubsMatrix(
	cols : [RuSubsColumn]
);

ruSubsMatrix2s(matrix : RuSubsMatrix, math : RuMath) -> string {
	n_rows = if (matrix.cols == []) 0 else length(matrix.cols[0].rows);
	ruStringMatrix2s(
		map(matrix.cols, \col -> map(col.rows, \row -> ruIndex2s(row, i2s, math))),
		Some(map(matrix.cols, \col -> ru2s(col.var, math))),
		Some(map(enumFromTo(1, n_rows), \i -> "h_" + i2s(i)))
	);
}

ruMakeSubsMatrix(subs : [[RuSubData<?>]]) -> RuSubsMatrix {
	vars = set2array(fold(subs, makeSet(), \acc, ss ->
		fold(ss, acc, \ac, s ->
			mergeSets(ac, buildSet(map(hashMapValues(s.sub.map), \se -> se.var)))
		)
	));
	make_cell = \v, ss -> {
		foldi(ss, ruMakeIndex(), \i, ac, s ->
			switch (ruLookupSubst(s.sub, v)) {
				Some(ex): ruSetIndex(ex, i, ac);
				None(): ruSetIndex(RuExp([v], -1), i, ac);
			}
		)
	}
	RuSubsMatrix(
		fold(vars, [], \acc, v ->
			concat(acc, 
				[RuSubsColumn(v,
					fold(subs, [], \ac, ss ->
						concat(ac, [make_cell(v, ss)])
					)
				)]
			)
		)
	);
}

RuSubArrData(
	subs : [RuSubst],
	data : ?
);

ruIntersectCols(col1 : [RuSubArrData<[Set<int>]>], col2 : [RuUnified<[Set<int>]>], math : RuMath) -> [RuSubArrData<[Set<int>]>] {
	fold(col1, [], \acc, unif1 ->
		fold(col2, acc, \ac, unif2 -> {
				common = mapi(unif1.data, \i, d1 -> intersectSets(d1, unif2.data[i]));
				if (exists(common, isEmptySet)) ac else
				concat(ac, [RuSubArrData(concat(unif1.subs, [unif2.sub]), common)]);
			}
		)
	);
}

ruUnifySubsProd(subs : [[RuSubData<?>]], admitExp : (RuExp) -> bool, timer : RuTaskTimer, math : RuMath, env : RuEnv) -> [RuSubData<[?]>] {
	if (subs == [] || exists(subs, \s -> s == [])) [] else 
	if (length(subs) == 1) map(subs[0], \d -> RuSubData(d.sub, [d.data])) else {
		matrix = ruMakeSubsMatrix(subs);
		if (matrix.cols == []) {
			mapCartProd(CartProd(subs), \vect -> RuSubData(ruEmptySubst, map(vect, \sd -> sd.data)));
		} else {
			//println("ruUnifySubsProd!: \n" + ruSubsMatrix2s(matrix, math));
			empty = ref false;
			unified = ruMapi(matrix.cols, 
				\i, col -> {
					size = fold(col.rows, 1, \acc, ind -> acc * ruIndexDataCount(ind));
					t = ruMakeTimer();
					uns = ruUnifyIndexes(col.rows, ruEmptySubst, math, env, 3.0);
					unif_col = filtermap(uns, \unif -> {
							switch (ruLookupSubst(unif.sub, col.var)) {
								None(): 
									maybeBind(ruAdd2Subst1(unif.sub, col.var, unif.expr, math, env), \s ->
										if (ruSubSatisfies(s, admitExp)) {
											Some(RuUnified(s, unif.data, ruApplySubst(unif.expr, s)));
										} else {
											None();
										}
									);
								Some(ex):
									maybeBind(ruUnifyExps([unif.expr, ex], unif.sub, math, env), \un -> 
										maybeBind(ruCompose(unif.sub, un), \s ->
											if (ruSubSatisfies(s, admitExp)) {
												Some(RuUnified(s, unif.data, ruApplySubst(ex, s)));
											} else {
												None();
											}
										)
									);
							}
						}
					);
					if (unif_col == []) {
						empty := true;
					}
					unif_col
				}, [], timer
			);
			if (^empty) [] else {
				inter_pair = ruFold(
					tail(unified), 
					Pair(map(unified[0], \unif -> RuSubArrData([unif.sub], unif.data)), []), 
					\acc, col -> Pair(
						ruIntersectCols(acc.first, col, math), 
						concat(acc.second, [length(acc.first) * length(col)])
					),
					timer
				);
				intersected = filtermap(inter_pair.first, \ss -> 
					maybeMap(
						fold(ss.subs, Some(ruEmptySubst), \acc, s2 -> 
							maybeBind(acc, \s1 ->
								maybeBind(ruUnifySubs([s1, s2], math, env), \s3 ->
									if (ruSubSatisfies(s3, admitExp) && !ruTimeIsOver(timer.timer)) {
										Some(s3);
									} else {
										None();
									}
								)
							)
						),
						\s -> RuSubData(s, ss.data)
					)
				);
				fold(intersected, [],
					\acc, unif -> {
						prod = CartProd(map(unif.data, \d -> set2array(d)));
						concat(acc, mapCartProd(prod, \v -> RuSubData(unif.sub, mapi(v, \i, n -> subs[i][n].data))))
					}
				);
			}
		}
	}
}
