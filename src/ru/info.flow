import comm;
import ru/util/vol;
import ru/cache/cache;

export {
	ruInfoCommands : [RuComm];
}

ruInfoCommands = [
	ruCommInfoOutline,
	ruCommInfoMath,
	ruCommInfoHover,
	ruCommInfoDecl,
	ruCommInfoUses,
	ruCommInfoFind,
	ruCommInfoSymbol,
	ruCommInfoSource,
	ruCommInfoShow,
	ruCommInfoAxiomatics,
	ruCommInfoVolume,
];

ruCommInfoDecl = RuComm(
	RuCommDescr(
		"info-decl", "info", "declaration of entity at the given position", "", false, false, 
		[
			RuCommArg("file", false, "input file", ""), 
			RuCommArg("line", false, "line of expr", ""), 
			RuCommArg("col", false, "column of expr", "")
		], []
	), 
	ruRunInfoDecl
);

ruRunInfoDecl(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	file = lookupTreeDef(task.args, "file", "");
	line = s2i(lookupTreeDef(task.args, "line", "-1"));
	col = s2i(lookupTreeDef(task.args, "col", "-1"));
	module = ruTrimPath(file, conf, ".ru");
	code = ruCodeCacheGet(s2id_(module), env).code;
	name = ruNameByLineCol(line, col, code);
	maybeApply(ruDeclCacheGet(s2id_(name)), \decl ->
		maybeApply(ruCacheGet(decl.descr.src, false, env), \cached -> 
			env.out.onMessage(
				ruRange2s(
					ruDeclRange(decl, cached, env), 
					"declaration of " + name, 
					cached.info.path, 
					ruCodeCacheGet(decl.descr.src, env).code
				)
			)
		)
	);
	Some(state);
}

ruCommInfoHover = RuComm(
	RuCommDescr(
		"info-hover", "info", "hover info", "", false, false, 
		[
			RuCommArg("file", false, "input file", ""), 
			RuCommArg("line", false, "line of expr", ""), 
			RuCommArg("col", false, "column of expr", "")
		], []
	), 
	ruRunInfoHover
);

ruRunInfoHover(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	file = lookupTreeDef(task.args, "file", "");
	file_id = ruFileId(file, conf);
	line = s2i(lookupTreeDef(task.args, "line", "-1"));
	col = s2i(lookupTreeDef(task.args, "col", "-1"));
	code = ruCodeCacheGet(file_id, env).code;
	name = ruNameByLineCol(line, col, code);
	do_hover = \nm -> {
		id = s2id_(nm);
		if (id != -1) {
			env.out.onMessage(ruCachedDecl2s(id, env));
		}
		Some(state);
	}
	switch (ruCacheGet(file_id, true, env)) {
		Some(src): {
			resolver = makeLineResolver(code);
			pos = findLineIndex(resolver, line, col);
			posTree = ruPositionsTree(src);
			positions = getTreeKeys(posTree);
			switch (treeIntervalSearch(posTree, pos)) {
				Some(x): {
					curr = ruPos(x);
					ind = elemIndex(positions, curr, -1) + 1;
					next = if (ind == length(positions)) strlen(code) else positions[ind];
					switch (x) {
						RuExp(nodes, __): {
							expr = substring(code, curr, next - curr);
							exp_ind = ruIndexOfPosInsideExp(expr, pos - curr);
							exp_nodes = ruExp2Nodes(x, ruRuleCacheGet());
							if (exp_ind >= length(exp_nodes)) {
								do_hover(name);
							} else {
								switch (exp_nodes[exp_ind]) {
									RuVar(v, t): {
										env.out.onMessage(id2s(v) + " : " + id2s(t));
										Some(state);
									}
									RuRuleNode(rule,__,__,__): {
										switch (ruDefCacheGetName(rule)) {
											Some(def): do_hover(id2s(def));
											None(): do_hover(id2s(rule));
										}
									}
								}
							}
						}
						RuTerm(type, nodes, __): do_hover(name);
						default: do_hover(name);
					}
				}
				None(): do_hover(name);
			}
		}
		None(): do_hover(name);
	}
}

ruIndexOfPosInsideExp(expr : string, pos : int) -> int {
	ruDoIndexOfPosInsideExp(expr, pos, false, 0, 0);
}

ruDoIndexOfPosInsideExp(expr : string, pos : int, ws : bool, curr : int, acc : int) -> int {
	if (curr == pos) acc else {
		ch = getCharAt(expr, curr);
		ws1 = (ch == " " || ch == "\n" || ch == "\t" || ch == "\r");
		ruDoIndexOfPosInsideExp(
			expr, pos, ws1, curr + 1, 
			acc + (if (!ws && ws1) 1 else 0)
		);
	}
}

ruCommInfoFind = RuComm(
	RuCommDescr(
		"info-find", "info", "find entity with a given name", "name", false, false, 
		[RuCommArg("name", false, "entity name", "")], []
	),
	ruRunInfoFind
);

ruRunInfoFind(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	name = lookupTreeDef(task.args, "name", "");
	switch (ruDeclCacheGet(s2id_(name))) {
		Some(decl): {
			maybeApply(ruCacheGet(decl.descr.src, false, env), \cached ->
				env.out.onMessage(
					ruRange2s(
						ruDeclRange(decl, cached, env), 
						"declaration of " + name, 
						cached.info.path, 
						ruCodeCacheGet(cached.info.id, env).code
					)
				)
			)
		}
		None(): {
			env.out.onMessage("Declaration '" + name + "' is not found");
		}
	}
	Some(state);
}

ruCommInfoSymbol = RuComm(
	RuCommDescr(
		"info-symbol", "info", "find entity with a given name, output result in JSON format", "name", false, false, 
		[RuCommArg("name", false, "entity name", "")], []
	),
	ruRunInfoSymbol
);

ruRunInfoSymbol(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	name = lookupTreeDef(task.args, "name", "");
	maybeApply(ruCachedDecl2LspSymbolInfo(s2id_(name), env), \info -> {
		json = JsonArray([lspSymbolInformation2Json(info)]);
		env.out.onMessage(json2string(json));
	});
	Some(state);
}

ruCommInfoSource = RuComm(
	RuCommDescr(
		"info-source", "info", "find source and output it's characteristics", "name", false, false, 
		[RuCommArg("name", false, "entity name", "")], []
	),
	ruRunInfoSource
);

ruRunInfoSource(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	name = lookupTreeDef(task.args, "name", "");
	switch (ruCacheGet(s2id_(name), false, env)) {
		Some(src): {
			env.out.onMessage("Source '" + name + "' decls (" + i2s(length(src.decls)) + "):\n" +
				strGlue(map(src.decls, \d -> "\t" + ruDeclKind(d) + " " + id2s(d.descr.id)), "\n")
			);
		}
		None(): {
			env.out.onMessage("Source '" + name + "' is not found");
		}
	};
	Some(state);
}

ruCommInfoShow = RuComm(
	RuCommDescr(
		"info-show", "info", "find entity with a given name, and print it", "name", false, false, 
		[RuCommArg("name", false, "entity name", "")], []
	),
	ruRunInfoShow
);

ruRunInfoShow(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	math = ruMathFromSources(state.ru, env);
	name = lookupTreeDef(task.args, "name", "");
	switch (ruFindDecl(s2id_(name), math.decls, env)) {
		Some(decl): {
			env.out.onMessage(ru2s(decl, math));
		}
		None(): { 
			env.out.onMessage("Declaration '" + name + "' is not found");
		}
	}
	Some(state);
}

ruCommInfoOutline = RuComm(
	RuCommDescr(
		"info-outline", "info", "prints a file outline", "file", false, false, 
		[RuCommArg("file", false, "input file", "")], []
	),
	ruRunInfoOutline
);

ruRunInfoOutline(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	file = lookupTreeDef(task.args, "file", "");
	module = ruTrimPath(file, conf, ".ru");
	maybeApply(ruCacheGet(s2id_(module), false, env), \src -> {
		code = ruCodeCacheGet(src.info.id, env).code;
		resolver = makeLineResolver(code);
		iter(src.imports, \imp -> 
			maybeApply(ruNameRangeByPos(imp.pos, code), \range -> 
				env.out.onMessage(
					ruRangeWithResolver2s(src.info.path, range, "import " + id2s(imp.id), resolver)
				)
			)
		);
		iter(src.decls, \decl ->
			maybeApply(ruNameRangeByPos(decl.descr.pos, code),
				\range ->
					env.out.onMessage(
						ruRangeWithResolver2s(src.info.path, range, ruDeclKind(decl) + " " + 
						id2s(decl.descr.id), resolver)
					)
			)
		);
	});
	Some(state)
}

ruCommInfoUses = RuComm(
	RuCommDescr(
		"info-uses", "info", "prints all uses of a name", "name", false, false, 
		[RuCommArg("name", false, "entity name", "")], []
	),
	ruRunInfoUses
);

ruRunInfoUses(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	name = lookupTreeDef(task.args, "name", "");
	id = s2id_(name);
	maybeApply(ruDeclCacheGet(id), \decl ->
		maybeApply(ruCacheGet(decl.descr.src, false, env), \src ->
			iter(ruSourceCacheAll(true, env), \s -> { 
				iter(s.decls, \d ->
					switch (d) {
						RuTheorem(__,__,__,proof):
							iter(proof.steps, \step ->
								if (step.assertion == id) {
									code = ruCodeCacheGet(s.info.id, env).code;
									maybeApply(ruNameRangeByPos(step.pos, code),
										\range -> 
											env.out.onMessage(ruRange2s(range, "uses " + name, src.info.path, code))
									);
								}
							);
						default: { }
					}
				);
			})
		)
	);
	Some(state)
}

ruCommInfoMath = RuComm(
	RuCommDescr(
		"info-math", "info", "prints info about math entities of different kinds", "kind", false, false, 
		[RuCommArg("kind", true, "kind of math, one of: consts, types, axioms, rules, defs. No kind means all of them", "")], []
	),
	ruRunInfoMath
);

ruRunInfoMath(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	kind = lookupTreeDef(task.args, "kind", "");
	info = JsonArray(filtermap(
		filter(ruDeclCacheAll(), \decl ->
			switch (decl) {
				RuConst(__,__,__):      kind == "const" || kind == "";
				RuType(__,__):          kind == "type"  || kind == "";
				RuRule(__,__,__):       kind == "rule"  || kind == "";
				RuAxiom(__,__):         kind == "axiom" || kind == "";
				RuDef(__,__,__,__):     kind == "def"   || kind == "";
				RuTheorem(__,__,__,__): kind == "theorem";
			}
		),
		\decl -> {
			path0 = decl.descr.src;
			path = eitherMap(ruSourceCacheGet(path0, false, env), \src -> src.info.path, id2s(path0));
			name = id2s(decl.descr.id);
			code = ruCodeCacheGet(decl.descr.src, env).code;
			maybeMap(ruNameRangeByPos(decl.descr.pos, code),
				\range ->
					JsonObject([
						Pair("kind", JsonString(ruDeclKind(decl))),
						Pair("location", lspLocation2Json(ruRange2LspLocation(range, path, code))),
						Pair("name", JsonString(name)),
						Pair("tooltip", JsonString(ruCachedDecl2s(s2id_(name), env)))
					])
			)
		}
	));
	env.out.onMessage(json2string(info));
	Some(state);
}

ruCommInfoAxiomatics = RuComm(
	RuCommDescr("info-axiomatics", "info", "prints axiomatics info: base axioms for theorems", "", false, false, [], []),
	ruRunInfoAxiomatics
);

ruRunInfoAxiomatics(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	th_axioms = ruDeclCacheTheoremAxioms();
	ax_sets = foldTree(th_axioms, makeTree(), \th, axs, acc -> 
		switch (findInOrder(acc, \as, ths -> if (equalSet(as, axs)) Some(Pair(as, ths)) else None())) {
			Some(pair): setTree(acc, pair.first, insertSet(pair.second, th));
			None(): setTree(acc, axs, makeSet1(th));
		}
	);
	traverseInOrder(ax_sets,
		\axs, names -> {
			if (sizeSet(axs) > 1) {
				out = "axioms: {" + strGlue(set2array(axs), ", ") + "}\n" + "theorems: {" + strGlue(set2array(names), ", ") + "}\n";
				ruDebugLog(out, conf);
				ruAddStats("theorem-axioms", RuStatsRow(out, pairs2tree([
					Pair("axioms", i2d(sizeSet(axs))),
					Pair("theorems", i2d(sizeSet(names))),
				])));
				env.out.onMessage(out);
			}
		}
	);
	stats = "<< theorem axioms distribution >>\n" +
	"distrib: \n" +
	strIndent(ruProcStats("theorem-axioms", ruDistribLinSumStats("axioms", "theorems", 10))) + "\n" +
	"max axioms:   " + ruProcStats("theorem-axioms", ruMaxStats("axioms")) + "\n" +
	"avg axioms:   " + ruProcStats("theorem-axioms", ruAvgStats("axioms")) + "\n" +
	"sigma axioms: " + ruProcStats("theorem-axioms", ruSigmaStats("axioms")) + "\n"
	"\n" +
	"max theorems:   " + ruProcStats("theorem-axioms", ruMaxStats("theorems")) + "\n" +
	"avg theorems:   " + ruProcStats("theorem-axioms", ruAvgStats("theorems")) + "\n" +
	"sigma theorems: " + ruProcStats("theorem-axioms", ruSigmaStats("theorems")) + "\n";
	env.out.onMessage(stats);
	ruDebugLog(stats, conf);
	Some(state);
}

ruCommInfoVolume = RuComm(
	RuCommDescr("info-volume", "info", "prints how much of a heap space each kind of AST nodes occupy", "", false, false, [], []), 
	ruRunInfoVolume
);

ruRunInfoVolume(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	task = unit.task;
	state = unit.state;
	conf = state.conf;
	ru_math = ruMathFromSources(state.ru, env);
	ru_sources_vol    = ruJavaTreeVol(ru_math.sources, \_ -> ruJavaIntVol(), ruJavaRuVol);
	ru_consts_vol     = ruJavaTreeVol(ru_math.decls.consts, \_ -> ruJavaIntVol(), ruJavaRuVol);
	ru_types_vol      = ruJavaTreeVol(ru_math.decls.types, \_ -> ruJavaIntVol(), ruJavaRuVol);
	ru_rules_vol      = ruJavaTreeVol(ru_math.decls.rules, \_ -> ruJavaIntVol(), ruJavaRuVol);
	ru_assertions_vol = ruJavaTreeVol(ru_math.decls.assertions, \_ -> ruJavaIntVol(), ruJavaRuVol);
	ru_proofs_vol     = ruJavaTreeVol(ruDeclsProofs(ru_math.decls), \_ -> ruJavaIntVol(), ruJavaRuVol);
	ru_headers_vol    = ru_assertions_vol - ru_proofs_vol;

	mm_sources = state.mm;
	mm_sources_vol = ruJavaTreeVol(mm_sources, \_ -> ruJavaIntVol(), mmJavaMmVol);

	ids_vol           = ruJavaArrayVol(ruIds(), ruJavaStringVol);

	total_vol = ru_sources_vol + mm_sources_vol + ids_vol;
	print_precent  = \x, all -> " (" + d2st(x*100.0 / all, 2) + "%)";
	env.out.onMessage(
		"Memory volume statistics:\n" +
		"-------------------------\n" +
		(if (ru_sources_vol <= 64.0) "  ru sources:    0 b\n" else {
		"  ru sources:    " + memory2s(ru_sources_vol)    + print_precent(ru_sources_vol, total_vol) + "\n" +
		"  ru constants:  " + memory2s(ru_consts_vol)     + print_precent(ru_consts_vol, total_vol) + "\n" +
		"  ru types:      " + memory2s(ru_types_vol)      + print_precent(ru_types_vol, total_vol) + "\n" +
		"  ru rules:      " + memory2s(ru_rules_vol)      + print_precent(ru_rules_vol, total_vol) + "\n" +
		"  ru assertions: " + memory2s(ru_assertions_vol) + print_precent(ru_assertions_vol, total_vol) + "\n" +
		"  ru proofs:     " + memory2s(ru_proofs_vol)     + print_precent(ru_proofs_vol, total_vol) + "\n" +
		"  ru headers:    " + memory2s(ru_headers_vol)    + print_precent(ru_headers_vol, total_vol) + "\n" +
		}) +
		"\n" +
		(if (mm_sources_vol <= 64.0) "  mu sources:    0 b\n" else {
		"  mm sources:    " + memory2s(mm_sources_vol)    + print_precent(mm_sources_vol, total_vol) + "\n" +
		}) +
		"\n" +
		"  ids:           " + memory2s(ids_vol) + print_precent(ids_vol, total_vol) + "\n"
	);
	Some(state);
}
