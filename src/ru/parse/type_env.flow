import ru/parse/trie;
import ru/src_utils;

export {
	RuTypeEnv(
		trie   : RuTrie<string, RuRuleRef>,
		supers : Tree<string, RuRule>,
	);
	ruNoTypeEnv = RuTypeEnv(ruTrieEmpty, makeTree());

	ruAddTerm2RuTrie(term : RuTerm, rule : Maybe<RuRuleRef>, trie : RuTrie<string, RuRuleRef>, conf : RuConf) -> RuTrie<string, RuRuleRef>;
	ruRemoveTermFromTrie(term : RuTerm, trie : RuTrie<string, RuRuleRef>) -> RuTrie<string, RuRuleRef>;
	
	ruMergeTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv;
	ruMergeTypeEnvTree(e1 : Tree<string, RuTypeEnv>, e2 : Tree<string, RuTypeEnv>) -> Tree<string, RuTypeEnv>;
	ruMakeTypeEnv(type : RuType, conf : RuConf) -> RuTypeEnv;
}

ruAddTerm2RuTrie(term : RuTerm, rule : Maybe<RuRuleRef>, trie : RuTrie<string, RuRuleRef>, conf : RuConf) -> RuTrie<string, RuRuleRef> {
	term_key = \x -> switch (x) {
		RuConstRef(c):  c;
		RuVar(v, t): t;
	}
	ruAdd2Trie(map(term.expr, term_key), rule, trie, 
		\a1, a2 -> {
			if (a1 != a2) {
				conf.onError("rule term: '" + ruTerm2s(term.expr) + "' is already used", []);
			}
			a1
		}
	)
}

ruRemoveTermFromTrie(term : RuTerm, trie : RuTrie<string, RuRuleRef>) -> RuTrie<string, RuRuleRef> {
	term_key = \x -> switch (x) {
		RuConstRef(c):  c;
		RuVar(v, t): t;
	}
	ruRemoveFromTrie(map(term.expr, term_key), trie);
}

ruMergeTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv {
	RuTypeEnv(
		ruMergeRuTrie(e1.trie, e2.trie, \a1, a2 -> a1),
		mergeTree(e1.supers, e2.supers)
	)
}

ruMergeTypeEnvTree(t1 : Tree<string, RuTypeEnv>, t2 : Tree<string, RuTypeEnv>) -> Tree<string, RuTypeEnv> {
	mergeTreeCustom(t1, t2, \__, e1, e2 -> ruMergeTypeEnv(e1, e2));
}

ruMakeTypeEnv(type : RuType, conf : RuConf) -> RuTypeEnv {
	RuTypeEnv(
		ruAddTerm2RuTrie(
			RuTerm(type.descr.name, [RuVar("x", type.descr.name)], type.pos), 
			None(),
			ruTrieEmpty, conf
		),
		fold(type.supers, makeTree(), \ac, super -> 
			setTree(ac, super, ruMakeSuperRule(super, type.descr.name, type.descr.source, type.pos))
		)
	)
}
