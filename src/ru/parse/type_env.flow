import base/trie;
import ru/util/utils;

export {
	RuTypeEnv(
		trie   : RuTrie<int, RuRuleNode>,
		supers : Tree<int, RuRule>,
	);
	ruNoTypeEnv = RuTypeEnv(ruTrieEmpty, makeTree());

	ruAddRule2TypeEnvTree(rule : RuRule, tenv : Tree<int, RuTypeEnv>, env : RuEnv) -> Tree<int, RuTypeEnv>;
	ruAddRule2TypeEnv(rule : RuRule, te : RuTypeEnv, env : RuEnv) -> RuTypeEnv;	
	
	ruMergeTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv;
	ruMergeTypeEnvTree(e1 : Tree<int, RuTypeEnv>, e2 : Tree<int, RuTypeEnv>) -> Tree<int, RuTypeEnv>;
	ruMakeTypeEnv(type : RuType, env : RuEnv) -> RuTypeEnv;

	ruTypeEnv2s(tenv : RuTypeEnv) -> string;
	ruTypeEnvTree2s(tree : Tree<int, RuTypeEnv>) -> string;
}

ruAddRule2TypeEnvTree(rule : RuRule, tenv : Tree<int, RuTypeEnv>, env : RuEnv) -> Tree<int, RuTypeEnv> {
	switch (lookupTree(tenv, rule.term.type)) {
		Some(te): setTree(tenv, rule.term.type, ruAddRule2TypeEnv(rule, te, env));
		None(): tenv;
	}
}

ruAddRule2TypeEnv(rule : RuRule, te : RuTypeEnv, env : RuEnv) -> RuTypeEnv {
	RuTypeEnv(te with
		trie = ruAddTerm2RuTrie(rule.term, 
			Some(RuRuleNode(rule.info.id, rule.term.type, sizeTree(rule.vars), 0)),
			te.trie, env
		)
	);
}

ruAddTerm2RuTrie(term : RuTerm, rule : Maybe<RuRuleNode>, trie : RuTrie<int, RuRuleNode>, env : RuEnv) -> RuTrie<int, RuRuleNode> {
	term_key = \x -> switch (x) {
		RuConstRef(id):  id;
		RuVar(id, type): type;
	}
	ruAdd2Trie(trie, map(term.nodes, term_key), rule, 
		\a1, a2 -> {
			if (a1 != a2) {
				env.out.onError("rule term: '" + ruTerm2s(term) + "' is already used", []);
			}
			a1
		}
	)
}

ruRemoveTermFromTrie(term : RuTerm, trie : RuTrie<int, RuRuleNode>) -> RuTrie<int, RuRuleNode> {
	term_key = \x -> switch (x) {
		RuConstRef(id):  id;
		RuVar(id, type): type;
	}
	ruRemoveFromTrie(map(term.nodes, term_key), trie);
}

ruMergeTypeEnv(e1 : RuTypeEnv, e2 : RuTypeEnv) -> RuTypeEnv {
	RuTypeEnv(
		ruMergeRuTrie(e1.trie, e2.trie, \a1, a2 -> a1),
		mergeTree(e1.supers, e2.supers)
	)
}

ruMergeTypeEnvTree(t1 : Tree<int, RuTypeEnv>, t2 : Tree<int, RuTypeEnv>) -> Tree<int, RuTypeEnv> {
	mergeTreeCustom(t1, t2, \__, e1, e2 -> ruMergeTypeEnv(e1, e2));
}

ruMakeTypeEnv(type : RuType, env : RuEnv) -> RuTypeEnv {
	RuTypeEnv(
		ruAddTerm2RuTrie(
			RuTerm(type.info.id, [RuVar(s2id("x"), type.info.id)], type.info.pos), 
			None(),
			ruTrieEmpty, env
		),
		fold(type.supers, makeTree(), \ac, super -> 
			setTree(ac, super, ruMakeSuperRule(super, type.info.id, type.info.src, type.info.pos))
		)
	)
}

ruTypeEnv2s(tenv : RuTypeEnv) -> string {
	ruTrie2s(tenv.trie, id2s, \n -> id2s(n.rule));
}

ruTypeEnvTree2s(tree : Tree<int, RuTypeEnv>) -> string {
	foldTree(tree, "", \type, tenv, acc ->
		acc + "\ntype: " + id2s(type) + "\n" + strIndent(ruTypeEnv2s(tenv))
	);
}