import ru/parse/exp;
import ru/parse/parse;

import ru/verify/verify;

export {
	ruCollectMath(parsed : Tree<int, RuParsed>, conf : RuConf, skip_proofs : bool) -> Maybe<RuMath>;
}

ruCollectMath(parsed : Tree<int, RuParsed>, conf0 : RuConf, skip_proofs : bool) -> Maybe<RuMath> {
	err_count = ref 0;
	conf = ruAddErrCounter(conf0, err_count);
	timer = ruMakeTimer();
	ref_collect_counter := 0;
	env = ruDoCollectMath(parsed, makeSet(), conf, ruMakeEmptyCollectEnv(skip_proofs));
	collected = env.verified.math;
	ruSaveIds(conf);
	if (ruVerbose(conf) > 0) {
		conf.onMessage("ru collected: " + i2s(sizeTree(collected.sources)) + " files in " + ruTimePassed2s(timer));
		if (ruVerbose(conf) > 1) {
			conf.onMessage("\tcollection iterations: " + i2s(^ref_collect_counter));
			conf.onMessage("\tmax read batch size: " + ruProcStats("sources_profile", ruMaxStats("size")));
			conf.onMessage("\tavg read batch size: " + ruProcStats("sources_profile", ruAvgStats("size")));
			conf.onMessage("\tsig read batch size: " + ruProcStats("sources_profile", ruSigmaStats("size")));
		}
	}
	if (^err_count == 0) {
		Some(collected);
	} else {
		None();
	}
}

RuCollectEnv(
	skipProofs : bool,
	verified : RuVerifyAcc,
	tenv : Tree<int, RuTypeEnv>
);

ruMakeEmptyCollectEnv(skip_proofs : bool) -> RuCollectEnv {
	RuCollectEnv(skip_proofs, RuVerifyAcc(ruEmptyMath, makeSet(), makeSet()), makeTree());
}

ruMergeCollectEnv(e1 : RuCollectEnv, e2 : RuCollectEnv, conf : RuConf) -> RuCollectEnv {
	RuCollectEnv(
		e1.skipProofs,
		ruMergeVerifyAcc(e1.verified, e2.verified, conf),
		ruMergeTypeEnvTree(e1.tenv, e2.tenv)
	);
}

ref_collect_counter = ref 0;

ruDoCollectMath(left : Tree<int, RuParsed>, done : Set<int>, conf : RuConf, acc : RuCollectEnv) -> RuCollectEnv {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(ruParsedImports(src), \imp -> containsSet(done, imp))
		);
		if (ready == []) {
			conf.onError("cyclic import detected while collecting:\n" + ruRevealCyclicImport(left), []);
			acc
		} else {
			if (ruVerbose(conf) > 1) {
				ref_collect_counter := ^ref_collect_counter + 1;
				ruAddStats("sources_profile", 
					RuStatsRow("iteration: " + i2s(^ref_collect_counter), pairs2tree([Pair("size", i2d(length(ready)))]))
				);
				//conf.onMessage("\t\tgoing to collect: \n" + strGlue(map(ready, \p -> "\t\t\t" + ruParsedModule(p)), "\n"));
				if (ruVerbose(conf) > 2) {
					conf.onMessage("\t\tgoing to collect: \n" + strGlue(map(ready, \p -> "\t\t\t" + id2s(ruParsedModule(p))), "\n"));
					if (ruVerbose(conf) > 3) {
						conf.onMessage("COLLECT ITER: " + i2s(^ref_collect_counter) + ", NUM SRCS: " + i2s(length(ready)));
					}
				}
			}
			approve_src = \src -> RuVerifyAcc(
				ruMakeMathFromSource(src, conf),
				fold(src.decls, makeSet(), \ac, decl -> insertSet(ac, decl.descr.id)),
				makeSet()
			);
			collected = filtermap(ready, \parsed ->
				switch (parsed) {
					RuParseSource(__,__,info): {
						//if (ruVerbose(conf) > 2) {
						//	conf.onMessage("\t\t\tstarted collecting parsed: '" + ruParsedModule(parsed) + "'");
						//}
						r = ruCollectParsed(parsed, acc, conf);
						//if (ruVerbose(conf) > 2) {
						//	conf.onMessage("\t\t\tfinished collecting parsed: '" + ruParsedModule(parsed) + "'");
						//}
						Some(r);
					}
					RuCachedSource(src, depChanged,__): {
						//if (ruVerbose(conf) > 2) {
						//	conf.onMessage("\t\t\tstarted collecting cached: '" + ruParsedModule(parsed) + "'");
						//}
						if (!depChanged()) {
							timer = ruMakeTimer();
							ret = Some(ruCollectCached(src, RuCollectEnv(acc with verified = approve_src(src)), conf)); 
							if (ruVerbose(conf) > 1) {
								conf.onMessage("\tru collected cached: '" + src.info.module + "' in " + ruTimePassed2s(timer));
							}
							ret;
						} else {
							timer = ruMakeTimer();
							new_verified = ruVerifySource(src, acc.verified, conf);
							if (sizeSet(acc.verified.disproved) == sizeSet(new_verified.disproved)) {
								ret = ruCollectCached(src, RuCollectEnv(acc with verified = new_verified), conf);
								if (ruVerbose(conf) > 1) {
									conf.onMessage("\tru collected verified: '" + src.info.module + "' in " + ruTimePassed2s(timer));
								}
								Some(ret);
							} else {
								maybeBind(ruLoadOne(conf, src.info.id, \__,__ -> None()), \l ->
									maybeMap(ruParseOne(l, conf), \s ->
										ruCollectOne(s, acc, conf)
									)
								);
							}
						}
					}
				}
			);
			//if (ruVerbose(conf) > 2) {
			//	conf.onMessage("\t\tcollected: \n" + strGlue(map(ready, \p -> "\t\t\t" + ruParsedModule(p)), "\n"));
			//}
			new_acc = ruMergeCollectEnv(acc, 
				fold(collected, 
					ruMakeEmptyCollectEnv(acc.skipProofs), 
					\ac, coll -> ruMergeCollectEnv(coll, ac, conf)), 
				conf
			);
			new_left = fold(ready, left, \ac, parsed -> removeFromTree(ac, ruParsedModule(parsed)));
			new_done = fold(ready, done, \ac, parsed -> insertSet(ac, ruParsedModule(parsed)));
			//if (ruVerbose(conf) > 2) {
			//	conf.onMessage("\t\tfolded: \n" + strGlue(map(ready, \p -> "\t\t\t" + ruParsedModule(p)), "\n"));
			//}
			ruDoCollectMath(new_left, new_done, conf, new_acc);
		}
	}
}

ruCollectCached(src : RuSource, acc : RuCollectEnv, conf : RuConf) -> RuCollectEnv {
	RuCollectEnv(acc with 
		tenv = fold(src.decls, acc.tenv, \ac, decl ->
			switch (decl) {
				RuType(descr,__): setTree(ac, descr.id, ruMakeTypeEnv(decl, conf));
				RuRule(descr, vars, term): {
					switch (lookupTree(ac, term.type)) {
						Some(te): {
							setTree(ac, term.type, 
								RuTypeEnv(te with
									trie = ruAddTerm2RuTrie(term, 
										Some(RuRuleNode(descr.id, term.type, sizeTree(vars), 0)),
										te.trie, conf
									)
								)
							);
						}
						None(): {
							conf.onError("Unknown type: '" + id2s(term.type) + "'", [RuPlace(src.info.module, descr.pos)]);
							ac;
						}
					}
				}
				default: ac;
			}
		)
	);
}

ruCollectOne(parsed : RuParsed, acc : RuCollectEnv, conf : RuConf) -> RuCollectEnv {
	switch (parsed) {
		RuParseSource(__,__,__): ruCollectParsed(parsed, acc, conf);
		RuCachedSource(src, __,__): ruCollectCached(src, acc, conf);
	}
}

RuCollectAcc(
	skipProofs : bool,
	file : string,
	module : int,
	global : RuMath,
	local : RuMath,
	tenv : Tree<int, RuTypeEnv>,
	conf : RuConf
);

ruCollectParsed(src : RuParseSource, acc : RuCollectEnv, conf : RuConf) -> RuCollectEnv {
	timer = ruMakeTimer();
	switch (lookupTree(acc.verified.math.sources, src.info.id)) {
		Some(__): {
			conf.onError("source '" + src.info.module + "' is already defined", []);
			acc
		}
		None(): {
			imps = map(src.imports, \imp -> RuImport(imp.module, imp.pos));
			acc0 = RuCollectAcc(acc.skipProofs, src.info.path, src.info.id, acc.verified.math, ruEmptyMath, acc.tenv, conf);
			acc1 = fold(src.decls, acc0, \ac, block -> 
				switch(block) {
					RuParseDecl(): ruCollectSyntax(block, ac);
					RuParseComment(__,__,__): ac;
				}
			);
			parse_decls : [RuParseDecl] = filtermap(src.decls, \block -> 
				switch(block) {
					RuParseDecl(): Some(block);
					RuParseComment(__,__,__): None();
				}
			);
			created_decls = ruConcurrent(map(parse_decls, \decl -> \-> ruCreateAssertion(decl, acc1)));
			//created_decls = map(parse_decls, \decl -> ruCreateAssertion(decl, acc1));
			assertions = filtermap(created_decls, idfn);
			acc2 = fold(assertions, acc1, \ac, ass -> 
				RuCollectAcc(ac with
					local = RuMath(ac.local with 
						assertions = setTree(ac.local.assertions, ass.descr.id, ass)
					)
				)
			);
			blocks = fold(src.decls, [], \ac, block -> 
				switch (block) {
					RuParseConst(id,__,__,__):
						eitherMap(lookupTree(acc2.local.consts, id), \c -> concat(ac, [c]), ac);
					RuParseType(id,__,__): 
						eitherMap(lookupTree(acc2.local.types, id), \t -> concat(ac, [t]), ac);
					RuParseRule(id,__,__,__):
						eitherMap(lookupTree(acc2.local.rules, id), \r -> concat(ac, [r]), ac);
					RuParseAxiom(id,__,__,__,__,__):
						eitherMap(lookupTree(acc2.local.assertions, id), \a -> concat(ac, [a]), ac);
					RuParseTheorem(id,__,__,__,__,__,__,__):
						eitherMap(lookupTree(acc2.local.assertions, id), \t -> concat(ac, [t]), ac);
					RuParseDef(id,__,__,__,__,__,__,__):
						eitherMap(lookupTree(acc2.local.assertions, id), \d -> concat(ac, [d]), ac);
					RuParseComment(text, json, pos):
						concat(ac, [RuComment(text, ruCollectAnnotation(json, pos, src.info.module, conf), pos)]);
				}
			);
			if (ruVerbose(conf) > 1) {
				conf.onMessage("\tru collected: '" + src.info.path + "' in " + ruTimePassed2s(timer));
			}
			ru_src = ruBclocks2Src(RuSource(imps, [], [], src.info), blocks);
			ruToMemCache(ru_src, conf);
			ruToDiskCache(ru_src, conf);
			RuCollectEnv(
				acc2.skipProofs,
				ruVerifySource(ru_src, acc.verified,	conf),
				acc2.tenv
			);
		}
	}
}

ruCollectAnnotation(json_str : string, pos : int, file : string, conf : RuConf) -> JsonObject {
	if (json_str == "") JsonObject([]) else {
		json = parseJson(json_str);
		switch (json) {
			JsonObject(__): json;
			default: {
				conf.onError("Annotation must be a JSON object, got:\n\t" + json_str + "\n", [RuPlace(file, pos)]);
				JsonObject([]);
			}
		}
	}
}

ruCollectSyntax(decl : RuParseDecl, acc : RuCollectAcc) -> RuCollectAcc {
	switch (decl) {
		RuParseConst(__,__,__,__): ruCollectConst(decl, acc);
		RuParseType(__,__,__):     ruCollectType(decl, acc);
		RuParseRule(__,__,__,__):  ruCollectRule(decl, acc);
		default: acc;
	}
}

ruCreateAssertion(decl : RuParseDecl, acc : RuCollectAcc) -> Maybe<RuAssertion> {
	switch (decl) {
		RuParseAxiom(__,__,__,__,__,__):         ruCreateAxiom(decl, acc);
		RuParseTheorem(__,__,__,__,__,__,__,__): ruCreateTheorem(decl, acc);
		RuParseDef(__,__,__,__,__,__,__,__):     ruCreateDef(decl, acc);
		default: None();
	}
}

ruCollectConst(const : RuParseConst, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupConst(acc, const.id)) {
		Some(__): {
			acc.conf.onError("constant '" + id2s(const.id) + "' is already defined", [RuPlace(acc.file, const.pos)]);
			acc
		}
		None(): {
			RuCollectAcc(acc with
				local = RuMath(acc.local with 
					consts = setTree(acc.local.consts, const.id, 
						RuConst(
							RuDescr(const.id, acc.module, [], const.pos), 
							if (const.ascii == -1) -1 else const.ascii, 
							if (const.latex == -1) -1 else const.latex
						)
					),
				)
			);
		}
	}
}

ruCollectType(type : RuParseType, acc : RuCollectAcc) -> RuCollectAcc {
	switch (lookupTree(acc.tenv, type.id)) {
		Some(__): {
			acc.conf.onError("type '" + id2s(type.id) + "' is already defined", [RuPlace(acc.file, type.pos)]);
			acc
		}
		None(): {
			conf1 = ruAddErr2Conf(acc.conf, "\nat type '" + id2s(type.id) + "'");
			new_type = RuType(
				RuDescr(type.id, acc.module, [], type.pos), 
				type.supers
			);
			RuCollectAcc(acc with
				local = ruAddType(new_type, acc.local, conf1),
				tenv = setTree(acc.tenv, type.id, 
					ruMakeTypeEnv(new_type, conf1)
				)
			)
		}
	}
}

ruCollectRule(rule : RuParseRule, acc : RuCollectAcc) -> RuCollectAcc {
	switch (ruLookupRule(acc, rule.id)) {
		Some(__): {
			acc.conf.onError("rule '" + id2s(rule.id) + "' is already defined", [RuPlace(acc.file, rule.pos)]);
			acc
		}
		None(): {
			conf1 = ruAddErr2Conf(acc.conf, "\nat rule " + id2s(rule.id));
			type = rule.term.type;
			vars = ruCollectVars(rule.vars, acc, conf1);
			term = ruMakeTerm(rule.term, vars, acc, ruAddErr2Conf(acc.conf, "\nat rule: " + id2s(rule.id)));
			new_rule = RuRule(RuDescr(rule.id, acc.module, [], rule.pos), vars, term);
			switch (lookupTree(acc.tenv, rule.term.type)) {
				Some(tenv): {
					RuCollectAcc(acc with
						local = RuMath(acc.local with 
							rules = setTree(acc.local.rules, rule.id, new_rule),
						),
						tenv = setTree(acc.tenv, type,
							RuTypeEnv(tenv with 
								trie = ruAddTerm2RuTrie(new_rule.term, 
									Some(RuRuleNode(rule.id, type, sizeTree(vars), 0)),
									tenv.trie, conf1
								)
							)
						)
					);
				}
				None(): {
					acc.conf.onError("unknown type '" + id2s(rule.term.type) + "'", [RuPlace(acc.file, rule.term.pos)]);
					acc;
				}
			}
		}
	}
}

ruMakeTerm(term : RuParseExp, vars : Tree<int, RuVar>, acc : RuCollectAcc, conf : RuConf) -> RuTerm {
	expr = fold(term.symbs, [], \ac, symb -> {
		switch (ruLookupConst(acc, symb)) {
			Some(s): concat(ac, [RuConstRef(symb)]);
			None(): 
				switch (lookupTree(vars, symb)) {
					Some(v): concat(ac, [RuVar(symb, v.type)]);
					None(): {
						conf.onError("unknown symbol '" + id2s(symb) + "' in term '" + ruParse2s(term) + "'", [RuPlace(acc.file, term.pos)]);
						//println("glob consts:\n" + strGlue(map(getTreeKeys(acc.global.consts), \c -> "\t'" + c + "'"), "\n") + "\n");
						//println("local consts:\n" + strGlue(map(getTreeKeys(acc.local.consts), \c -> "\t'" + c + "'"), "\n") + "\n");
						quit(0);
						ac
					}
				}
			}
		}
	);
	RuTerm(term.type, expr, term.pos);
}

ruCreateAxiom(ax : RuParseAxiom, acc : RuCollectAcc) -> Maybe<RuAxiom> {
	switch (ruLookupAssertion(acc, ax.id)) {
		Some(__): {
			acc.conf.onError("assertion with name '" + id2s(ax.id) + "' is already defined", [RuPlace(acc.file, ax.pos)]);
			None();
		}
		None(): {
			err = \-> { acc.conf.onError("error in axiom " + id2s(ax.id), [RuPlace(acc.file, ax.pos)]); None(); }
			conf1 = ruAddErr2Conf(acc.conf, "\nat axiom " + id2s(ax.id));
			vars = ruCollectVars(ax.vars, acc, conf1);
			disjs = ruCollectDisjs(ax.disjs, vars, acc, conf1);
			hyps = filtermap(ax.hyps, \h -> ruCollectHyp(h, vars, acc, conf1));
			if (length(hyps) != length(ax.hyps)) {
				err();
			} else {
				switch (ruCollectExp(ax.prop, vars, acc, conf1)) {
					Some(prop): {
						Some(RuAxiom(
							RuDescr(ax.id, acc.module, [], ax.pos), 
							RuStatement(vars, disjs, hyps, prop)
						));
					}
					None(): err();
				}
			}
		}
	}
}

ruCollectExp(ex : RuParseExp, vars : Tree<int, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuExp> {
	ruParseExp(ruMakeTerm(ex, vars, acc, conf), acc.tenv, RuPlace(acc.file, ex.pos), conf)
}

ruCollectVars(vars : [RuParseVar], acc : RuCollectAcc, conf : RuConf) -> Tree<int, RuVar> {
	fold(vars, makeTree(), \ac, v ->
		switch (lookupTree(acc.tenv, v.type)) {
			Some(tp): {
				setTree(ac, v.id, RuVar(v.id, v.type));
			}
			None(): {
				conf.onError("unknown var '" + id2s(v.id) + "' of type '" + id2s(v.type) + "'", [RuPlace(acc.file, v.pos)]);
				ac
			}
		}
	)
}

ruCollectMeta(m : RuParseMeta, vars : Tree<int, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Set<int> {
	fold(m.meta, makeSet(), \ac, v -> {
		if (containsKeyTree(vars, v)) insertSet(ac, v) else {
			conf.onError("unknown var '" + id2s(v) + "'", [RuPlace(acc.file, m.pos)]);
			ac
		}
	});
}

ruCollectDisjs(disjs : [RuParseDisj], vars : Tree<int, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Set<RuDisj> {
	make_var = \v, t -> RuVar(v, t);
	fold(disjs, makeSet(), \acc1, disj -> 
		fold(disj.vars, acc1, \acc2, v1 ->
			fold(disj.vars, acc2, \acc3, v2 -> {
					switch (lookupTree(vars, v1)) {
						Some(vr1): {
							switch (lookupTree(vars, v2)) {
								Some(vr2): {
									if (vr1.id < vr2.id) 
										insertSet(acc3, 
											RuDisj(
												make_var(vr1.id, vr1.type), 
												make_var(vr2.id, vr2.type)
											)
										) 
									else if (vr2.id < vr1.id) 
										insertSet(acc3, 
											RuDisj(
												make_var(vr2.id, vr2.type), 
												make_var(vr1.id, vr1.type)
											)
										) 
									else acc3 
								}
								None(): {
									conf.onError("unknown var '" + id2s(v2) + "' in disjointed set, vars: " + 
									strGlue(map(getTreeValues(vars), \v -> "'" + id2s(v.id) + "'"), ", "), 
									[RuPlace(acc.file, disj.pos)]); acc3;
								}
							}
						}
						None(): {
							conf.onError("unknown var '" + id2s(v1) + "' in disjointed set, vars: " + 
							strGlue(map(getTreeValues(vars), \v -> "'" + id2s(v.id) + "'"), ", "), 
							[RuPlace(acc.file, disj.pos)]); acc3;
						}
					}
				}
			)
		)
	)
}

ruCollectHyp(hyp : RuParseHyp, vars : Tree<int, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuHyp> {
	maybeMap(
		ruCollectExp(hyp.expr, vars, acc, conf), 
		\expr -> RuHyp(hyp.ind, expr, hyp.pos)
	)
}

ruCreateTheorem(th : RuParseTheorem, acc : RuCollectAcc) -> Maybe<RuTheorem> {
	switch (ruLookupAssertion(acc, th.id)) {
		Some(__): {
			acc.conf.onError("assertion with name " + id2s(th.id) + " is already defined", [RuPlace(acc.file, th.pos)]);
			None()
		}
		None(): {
			err = \-> { acc.conf.onError("error in theorem " + id2s(th.id), [RuPlace(acc.file, th.pos)]); None(); }
			conf1 = ruAddErr2Conf(acc.conf, "\nat theorem " + id2s(th.id));
			vars = ruCollectVars(th.vars, acc, conf1);
			disjs = ruCollectDisjs(th.disjs, vars, acc, conf1);
			meta = ruCollectMeta(th.meta, vars, acc, conf1);
			hyps = filtermap(th.hyps, \h -> ruCollectHyp(h, vars, acc, conf1));
			if (length(hyps) != length(th.hyps)) {
				err();
			} else {
				switch (ruCollectExp(th.prop, vars, acc, conf1)) { 
					Some(prop): {
						switch (ruCollectProof(th.proof, vars, acc, conf1)) {
							Some(proof): Some(RuTheorem(
								RuDescr(th.id, acc.module, [], th.pos), 
								RuStatement(vars, disjs, hyps, prop), 
								meta, proof
							));
							None(): err();
						}
					}
					None(): err();
				}
			}
		}
	}
}

ruCollectProof(proof : RuParseProof, vars : Tree<int, RuVar>, acc : RuCollectAcc, conf : RuConf) -> Maybe<RuProof> {
	if (acc.skipProofs) Some(ruNoProof) else {
		proof_vars = ruCollectVars(proof.vars, acc, conf);
		all_vars = mergeTreeCustom(proof_vars, vars, \v, w,__ -> {
			conf.onError("duplicate variable '" + id2s(v) + "'", [RuPlace(acc.file, proof.pos)]);
			w
		});
		proof_disjs = ruCollectDisjs(proof.disjs, all_vars, acc, conf);
		do_ref = \r -> switch (r) {
			RuParseHypRef(i, p): RuHypRef(i, p);
			RuParseStepRef(i, p): RuStepRef(i, p);
		}
		steps = filtermap(proof.steps,
			\s ->
				maybeMap(ruCollectExp(s.expr, all_vars, acc, conf),
					\expr -> RuStep(s.ind, s.assertion, map(s.refs, do_ref), expr, s.pos)
				)
		);
		if (length(steps) != length(proof.steps)) None() else {
			Some(RuProof(proof_vars, proof_disjs, steps, proof.pos));
		}
	}
}

ruCreateDef(df : RuParseDef, acc : RuCollectAcc) -> Maybe<RuDef> {
	switch (ruLookupAssertion(acc, df.id)) {
		Some(__): {
			acc.conf.onError("assertion with name '" + id2s(df.id) + "' is already defined", [RuPlace(acc.file, df.pos)]);
			None()
		}
		None(): {
			err = \-> { acc.conf.onError("error in definition " + id2s(df.id), [RuPlace(acc.file, df.pos)]); None(); }
			conf1 = ruAddErr2Conf(acc.conf, "\nat definitoin " + id2s(df.id));
			vars = ruCollectVars(df.vars, acc, conf1);
			disjs = ruCollectDisjs(df.disjs, vars, acc, conf1);
			prop_ex = fold(df.prop.symbs, [], \ac, s ->
				if (s == s2id("defiendum")) concat(ac, df.defm.symbs) else
				if (s == s2id("definiens")) concat(ac, df.defs.symbs) else
				concat(ac, [s])
			);
			hyps = filtermap(df.hyps, \h -> ruCollectHyp(h, vars, acc, conf1));
			if (length(hyps) != length(df.hyps)) {
				err();
			} else {
				switch (ruCollectExp(RuParseExp(df.prop.type, prop_ex, df.prop.pos), vars, acc, conf1)) {
					Some(prop): {
						switch (ruCollectExp(df.defm, vars, acc, conf1)) {
							Some(defm): {
								switch (ruCollectExp(df.defs, vars, acc, conf1)) {
									Some(defs): 
										Some(RuDef(
											RuDescr(df.id, acc.module, [], df.pos), 
											RuStatement(vars, disjs, hyps, prop), 
											defm, defs
										));
									None(): err();
								}
							}
							None(): err();
						}
					}
					None(): err();
				}
			}
		}
	}
}

ruLookupConst(acc : RuCollectAcc, n : int) -> Maybe<RuConst> {
	switch(lookupTree(acc.global.consts, n)) {
		Some(c): Some(c);
		None(): lookupTree(acc.local.consts, n);
	}
}

ruLookupRule(acc : RuCollectAcc, n : int) -> Maybe<RuRule> {
	switch(lookupTree(acc.global.rules, n)) {
		Some(r): Some(r);
		None(): lookupTree(acc.local.rules, n);
	}
}

ruLookupAssertion(acc : RuCollectAcc, n : int) -> Maybe<RuAssertion> {
	switch(lookupTree(acc.global.assertions, n)) {
		Some(a): Some(a);
		None(): lookupTree(acc.local.assertions, n);
	}
}
