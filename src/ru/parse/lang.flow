import base/stats;
import ru/parse/exp;
import ru/parse/parse;
import ru/verify/math;

export {
	ruCollectSourcesLang(sources : [RuParsed], src_deps : Tree<int, Set<int>>, env : RuEnv) -> RuLang;
}

ruCollectSourcesLang(sources : [RuParsed], src_deps : Tree<int, Set<int>>, env : RuEnv) -> RuLang {
	lang = fold(sources, ruEmptyLang, \acc, src -> {
		switch (src) {
			RuParseSource(__,decls,__,info): {
				fold(src.decls, acc, \ac, decl ->
					switch (decl) {
						RuParseConst(__,__,__,__,__): ruCollectConst(ruCreateConst(decl, info, env), ac, info, env);
						RuParseType(__,__,__,__):     ruCollectType(ruCreateType(decl, info, env), ac, info, env);
						RuParseRule(__,__,__,__,__):  ruCollectRule(ruCreateRule(decl, info, env), acc, info, env);
						default: ac;
					}
				)
			}
			RuSource(__,decls,__,info): {
				fold(src.decls, acc, \ac, decl ->
					switch (decl) {
						RuConst(__,__,__): ruCollectConst(decl, ac, info, env);
						RuType(__,__):     ruCollectType(decl, ac, info, env);
						RuRule(__,__,__):  ruCollectRule(decl, ac, info, env);
						default: ac;
					}
				)
			}
		}
	});
	ruCheckLang(lang, src_deps, env);
	lang;
}

ruCollectConst(const : RuConst, acc : RuLang, src_info : RuFileInfo, env : RuEnv) -> RuLang {
	switch (lookupTree(acc.consts, const.info.id)) {
		Some(__): {
			env.out.onError("constant '" + id2s(const.info.id) + "' is already defined", [ruDeclPlace(const, env)]);
			acc
		}
		None(): {
			RuLang(acc with
				consts = setTree(acc.consts, const.info.id, const)
			);
		}
	}
}

ruCreateConst(const : RuParseConst, src_info : RuFileInfo, env : RuEnv) -> RuConst {
	RuConst(
		RuDeclInfo(
			const.id, 
			src_info.id, 
			ruCollectComments(const.comments, src_info, env), 
			const.pos
		), 
		const.ascii, 
		const.latex
	);
}

ruCollectType(type : RuType, acc : RuLang, src_info : RuFileInfo, env : RuEnv) -> RuLang {
	switch (lookupTree(acc.types, type.info.id)) {
		Some(__): {
			env.out.onError("type '" + id2s(type.info.id) + "' is already defined", [ruDeclPlace(type, env)]);
			acc
		}
		None(): {
			RuLang(acc with
				types = setTree(acc.types, type.info.id, type)
			);
		}
	}
}


ruCreateType(type : RuParseType, src_info : RuFileInfo, env : RuEnv) -> RuType {
	RuType(
		RuDeclInfo(
			type.id, 
			src_info.id, 
			ruCollectComments(type.comments, src_info, env), 
			type.pos
		), 
		type.supers
	);
}

ruCollectRule(rule : RuRule, acc : RuLang, src_info : RuFileInfo, env : RuEnv) -> RuLang {
	switch (lookupTree(acc.rules, rule.info.id)) {
		Some(__): {
			env.out.onError("rule '" + id2s(rule.info.id) + "' is already defined", [ruDeclPlace(rule, env)]);
			acc
		}
		None(): {
			RuLang(acc with
				rules = setTree(acc.rules, rule.info.id, rule)
			);
		}
	}
}

ruCreateRule(rule : RuParseRule, src_info : RuFileInfo, env : RuEnv) -> RuRule {
	vars = ruCreateVars(rule.vars);
	RuRule(
		RuDeclInfo(
			rule.id, 
			src_info.id, 
			ruCollectComments(rule.comments, src_info, env), 
			rule.pos
		), 
		vars, 
		ruCreateTerm(rule.term, vars, src_info, env)
	);
}

ruCreateTerm(term : RuParseExp, vars : Tree<int, RuVar>, src_info : RuFileInfo, env : RuEnv) -> RuTerm {
	expr = fold(term.symbs, [], \ac, symb ->
		switch (lookupTree(vars, symb)) {
			Some(v): concat(ac, [RuVar(symb, v.type)]);
			None():  concat(ac, [RuConstRef(symb)]);
		}
	);
	RuTerm(term.type, expr, term.pos);
}

ruCollectComments(comms : [RuParseComment], info : RuFileInfo, env : RuEnv) -> [RuComment] {
	map(comms, \comm -> 
		RuComment(comm.text, ruCollectAnnotation(comm.json, comm.pos, info, env), comm.pos)
	);
}

ruCollectAnnotation(json_str : string, pos : int, info : RuFileInfo, env : RuEnv) -> JsonObject {
	if (json_str == "") JsonObject([]) else {
		json = parseJson(json_str);
		switch (json) {
			JsonObject(__): json;
			default: {
				env.out.onError("Annotation must be a JSON object, got:\n\t" + json_str + "\n", [RuPlace(info.path, pos)]);
				JsonObject([]);
			}
		}
	}
}

ruCreateVars(vars : [RuParseVar]) -> Tree<int, RuVar> {
	fold(vars, makeTree(), \ac, v -> setTree(ac, v.id, RuVar(v.id, v.type)));
}

ruCheckLang(lang : RuLang, imports : Tree<int, Set<int>>, env : RuEnv) -> void {
	traverseInOrder(lang.types, \id, type -> 
		iter(type.supers, \sup -> ruCheckTypePreceeds(sup, lang, type, imports, env))
	);
	traverseInOrder(lang.rules, \id, rule -> {
		ruCheckVars(rule.vars, lang, rule, imports, env);
		ruCheckTerm(rule.term, rule.vars, lang, rule, imports, env);
	});
}

//ruCheckType(type : RuType, lang : RuLang, decl : RuDecl, imports : Tree<int, Set<int>>, env : RuEnv) -> void {
//	iter(type.supers, \sup -> ruCheckTypePreceeds(sup, lang, type, imports, env));
//}

ruCheckVars(vars : Tree<int, RuVar>, lang : RuLang, decl : RuDecl, imports : Tree<int, Set<int>>, env : RuEnv) -> void {
	traverseInOrder(vars, \id, v -> ruCheckTypePreceeds(v.type, lang, decl, imports, env));
}

ruCheckTerm(term : RuTerm, vars : Tree<int, RuVar>, lang : RuLang, decl : RuDecl, imports : Tree<int, Set<int>>, env : RuEnv) -> void {
	ruCheckTypePreceeds(term.type, lang, decl, imports, env);
	iter(term.nodes, \node -> 
		switch (node) {
			RuConstRef(id): {
				if (!containsKeyTree(lang.consts, id)) {
					env.out.onError("symbol '" + id2s(id) + "' is not declared as constant", [ruDeclPlace(decl, env)]);
				}
			}
			RuVar(id, type): {
				if (!containsKeyTree(vars, id)) {
					env.out.onError("variable '" + id2s(id) + "' is not declared as variable", [ruDeclPlace(decl, env)]);
				}
			}
		}
	);
}

ruCheckTypePreceeds(type_id : int, lang : RuLang, decl : RuDecl, imports : Tree<int, Set<int>>, env : RuEnv) -> void {
	switch (lookupTree(lang.types, type_id)) {
		Some(type): {
			if (!ruDeclPreceeds(type, decl, imports)) {
				env.out.onError("type: '" + id2s(type_id) + "' must preceed '" + id2s(decl.info.id) + "'", [ruDeclPlace(decl, env)]);
			}
		}
		None(): {
			env.out.onError("type: '" + id2s(type_id) + "' is undefined", [ruDeclPlace(decl, env)]);
		}
	}
}
