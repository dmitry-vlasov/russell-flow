import math/stringmath;
import ru/parse/exps/parser;
import ru/src;

export {
	ruParseExps(types: [int], nodes : [RuTermNode], lang : RuLang, place : RuPlace, env : RuEnv) -> Maybe<[RuExp]>;
	ruParseExp(term: RuTerm, lang : RuLang, place : RuPlace, env : RuEnv) -> Maybe<RuExp>;
}

ruParseExp(term: RuTerm, lang : RuLang, place : RuPlace, env : RuEnv) -> Maybe<RuExp> {
	maybeBind(ruParseExps([term.type], term.nodes, lang, place, env), \es ->
		if (length(es) != 1) None() else Some(es[0])
	)
}

ruCreateTypeParsers(nodes : [RuTermNode], lang : RuLang, env : RuEnv) -> Tree<int, RuTypeParser> {
	types = foldTree(lang.types, 
		makeTree(), 
		\id, type, acc -> setTree(acc, id, ruMakeTypeParser(type, env))
	);
	symbs = fold(nodes, makeSet(), \acc, node -> 
		switch (node) {
			RuVar(__, type): acc;
			RuConstRef(c): insertSet(acc, c);
		}
	);
	fold(
		filter(
			getTreeValues(lang.rules),
			\rule -> forall(rule.term.nodes, \node ->
				switch (node) {
					RuConstRef(c): containsSet(symbs, c);
					default: true;
				}
			)
		), 
		types,
		\acc, rule -> ruAddRule2TypeParserTree(rule, acc, env)
	);
}

RuParseAcc(
	exps : [RuExp],
	pos : int,
);

ruParseExps(tps: [int], nodes : [RuTermNode], lang : RuLang, place : RuPlace, env : RuEnv) -> Maybe<[RuExp]> {
	if (length(nodes) == 0) {
		env.out.error("empty expression is met", []);
		None()
	} else {
		types = ruCreateTypeParsers(nodes, lang, env);
		maybeBind(
			fold(tps,
				Some(RuParseAcc([], 0)),
				\macc, type -> maybeBind(macc,
					\acc -> switch (lookupTree(types, type)) {
						Some(tenv): {
							ret = maybeMap(
								ruParseExpr(
									RuParseEnv(nodes, types, lang, env),
									acc.pos,
									RuParseStack(None(), acc.pos, acc.pos, type, tenv.trie, [])
								),
								\pair -> RuParseAcc(arrayPush(acc.exps, RuExp(reverseA(pair.first), acc.pos)), pair.second)
							);
							if (ret == None()) {
								term_symbs = set2array(fold(nodes, makeSet(),
									\ac, node -> 
										switch (node) {
											RuVar(__,__): ac;
											RuConstRef(c): insertSet(ac, c);
										}
								));
								err = "expr: '" + ruTypedTermNodes2s(nodes) + "' was not parsed" +
									(if (env.conf.verbose <= 1) "" else 
									"\n" + ruTypeParserTree2s(types) + "\n" +
									"term symbs: " + strGlue(map(term_symbs, id2s), ", ") + "\n" + 
									"all rules:\n" + concatStrings(map(getTreeValues(lang.rules), \r -> "\t" + ruTerm2s(r.term) + "\n")));
								env.out.error(err, [place]);
								//ruCrash("parser failure:\n" + err + "\n\n");
							}
							ret
						}
						None(): {
							env.out.error("unknown type: '" + id2s(type) + "', term: " + ruTypedTermNodes2s(nodes), [place]);
							fail("AAA");
							None();
						}
					}
				)
			), \acc: RuParseAcc -> if (acc.pos == length(nodes)) Some(acc.exps) else {
				env.out.error("some extra expression leftover is not parsed, term: " + ruTypedTermNodes2s(nodes), [place]);
				None();
			}
		)
	}
}

RuParseEnv(
	nodes : [RuTermNode],
	types : Tree<int, RuTypeParser>,
	lang : RuLang,
	env : RuEnv,
);

RuParseStack(
	parent : Maybe<RuParseStack>,
	start : int,
	curr : int,
	type_id : int,
	trie : RuTrie2<int, RuRuleNode>,
	expr : [[RuExpNode]],
);

ruDoConcatAReversed(i: int, expr : [[RuExpNode]], acc: [RuExpNode]) -> [RuExpNode] {
	if (i == -1) acc else {
		ruDoConcatAReversed(i - 1, expr, concat(acc, expr[i]))
	}
}

ruConcatAReversed(expr : [[RuExpNode]]) -> [RuExpNode] {
	ruDoConcatAReversed(length(expr) - 1, expr, [])
}

ruPopExprStack(env : RuParseEnv, pos : int, stack : RuParseStack) -> RuParseStack {
	switch (stack.trie.data) {
		Some(rf): {
			subexpr = ruConcatAReversed(stack.expr);
			full_expr = arrayPush(subexpr,
				RuRuleNode(
					rf.idType,
					ruMakeArityLen(ruArityLen2Arity(rf.arityLen), length(subexpr))
				),
			);
			switch (stack.parent) {
				Some(parent): {
					ruPopExprStack(env, pos, 
						RuParseStack(parent with expr = arrayPush(parent.expr, full_expr))
					);
				}
				None(): 
					RuParseStack(stack with expr = [full_expr]);
			}
		}
		None(): stack;
	}
}

ruParseExpr(env : RuParseEnv, pos : int, stack0 : RuParseStack) -> Maybe<Pair<[RuExpNode], int>> {
	stack = RuParseStack(stack0 with curr = pos);
	do_step = \st, n -> {
		poped = ruPopExprStack(env, pos, RuParseStack(st with trie = n));
		if (ruTrie2IsEnd(poped.trie) && isNone(poped.parent)) {
			Some(Pair(poped.expr[0], pos + 1));
		} else {
			ruParseExpr(env, pos + 1, poped);
		}
	}
	try_var = \t, n -> maybeBind(lookupTree(env.types, t),
		\tenv -> if (t == stack.type_id && stack.curr == stack.start) None() else {
			ruParseExpr(env, pos,
				RuParseStack(
					Some(RuParseStack(stack with trie = n)), 
					pos, pos, t, tenv.trie, []
				)
			)
		}
	);
	try_supers = \v, t -> {
		supers = lookupTreeDef(env.types, t, ruNoTypeParser).supers;
		foldTree(stack.trie.map1, None(), \tp, m, ac -> 
			if (isSome(ac)) ac else {
				switch (lookupTree(supers, tp)) {
					Some(r): {
						switch (do_step(RuParseStack(stack with 
							expr = arrayPush(
								stack.expr,
								[
									RuVar(v, t),
									ruMakeParsedRule(r.info.id, r.term.type, 1, 1),
								], 
							)
						), m)) {
							Some(ret): Some(ret);
							None(): try_var(tp, m);
						}
					}
					None(): try_var(tp, m);
				}
			}
		);
	}
	switch (env.nodes[pos]) {
		RuVar(v, t_id): {
			switch (lookupTree(stack.trie.map1, t_id)) {
				Some(n): {
					switch (do_step(RuParseStack(stack with expr = arrayPush(stack.expr, [RuVar(v, t_id)])), n)) {
						Some(ret): Some(ret);
						None(): try_supers(v, t_id);
					}
				}
				None(): try_supers(v, t_id);
			}
		}
		RuConstRef(id): {
			switch (lookupTree(stack.trie.map2, id)) {
				Some(n): {
					switch (do_step(stack, n)) {
						Some(ret): Some(ret);
						None(): foldTree(stack.trie.map1, None(), \t, v, ac ->
							if (isSome(ac)) ac else try_var(t, v)
						);
					}
				}
				None(): foldTree(stack.trie.map1, None(), \t, v, ac ->
					if (isSome(ac)) ac else try_var(t, v)
				);
			}
		}
	}
}
