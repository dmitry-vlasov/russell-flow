import base/trie;
import ru/util/utils;
import ru/parse/src;

export {
	RuParserNode ::= RuTypeRef, RuConstRef;
	RuTypeRef(id: int);

	RuNonterm(
		rules : RuTrie<RuParserNode, RuRuleNode>
	);
	RuGrammar(
		nonterms : Tree<int, RuNonterm>,
	);

	ruAddRule2Grammar(rule : RuRule, gram : RuGrammar, env : RuEnv) -> RuGrammar;
	ruAddRule2Nonterm(rule : RuRule, nonterm : RuNonterm, env : RuEnv) -> RuNonterm;	
	ruMakeNonterm(type : RuType, env : RuEnv) -> RuNonterm;
	ruTermNode2ParserNode(n : RuTermNode) -> RuParserNode;

	ruNonterm2s(nonterm : RuNonterm) -> string;
	ruGrammar2s(gram: RuGrammar) -> string;
}

ruAddRule2Grammar(rule : RuRule, gram : RuGrammar, env : RuEnv) -> RuGrammar {
	RuGrammar(setTree(gram.nonterms, rule.term.type, 
		ruAddRule2Nonterm(rule,
			either(
				lookupTree(gram.nonterms, rule.term.type),
				RuNonterm(ruMakeTrie())
			),
			env
		)
	));
}

ruAddRule2Nonterm(rule : RuRule, nonterm : RuNonterm, env : RuEnv) -> RuNonterm {
	ruAddTerm2Nonterm(rule.term, 
		Some(ruMakeRuleNode(rule.info.id, rule.term.type, sizeTree(rule.vars), 0)),
		nonterm, env
	);
}

ruAddTerm2Nonterm(term : RuTerm, rule : Maybe<RuRuleNode>, nonterm : RuNonterm, env : RuEnv) -> RuNonterm {
	RuNonterm(ruAdd2Trie(nonterm.rules, map(term.nodes, ruTermNode2ParserNode), rule, 
		\a1, a2 -> {
			if (a1 != a2) {
				env.out.error(
					"rule term: '" + ruTerm2s(term) + "' is already used,\nrule:\n" + strIndent(eitherMap(rule, ruRuleNode2s, "NONE")), 
					[]
				);
				fail("crash");
			}
			a1
		}
	))
}

ruTermNode2ParserNode(n : RuTermNode) -> RuParserNode {
	switch (n) {
		RuConstRef(id):  n;
		RuVar(__, type): RuTypeRef(type);
	}
}

ruMakeNonterm(type : RuType, env : RuEnv) -> RuNonterm {
	fold(type.supers, 
		ruAddTerm2Nonterm(
			RuTerm(type.info.id, [RuVar(ruIdX(), type.info.id)], type.info.pos), 
			None(),
			RuNonterm(ruMakeTrie()), env
		),
		\acc, super -> {
			rule = ruMakeSuperRule(super, type.info.id, type.info.src, type.info.pos);
			rule_node = ruMakeRuleNode(rule.info.id, rule.term.type, sizeTree(rule.vars), 0);
			ruAddTerm2Nonterm(rule.term, Some(rule_node), acc, env)
		}
	)
}

ruNonterm2s(nonterm : RuNonterm) -> string {
	ruTrie2s(nonterm.rules,
		//\x -> ruRuParserNode2s(x),
		\x -> id2s(x.id),
		\n -> "id=" + id2s(ruIdType2Id(n.idType)) + " type=" + id2s(ruIdType2Type(n.idType))
	)
}

ruGrammar2s(gram : RuGrammar) -> string {
	foldTree(gram.nonterms, "", \type, nonterm, acc ->
		acc + "\n" + id2s(type) + ":\n" + strIndent(ruNonterm2s(nonterm))
	)
}

ruRuParserNode2s(node: RuParserNode) -> string {
	switch (node) {
		RuTypeRef(id):  "type " + id2s(id);
		RuConstRef(id): "const " + id2s(id);
	}
}
