import base/trie2;
import ru/util/utils;
import ru/parse/src;

export {
	RuTypeParser(
		trie   : RuTrie2<int, RuRuleNode>,
		supers : Tree<int, RuRule>,
	);
	ruNoTypeParser = RuTypeParser(ruTrie2Empty(), makeTree());

	ruAddRule2TypeParserTree(rule : RuRule, tenv : Tree<int, RuTypeParser>, env : RuEnv) -> Tree<int, RuTypeParser>;
	ruAddRule2TypeParser(rule : RuRule, te : RuTypeParser, env : RuEnv) -> RuTypeParser;	
	ruMakeTypeParser(type : RuType, env : RuEnv) -> RuTypeParser;

	ruTypeParser2s(tenv : RuTypeParser) -> string;
	ruTypeParserTrie2s(trie: RuTrie2<int, RuRuleNode>) -> string;
	ruTypeParserTree2s(tree : Tree<int, RuTypeParser>) -> string;
}

ruAddRule2TypeParserTree(rule : RuRule, tenv : Tree<int, RuTypeParser>, env : RuEnv) -> Tree<int, RuTypeParser> {
	switch (lookupTree(tenv, rule.term.type)) {
		Some(te): {
			setTree(tenv, rule.term.type, ruAddRule2TypeParser(rule, te, env));
		}
		None(): tenv;
	}
}

ruAddRule2TypeParser(rule : RuRule, te : RuTypeParser, env : RuEnv) -> RuTypeParser {
	if (ruTermIsVar(rule.term)) te else {
		RuTypeParser(te with
			trie = ruAddTerm2RuTrie2(rule.term, 
				Some(ruMakeRuleNode(rule.info.id, rule.term.type, sizeTree(rule.vars), 0)),
				te.trie, env
			)
		);
	}
}

ruAddTerm2RuTrie2(term : RuTerm, rule : Maybe<RuRuleNode>, trie : RuTrie2<int, RuRuleNode>, env : RuEnv) -> RuTrie2<int, RuRuleNode> {
	ruAdd2Trie2(trie, map(term.nodes, ruTermNode2Key), rule, 
		\a1, a2 -> {
			if (a1 != a2) {
				env.out.error(
					"rule term: '" + ruTerm2s(term) + "' is already used,\nrule:\n" + strIndent(eitherMap(rule, ruRuleNode2s, "NONE")), 
					[]
				);
				fail("crash");
			}
			a1
		}
	)
}

ruTermNode2Key(n : RuTermNode) -> Pair<int, bool> {
	switch (n) {
		RuConstRef(id):  Pair(id, false);
		RuVar(id, type): Pair(type, true);
	}
}

ruMakeTypeParser(type : RuType, env : RuEnv) -> RuTypeParser {
	RuTypeParser(
		ruAddTerm2RuTrie2(
			RuTerm(type.info.id, [RuVar(ruIdX(), type.info.id)], type.info.pos), 
			None(),
			ruTrie2Empty(), env
		),
		fold(type.supers, makeTree(), \ac, super -> 
			setTree(ac, super, ruMakeSuperRule(super, type.info.id, type.info.src, type.info.pos))
		)
	)
}

ruTypeParserTrie2s(trie: RuTrie2<int, RuRuleNode>) -> string {
	ruTrie2Tos(trie, id2s, \n -> "id=" + id2s(ruIdType2Id(n.idType)) + " type=" + id2s(ruIdType2Type(n.idType)))
}

ruTypeParser2s(tenv : RuTypeParser) -> string {
	(if (ruSize2Trie2(tenv.trie) == 0) "" else
		"rules: " + i2s(ruSize2Trie2(tenv.trie)) + ":\n" + 
			strIndent(ruTypeParserTrie2s(tenv.trie)) + "\n"
	) +
	(if (sizeTree(tenv.supers) == 0) "" else 
		"supers:\n" + 
			foldTree(tenv.supers, "", \type, super, acc ->
				acc + "\t" + id2s(cast(super.term.nodes[0]: RuTermNode -> RuVar).type) + ": " + id2s(type) + "\n"
			)
	)
}

ruTypeParserTree2s(tree : Tree<int, RuTypeParser>) -> string {
	foldTree(tree, "", \type, tenv, acc ->
		acc + "\n" + id2s(type) + ":\n" + strIndent(ruTypeParser2s(tenv))
	)
}
