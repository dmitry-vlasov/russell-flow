import ru/update;

export {
	ruWriteSource(src : RuSource, math : RuMath, conf : RuConf) -> void;
	ruWriteRefactoredSources(srcs : Set<string>, math : RuMath, conf : RuConf) -> void;
}

ruWriteSource(src : RuSource, math : RuMath, conf : RuConf) -> void {
	path = src.info.path;
	test = lookupTreeDef(conf.opts, "test-write", "");
	if (test != "1") {
		dir = ruDirName(path);
		err = ensureDirectoryExists(dir);
		if (err != "") {
			conf.onError("failed to create directory: '" + dir + "'", [RuPlace(src.info.module, -1)]);
		}
	}
	ext = ltrim2(getFileExt(path), ".");
	maxlen = s2i(lookupTreeDef(conf.opts, "maxlen-expr", "32"));
	src_str = ru2sWrapExp(src, math.rules, \s -> ruIndentBrackets(s, maxlen));
	if (!setFileContent(src.info.path, src_str)) {
		conf.onError("failed to save file", [RuPlace(src.info.module, -1)]);
	} else {
		if (conf.verbose >= 2) {
			conf.onMessage("\t" + ext + " has written : '" + path + "'");
		}
		if (conf.verbose >= 3) {
			conf.onMessage("\tsource saved:\n--------------------\n" + src_str + "\n--------------------\n\n\n");
		}
		ruToMemCache(ruUpdateSourcePositions(src, conf), conf);
		ruToDiskCache(ruUpdateSourcePositions(src, conf), conf);
	}
}

ruWriteRefactoredSources(srcs : Set<string>, math : RuMath, conf : RuConf) -> void {
	start = timestamp();
	iterSet(srcs, \s -> 
		maybeApply(lookupTree(math.sources, s), \src ->
			ruWriteSource(src, math, conf)
		)
	);
	if (conf.verbose > 0) {
		msg = 
			"ru saved: " + i2s(sizeSet(srcs)) + " refactored sources in " + d2st((timestamp() - start)/ 1000.0, 2) + "s" + 
			(if (conf.verbose == 1) "" else
				"\n\tsaved sources:\n" + strGlue(map(set2array(srcs), \src -> "\t\t" + src), "\n")
			);
		conf.onMessage(msg);
	}
}
