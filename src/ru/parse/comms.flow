import ru/parse/collect;
import ru/parse/write;

export {
	ruIoCommands : [RuComm] = [ 
		ruCommRead,
		ruCommWrite
	];
	ruRunWrite(task : ScTask, env : RuState) -> Maybe<RuState>;
	ruRunRead(task : ScTask, env : RuState) -> Maybe<RuState>;
}

ruCommWrite = RuComm(
	"write-ru", "io", "write a Russell file to a filesystem", "target", false,
	[
		RuCommArg("target", true, "input file, module or 'all' (default)", "all"),
		RuCommArg("monolithic", true, "include all dependencies into a target file", ""),
		RuCommArg("test-write", true, "perform a test writing - do not save files", ""),
	],
	ruRunWrite
);

ruRunWrite(task : ScTask, env : RuState) -> Maybe<RuState> {
	math = env.ruMath;
	test = lookupTreeDef(task.args, "test-write", "");
	conf = if (test != "1") env.conf else RuConf(env.conf with opts = setTree(env.conf.opts, "test-write", "1"));
	write_module = \module -> {
		switch (lookupTree(math.sources, module)) {
			Some(src): {
				if (ruVerbose(conf) > 1)  {
					conf.onMessage("\tgoing to save: '" + id2s(module) + "'");
				}
				monolith =lookupTreeDef(task.args, "monolithic", "");
				if (monolith == "") {
					ruWriteSource(src, math, conf);
				} else {
					if (monolith != "1") {
						ruWriteSource(ruMath2SingleSource(math, monolith, conf), math, conf);
					} else {
						ruWriteSource(ruMath2SingleSource(math, src.info.path, conf), math, conf);
					}
				}
			}
			None(): conf.onMessage("module: '" + id2s(module) + "' is not found");
		}
	}
	if (sizeTree(math.sources) == 0) {
		conf.onError("There are no Russell sources at all.", []);
	} else {
		file = lookupTreeDef(task.args, "target", "");
		ruSaveIds(conf);
		if (file == "all") {
			timer = ruMakeTimer();
			iter(getTreeValues(math.sources), 
				\src -> ruWriteSource(src, math, conf)
			);
			if (ruVerbose(conf) > 0 && ruTimePassed(timer) > 100.0) {
				conf.onMessage("ru written " + i2s(sizeTree(math.sources)) + " files in " + ruTimePassed2s(timer));
			}
		} else {
			file_id = s2id(file);
			if (containsKeyTree(math.sources, file_id)) {
				write_module(file_id)
			} else {
				module = ruTrimPath(file, conf, ".ru");
				module_id = s2id(module);
				if (containsKeyTree(math.sources, module_id)) {
					write_module(module_id)
				} else {
					conf.onError("Russell source '" + file + "' is not found", []);
				}
			}
		}
	}
	Some(env);
}

ruCommRead = RuComm(
	"read-ru", "io", "read a Russell file", "file", true, 
	[
		RuCommArg("file", false, "input file", ""),
		RuCommArg("skip-proofs", true, "leave proofs blank", ""),
	],
	ruRunRead
);

ruRunRead(task : ScTask, env : RuState) -> Maybe<RuState> {
	file = lookupTreeDef(task.args, "file", "");
	if (!endsWith(file, ".ru")) {
		env.conf.onError("Wrong extension of a file: '" + file + "', must be *.ru", []);
		None();
	} else {
		conf = env.conf;
		path = ruResolveRelativePath(file, conf.workingDir);
		if (!fileExists(path)) {
			conf.onError("ru file: '" + file + "' is not found", []);
			None();
		} else {
			module = ruTrimPath(path, conf, getFileExt(file));
			skip_proofs = lookupTreeDef(task.args, "skip-proofs", "");
			ru = maybeBind(
				maybeBind(ruLoadAll(conf, s2id(module), ruFromCache), \loaded ->
					ruParseAll(getTreeValues(loaded), conf)
				), 
				\parsed -> ruCollectMath(parsed, conf, skip_proofs == "1")
			);
			maybeMap(ru, \math -> RuState(env with ruMath = math));
		}
	}
}
