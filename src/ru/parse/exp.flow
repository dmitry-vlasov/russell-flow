import math/stringmath;
import ru/parse/type_env;

export {
	ruParseExp(term : RuTerm, types : Tree<string, RuWithSource<RuTypeEnv>>, conf : RuConf) -> Maybe<RuExp> {
		if (length(term.expr) == 0) {
			conf.onError("empty expression met", []);
			None()
		} else {
			switch (lookupTree(types, term.type)) {
				Some(ws): {
					tenv = ws.item;
					ret = maybeMap(
						ruParseExpr(RuParseEnv(term.expr, types, conf), 0, RuParseStack(None(), 0, 0, tenv.type.name, tenv.trie, [])),
						\nodes -> RuExp(nodes, term.pos)
					);
					if (ret == None()) {
						conf.onMessage("expr: " + ruTerm2s(term.expr) + " was not parsed");
					}
					ret
				}
				None(): {
					conf.onError("unknown type: " + term.type, []);
					None();
				}
			}
		}
	}
}

RuParseEnv(
	nodes : [RuTermNode],
	types : Tree<string, RuWithSource<RuTypeEnv>>, 
	conf : RuConf,
);

RuParseStack(
	parent : Maybe<RuParseStack>,
	start : int,
	curr : int,
	type : string,
	trie : RuTrie<string, RuRuleRef>,
	expr : [[RuExpNode]],
);

ruPopExprStack(env : RuParseEnv, pos : int, stack : RuParseStack) -> RuParseStack {
	switch (stack.trie.data) {
		Some(ref): {
			switch (stack.parent) {
				Some(parent): {
					subexpr = concatA(reverseA(stack.expr));
					ruPopExprStack(env, pos, 
						RuParseStack(parent with
							expr = concat(
								[
									concat(
										[RuRuleRef(ref.name, ref.type, ref.arity, length(subexpr))], 
										subexpr
									)
								], 
								parent.expr
							)
						)
					);
				}
				None(): stack;
			}
		}
		None(): stack;
	}
}

ruParseExpr(env : RuParseEnv, pos : int, stack0 : RuParseStack) -> Maybe<[RuExpNode]> {
	stack = RuParseStack(stack0 with curr = pos);
	if (pos == length(env.nodes)) {
		expr = concatA(reverseA(stack.expr));
		switch (stack.trie.data) {
			Some(ref): Some(concat(
				[RuRuleRef(ref.name, ref.type, ref.arity, length(expr))], 
				expr
			));
			None(): Some(expr);
		}
	} else {
		do_step = \st, n -> {
			poped = ruPopExprStack(env, pos, RuParseStack(st with trie = n));
			ruParseExpr(env, pos + 1, poped);
		}
		try_supers = \v, t -> {
			supers = lookupTreeDef(env.types, t, RuWithSource(ruNoTypeEnv, "")).item.supers;
			foldTree(stack.trie.map, None(), \tp, m, ac -> 
				if (ac != None()) ac else {
					switch (lookupTree(supers, tp)) {
						Some(r): 
							do_step(RuParseStack(stack with 
								expr = concat([[RuRuleRef(r.name, r.term.type, 1, 1), RuVar(v, t)]], stack.expr)
							), m);
						None(): ac;
					}
				}
			);
		}
		try_vars = \-> {
			foldTree(stack.trie.map, None(), \t, n, ac ->
				if (ac != None()) ac else {
					switch (lookupTree(env.types, t)) {
						Some(ws): {
							tenv = ws.item;
							if (tenv.type.name == stack.type && stack.curr == stack.start) ac else {
								ruParseExpr(env, pos, 
									RuParseStack(
										Some(RuParseStack(stack with trie = n)), 
										pos, pos, tenv.type.name, tenv.trie, []
									)
								)
							}
						}
						None(): ac;
					}
				}
			)
		}
		switch (env.nodes[pos]) {
			RuVar(v, t):
				switch (lookupTree(stack.trie.map, t)) {
					Some(n): {
						switch (do_step(RuParseStack(stack with expr = concat([[RuVar(v, t)]], stack.expr)), n)) {
							Some(ret): Some(ret);
							None(): 
								switch (try_supers(v, t)) {
									Some(ret): Some(ret);
									None(): try_vars();
								}
						}
					}
					None(): 
						switch (try_supers(v, t)) {
							Some(ret): Some(ret);
							None(): try_vars();
						}
				}
			RuConstRef(c): {
				switch (lookupTree(stack.trie.map, c)) {
					Some(n): {
						switch (do_step(stack, n)) {
							Some(ret): Some(ret);
							None(): try_vars();
						}
					}
					None(): try_vars();
				}
			}
		}
	}
}
