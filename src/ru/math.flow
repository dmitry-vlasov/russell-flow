import base/stats;
import ru/parse/type_env;
import ru/cache;

export {
	RuMath(
		sources    : Tree<string, RuSource>,
		consts     : Tree<string, RuConst>,
		types      : Tree<string, RuTypeEnv>,
		rules      : Tree<string, RuRule>,
		assertions : Tree<string, RuAssertion>
	);
	ruEmptyMath = RuMath(makeTree(), makeTree(), makeTree(), makeTree(), makeTree());

	ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace;
	ruFindSource(name : string, math : RuMath) -> string;
	ruNameSource(name : string, math : RuMath) -> Maybe<RuSource>;
	ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom>;
	ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem>;
	ruMathDefs(math : RuMath) ->Tree<string, RuDef>;
	ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule>;

	ruMathStats(math : RuMath) -> string;
	ruMathInfo(math : RuMath) -> string;

	ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath;
	ruRemoveSource(src : RuSource, m : RuMath) -> RuMath;
	ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruMakeMathFromSource(src : RuSource, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuMath;
	ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath;
	ruMath2SingleSource(math : RuMath, file : string, conf : RuConf) -> RuSource;

	ruFixLeftRecursiveRules(math : RuMath, conf : RuConf) -> RuMath;
	ruCollectAllImported(name : string, math : RuMath) -> Set<RuSource>;

	ruOrderSources(math : RuMath) -> [RuSource];
	ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;
	ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddComment(c : RuComment, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;

	ruSourceTheorems(src : RuSource) -> [RuTheorem];
	ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem;

	ruMathAssertionDepths(math : RuMath) -> Tree<string, int>;
	ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>>;
	ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<string, Set<string>>;
	ruMathAssertionProofSteps(math : RuMath) -> Tree<string, Tree<string, [int]>>;

	ruAssertionDepth(ass : string, math : RuMath) -> int;
	ruAssertionAxioms(ass : string, math : RuMath) -> Set<string>;
	ruAssertionDependencies(ass : string, math : RuMath, conf : RuConf) -> Set<string>;
	ruAssertionDependendsOn(ass : string,  dep : string, math : RuMath, conf : RuConf) -> bool;
	ruAssertionCyclicDependency(ass : string,  math : RuMath, conf : RuConf) -> bool;
	ruAssertionsProofSteps(as : Set<string>, math : RuMath) -> Tree<string, Tree<string, [int]>>;

	ruSourceDeclNames(src : string, acc : Set<string>, math : RuMath, conf : RuConf) -> Set<string>;

	ruCheckCyclicDependencies(math : RuMath, conf : RuConf) -> RuMath;
}

ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, ruFindSource(name, math), ruNoSource).info.module, pos
	);
}

ruFindSource(name : string, math : RuMath) -> string {
	switch (lookupTree(math.assertions, name)) {
		Some(a): a.src;
		None(): {
			switch (lookupTree(math.consts, name)) {
				Some(c): c.src;
				None(): {
					switch (lookupTree(math.types, name)) {
						Some(e): e.type.src;
						None(): {
							switch (lookupTree(math.rules, name)) {
								Some(r): r.src;
								None(): "";
							}
						}
					}
				}
			}
		}
	}
}

ruNameSource(name : string, math : RuMath) -> Maybe<RuSource> {
	lookupTree(math.sources, ruFindSource(name, math));
}

ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuAxiom(__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuTheorem(__,__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathDefs(math : RuMath) ->Tree<string, RuDef> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuDef(__,__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule> {
	switch (lookupTree(math.types, infer)) {
		Some(infEnv): lookupTree(infEnv.supers, super);
		None(): {
			conf.onError("unknown type: " + infer, []);
			quit(-1);
			None();
		}
	}
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"sources:    " + i2s(sizeTree(math.sources)),
		"consts:     " + i2s(sizeTree(math.consts)),
		"types:      " + i2s(sizeTree(math.types)),
		"rules:      " + i2s(sizeTree(math.rules)),
		"assertions: " + i2s(sizeTree(math.assertions)),
		"  axioms:   " + i2s(sizeTree(ruMathAxioms(math))),
		"  theorems: " + i2s(sizeTree(ruMathTheorems(math))),
		"  defs:     " + i2s(sizeTree(ruMathDefs(math)))
	], "\n")
}

ruMathInfo(math : RuMath) -> string {
	strGlue([
		"sources:    " + strGlue(getTreeKeys(math.sources), ", "),
		"consts:     " + strGlue(getTreeKeys(math.consts), ", "),
		"types:      " + strGlue(getTreeKeys(math.types), ", "),
		"rules:      " + strGlue(getTreeKeys(math.rules), ", "),
		"assertions: " + strGlue(getTreeKeys(math.assertions), ", "),
	], "\n")
}

ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath {
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \name, s1, s2 -> { conf.onError("duplicate source: " + name, []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \name, c1, c2 -> { conf.onError("duplicate constant: " + name, []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \type, e1, e2 -> ruMergeRuTypeEnv(e1, e2)),
		mergeTreeCustom(m1.rules, m2.rules, \name, r1, r2 -> { conf.onError("duplicate rule: " + name, []); r1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \name, a1, a2 -> { conf.onError("duplicate assertion: " + name, []); a1 })
	);
}

ruRemoveSource(src : RuSource, m : RuMath) -> RuMath {
	if (!containsKeyTree(m.sources, src.info.module)) m else {
		fold(src.decls, 
			RuMath(m with sources = removeFromTree(m.sources, src.info.module)), 
			\acc, block -> {
				switch (block) {
					RuConst(name,__,__,__,__):
						RuMath(acc with consts = removeFromTree(acc.consts, name));
					RuType(name,__,__,__):
						RuMath(acc with types = removeFromTree(acc.types, name));
					RuRule(name,__,__,__,__):
						RuMath(acc with rules = removeFromTree(acc.rules, name));
					RuAxiom(name,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, name));
					RuTheorem(name,__,__,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, name));
					RuDef(name,__,__,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, name));
					RuComment(__,__,__): acc;
				}
			}
		);
	}
}

ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	module = src.info.module;
	fold(src.decls, 
		RuMath(m with sources = setTree(m.sources, module, src)), 
		\acc, block -> {
			switch (block) {
				RuConst(name,__,__,__,__):
					RuMath(acc with consts = setTree(acc.consts, name, block));
				RuType(name,__,__,__):
					RuMath(acc with types = setTree(acc.types, name, ruMakeTypeEnv(block, acc.types, module, conf)));
				RuRule(name, __, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(env): {
							RuMath(acc with 
								rules = setTree(acc.rules, name, block),
								types = setTree(acc.types, env.type.name,
									RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(name, term.type, sizeTree(vars), 0)),
											env.trie, conf
										)
									)
								)
							);
						}
						None(): {
							conf.onError("!!! type " + term.type + " is not found", [RuPlace(module, pos)]);
							acc
						}
					}
				RuAxiom(name,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, block));
				RuTheorem(name,__,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, block));
				RuDef(name,__,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, block));
				RuComment(__,__,__): acc;
			}
		}
	);
}

ruMakeMathFromSource(src : RuSource, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuMath {
	module = src.info.module;
	fold(src.decls, 
		RuMath(ruEmptyMath with sources = makeTree1(module, src), types = types), 
		\acc, block -> {
			switch (block) {
				RuConst(name,__,__,__,__):
					RuMath(acc with consts = setTree(acc.consts, name, block));
				RuType(name,__,__,__): {
					type = ruMakeTypeEnv(block, acc.types, module, conf);
					RuMath(acc with 
						types = setTree(acc.types, name, type),
						rules = fold(getTreeValues(type.supers), acc.rules, 
							\ac, super -> setTree(ac, super.name, super)
						)
					);
				}
				RuRule(name, __, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(env): {
							RuMath(acc with 
								rules = setTree(acc.rules, name, block),
								types = setTree(acc.types, env.type.name,
									RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(name, term.type, sizeTree(vars), 0)),
											env.trie, conf
										)
									)
								)
							);
						}
						None(): {
							conf.onError("type " + term.type + " is not found", [RuPlace(module, pos)]);
							acc
						}
					}
				RuAxiom(name,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, block));
				RuTheorem(name,__,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, block));
				RuDef(name,__,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, block));
				RuComment(__,__,__): acc;
			}
		}
	);
}

ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath {
	module = src.info.module;
	RuMath(m with 
		assertions = fold(src.decls, m.assertions,
			\acc, block -> {
				switch (block) {
					RuAxiom(name,__,__,__,__,__,__):         setTree(acc, name, block);
					RuTheorem(name,__,__,__,__,__,__,__,__): setTree(acc, name, block);
					RuDef(name,__,__,__,__,__,__,__,__):     setTree(acc, name, block);
					default: acc;
				}
			}
		)
	);
}

ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	ruAddSource(src, ruRemoveSource(src, m), conf);
}


ruMath2SingleSource(math : RuMath, path : string, conf : RuConf) -> RuSource {
	module = ruTrimPath(path, conf, ".ru");
	created = timestamp();
	RuSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			ruMathCollectSource(src, math, acc)
		).first,
		ruNewFileInfo(module, conf, ".ru")
	);
}

ruMathCollectSource(src : RuSource, math : RuMath, acc : Pair<[RuBlock], Set<string>>) -> Pair<[RuBlock], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.module)) {
					Some(inc_src): ruMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

ruFixLeftRecursiveRules(math : RuMath, conf : RuConf) -> RuMath {
	start = timestamp();
	fixRule = \r -> 
		if (length(r.term.expr) <= 1) r else {
			switch (r.term.expr[0]) {
				RuVar(__,__):
					RuRule(r with term = RuTerm(r.term with expr = 
						concat3([RuConstRef("(")], r.term.expr, [RuConstRef(")")])
					));
				default: r;
			}
		}
	fixSource = \s -> 
		RuSource(s with
			decls = map(s.decls, \decl -> 
				switch (decl) {
					RuRule(__,__,__,__,__): fixRule(decl);
					default: decl;
				}
			)
		);
	if (conf.verbose > 0) {
		conf.onMessage("ru potentially left-recursive rules are fixed" + " in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	RuMath(math with
		rules = mapTree(math.rules, \r -> fixRule(r)),
		sources = mapTree(math.sources, fixSource)
	);
}

ruCollectAllImported(name : string, math : RuMath) -> Set<RuSource> {
	switch (ruNameSource(name, math)) {
		Some(src): ruDoCollectAllImported(src, math, makeSet());
		None(): makeSet();
	}
}

ruDoCollectAllImported(src : RuSource, math : RuMath, acc : Set<RuSource>) -> Set<RuSource> {
	if (containsSet(acc, src)) acc else {
		fold(src.imports, insertSet(acc, src), 
			\ac, imp -> ruDoCollectAllImported(lookupTreeDef(math.sources, imp.module, ruNoSource), math, ac)
		)
	}
}

ruOrderSources(math : RuMath) -> [RuSource] {
	foldTree(math.sources, Pair([], makeSet()), \__, src, acc ->
		ruDoOrderSources(src, math, acc)
	).first
}

ruDoOrderSources(src : RuSource, math : RuMath, acc : Pair<[RuSource], Set<string>>) -> Pair<[RuSource], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), \ac, imp ->
			ruDoOrderSources(lookupTreeDef(math.sources, imp.module, ruNoSource), math, ac)
		);
		Pair(concat(acc1.first, [src]), acc1.second);
	}
}

ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruNameSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(name, src), a)
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = setTree(math.assertions, name, a),
				sources = setTree(math.sources, src.info.module, updated_src)
			);
		}
		None(): math;
	}
}

ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	updated_src = RuSource(src with decls = insertArray(src.decls, i, a));
	//ruToCache(updated_src, conf);
	RuMath(math with 
		assertions = setTree(math.assertions, name, a),
		sources = setTree(math.sources, src.info.module, updated_src)
	);
}

ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruNameSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				removeIndex(src.decls, ruIndexOfDecl(name, src))
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = removeFromTree(math.assertions, name),
				sources = setTree(math.sources, src.info.module, updated_src)
			);
		}
		None(): math;
	}
}

ruAddComment(c : RuComment, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	updated_src = RuSource(src with decls = insertArray(src.decls, i, c));
	RuMath(math with sources = setTree(math.sources, src.info.module, updated_src));
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem {
	switch (lookupTree(math.assertions, name)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(__,__,__,__,__,__,__,__,__): ass;
				default: {
					conf.onError("theorem " + name + " is not found", []);
					ruNoTheorem;
				}
			}
		}
		None(): {
			conf.onError("theorem " + name + " is not found", []);
			ruNoTheorem;
		}
	}
}

ruMathAssertionDepths(math : RuMath) -> Tree<string, int> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDepths(math, name, acc));
}

ruDoMathAssertionDepths(math : RuMath, as_name : string, acc : Tree<string, int>) -> Tree<string, int> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(name,__,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDepths(math, step.assertion, ac));
							max_depth = fold(proof.steps, 0, \ac, step -> max(ac, lookupTreeDef(acc1, step.assertion, 0)));
							setTree(acc1, name, max_depth + 1);
						}
					}
				}
				RuAxiom(name,__,__,__,__,__,__):     setTree(acc, name, 0);
				RuDef(name,__,__,__,__,__,__,__,__): setTree(acc, name, 0);
			}
		}
		None(): acc;
	}
}

ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionAxioms(math, name, acc));
}

ruDoMathAssertionAxioms(math : RuMath, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(name,__,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionAxioms(math, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, name, axioms);
						}
					}
				}
				RuAxiom(name,__,__,__,__,__,__):     setTree(acc, name, makeSet1(name));
				RuDef(name,__,__,__,__,__,__,__,__): setTree(acc, name, makeSet());
			}
		}
		None(): acc;
	}
}

ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDependencies(name, acc, math, conf));
}

ruDoMathAssertionDependencies(as_name : string, acc : Tree<string, Set<string>>, math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	if(containsKeyTree(acc, as_name)) {
		acc; 
	} else { 
		switch (lookupTree(math.assertions, as_name)) {
			Some(a): {
				switch (a) {
					RuTheorem(name,__,__,__,__,__,__,proof,__): {
						switch (lookupTree(acc, name)) {
							Some(v): acc;
							None(): {
								acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDependencies(step.assertion, ac, math, conf));
								deps = fold(proof.steps, 
									buildSet(map(proof.steps, \step -> step.assertion)), 
									\ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet()))
								);
								setTree(acc1, name, deps);
							}
						}
					}
					RuAxiom(name,__,__,__,__,__,__):     setTree(acc, name, makeSet());
					RuDef(name,__,__,__,__,__,__,__,__): setTree(acc, name, makeSet());
				}
			}
			None(): acc;
		}
	}
}

ruMathAssertionProofSteps(math : RuMath) -> Tree<string, Tree<string, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(name,__,__,__,__,__,__,proof,__):
					foldi(proof.steps, ac, \i, a, step -> {
						tr = lookupTreeDef(a, step.assertion, makeTree());
						setTree(a, step.assertion,
							setTree(tr, name, 
								concat(lookupTreeDef(tr, name, []), [i])	
							)
						);
					});
				default: ac;
			}
		)
	);	
}

ruAssertionDepth(ass : string, math : RuMath) -> int {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,__,__,__,__,proof,__): {
					1 + fold(proof.steps, 0, \acc, step -> max(acc, ruAssertionDepth(step.assertion, math)));
				}
				RuAxiom(__,__,__,__,__,__,__):     0;
				RuDef(__,__,__,__,__,__,__,__,__): 0;
			}
		}
		None(): -1;
	}
}

ruAssertionAxioms(ass : string, math : RuMath) -> Set<string> {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,__,__,__,__,proof,__): {
					fold(proof.steps, makeSet(), \acc, step -> mergeSets(acc, ruAssertionAxioms(step.assertion, math)));
				}
				RuAxiom(name,__,__,__,__,__,__):     makeSet1(name);
				RuDef(name,__,__,__,__,__,__,__,__): makeSet();
			}
		}
		None(): makeSet();
	}
}

ruAssertionDependencies(ass : string, math : RuMath, conf : RuConf) -> Set<string> {
	lookupTreeDef(ruDoMathAssertionDependencies(ass, makeTree(), math, conf), ass, makeSet());
}

ruAssertionDependendsOn(ass : string, dep : string, math : RuMath, conf : RuConf) -> bool {
	containsSet(ruAssertionDependencies(ass, math, conf), dep);
}

ruAssertionCyclicDependency(ass : string, math : RuMath, conf : RuConf) -> bool {
	ruAssertionDependendsOn(ass, ass, math, conf);
}

ruCheckCyclicDependencies(math : RuMath, conf : RuConf) -> RuMath {
	start = timestamp();
	all_deps = ruMathAssertionDependencies(math, conf);

	ret = foldTree(math.assertions, false, 
		\name, __, acc -> {
			deps = lookupTreeDef(all_deps, name, makeSet());
			ret = if (containsSet(deps, name)) {
				conf.onMessage("Cyclic dependency found: " + name + " dependes on: " + strGlue(set2array(deps), ", "));
				true;
			} else {
				if (conf.verbose == 2) {
					conf.onMessage("Assertion " + name + " has " + i2s(sizeSet(deps)) + " dependencies, yet no cyclic are found");
				}
				if (conf.verbose == 3) {
					conf.onMessage("Assertion " + name + " has " + i2s(sizeSet(deps)) + " dependencies: " + strGlue(set2array(deps), ", "));
				}
				false;
			}
			ret || acc;
		}
	)
	if (conf.verbose > 0 && !ret) {
		conf.onMessage("No cyclic dependencies are found in " + i2s(sizeTree(math.assertions)) + " assertions");
	}
	math;
}

ruAssertionsProofSteps(as : Set<string>, math : RuMath) -> Tree<string, Tree<string, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(name,__,__,__,__,__,__,proof,__):
					foldi(proof.steps, ac, \i, a, step ->
						if (!containsSet(as, step.assertion)) a else {
							tr = lookupTreeDef(a, step.assertion, makeTree());
							setTree(a, step.assertion,
								setTree(tr, name, 
									concat(lookupTreeDef(tr, name, []), [i])	
								)
							);
						}
					);
				default: ac;
			}
		)
	);	
}

ruSourceDeclNames(src : string, acc : Set<string>, math : RuMath, conf : RuConf) -> Set<string> {
	ruDoSourceDeclNames(src, Pair(acc, makeSet()), math, conf).first;
}

ruDoSourceDeclNames(src : string, acc : Pair<Set<string>, Set<string>>, math : RuMath, conf : RuConf) -> Pair<Set<string>, Set<string>> {
	if (containsSet(acc.second, src)) acc else {
		eitherMap(lookupTree(math.sources, src), 
			\s -> fold(s.imports, 
				fold(s.decls, 
					Pair(acc.first, insertSet(acc.second, src)), 
					\ac, decl -> {
						switch (decl) {
							RuDecl(): Pair(insertSet(ac.first, ruDeclName(decl)), ac.second);
							default: ac;
						}
					}
				),
				\ac, imp -> ruDoSourceDeclNames(imp.module, ac, math, conf)
			),
			acc
		);
	}
}
