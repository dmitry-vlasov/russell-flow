import base/stats;
import ru/parse/type_env;
import ru/cache;

export {
	RuMath(
		sources    : Tree<string, RuSource>,
		consts     : Tree<string, RuConst>,
		types      : Tree<string, RuTypeEnv>,
		rules      : Tree<string, RuRule>,
		assertions : Tree<string, RuAssertion>
	);
	ruEmptyMath = RuMath(makeTree(), makeTree(), makeTree(), makeTree(), makeTree());

	ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace;
	ruFindSource(name : string, math : RuMath) -> string;
	ruNameSource(name : string, math : RuMath) -> Maybe<RuSource>;
	ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom>;
	ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem>;
	ruMathDefs(math : RuMath) ->Tree<string, RuDef>;
	ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule>;

	ruMathStats(math : RuMath) -> string;
	ruMathInfo(math : RuMath) -> string;

	ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath;
	ruRemoveSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruAddImportToSource(src : RuSource, module : string, math : RuMath, conf : RuConf) -> RuMath;
	ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruMakeMathFromSource(src : RuSource, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuMath;
	ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath;
	ruMath2SingleSource(math : RuMath, file : string, conf : RuConf) -> RuSource;

	ruNameAllImported(name : string, math : RuMath) -> Set<RuSource>;
	ruSourceAllImported(src : string, math : RuMath) -> Set<RuSource>;
	ruMathAllImported(math : RuMath, conf : RuConf) -> Tree<string, Set<string>>;

	ruOrderSources(math : RuMath) -> [RuSource];
	ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;
	ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;

	ruSourceTheorems(src : RuSource) -> [RuTheorem];
	ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem;

	ruMathAssertionDepths(math : RuMath) -> Tree<string, int>;
	ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>>;
	ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<string, Set<string>>;
	ruMathAssertionProofSteps(math : RuMath) -> Tree<string, Tree<string, [int]>>;
	ruDoMathAssertionDependencies(name : string, acc : Tree<string, Set<string>>, math : RuMath, conf : RuConf) -> Tree<string, Set<string>>;

	ruAssertionDepth(ass : string, math : RuMath) -> int;
	ruAssertionAxioms(ass : string, math : RuMath) -> Set<string>;
	ruAssertionDependencies(ass : string, math : RuMath, conf : RuConf) -> Set<string>;
	ruAssertionDependendsOn(ass : string,  dep : string, math : RuMath, conf : RuConf) -> bool;
	ruAssertionCyclicDependency(ass : string,  math : RuMath, conf : RuConf) -> bool;
	ruAssertionsProofSteps(as : Set<string>, math : RuMath) -> Tree<string, Tree<string, [int]>>;

	ruSourceDeclNames(src : string, acc : Set<string>, math : RuMath, conf : RuConf) -> Set<string>;
}

ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, ruFindSource(name, math), ruNoSource).info.module, pos
	);
}

ruFindSource(name : string, math : RuMath) -> string {
	switch (lookupTree(math.assertions, name)) {
		Some(a): a.descr.source;
		None(): {
			switch (lookupTree(math.consts, name)) {
				Some(c): c.descr.source;
				None(): {
					switch (lookupTree(math.types, name)) {
						Some(e): e.type.descr.source;
						None(): {
							switch (lookupTree(math.rules, name)) {
								Some(r): r.descr.source;
								None(): "";
							}
						}
					}
				}
			}
		}
	}
}

ruNameSource(name : string, math : RuMath) -> Maybe<RuSource> {
	lookupTree(math.sources, ruFindSource(name, math));
}

ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuAxiom(__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuTheorem(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathDefs(math : RuMath) ->Tree<string, RuDef> {
	foldTree(math.assertions, makeTree(),
		\name, ass, acc -> {
			switch (ass) { 
				RuDef(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule> {
	switch (lookupTree(math.types, infer)) {
		Some(infEnv): lookupTree(infEnv.supers, super);
		None(): {
			conf.onError("unknown type: " + infer, []);
			quit(-1);
			None();
		}
	}
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"sources:    " + i2s(sizeTree(math.sources)),
		"consts:     " + i2s(sizeTree(math.consts)),
		"types:      " + i2s(sizeTree(math.types)),
		"rules:      " + i2s(sizeTree(math.rules)),
		"assertions: " + i2s(sizeTree(math.assertions)),
		"  axioms:   " + i2s(sizeTree(ruMathAxioms(math))),
		"  theorems: " + i2s(sizeTree(ruMathTheorems(math))),
		"  defs:     " + i2s(sizeTree(ruMathDefs(math)))
	], "\n")
}

ruMathInfo(math : RuMath) -> string {
	strGlue([
		"sources:    " + strGlue(getTreeKeys(math.sources), ", "),
		"consts:     " + strGlue(getTreeKeys(math.consts), ", "),
		"types:      " + strGlue(getTreeKeys(math.types), ", "),
		"rules:      " + strGlue(getTreeKeys(math.rules), ", "),
		"assertions: " + strGlue(getTreeKeys(math.assertions), ", "),
	], "\n")
}

ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath {
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \name, s1, s2 -> { conf.onError("duplicate source: " + name, []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \name, c1, c2 -> { conf.onError("duplicate constant: " + name, []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \type, e1, e2 -> ruMergeRuTypeEnv(e1, e2)),
		mergeTreeCustom(m1.rules, m2.rules, \name, r1, r2 -> { conf.onError("duplicate rule: " + name, []); r1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \name, a1, a2 -> { conf.onError("duplicate assertion: " + name, []); a1 })
	);
}

ruRemoveSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	module = src.info.module;
	if (!containsKeyTree(m.sources, module)) m else {
		fold(src.decls, 
			RuMath(m with sources = removeFromTree(m.sources, module)), 
			\acc, decl -> {
				switch (decl) {
					RuConst(descr,__,__,__):
						RuMath(acc with consts = removeFromTree(acc.consts, descr.name));
					RuType(descr,__,__):
						RuMath(acc with types = removeFromTree(acc.types, descr.name));
					RuRule(descr, vars, term, pos): {
						switch (lookupTree(acc.types, term.type)) {
							Some(env): {
								RuMath(acc with 
									rules = removeFromTree(acc.rules, descr.name),
									types = setTree(acc.types, env.type.descr.name,
										RuTypeEnv(env with 
											trie = ruRemoveTermFromTrie(term, env.trie)
										)
									)
								);
							}
							None(): {
								conf.onError("!!! type " + term.type + " is not found", [RuPlace(module, pos)]);
								acc
							}
						}
					}
					RuAxiom(descr,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.name));
					RuTheorem(descr,__,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.name));
					RuDef(descr,__,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, descr.name));
				}
			}
		);
	}
}

ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	module = src.info.module;
	fold(src.decls, 
		RuMath(m with sources = setTree(m.sources, module, src)), 
		\acc, decl -> {
			switch (decl) {
				RuConst(descr,__,__,__):
					RuMath(acc with consts = setTree(acc.consts, descr.name, decl));
				RuType(descr,__,__):
					RuMath(acc with types = setTree(acc.types, descr.name, ruMakeTypeEnv(decl, acc.types, module, conf)));
				RuRule(descr, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(env): {
							RuMath(acc with 
								rules = setTree(acc.rules, descr.name, decl),
								types = setTree(acc.types, env.type.descr.name,
									RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(descr.name, term.type, sizeTree(vars), 0)),
											env.trie, conf
										)
									)
								)
							);
						}
						None(): {
							conf.onError("!!! type " + term.type + " is not found", [RuPlace(module, pos)]);
							acc
						}
					}
				RuAxiom(descr,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuTheorem(descr,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuDef(descr,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
			}
		}
	);
}

ruAddImportToSource(src : RuSource, module : string, math : RuMath, conf : RuConf) -> RuMath {
	if (exists(src.imports, \imp -> imp.module == module)) math else {
		RuMath(math with 
			sources = setTree(math.sources, src.info.module, RuSource(src with
				imports = concat(src.imports, [RuImport(module, -1)])
			))
		);
	}
}

ruMakeMathFromSource(src : RuSource, types : Tree<string, RuTypeEnv>, conf : RuConf) -> RuMath {
	module = src.info.module;
	fold(src.decls, 
		RuMath(ruEmptyMath with sources = makeTree1(module, src), types = types), 
		\acc, decl -> {
			switch (decl) {
				RuConst(descr,__,__,__):
					RuMath(acc with consts = setTree(acc.consts, descr.name, decl));
				RuType(descr,__,__): {
					type = ruMakeTypeEnv(decl, acc.types, module, conf);
					RuMath(acc with 
						types = setTree(acc.types, descr.name, type),
						rules = fold(getTreeValues(type.supers), acc.rules, 
							\ac, super -> setTree(ac, super.descr.name, super)
						)
					);
				}
				RuRule(descr, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(env): {
							RuMath(acc with 
								rules = setTree(acc.rules, descr.name, decl),
								types = setTree(acc.types, env.type.descr.name,
									RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(descr.name, term.type, sizeTree(vars), 0)),
											env.trie, conf
										)
									)
								)
							);
						}
						None(): {
							conf.onError("type " + term.type + " is not found", [RuPlace(module, pos)]);
							acc
						}
					}
				RuAxiom(descr,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuTheorem(descr,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
				RuDef(descr,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, descr.name, decl));
			}
		}
	);
}

ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath {
	module = src.info.module;
	RuMath(m with 
		assertions = fold(src.decls, m.assertions,
			\acc, decl -> {
				switch (decl) {
					RuAxiom(descr,__,__,__,__,__):         setTree(acc, descr.name, decl);
					RuTheorem(descr,__,__,__,__,__,__,__): setTree(acc, descr.name, decl);
					RuDef(descr,__,__,__,__,__,__,__):     setTree(acc, descr.name, decl);
					default: acc;
				}
			}
		)
	);
}

ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	ruAddSource(src, ruRemoveSource(src, m, conf), conf);
}

ruMath2SingleSource(math : RuMath, path : string, conf : RuConf) -> RuSource {
	module = ruTrimPath(path, conf, ".ru");
	created = timestamp();
	RuSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			ruMathCollectSource(src, math, acc)
		).first,
		foldTree(math.sources, [], \__,src, acc ->
			concat(acc, src.comments)
		),
		ruNewFileInfo(module, conf, ".ru")
	);
}

ruMathCollectSource(src : RuSource, math : RuMath, acc : Pair<[RuDecl], Set<string>>) -> Pair<[RuDecl], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.module)) {
					Some(inc_src): ruMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

ruNameAllImported(name : string, math : RuMath) -> Set<RuSource> {
	ruSourceAllImported(ruFindSource(name, math), math);
}

ruSourceAllImported(s : string, math : RuMath) -> Set<RuSource> {
	switch (lookupTree(math.sources, s)) {
		Some(src): ruDoSourceAllImported(src, math, makeSet());
		None(): makeSet();
	}
}

ruDoSourceAllImported(src : RuSource, math : RuMath, acc : Set<RuSource>) -> Set<RuSource> {
	if (containsSet(acc, src)) acc else {
		fold(src.imports, insertSet(acc, src), 
			\ac, imp -> ruDoSourceAllImported(lookupTreeDef(math.sources, imp.module, ruNoSource), math, ac)
		);
	}
}

ruMathAllImported(math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	foldTree(math.sources, Pair(makeTree(), makeSet()), \name, src, acc ->
		ruDoMathAllImported(name, math, conf, acc)
	).first;
}

ruDoMathAllImported(name : string, math : RuMath, conf : RuConf, acc : Pair<Tree<string, Set<string>>, Set<string>>) -> Pair<Tree<string, Set<string>>, Set<string>> {
	if (containsKeyTree(acc.first, name) || containsSet(acc.second, name)) acc else {
		eitherMap(lookupTree(math.sources, name),
			\src -> {
				acc1 = fold(src.imports, 
					Pair(acc.first, insertSet(acc.second, name)), 
					\ac, imp -> ruDoMathAllImported(imp.module, math, conf, ac)
				);
				Pair(
					setTree(acc1.first, name, 
						fold(src.imports, makeSet(), \ac, imp -> mergeSets(ac, lookupTreeDef(acc1.first, imp.module, makeSet())))
					),
					acc1.second
				);
			},
			acc
		);
	}
}

ruOrderSources(math : RuMath) -> [RuSource] {
	foldTree(math.sources, Pair([], makeSet()), \__, src, acc ->
		ruDoOrderSources(src, math, acc)
	).first
}

ruDoOrderSources(src : RuSource, math : RuMath, acc : Pair<[RuSource], Set<string>>) -> Pair<[RuSource], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), \ac, imp ->
			ruDoOrderSources(lookupTreeDef(math.sources, imp.module, ruNoSource), math, ac)
		);
		Pair(concat(acc1.first, [src]), acc1.second);
	}
}

ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruNameSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(name, src), a)
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = setTree(math.assertions, name, a),
				sources = setTree(math.sources, src.info.module, updated_src)
			);
		}
		None(): math;
	}
}

ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	updated_src = RuSource(src with decls = insertArray(src.decls, i, a));
	//ruToCache(updated_src, conf);
	RuMath(math with 
		assertions = setTree(math.assertions, name, a),
		sources = setTree(math.sources, src.info.module, updated_src)
	);
}

ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruNameSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				removeIndex(src.decls, ruIndexOfDecl(name, src))
			);
			//ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = removeFromTree(math.assertions, name),
				sources = setTree(math.sources, src.info.module, updated_src)
			);
		}
		None(): math;
	}
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem {
	switch (lookupTree(math.assertions, name)) {
		Some(ass): {
			switch (ass) {
				RuTheorem(__,__,__,__,__,__,__,__): ass;
				default: {
					conf.onError("theorem " + name + " is not found", []);
					ruNoTheorem;
				}
			}
		}
		None(): {
			conf.onError("theorem " + name + " is not found", []);
			ruNoTheorem;
		}
	}
}

ruMathAssertionDepths(math : RuMath) -> Tree<string, int> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDepths(math, name, acc));
}

ruDoMathAssertionDepths(math : RuMath, as_name : string, acc : Tree<string, int>) -> Tree<string, int> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(descr,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, descr.name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDepths(math, step.assertion, ac));
							max_depth = fold(proof.steps, 0, \ac, step -> max(ac, lookupTreeDef(acc1, step.assertion, 0)));
							setTree(acc1, descr.name, max_depth + 1);
						}
					}
				}
				RuAxiom(descr,__,__,__,__,__):     setTree(acc, descr.name, 0);
				RuDef(descr,__,__,__,__,__,__,__): setTree(acc, descr.name, 0);
			}
		}
		None(): acc;
	}
}

ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionAxioms(math, name, acc));
}

ruDoMathAssertionAxioms(math : RuMath, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(a): {
			switch (a) {
				RuTheorem(descr,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, descr.name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionAxioms(math, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, descr.name, axioms);
						}
					}
				}
				RuAxiom(descr,__,__,__,__,__):     setTree(acc, descr.name, makeSet1(descr.name));
				RuDef(descr,__,__,__,__,__,__,__): setTree(acc, descr.name, makeSet());
			}
		}
		None(): acc;
	}
}

ruMathAssertionDependencies(math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDependencies(name, acc, math, conf));
}

ruDoMathAssertionDependencies(as_name : string, acc : Tree<string, Set<string>>, math : RuMath, conf : RuConf) -> Tree<string, Set<string>> {
	if(containsKeyTree(acc, as_name)) {
		acc; 
	} else { 
		switch (lookupTree(math.assertions, as_name)) {
			Some(a): {
				switch (a) {
					RuTheorem(descr,__,__,__,__,__,proof,__): {
						switch (lookupTree(acc, descr.name)) {
							Some(v): acc;
							None(): {
								acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDependencies(step.assertion, ac, math, conf));
								deps = fold(proof.steps, 
									buildSet(map(proof.steps, \step -> step.assertion)), 
									\ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet()))
								);
								setTree(acc1, descr.name, deps);
							}
						}
					}
					RuAxiom(descr,__,__,__,__,__):     setTree(acc, descr.name, makeSet());
					RuDef(descr,__,__,__,__,__,__,__): setTree(acc, descr.name, makeSet());
				}
			}
			None(): acc;
		}
	}
}

ruMathAssertionProofSteps(math : RuMath) -> Tree<string, Tree<string, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(descr,__,__,__,__,__,proof,__):
					foldi(proof.steps, ac, \i, a, step -> {
						tr = lookupTreeDef(a, step.assertion, makeTree());
						setTree(a, step.assertion,
							setTree(tr, descr.name, 
								concat(lookupTreeDef(tr, descr.name, []), [i])	
							)
						);
					});
				default: ac;
			}
		)
	);	
}

ruAssertionDepth(ass : string, math : RuMath) -> int {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,__,__,__,proof,__): {
					1 + fold(proof.steps, 0, \acc, step -> max(acc, ruAssertionDepth(step.assertion, math)));
				}
				RuAxiom(__,__,__,__,__,__):     0;
				RuDef(__,__,__,__,__,__,__,__): 0;
			}
		}
		None(): -1;
	}
}

ruAssertionAxioms(ass : string, math : RuMath) -> Set<string> {
	switch (lookupTree(math.assertions, ass)) {
		Some(a): {
			switch (a) {
				RuTheorem(__,__,__,__,__,__,proof,__): {
					fold(proof.steps, makeSet(), \acc, step -> mergeSets(acc, ruAssertionAxioms(step.assertion, math)));
				}
				RuAxiom(descr,__,__,__,__,__):  makeSet1(descr.name);
				RuDef(descr,__,__,__,__,__,__,__): makeSet();
			}
		}
		None(): makeSet();
	}
}

ruAssertionDependencies(ass : string, math : RuMath, conf : RuConf) -> Set<string> {
	lookupTreeDef(ruDoMathAssertionDependencies(ass, makeTree(), math, conf), ass, makeSet());
}

ruAssertionDependendsOn(ass : string, dep : string, math : RuMath, conf : RuConf) -> bool {
	containsSet(ruAssertionDependencies(ass, math, conf), dep);
}

ruAssertionCyclicDependency(ass : string, math : RuMath, conf : RuConf) -> bool {
	ruAssertionDependendsOn(ass, ass, math, conf);
}

ruAssertionsProofSteps(as : Set<string>, math : RuMath) -> Tree<string, Tree<string, [int]>> {
	foldTree(math.sources, makeTree(), \__, src, acc ->
		fold(src.decls, acc, \ac, decl ->
			switch (decl) {
				RuTheorem(descr,__,__,__,__,__,proof,__):
					foldi(proof.steps, ac, \i, a, step ->
						if (!containsSet(as, step.assertion)) a else {
							tr = lookupTreeDef(a, step.assertion, makeTree());
							setTree(a, step.assertion,
								setTree(tr, descr.name, 
									concat(lookupTreeDef(tr, descr.name, []), [i])	
								)
							);
						}
					);
				default: ac;
			}
		)
	);	
}

ruSourceDeclNames(src : string, acc : Set<string>, math : RuMath, conf : RuConf) -> Set<string> {
	ruDoSourceDeclNames(src, Pair(acc, makeSet()), math, conf).first;
}

ruDoSourceDeclNames(src : string, acc : Pair<Set<string>, Set<string>>, math : RuMath, conf : RuConf) -> Pair<Set<string>, Set<string>> {
	if (containsSet(acc.second, src)) acc else {
		eitherMap(lookupTree(math.sources, src), 
			\s -> fold(s.imports, 
				fold(s.decls, 
					Pair(acc.first, insertSet(acc.second, src)), 
					\ac, decl -> Pair(insertSet(ac.first, ruDeclName(decl)), ac.second)
				),
				\ac, imp -> ruDoSourceDeclNames(imp.module, ac, math, conf)
			),
			acc
		);
	}
}
