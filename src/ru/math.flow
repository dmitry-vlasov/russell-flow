import base/stats;
import ru/parse/type_env;
import ru/cache;

export {
	RuMath(
		sources    : Tree<string, RuSource>,
		consts     : Tree<string, RuWithSource<RuConst>>,
		types      : Tree<string, RuWithSource<RuTypeEnv>>,
		rules      : Tree<string, RuWithSource<RuRule>>,
		assertions : Tree<string, RuWithSource<RuAssertion>>
	);
	ruEmptyMath = RuMath(makeTree(), makeTree(), makeTree(), makeTree(), makeTree());

	ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace;
	ruFindSource(name : string, math : RuMath) -> string;
	ruNameSource(name : string, math : RuMath) -> Maybe<RuSource>;
	ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom>;
	ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem>;
	ruMathDefs(math : RuMath) ->Tree<string, RuDef>;
	ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule>;

	ruMathStats(math : RuMath) -> string;
	ruMathInfo(math : RuMath) -> string;

	ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath;
	ruRemoveSource(src : RuSource, m : RuMath) -> RuMath;
	ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath;
	ruMakeMathFromSource(src : RuSource, types : Tree<string, RuWithSource<RuTypeEnv>>, conf : RuConf) -> RuMath;
	ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath;
	ruMath2SingleSource(math : RuMath, file : string, conf : RuConf) -> RuSource;

	ruFixLeftRecursiveRules(math : RuMath, conf : RuConf) -> RuMath;
	ruCollectAllImported(name : string, math : RuMath) -> Set<RuSource>;

	ruOrderSources(math : RuMath) -> [RuSource];
	ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;
	ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath;
	ruAddComment(c : RuComment, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath;

	ruSourceTheorems(src : RuSource) -> [RuTheorem];
	ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem;

	ruMathAssertionDepths(math : RuMath) -> Tree<string, int>;
	ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>>;

	ruAssertionDepth(ass : string, math : RuMath) -> int;
	ruAssertionAxioms(ass : string, math : RuMath) -> Set<string>;
	ruAssertionDependencies(ass : string, math : RuMath) -> Set<string>;
}

ruMakePlace(name : string, pos : int, math : RuMath) -> RuPlace {
	RuPlace(
		lookupTreeDef(math.sources, ruFindSource(name, math), ruNoSource).info.module, pos
	);
}

ruFindSource(name : string, math : RuMath) -> string {
	switch (lookupTree(math.assertions, name)) {
		Some(ws): ws.source;
		None(): {
			switch (lookupTree(math.consts, name)) {
				Some(ws): ws.source;
				None(): {
					switch (lookupTree(math.types, name)) {
						Some(ws): ws.source;
						None(): {
							switch (lookupTree(math.rules, name)) {
								Some(ws): ws.source;
								None(): "";
							}
						}
					}
				}
			}
		}
	}
}

ruNameSource(name : string, math : RuMath) -> Maybe<RuSource> {
	lookupTree(math.sources, ruFindSource(name, math));
}

ruMathAxioms(math : RuMath) ->Tree<string, RuAxiom> {
	foldTree(math.assertions, makeTree(),
		\name, ws, acc -> {
			ass = ws.item;
			switch (ass) { 
				RuAxiom(__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathTheorems(math : RuMath) ->Tree<string, RuTheorem> {
	foldTree(math.assertions, makeTree(),
		\name, ws, acc -> {
			ass = ws.item;
			switch (ass) { 
				RuTheorem(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruMathDefs(math : RuMath) ->Tree<string, RuDef> {
	foldTree(math.assertions, makeTree(),
		\name, ws, acc -> {
			ass = ws.item;
			switch (ass) { 
				RuDef(__,__,__,__,__,__,__,__): setTree(acc, name, ass); 
				default: acc; 
			} 
		}
	)
}

ruSuperRule(infer : string, super : string, math : RuMath, conf : RuConf) -> Maybe<RuRule> {
	switch (lookupTree(math.types, infer)) {
		Some(infEnv): lookupTree(infEnv.item.supers, super);
		None(): {
			conf.onError("unknown type: " + infer, []);
			quit(-1);
			None();
		}
	}
}

ruMathStats(math : RuMath) -> string {
	strGlue([
		"sources:    " + i2s(sizeTree(math.sources)),
		"consts:     " + i2s(sizeTree(math.consts)),
		"types:      " + i2s(sizeTree(math.types)),
		"rules:      " + i2s(sizeTree(math.rules)),
		"assertions: " + i2s(sizeTree(math.assertions)),
		"  axioms:   " + i2s(sizeTree(ruMathAxioms(math))),
		"  theorems: " + i2s(sizeTree(ruMathTheorems(math))),
		"  defs:     " + i2s(sizeTree(ruMathDefs(math)))
	], "\n")
}

ruMathInfo(math : RuMath) -> string {
	strGlue([
		"sources:    " + strGlue(getTreeKeys(math.sources), ", "),
		"consts:     " + strGlue(getTreeKeys(math.consts), ", "),
		"types:      " + strGlue(getTreeKeys(math.types), ", "),
		"rules:      " + strGlue(getTreeKeys(math.rules), ", "),
		"assertions: " + strGlue(getTreeKeys(math.assertions), ", "),
	], "\n")
}

ruMergeMath(m1 : RuMath, m2 : RuMath, conf : RuConf) -> RuMath {
	RuMath(
		mergeTreeCustom(m1.sources, m2.sources, \name, s1, s2 -> { conf.onError("duplicate source: " + name, []); s1 }),
		mergeTreeCustom(m1.consts, m2.consts, \name, c1, c2 -> { conf.onError("duplicate constant: " + name, []); c1 }),
		mergeTreeCustom(m1.types, m2.types, \type, e1, e2 -> RuWithSource(ruMergeRuTypeEnv(e1.item, e2.item), e1.source)),
		mergeTreeCustom(m1.rules, m2.rules, \name, r1, r2 -> { conf.onError("duplicate rule: " + name, []); r1 }),
		mergeTreeCustom(m1.assertions, m2.assertions, \name, a1, a2 -> { conf.onError("duplicate assertion: " + name, []); a1 })
	);
}

ruRemoveSource(src : RuSource, m : RuMath) -> RuMath {
	if (!containsKeyTree(m.sources, src.info.module)) m else {
		fold(src.decls, 
			RuMath(m with sources = removeFromTree(m.sources, src.info.module)), 
			\acc, block -> {
				switch (block) {
					RuConst(name,__,__,__):
						RuMath(acc with consts = removeFromTree(acc.consts, name));
					RuType(name,__,__):
						RuMath(acc with types = removeFromTree(acc.types, name));
					RuRule(name,__,__,__):
						RuMath(acc with rules = removeFromTree(acc.rules, name));
					RuAxiom(name,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, name));
					RuTheorem(name,__,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, name));
					RuDef(name,__,__,__,__,__,__,__):
						RuMath(acc with assertions = removeFromTree(acc.assertions, name));
					RuComment(__,__,__): acc;
				}
			}
		);
	}
}

ruAddSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	module = src.info.module;
	fold(src.decls, 
		RuMath(m with sources = setTree(m.sources, module, src)), 
		\acc, block -> {
			switch (block) {
				RuConst(name,__,__,__):
					RuMath(acc with consts = setTree(acc.consts, name, RuWithSource(block, module)));
				RuType(name,__,__):
					RuMath(acc with types = setTree(acc.types, name, RuWithSource(ruMakeTypeEnv(block, acc.types, module, conf), module)));
				RuRule(name, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(ws): {
							env = ws.item;
							RuMath(acc with 
								rules = setTree(acc.rules, name, RuWithSource(block, module)),
								types = setTree(acc.types, env.type.name,
									RuWithSource(RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(name, term.type, sizeTree(vars), 0)),
											env.trie, conf
										)
									), module)
								)
							);
						}
						None(): {
							conf.onError("!!! type " + term.type + " is not found", [RuPlace(module, pos)]);
							acc
						}
					}
				RuAxiom(name,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, RuWithSource(block, module)));
				RuTheorem(name,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, RuWithSource(block, module)));
				RuDef(name,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, RuWithSource(block, module)));
				RuComment(__,__,__): acc;
			}
		}
	);
}

ruMakeMathFromSource(src : RuSource, types : Tree<string, RuWithSource<RuTypeEnv>>, conf : RuConf) -> RuMath {
	module = src.info.module;
	fold(src.decls, 
		RuMath(ruEmptyMath with sources = makeTree1(module, src), types = types), 
		\acc, block -> {
			switch (block) {
				RuConst(name,__,__,__):
					RuMath(acc with consts = setTree(acc.consts, name, RuWithSource(block, module)));
				RuType(name,__,__): {
					type = ruMakeTypeEnv(block, acc.types, module, conf);
					RuMath(acc with 
						types = setTree(acc.types, name, RuWithSource(type, module)),
						rules = fold(getTreeValues(type.supers), acc.rules, 
							\ac, super -> setTree(ac, super.name, RuWithSource(super, module))
						)
					);
				}
				RuRule(name, vars, term, pos):
					switch (lookupTree(acc.types, term.type)) {
						Some(ws): {
							env : RuTypeEnv = ws.item;
							RuMath(acc with 
								rules = setTree(acc.rules, name, RuWithSource(block, module)),
								types = setTree(acc.types, env.type.name,
									RuWithSource(RuTypeEnv(env with 
										trie = ruAddTerm2RuTrie(term, 
											Some(RuRuleRef(name, term.type, sizeTree(vars), 0)),
											env.trie, conf
										)
									), module)
								)
							);
						}
						None(): {
							conf.onError("type " + term.type + " is not found", [RuPlace(module, pos)]);
							acc
						}
					}
				RuAxiom(name,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, RuWithSource(block, module)));
				RuTheorem(name,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, RuWithSource(block, module)));
				RuDef(name,__,__,__,__,__,__,__):
					RuMath(acc with assertions = setTree(acc.assertions, name, RuWithSource(block, module)));
				RuComment(__,__,__): acc;
			}
		}
	);
}

ruAddSourceAssertions(src : RuSource, m : RuMath) -> RuMath {
	module = src.info.module;
	RuMath(m with 
		assertions = fold(src.decls, m.assertions,
			\acc, block -> {
				switch (block) {
					RuAxiom(name,__,__,__,__,__):         setTree(acc, name, RuWithSource(block, module));
					RuTheorem(name,__,__,__,__,__,__,__): setTree(acc, name, RuWithSource(block, module));
					RuDef(name,__,__,__,__,__,__,__):     setTree(acc, name, RuWithSource(block, module));
					default: acc;
				}
			}
		)
	);
}

ruReplaceSource(src : RuSource, m : RuMath, conf : RuConf) -> RuMath {
	ruAddSource(src, ruRemoveSource(src, m), conf);
}


ruMath2SingleSource(math : RuMath, path : string, conf : RuConf) -> RuSource {
	module = ruTrimPath(path, conf, ".ru");
	created = timestamp();
	RuSource([],
		foldTree(math.sources, Pair([], makeSet()), \__,src, acc ->
			ruMathCollectSource(src, math, acc)
		).first,
		ruNewFileInfo(module, conf, ".ru")
	);
}

ruMathCollectSource(src : RuSource, math : RuMath, acc : Pair<[RuBlock], Set<string>>) -> Pair<[RuBlock], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), 
			\ac, imp -> {
				switch (lookupTree(math.sources, imp.module)) {
					Some(inc_src): ruMathCollectSource(inc_src, math, ac);
					None(): ac;
				}
			}
		);
		Pair(concat(acc1.first, src.decls), acc1.second)
	}
}

ruFixLeftRecursiveRules(math : RuMath, conf : RuConf) -> RuMath {
	start = timestamp();
	fixRule = \r -> 
		if (length(r.term.expr) <= 1) r else {
			switch (r.term.expr[0]) {
				RuVar(__,__):
					RuRule(r with term = RuTerm(r.term with expr = 
						concat3([RuConstRef("(")], r.term.expr, [RuConstRef(")")])
					));
				default: r;
			}
		}
	fixSource = \s -> 
		RuSource(s with
			decls = map(s.decls, \decl -> 
				switch (decl) {
					RuRule(__,__,__,__): fixRule(decl);
					default: decl;
				}
			)
		);
	if (conf.verbose > 0) {
		conf.onMessage("ru potentially left-recursive rules are fixed" + " in " + d2st((timestamp() - start)/ 1000.0, 2) + "s");
	}
	RuMath(math with
		rules = mapTree(math.rules, \ws -> RuWithSource(fixRule(ws.item), ws.source)),
		sources = mapTree(math.sources, fixSource)
	);
}

ruCollectAllImported(name : string, math : RuMath) -> Set<RuSource> {
	switch (ruNameSource(name, math)) {
		Some(src): ruDoCollectAllImported(src, math, makeSet());
		None(): makeSet();
	}
}

ruDoCollectAllImported(src : RuSource, math : RuMath, acc : Set<RuSource>) -> Set<RuSource> {
	if (containsSet(acc, src)) acc else {
		fold(src.imports, insertSet(acc, src), 
			\ac, imp -> ruDoCollectAllImported(lookupTreeDef(math.sources, imp.module, ruNoSource), math, ac)
		)
	}
}

ruOrderSources(math : RuMath) -> [RuSource] {
	foldTree(math.sources, Pair([], makeSet()), \__, src, acc ->
		ruDoOrderSources(src, math, acc)
	).first
}

ruDoOrderSources(src : RuSource, math : RuMath, acc : Pair<[RuSource], Set<string>>) -> Pair<[RuSource], Set<string>> {
	if (containsSet(acc.second, src.info.module)) acc else {
		acc1 = fold(src.imports, Pair(acc.first, insertSet(acc.second, src.info.module)), \ac, imp ->
			ruDoOrderSources(lookupTreeDef(math.sources, imp.module, ruNoSource), math, ac)
		);
		Pair(concat(acc1.first, [src]), acc1.second);
	}
}

ruReplaceAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruNameSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				replace(src.decls, ruIndexOfDecl(name, src), a)
			);
			ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = setTree(math.assertions, name, RuWithSource(a, src.info.module)),
				sources = setTree(math.sources, src.info.module, updated_src)
			);
		}
		None(): math;
	}
}

ruAddAssertion(a : RuAssertion, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	updated_src = RuSource(src with decls = insertArray(src.decls, i, a));
	ruToCache(updated_src, conf);
	RuMath(math with 
		assertions = setTree(math.assertions, name, RuWithSource(a, src.info.module)),
		sources = setTree(math.sources, src.info.module, updated_src)
	);
}

ruDeleteAssertion(a : RuAssertion, math : RuMath, conf : RuConf) -> RuMath {
	name = ruDeclName(a);
	switch (ruNameSource(name, math)) {
		Some(src): {
			updated_src = RuSource(src with decls = 
				removeIndex(src.decls, ruIndexOfDecl(name, src))
			);
			ruToCache(updated_src, conf);
			RuMath(math with 
				assertions = setTree(math.assertions, name, RuWithSource(a, src.info.module)),
				sources = setTree(math.sources, src.info.module, updated_src)
			);
		}
		None(): math;
	}
}

ruAddComment(c : RuComment, i : int, src : RuSource, math : RuMath, conf : RuConf) -> RuMath {
	updated_src = RuSource(src with decls = insertArray(src.decls, i, c));
	RuMath(math with sources = setTree(math.sources, src.info.module, updated_src));
}

ruSourceTheorems(src : RuSource) -> [RuTheorem] {
	filtermap(src.decls, \decl -> 
		switch (decl) {
			RuTheorem(__,__,__,__,__,__,__,__): Some(decl);
			default: None();
		}
	)
}

ruTheorem(name : string, math : RuMath, conf : RuConf) -> RuTheorem {
	switch (lookupTree(math.assertions, name)) {
		Some(ws): {
			ass = ws.item;
			switch (ass) {
				RuTheorem(__,__,__,__,__,__,__,__): ass;
				default: {
					conf.onError("theorem " + name + " is not found", []);
					ruNoTheorem;
				}
			}
		}
		None(): {
			conf.onError("theorem " + name + " is not found", []);
			ruNoTheorem;
		}
	}
}

ruMathAssertionDepths(math : RuMath) -> Tree<string, int> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionDepths(math, name, acc));
}

ruDoMathAssertionDepths(math : RuMath, as_name : string, acc : Tree<string, int>) -> Tree<string, int> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(ws): {
			switch (ws.item) {
				RuTheorem(name,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionDepths(math, step.assertion, ac));
							max_depth = fold(proof.steps, 0, \ac, step -> max(ac, lookupTreeDef(acc1, step.assertion, 0)));
							setTree(acc1, name, max_depth + 1);
						}
					}
				}
				RuAxiom(name,__,__,__,__,__):     setTree(acc, name, 0);
				RuDef(name,__,__,__,__,__,__,__): setTree(acc, name, 0);
			}
		}
		None(): acc;
	}
}

ruMathAssertionAxioms(math : RuMath) -> Tree<string, Set<string>> {
	foldTree(math.assertions, makeTree(), \name, __, acc -> ruDoMathAssertionAxioms(math, name, acc));
}

ruDoMathAssertionAxioms(math : RuMath, as_name : string, acc : Tree<string, Set<string>>) -> Tree<string, Set<string>> {
	switch (lookupTree(math.assertions, as_name)) {
		Some(ws): {
			switch (ws.item) {
				RuTheorem(name,__,__,__,__,__,proof,__): {
					switch (lookupTree(acc, name)) {
						Some(v): acc;
						None(): {
							acc1 = fold(proof.steps, acc, \ac, step -> ruDoMathAssertionAxioms(math, step.assertion, ac));
							axioms = fold(proof.steps, makeSet(), \ac, step -> mergeSets(ac, lookupTreeDef(acc1, step.assertion, makeSet())));
							setTree(acc1, name, axioms);
						}
					}
				}
				RuAxiom(name,__,__,__,__,__):     setTree(acc, name, makeSet1(name));
				RuDef(name,__,__,__,__,__,__,__): setTree(acc, name, makeSet());
			}
		}
		None(): acc;
	}
}

ruAssertionDepth(ass : string, math : RuMath) -> int {
	switch (lookupTree(math.assertions, ass)) {
		Some(ws): {
			switch (ws.item) {
				RuTheorem(__,__,__,__,__,__,proof,__): {
					1 + fold(proof.steps, 0, \acc, step -> max(acc, ruAssertionDepth(step.assertion, math)));
				}
				RuAxiom(__,__,__,__,__,__):     0;
				RuDef(__,__,__,__,__,__,__,__): 0;
			}
		}
		None(): -1;
	}
}

ruAssertionAxioms(ass : string, math : RuMath) -> Set<string> {
	switch (lookupTree(math.assertions, ass)) {
		Some(ws): {
			switch (ws.item) {
				RuTheorem(__,__,__,__,__,__,proof,__): {
					fold(proof.steps, makeSet(), \acc, step -> mergeSets(acc, ruAssertionAxioms(step.assertion, math)));
				}
				RuAxiom(name,__,__,__,__,__):     makeSet1(name);
				RuDef(name,__,__,__,__,__,__,__): makeSet();
			}
		}
		None(): makeSet();
	}
}

ruAssertionDependencies(ass : string, math : RuMath) -> Set<string> {
	switch (lookupTree(math.assertions, ass)) {
		Some(ws): {
			switch (ws.item) {
				RuTheorem(__,__,__,__,__,__,proof,__): {
					fold(proof.steps, makeSet(), \acc, step -> 
						mergeSets(acc, insertSet(ruAssertionDependencies(step.assertion, math), step.assertion))
					);
				}
				RuAxiom(name,__,__,__,__,__):     makeSet1(name);
				RuDef(name,__,__,__,__,__,__,__): makeSet1(name);
			}
		}
		None(): makeSet();
	}
}