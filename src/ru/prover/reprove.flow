import ds/vector;
import ru/prover/prove;
import ru/prover/stats;
import comm;

export {
	ruCommReprove : RuComm;
}

ruCommReprove = RuComm(
	RuCommDescr(
		"reprove", "prover", "reprove entities", "target", true, false, 
		[
			RuCommArg("file", true, "input file", ""),
			RuCommArg("max-proofs", true, "limit number of proofs in variant tree", "-1"),
			RuCommArg("max-variants", true, "limit number of assertion choice variants", "-1"),
			RuCommArg("target", true, "the target: a theorem, file or all", "all")
		], []
	),
	ruRunReprove
);

ruReproveTactic(theorem : RuTheorem, math : RuMath, mapping : ref Tree<RuProverProp, RuProofStep>) -> (RuProverTree) -> Maybe<RuProverProp> {
	proof = ruMakeTreeProof(theorem, math);
	leafs = ref [];
	queue = ref [];
	\tree -> {
		if (length(^queue) == 0) {
			if (sizeTree(^mapping) == 0) {
				traverseInOrder(tree.leafs, \__, n -> 
					if (length(^queue) == 0) {
						switch (n.parent) {
							RuProverRoot(__,__,__):
								if (n.assertion.descr.id == proof.assertion) {
									refArrayPush(queue, Pair(n, proof));
								} 
							default: {	}
						}
					}
				);
			} else if (length(^leafs) > 0) {
				first_leaf = ^leafs[0];
				n = first_leaf.first;
				s = first_leaf.second;
				leafs := removeIndex(^leafs, 0);
				iteri(^(n.children), \i, child -> {
					step_child = s.children[i];
					switch (step_child) {
						RuProofStep(assertion,__,__) : {
							iter(^(child.children), \grand ->
								if (grand.assertion.descr.id == assertion) {
									refArrayPush(queue, Pair(grand, step_child));
								}
							);
						}
						default: { }
					}
				});
			} else { }
		}
		if (length(^queue) > 0) {
			first_queue = ^queue[0];
			n = first_queue.first;
			s = first_queue.second;
			queue := removeIndex(^queue, 0);
			if (exists(s.children, \ch -> switch (ch) { RuProofStep(__,__,__): true; default: false; })) {
				refArrayPush(leafs, Pair(n, s));
			}
			mapping := setTree(^mapping, n, s);
			Some(n);
		} else {
			None();
		}
	}
}

ruReproveUnifyPremise(
	th : RuTheorem, 
	unify : (RuProverHyp) -> [RuUnified<RuHyp>], 
	mapping : ref Tree<RuProverProp, RuProofStep>, 
	math : RuMath, 
	env : RuEnv,
	max_proofs : int
) -> (RuProverHyp) -> [RuUnified<RuHyp>] {
	if (lookupTreeDef(env.conf.opts, "reprove-singleton", "1") == "1") {
		\hyp : RuProverHyp ->  {
			unif = unify(hyp);
			switch (hyp) {
				RuProverExp(i, __,__,__, parent): {
					switch (lookupTree(^mapping, parent)) {
						Some(step): {
							switch (step.children[i]) {
								RuProofStep(__,__,__): [];
								RuProofHyp(ind,__): {
									p1 = filter(unif, \un -> un.data.ind == ind);
									if (max_proofs <= 1) p1 else {
										concat(p1, take(unif, max_proofs - 1));
									}
								}
							}
						}
						None(): {
							ruCrash("must not happen");
							[];
						}
					}
				}
				RuProverRoot(__,__,__): unif;
			}
		}
	} else unify;
}

ruReproveUnifyAssertion(
	unify : (RuProverHyp) -> [RuUnified<RuAssertion>], 
	mapping : ref Tree<RuProverProp, RuProofStep>, 
	root : RuAssertion,
	math : RuMath, 
	env : RuEnv,
	max_variants : int
) -> (RuProverHyp) -> [RuUnified<RuAssertion>] {
	if (lookupTreeDef(env.conf.opts, "reprove-singleton", "1") == "1") {
		\hyp : RuProverHyp ->  {
			switch (hyp) {
				RuProverExp(i, __,__,__, parent): {
					switch (lookupTree(^mapping, parent)) {
						Some(step): {
							switch (step.children[i]) {
								RuProofStep(ass, children, expr): {
									e1 = hyp.expr;
									assertion = lookupTreeDef(math.decls.assertions, ass, ruNoAxiom);
									e2 = assertion.stat.prop;
									v1 = eitherMap(
										ruUnifyExps([e1, e2], makeTree(), math, env),
										\sub -> [RuUnified(sub, assertion, ruApplySubst(e1, sub))], []
									);
									if (max_variants <= 1) v1 else {
										v2 = unify(hyp);
										concat(v1, take(v2, max_variants - 1));
									}
								}
								RuProofHyp(h,__): [];
							}
						}
						None(): {
							ruCrash("must not happen");
							[];
						}
					}
				}
				RuProverRoot(__,e1,__): {
					e2 = root.stat.prop;
					eitherMap(
						ruUnifyExps([e1, e2], makeTree(), math, env),
						\sub -> [RuUnified(sub, root, ruApplySubst(e1, sub))], []
					);
				}
			}
		}
	} else {
		unify;
	}
}

ruRunReprove(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	task = unit.task;
	// At first read the math from file
	file = lookupTreeDef(task.args, "file", "");
	conf = state.conf;
	math = ruMathFromSources(state.ru, env);
	target0 = lookupTreeDef(task.args, "target", file);
	target = ruTrimPath(target0, conf, ".ru");
	if (ruVerbose(conf) > 0) {
		env.out.onMessage("repoving target: '" + target + "'");
	}
	reproved_count = ref 0;
	failed_count = ref 0;
	failed_th_names = ref [];
	max_time = ref 0.0;
	max_th_id = ref -1;
	depths = ruAssertionsDepths(math.decls.assertions);
	/*if (lookupTreeDef(conf.opts, "reprove-singleton", "") == "1") {
		env.out.onMessage("YEXX");
	}*/
	/*if (lookupTreeDef(conf.opts, "reprove-stats", "") == "1") {
		ruCommandTheoremDepthStats(math);
	}*/

	max_proofs = s2i(lookupTreeDef(task.args, "max-proofs", "-1"));
	max_variants = s2i(lookupTreeDef(task.args, "max-variants", "-1"));
	reproved = ref 0;
	disproved = ref [];
	push_disproved = ruMakeAtomicArrayPush(disproved);
	processed = ref 0;
	reprove_th = \th, index, time_limit -> {
		//if (math.ruVerbose(conf) > 0) {
		//	env.out.onMessage("going to reprove theorem " + th.descr.name);
		//}
		timer = ruMakeTimer();
		mapping = ref makeTree();
		root = lookupTreeDef(math.decls.assertions, ruProofQedStep(th.proof).assertion, ruNoAxiom);
		prover_env0 = ruInitProverEnv(th, math, env, index, time_limit);
		prover_env1 = RuProverEnv(prover_env0 with
			fns = RuProverFuncs(prover_env0.fns with
				unifyAssertion = ruReproveUnifyAssertion(
					prover_env0.fns.unifyAssertion, mapping, root, math, env, max_variants 
				),
				unifyPremise = ruReproveUnifyPremise(
					th, prover_env0.fns.unifyPremise, mapping, math, env, max_proofs
				),
				tactic = ruReproveTactic(th, math, mapping)
			)
		);
		prover_env2 = ruExpandHyp(prover_env1.tree.root, prover_env1);
		if (lookupTreeDef(conf.opts, "reprove-stats", "") == "1") {
			init_stats = RuStatsRow("reprove init " + id2s(th.descr.id), 
				pairs2tree([
					Pair("size", i2d(length(th.proof.steps))), 
					Pair("time", ruTimePassed(timer))
				])
			);
			ruAddStats("reprove_init", init_stats);
		}
		t = ruMakeTimer();
		prover_env3 = ruProve(prover_env2);
		prove_time = ruTimePassed(t);
		tm = ruTimePassed(timer);
		time = tm / 1000.0;
		if (time > ^max_time) {
			max_time := time;
			max_th_id := th.descr.id;
		}
		if (lookupTreeDef(conf.opts, "reprove-stats", "") == "1") {
			reprove_stats = RuStatsRow("reprove do " + id2s(th.descr.id), 
				pairs2tree([
					Pair("depth", i2d(lookupTreeDef(depths, th.descr.id, -1))),
					Pair("size", i2d(ruSizeProverTree(prover_env2.tree.root))),
					Pair("proof-size", i2d(length(th.proof.steps))), 
					Pair("proof-vol", i2d(fold(th.proof.steps, 0, \acc, step -> acc + length(step.expr.nodes)))), 
					Pair("time", prove_time),
					Pair("time-per-step", prove_time / i2d(length(th.proof.steps)))
				])
			);
			ruAddStats("reprove_time", reprove_stats);
			stats = RuStatsRow("reproved all " + id2s(th.descr.id), 
				pairs2tree([
					Pair("size", i2d(ruSizeProverTree(prover_env2.tree.root))), 
					Pair("time", tm)
				])
			);
			ruAddStats("reprove_all", stats);
		}
		atomicRefIntAddition(processed, 1);
		if (^(prover_env3.proofs) == []) {
			atomicRefIntAddition(failed_count, 1);
			push_disproved(th.descr.id);
			env.out.onError(
				"theorem '" + id2s(th.descr.id) + "' was NOT reproved in " + d2st(time, 2) + "s\n" + 
				ru2s(th, math), [ruDeclPlace(th)]
			);
			refArrayPush(failed_th_names, id2s(th.descr.id));
			false;
		} else {
			atomicRefIntAddition(reproved_count, 1);
			atomicRefIntAddition(reproved, 1);
			if (ruVerbose(conf) > 0) {
				env.out.onMessage(i2s(^reproved_count) + " theorem '" + id2s(th.descr.id) + "' was REPROVED in " + d2st(time, 2) + "s");
			}
			true;
		}
	}
	reprove_ass = \ass : RuAssertion, time_limit -> 
		switch (ass) {
			RuTheorem(__,__,__,__): reprove_th(ass, None(), time_limit);
			default: true;
		}
	reprove_decl = \decl : RuDecl, time_limit ->
		switch (decl) {
			RuTheorem(__,__,__,__): reprove_th(decl, None(), time_limit);
			default: true;
		}
	reprove_decls = \decls, time_limit -> {
		proof_lens = map(decls, \d -> {
			switch (d) {
				RuTheorem(__,__,__,proof): length(proof.steps);
				default: 0;
			}
		});
		sum_proof_lens = i2d(fold(proof_lens, 0, \acc, len -> acc + len));
		all(ruConcurrent(mapi(decls, \i, d -> {
			limit = time_limit * i2d(availableProcessors()) * i2d(proof_lens[i]) / sum_proof_lens;
			\-> reprove_decl(d, limit)
		})));
	}
	timer = ruMakeTimer();
	calc_total_steps = \decls -> fold(decls, 0, \acc, d ->
		switch (d) {
			RuTheorem(__,__,__,proof): acc + length(proof.steps);
			default: acc;
		}
	);
	calc_time_limit = \decls -> {
		opt = lookupTreeDef(conf.opts, "time-limit", lookupTreeDef(task.args, "time-limit", "600"));
		limit = if (opt == "auto") {
			i2d(calc_total_steps(decls)) * 3.0;
		} else {
			i2d(s2i(opt) * 1000);
		}
		if (ruVerbose(conf) > 0) {
			env.out.onMessage("reprove time limit: " + ruTime2s(limit));
		}
		limit
	}

	// ruTrackProgress(isOn : ref bool, counter : ref int, num : int, delta : int, tr : RuTimer, out : RuOut, msg : () -> string) -> void;
	track_progress = ref true;
	ret = if (target == "all" || target == "1") {
		decls = filtermap(concatA(map(ruSourcesOrder(math.sources), \src -> src.decls)), ruDecl2Assertion);
		time_limit = calc_time_limit(decls);
		chunks = splitByNumber(decls, s2i(lookupTreeDef(conf.opts, "reprove-split-num", "256")));
		//time_limit = time_limit * i2d(availableProcessors());
		//env.out.onMessage("reprove concurrent time limit: " + d2s(time_limit / 1000.0) + ".s");
		proof_lens = map(chunks, \chunk ->
			map(chunk, \d ->
				switch (d) {
					RuTheorem(__,__,__,proof): length(proof.steps);
					default: 0;
				}
			)
		);
		sum_proof_lens = map(proof_lens, \lens -> i2d(fold(lens, 0, \ac, len -> ac + len)));
		total_steps = fold(sum_proof_lens, 0.0, \acc, len -> acc + len);
		ruTrackProgress(track_progress, processed, length(decls), ruProgressUpdateMs(task, conf), timer, unit.out, \ ->
			"reproved: " + i2s(^reproved) + (if (^disproved == []) "" else ", disproved: " + 
				strGlue(map(^disproved, id2s), ", ")
			)
		);
		r = foldi(chunks, Pair(ruMakeIndex(), true), \n, acc, chunk -> {
			indexes = foldi(chunk, Pair(acc.first, []), \i, ac, ass ->
				Pair(ruSetIndex(ass.stat.prop, ass, ac.first), concat(ac.second, [ac.first]))
			);
			left_time = time_limit - ruTimePassed(timer);
			if (left_time <= 0.0) Pair(indexes.first, false) else {
				time_left_on_chunk = left_time * i2d(availableProcessors()) * sum_proof_lens[n] / total_steps * 2.0;
				//control_sum = foldi(chunk, 0.0, \i, ac, __ -> 
				//	ac + time_left_on_chunk * i2d(proof_lens[n][i]) / sum_proof_lens[n]
				//);
				//env.out.onMessage("time_left_on_chunk: " + d2s(time_left_on_chunk) + ", control_sum: " + d2s(control_sum));
				ret = all(ruConcurrent(mapi(chunk, \i, ass -> 
						\-> eitherMap(ruDecl2Theorem(ass), 
							\th -> {
								limit = time_left_on_chunk * i2d(proof_lens[n][i]) / sum_proof_lens[n];
								reprove_th(th, Some(indexes.second[i]), limit);
							}, 
							true
						)
				)));
				Pair(indexes.first, ret && acc.second);
			}
		}).second;
		env.out.onMessage("average time per step: " + ruTime2s(ruTimePassed(timer) / total_steps));
		r;
	} else if (target == "1-seq" || target == "all-seq") {
		decls = concatA(map(ruSourcesOrder(math.sources), \src -> src.decls));
		ms_time_limit = calc_time_limit(decls);
		ruTrackProgress(track_progress, processed, length(decls), ruProgressUpdateMs(task, conf), timer, unit.out, \ ->
			"reproved: " + i2s(^reproved) + (if (^disproved == []) "" else ", disproved: " + 
				strGlue(map(^disproved, id2s), ", ")
			)
		);
		all(mapi(decls, \i, d -> {
			left_time = ms_time_limit - ruTimePassed(timer);
			if (left_time <= 0.0) false else { 
				limit_on_one = left_time / i2d(length(decls) - i);
				//env.out.onMessage("limit_on_one: " + d2s(limit_on_one / 1000.0) + ".s");
				reprove_decl(d, limit_on_one);
			}
		}));
	} else {
		id = s2id(target);
		switch (lookupTree(math.sources, id)) {
			Some(src): {
				ms_time_limit = calc_time_limit(src.decls);
				reprove_decls(src.decls, ms_time_limit);
			}
			None(): {
				switch (lookupTree(math.decls.assertions, id)) {
					Some(ass): {
						ms_time_limit = calc_time_limit([ass]);
						reprove_ass(ass, ms_time_limit);
					}
					None(): {
						env.out.onMessage("no target for reproving");
						false
					}
				}
			}
		}
	}
	if (ruVerbose(conf) > 0) {
		env.out.onMessage("ru reproved '" + target + "' in " + ruTimePassed2s(timer));
		env.out.onMessage("Max time: " + d2st(^max_time, 2) + "s for a theorem: " + id2s(^max_th_id));
	}
	if (/*math.ruVerbose(conf) > 0 ||*/ ^failed_count > 0) {
		env.out.onMessage("Reproved: " + i2s(^reproved_count) + " theorems,");
		env.out.onMessage("Failed to reprove: " + i2s(^failed_count) + " theorems:");
		iter(^failed_th_names, \th -> env.out.onMessage("\t" + th));
	}
	if (lookupTreeDef(conf.opts, "reprove-stats", "") == "1") {
		ruCommandReproveTimeStats(math, env);
		//ruCommandReproveAllStats(math);
	}
	Some(RuState(state with 
		ru = math.sources,
		vars = setTree(state.vars, 
			"reprove.time", ValDouble(ruTimePassed(timer))
		)
	));
}
