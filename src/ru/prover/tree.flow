import ru/subst;
import ru/proof_tree;

export {
	ruMakeProofTree(proof : RuProverProof) -> RuProofTree;

	RuProverProof ::= RuProverProofHyp, RuProverProofProp;
	RuProverProofHyp ::= RuProverProofTop, RuProverProofExp;
		RuProverProofTop(
			node : RuProverHyp,
			expr  : RuExp,
			premise : RuPremise, 
			sub  : Tree<RuVar, RuExp>,
		);
		RuProverProofExp(
			node : RuProverHyp,
			expr  : RuExp, 
			sub   : Tree<RuVar, RuExp>,
			child : RuProverProofProp,
		);
		RuProverProofProp(
			node      : RuProverProp,
			sub       : Tree<RuVar, RuExp>,
			children  : [RuProverProofHyp],
		);

	RuProverNode ::= RuProverHyp, RuProverProp;
	RuProverHyp ::= RuProverExp, RuProverRoot;
		RuProverProp(
			id        : int,
			assertion : RuAssertion,
			proofs    : ref [RuProverProofProp],
			sub       : Tree<RuVar, RuExp>,
			outer     : Tree<RuVar, RuExp>,
			children  : ref [RuProverExp],
			parent    : RuProverHyp
		);
		RuProverExp(
			ind      : int,
			proofs   : ref [RuProverProofHyp],
			expr     : RuExp,
			children : ref [RuProverProp],
			parent   : RuProverProp
		);
		RuProverRoot(
			proofs   : ref [RuProverProofHyp],
			expr     : RuExp,
			children : ref [RuProverProp]
		);

	RuProverTree(
		leafs : Tree<int, RuProverProp>,
		root  : RuProverRoot
	);

	ruProverNode2s(node : RuProverNode, math : RuMath) -> string;
	ruProverTree2s(node : RuProverNode, math : RuMath) -> string;
	ruProverNode2json(node : RuProverNode, math : RuMath, conf : RuConf) -> Json;
	ruProverTree2json(node : RuProverTree, math : RuMath, conf : RuConf) -> Json;
	ruSizeProverTree(node : RuProverNode) -> int;

	ruNoProverHyp = RuProverRoot(ref [], ruNoExp, ref []);
	ruNoProverProp = RuProverProp(-1, ruNoAxiom, ref [], makeTree(), makeTree(), ref [], ruNoProverHyp);
}

ruSizeProverTree(node : RuProverNode) -> int {
	1 + switch (node) {
		RuProverProp(__,__,__,__,__, children,__): fold(^children, 0, \ac, ch -> ac + ruSizeProverTree(ch));
		RuProverExp(__,__,__, children,__): fold(^children, 0, \ac, ch -> ac + ruSizeProverTree(ch));
		RuProverRoot(__,__, children): fold(^children, 0, \ac, ch -> ac + ruSizeProverTree(ch));
	}
}

ruApplySubst2ProofNode(s : Tree<RuVar, RuExp>, n : RuProofTree) {
	switch (n) {
		RuProofStep(ass, children, ex):
			RuProofStep(
				ass, 
				map(children, \ch -> ruApplySubst2ProofNode(s, ch)), 
				ruApplySubst(ex, s)
			);
		RuProofHyp(h, ex): 
			RuProofHyp(h, ruApplySubst(ex, s));
	}
}

ruMakeProofTree(proof : RuProverProof) -> RuProofTree {
	switch (proof) {
		RuProverProofTop(node, expr, hyp, sub): RuProofHyp(hyp.ind, expr);
		RuProverProofExp(node, expr, sub, child): ruMakeProofTree(child);
		RuProverProofProp(node, sub, children):
			ruApplySubst2ProofNode(sub, 
				RuProofStep(
					node.assertion.info.id, 
					map(children, ruMakeProofTree),
					node.parent.expr
				)
			);
	}
}

ruProverNode2s(node : RuProverNode, math : RuMath) -> string {
	switch (node) {
		RuProverProp(ind, ass, proofs, sub, outer, children, parent):
			"Prop<ass=" + id2s(ass.info.id) + ", proofs_num=" + i2s(length(^proofs)) + ", children num:" + i2s(length(^children)) + ">" + 
			(if (length(^proofs) == 0) "" else
				"\n" + strIndent(strGlue(map(^proofs, \p -> RuProofTree2s(ruMakeProofTree(p), math)), "\n"))
			);
		RuProverExp(ind, proofs, expr, children, parent):
			"Hyp<expr=" + ru2s(expr, math) + ", proofs_num=" + i2s(length(^proofs)) + ", children num:" + i2s(length(^children)) + ">" + 
			(if (length(^proofs) == 0) "" else
				"\n" + strIndent(strGlue(map(^proofs, \p -> RuProofTree2s(ruMakeProofTree(p), math)), "\n"))
			);
		RuProverRoot(proofs, expr, children):
			"Root<expr=" + ru2s(expr, math) + ", proofs_num=" + i2s(length(^proofs)) + ", children num:" + i2s(length(^children)) + ">" + 
			(if (length(^proofs) == 0) "" else
				"\n" + strIndent(strGlue(map(^proofs, \p -> RuProofTree2s(ruMakeProofTree(p), math)), "\n"))
			);
	}
}

ruProverTree2s(node : RuProverNode, math : RuMath) -> string {
	ruProverNode2s(node, math) + 
	(if (length(^(node.children)) == 0) "" else 
	"\n" + strIndent(strGlue(map(^(node.children), \ch -> ruProverTree2s(ch, math)), "\n")))
}

ruProverNode2json(node : RuProverNode, math : RuMath, conf : RuConf) -> Json {
	maxlen = s2i(lookupTreeDef(conf.opts, "maxlen-expr", "32"));
	switch (node) {
		RuProverProp(ind, ass, proofs, sub, outer, children, parent): {
			/* export interface PropEntity {
				id: number;
				assertion: string;
				proofs: number;
				children : HypEntity[];
				parent: number;
				tooltip: string;
			} */
			expr = ruApplySubst(parent.expr, sub);
			JsonObject([
				Pair("id", JsonDouble(i2d(ind))),
				Pair("assertion", JsonString(id2s(ass.info.id))),
				Pair("proofs", JsonArray(map(^proofs, \proof ->
					JsonString(ru2sWrapExp(
							ruApplySubst(expr, proof.sub), 
							math, \s -> ruIndentBrackets(s, maxlen)
					))
				))),
				Pair("children", JsonArray(map(^children, \ch -> ruProverNode2json(ch, math, conf)))),
				Pair("grand", JsonDouble(i2d(
					switch (parent) {
						RuProverExp(__,__,__,__,grand): grand.id;
						RuProverRoot(__,__,__): -1;
					}
				))),
				Pair("tooltip", JsonString("TODO")),
			]);
		}
		RuProverExp(ind, proofs, expr, children, parent): {
			/* export interface HypEntity {
				ind: number;
				expr: string;
				proofs: number;
				children : number[];
				parent: number;
				tooltip: string;
			} */
			expr_plain = ru2sWrapExp(expr, math, idfn);
			expr_multyline = ru2sWrapExp(expr, math, \s -> ruIndentBrackets(s, maxlen));
			JsonObject([
				Pair("ind", JsonDouble(i2d(ind))),
				Pair("expr_plain", JsonString(expr_plain)),
				Pair("expr_multyline", JsonString(expr_multyline)),
				Pair("proofs", JsonArray(map(^proofs, \proof -> 
					JsonString(ru2sWrapExp(
							proof.expr, 
							math, \s -> ruIndentBrackets(s, maxlen)
					))
				))),
				Pair("children", JsonArray(map(^children, \ch -> JsonDouble(i2d(ch.id))))),
				Pair("parent", JsonDouble(i2d(parent.id))),
				Pair("tooltip", JsonString(expr_multyline)),
			]);
		}
		RuProverRoot(proofs, expr, children): {
			/* export interface RootEntity {
				expr: string;
				proofs: string[];
				children : number[];
				tooltip: string;
			} */
			expr_plain = ru2sWrapExp(expr, math, idfn);
			expr_multyline = ru2sWrapExp(expr, math, \s -> ruIndentBrackets(s, maxlen));
			JsonObject([
				Pair("expr_plain", JsonString(expr_plain)),
				Pair("expr_multyline", JsonString(expr_multyline)),
				Pair("proofs", JsonArray(map(^proofs, \root -> {
					tree = ruMakeProofTree(root);
					linear = ruMakeLinearProof(tree);
					//steps = map(linear, \step -> RuStep(step with expr = prover_env.fns.unconst(step.expr)));
					proof = RuProof(ruEmptyVarsDisjs, linear, -1);
					JsonString(ru2sWrapExp(
							proof, 
							math, \s -> ruIndentBrackets(s, maxlen)
					));
				}))),
				Pair("children", JsonArray(map(^children, \ch -> JsonDouble(i2d(ch.id))))),
				Pair("tooltip", JsonString(expr_multyline)),
			]);
		}
	}
}

/*
export interface ProofVariantTree {
	nodes: PropEntity[],
	root: RootEntity 
}
*/

ruProverTree2json(tree : RuProverTree, math : RuMath, conf : RuConf) -> Json {
	JsonObject([
		Pair("nodes", JsonArray(map(ruAllPropNodes(tree), \leaf -> ruProverNode2json(leaf, math, conf)))),
		Pair("root", ruProverNode2json(tree.root, math, conf)),
	]);
}

ruAllPropNodes(tree : RuProverTree) -> [RuProverProp] {
	list2array(ruDoAllPropNodes(makeList(), tree.root));
}

ruDoAllPropNodes(acc : List<RuProverProp>, node : RuProverNode) -> List<RuProverProp> {
	switch (node) {
		RuProverProp(ind, ass, proofs, sub, outer, children, parent): {
			fold(^children, Cons(node, acc), ruDoAllPropNodes);
		}
		RuProverExp(ind, proofs, expr, children, parent): {
			fold(^children, acc, ruDoAllPropNodes);
		}
		RuProverRoot(proofs, expr, children): {
			fold(^children, acc, ruDoAllPropNodes);
		}
	}
}
