import ru/subst;
import ru/proof_tree;

export {
	ruMakeProofTree(proof : RuProverProof) -> RuProofTree;

	RuProverProof ::= RuProverProofHyp, RuProverProofProp;
	RuProverProofHyp ::= RuProverProofTop, RuProverProofExp;
		RuProverProofTop(
			node : RuProverHyp,
			expr  : RuExp,
			premise : RuPremise, 
			sub  : Tree<RuVar, RuExp>,
		);
		RuProverProofExp(
			node : RuProverHyp,
			expr  : RuExp, 
			sub   : Tree<RuVar, RuExp>,
			child : RuProverProofProp,
		);
		RuProverProofProp(
			node      : RuProverProp,
			sub       : Tree<RuVar, RuExp>,
			children  : [RuProverProofHyp],
		);

	RuProverNode ::= RuProverHyp, RuProverProp;
	RuProverHyp ::= RuProverExp, RuProverRoot;
		RuProverProp(
			id        : int,
			assertion : RuAssertion,
			proofs    : ref [RuProverProofProp],
			sub       : Tree<RuVar, RuExp>,
			outer     : Tree<RuVar, RuExp>,
			children  : ref [RuProverExp],
			parent    : RuProverHyp,
			expanded  : ref bool
		);
		RuProverExp(
			ind      : int,
			proofs   : ref [RuProverProofHyp],
			expr     : RuExp,
			children : ref [RuProverProp],
			parent   : RuProverProp
		);
		RuProverRoot(
			proofs   : ref [RuProverProofHyp],
			expr     : RuExp,
			children : ref [RuProverProp]
		);

	RuProverNodeSnapshot(
		proofs   : int,
		expanded : bool
	);
	RuProverTreeSnapshot(
		tree : Tree<int, RuProverNodeSnapshot>,
		root : RuProverNodeSnapshot
	);
	RuProverTreeDiff(
		nodes : [RuProverProp],
		root : Maybe<RuProverRoot>
	);

	RuProverTree(
		leafs : Tree<int, RuProverProp>,
		nodes : Tree<int, RuProverProp>,
		root  : RuProverRoot
	);

	ruProverNode2s(node : RuProverNode, math : RuMath) -> string;
	ruProverTree2s(node : RuProverNode, math : RuMath) -> string;
	ruProverNode2json(node : RuProverNode, math : RuMath, conf : RuConf) -> Json;
	ruProverTreeDiff2json(diff : RuProverTreeDiff, math : RuMath, conf : RuConf) -> Json;
	ruProverTree2json(node : RuProverTree, math : RuMath, conf : RuConf) -> Json;
	ruSizeProverTree(node : RuProverNode) -> int;

	ruProverNode2Snapshot(node : RuProverNode) -> RuProverNodeSnapshot;
	ruProverTree2Snapshot(tree : RuProverTree) -> RuProverTreeSnapshot;
	ruProverTreeDiff(snap : RuProverTreeSnapshot, tree : RuProverTree) -> RuProverTreeDiff;

	ruNoProverHyp = RuProverRoot(ref [], ruNoExp, ref []);
	ruNoProverProp = RuProverProp(-1, ruNoAxiom, ref [], makeTree(), makeTree(), ref [], ruNoProverHyp, ref false);
}

ruSizeProverTree(node : RuProverNode) -> int {
	1 + switch (node) {
		RuProverProp(__,__,__,__,__, children,__,__): fold(^children, 0, \ac, ch -> ac + ruSizeProverTree(ch));
		RuProverExp(__,__,__, children,__): fold(^children, 0, \ac, ch -> ac + ruSizeProverTree(ch));
		RuProverRoot(__,__, children): fold(^children, 0, \ac, ch -> ac + ruSizeProverTree(ch));
	}
}

ruApplySubst2ProofNode(s : Tree<RuVar, RuExp>, n : RuProofTree) {
	switch (n) {
		RuProofStep(ass, children, ex):
			RuProofStep(
				ass, 
				map(children, \ch -> ruApplySubst2ProofNode(s, ch)), 
				ruApplySubst(ex, s)
			);
		RuProofHyp(h, ex): 
			RuProofHyp(h, ruApplySubst(ex, s));
	}
}

ruMakeProofTree(proof : RuProverProof) -> RuProofTree {
	switch (proof) {
		RuProverProofTop(node, expr, hyp, sub): RuProofHyp(hyp.ind, expr);
		RuProverProofExp(node, expr, sub, child): ruMakeProofTree(child);
		RuProverProofProp(node, sub, children):
			ruApplySubst2ProofNode(sub, 
				RuProofStep(
					node.assertion.info.id, 
					map(children, ruMakeProofTree),
					node.parent.expr
				)
			);
	}
}

ruProverNode2s(node : RuProverNode, math : RuMath) -> string {
	switch (node) {
		RuProverProp(ind, ass, proofs, sub, outer, children, parent, expanded):
			"Prop<" + 
				"ass=" + id2s(ass.info.id) + ", " + 
				"proofs_num=" + i2s(length(^proofs)) + ", " + 
				"children_num=" + i2s(length(^children)) + ", " + 
				"expanded=" + b2s(^expanded) +
			">" + 
			(if (length(^proofs) == 0) "" else
				"\n" + strIndent(strGlue(map(^proofs, \p -> RuProofTree2s(ruMakeProofTree(p), math)), "\n"))
			);
		RuProverExp(ind, proofs, expr, children, parent):
			"Hyp<expr=" + ru2s(expr, math) + ", proofs_num=" + i2s(length(^proofs)) + ", children num:" + i2s(length(^children)) + ">" + 
			(if (length(^proofs) == 0) "" else
				"\n" + strIndent(strGlue(map(^proofs, \p -> RuProofTree2s(ruMakeProofTree(p), math)), "\n"))
			);
		RuProverRoot(proofs, expr, children):
			"Root<expr=" + ru2s(expr, math) + ", proofs_num=" + i2s(length(^proofs)) + ", children num:" + i2s(length(^children)) + ">" + 
			(if (length(^proofs) == 0) "" else
				"\n" + strIndent(strGlue(map(^proofs, \p -> RuProofTree2s(ruMakeProofTree(p), math)), "\n"))
			);
	}
}

ruProverTree2s(node : RuProverNode, math : RuMath) -> string {
	ruProverNode2s(node, math) + 
	(if (length(^(node.children)) == 0) "" else 
	"\n" + strIndent(strGlue(map(^(node.children), \ch -> ruProverTree2s(ch, math)), "\n")))
}

ruProverNode2json(node : RuProverNode, math : RuMath, conf : RuConf) -> Json {
	maxlen = s2i(lookupTreeDef(conf.opts, "maxlen-expr", "32"));
	switch (node) {
		RuProverProp(ind, ass, proofs, sub, outer, children, parent, expanded): {
			expr = ruApplySubst(parent.expr, sub);
			tooltip = ru2s(ass, math);
			JsonObject([
				Pair("id", JsonDouble(i2d(ind))),
				Pair("assertion", JsonString(id2s(ass.info.id))),
				Pair("proofs", JsonArray(map(^proofs, \proof ->
					JsonString(ru2sWrapExp(
							ruApplySubst(expr, proof.sub), 
							math, \s -> ruIndentBrackets(s, maxlen)
					))
				))),
				Pair("children", JsonArray(map(^children, \ch -> ruProverNode2json(ch, math, conf)))),
				Pair("grand", JsonDouble(i2d(
					switch (parent) {
						RuProverExp(__,__,__,__,grand): grand.id;
						RuProverRoot(__,__,__): -1;
					}
				))),
				Pair("expanded", JsonBool(^expanded)),
				Pair("tooltip", JsonString(tooltip)),
			]);
		}
		RuProverExp(ind, proofs, expr, children, parent): {
			expr_plain = ru2sWrapExp(expr, math, idfn);
			expr_multyline = ru2sWrapExp(expr, math, \s -> ruIndentBrackets(s, maxlen));
			JsonObject([
				Pair("ind", JsonDouble(i2d(ind))),
				Pair("expr_plain", JsonString(expr_plain)),
				Pair("expr_multyline", JsonString(expr_multyline)),
				Pair("proofs", JsonArray(map(^proofs, \proof -> 
					JsonString(ru2sWrapExp(
							proof.expr, 
							math, \s -> ruIndentBrackets(s, maxlen)
					))
				))),
				Pair("children", JsonArray(map(^children, \ch -> JsonDouble(i2d(ch.id))))),
				Pair("parent", JsonDouble(i2d(parent.id))),
				Pair("tooltip", JsonString(expr_multyline)),
			]);
		}
		RuProverRoot(proofs, expr, children): {
			expr_plain = ru2sWrapExp(expr, math, idfn);
			expr_multyline = ru2sWrapExp(expr, math, \s -> ruIndentBrackets(s, maxlen));
			JsonObject([
				Pair("expr_plain", JsonString(expr_plain)),
				Pair("expr_multyline", JsonString(expr_multyline)),
				Pair("proofs", JsonArray(map(^proofs, \root -> {
					tree = ruMakeProofTree(root);
					linear = ruMakeLinearProof(tree);
					//steps = map(linear, \step -> RuStep(step with expr = prover_env.fns.unconst(step.expr)));
					proof = RuProof(ruEmptyVarsDisjs, linear, -1);
					JsonString(ru2sWrapExp(
							proof, 
							math, \s -> ruIndentBrackets(s, maxlen)
					));
				}))),
				Pair("children", JsonArray(map(^children, \ch -> JsonDouble(i2d(ch.id))))),
				Pair("tooltip", JsonString(expr_multyline)),
			]);
		}
	}
}

ruProverTree2json(tree : RuProverTree, math : RuMath, conf : RuConf) -> Json {
	JsonObject([
		Pair("nodes", JsonArray(map(getTreeValues(tree.nodes), \leaf -> ruProverNode2json(leaf, math, conf)))),
		Pair("root", ruProverNode2json(tree.root, math, conf)),
	]);
}

ruProverTreeDiff2json(diff : RuProverTreeDiff, math : RuMath, conf : RuConf) -> Json {
	nodes_json = JsonArray(map(diff.nodes, \leaf -> ruProverNode2json(leaf, math, conf)));
	switch (diff.root) {
		Some(root): {
			JsonObject([
				Pair("nodes", nodes_json),
				Pair("root", ruProverNode2json(root, math, conf))
			]);
		}
		None(): {
			JsonObject([
				Pair("nodes", nodes_json),
			]);
		}
	}
}

ruProverNode2Snapshot(node : RuProverNode) -> RuProverNodeSnapshot {
	switch (node) {
		RuProverProp(__,__,proofs,__,__,__,__,expanded): RuProverNodeSnapshot(length(^proofs), ^expanded);
		RuProverExp(__,proofs,__,__,__): RuProverNodeSnapshot(length(^proofs), true);
		RuProverRoot(proofs,__,__): RuProverNodeSnapshot(length(^proofs), true);
	}
}

ruProverTree2Snapshot(tree : RuProverTree) -> RuProverTreeSnapshot {
	RuProverTreeSnapshot(
		mapTree(tree.nodes, ruProverNode2Snapshot),
		ruProverNode2Snapshot(tree.root)
	);
}

ruProverTreeDiff(snap : RuProverTreeSnapshot, tree : RuProverTree) -> RuProverTreeDiff {
	RuProverTreeDiff(
		filter(getTreeValues(tree.nodes), \n ->
			switch (lookupTree(snap.tree, n.id)) {
				Some(s): s != ruProverNode2Snapshot(n);
				None(): true;
			}
		),
		if (snap.root != ruProverNode2Snapshot(tree.root)) Some(tree.root) else None()
	);
}
