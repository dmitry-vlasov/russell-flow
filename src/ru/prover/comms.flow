import ru/prover/prove;
import ru/prover/reprove;

export {
	ruProverCommands : [RuComm] = [
		ruCommReprove,
		ruCommProveStart,
		ruCommProveFinish,
		ruCommProveConfirmProof,
		ruCommProveTry,
		ruCommProveExpandLeafs
	]
}

ruCommProveStart = RuComm(
	RuCommDescr(
		"prove-start", "prover", "start proving a theorem", "theorem", true, false, 
		[
			RuCommArg("theorem", false, "a target theorem for proving", ""),
			RuCommArg("time-limit", true, "a default time limit for proving", ""),
		], []
	),
	ruRunProveStart
);

ruRunProveStart(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	task = unit.task;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	th_name = lookupTreeDef(task.args, "theorem", "");
	timer = ruMakeTimer();
	maybeBind(lookupTree(math.assertions, s2id(th_name)),
		\th -> {
			switch (th) {
				RuTheorem(__,__,__,__): {
					time_limit = s2d(lookupTreeDef(task.args, "time-limit", "-1.0"));
					if (ruVerbose(conf) > 0) {
						env.out.onMessage(
							"start proving a theorem: '" + th_name + "'" + 
							(if (time_limit > 0.0) ", time limit: " + ruTime2s(time_limit) else "")
						);
					}
					prover_env = ruInitProverEnv(th, math, env, None(), time_limit);
					Some(RuState(state with 
						prover = Some(RuProverState(th, prover_env)),
						vars = setTree(state.vars, 
							"prove-start.time", ValDouble(ruTimePassed(timer))
						)
					));
				}
				default: None();
			}
		}
	);
}

ruCommProveFinish = RuComm(
	RuCommDescr(
		"prove-finish", "prover", "finish proving a theorem", "", true, false, 
		[], [],
	),
	ruRunProveFinish
);

ruRunProveFinish(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	maybeMap(state.prover, \prover_state -> {
		penv = prover_state.env;
		if (ruVerbose(conf) > 0) {
			env.out.onMessage("finished proving: '" + penv.descr + "', it was " + 
				(if (ruProvedEnvIsProved(penv)) "PROVED" else "NOT proved")
			);
		}
		RuState(state with prover = None());
	});
}

ruCommProveConfirmProof = RuComm(
	RuCommDescr(
		"prove-confirm-proof", "prover", "attach a proof to a target theorem", "index", true, false, 
		[RuCommArg("index", true, "an index of a choosen proof. -1 means automatic choice of the shortest", "-1")], []
	),
	ruRunProveConfirmProof
);

ruRunProveConfirmProof(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	task = unit.task;
	conf = state.conf;
	maybeMap(state.prover, \prover_state -> {
		penv = prover_state.env;
		theorem = prover_state.theorem;
		index = s2i(lookupTreeDef(task.args, "index", "-1"));
		confirm = \proof -> {
			if (ruVerbose(conf) > 0) {
				env.out.onMessage("proof of: '" + penv.descr + "' is confirmed");
			}
			proved = RuTheorem(theorem with 
				proof = ruUpdateProofVars(RuProof(proof with steps = proof.steps), theorem, theorem)
			);
			math = ruMakeMathFromSources(state.ru, env);
			new_math = ruReplaceDecl(proved, math, env);
			RuState(state with 
				ru = new_math.sources,
				prover = None()
			);
		}
		if (index >= length(^(penv.proofs))) {
			if (length(^(penv.proofs)) == 0) {
				env.out.onError("target '" + penv.descr + "'' is NOT proved", []);
			} else {
				env.out.onError("proof index " + i2s(index) + " is out of bounds (must be <= " + i2s(length(^(penv.proofs))) + ")", []);
			}
			state;
		} else if (index < 0) {
			switch (ruProverEnvProof(penv)) {
				Some(proof):  confirm(proof);
				None(): {
					env.out.onError("target '" + penv.descr + "'' is NOT proved", []);
					state;
				}
			}
		} else {
			confirm(^(penv.proofs)[index]);
		}
	});
}

ruCommProveTry = RuComm(
	RuCommDescr(
		"prove-try", "prover", "try to prove a theorem using current tactic", "theorem", true, false, 
		[RuCommArg("time-limit", true, "a default time limit for proving step", "")], []
	),
	ruRunProveTry
);

ruRunProveTry(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	task = unit.task;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	timer = ruMakeTimer();
	maybeMap(state.prover,
		\prover_state -> {
			penv0 = prover_state.env;
			time_limit = s2d(lookupTreeDef(task.args, "time-limit", "-1.0"));
			if (ruVerbose(conf) > 0) {
				env.out.onMessage(
					"trying to prove: '" + penv0.descr + "'" + 
					(if (time_limit > 0.0) ", time limit: " + ruTime2s(time_limit) else "")
				);
			}
			penv1 = ruProve(penv0);
			RuState(state with 
				prover = Some(RuProverState(prover_state with env = penv1)),
				vars = setTree(setTree(state.vars, 
					"prove-try.time", ValDouble(ruTimePassed(timer))),
					"prove.success", ValBool(length(^(penv1.proofs)) > 0)
				)
			);
		}
	);
}

ruCommProveExpandLeafs = RuComm(
	RuCommDescr(
		"prove-expand-leafs", "prover", "try to prove a theorem using a breadth-first search", "", false, false, 
		[RuCommArg("time-limit", true, "a default time limit for proving step", "")], []
	),
	ruRunProveExpandLeafs
);

ruRunProveExpandLeafs(unit : RuUnit) -> Maybe<RuState> {
	env = ruUnitEnv(unit);
	state = unit.state;
	task = unit.task;
	conf = state.conf;
	math = ruMakeMathFromSources(state.ru, env);
	timer = ruMakeTimer();
	maybeMap(state.prover,
		\prover_state -> {
			penv0 = prover_state.env;
			time_limit = s2d(lookupTreeDef(task.args, "time-limit", "-1.0"));
			if (ruVerbose(conf) > 1) {
				env.out.onMessage(
					"expanding all leafs in: '" + penv0.descr + "'" +
					(if (time_limit > 0.0) ", time limit: " + ruTime2s(time_limit) else "")
				);
			}
			leafs = buildSet(getTreeKeys(penv0.tree.leafs));
			penv1 = ruSetProverEnvTactic(penv0, \tree -> 
				findInOrder(tree.leafs, \id, n -> if (containsSet(leafs, id)) Some(n) else None())
			);
			penv2 = ruProve(penv1);
			RuState(state with 
				prover = Some(RuProverState(prover_state with env = penv2)),
				vars = setTree(setTree(state.vars, 
					"prove-try.time", ValDouble(ruTimePassed(timer))),
					"prove.success", ValBool(length(^(penv2.proofs)) > 0)
				)
			);
		}
	);
}
