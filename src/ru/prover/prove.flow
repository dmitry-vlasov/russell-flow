import ru/prover/expand;

export {
	ruInitProver(
		task : RuProverTask,
		math : RuMath, 
		env : RuEnv, 
		asses : RuIndex<RuAssertion>, 
		ms_time_limit : double
	) -> RuProverEnv;

	ruProve(prover_env : RuProverEnv) -> RuProverEnv;
}

ruInitProver(
	task : RuProverTask,
	math : RuMath, 
	env : RuEnv, 
	asses : RuIndex<RuAssertion>, 
	ms_time_limit : double
) -> RuProverEnv {
	prover_env = ruInitProverEnv(task, math, env, asses, ms_time_limit);
	ruExpandHyp(prover_env.tree.root, prover_env);
}

ruProveProp(prop : RuProverProp, prover_env : RuProverEnv) -> RuProverEnv {
	t1 = ruMakeTimer();
	env1 = ruExpandProp(prop, prover_env);
	if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
		ruAddStats("ruExpandProp", RuStatsRow("expanding " + id2s(prop.assertion.info.id), 
			pairs2tree([
				Pair("time", ruTimePassed(t1)), 
				Pair("count", 1.0)
			])
		));
	}
	t2 = ruMakeTimer();
	ruBuildPropProofs(prop, ^(prop.proofs), env1);
	if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
		ruAddStats("ruBuildPropProofs", RuStatsRow("building proofs for " + id2s(prop.assertion.info.id), 
			pairs2tree([
				Pair("time", ruTimePassed(t2)), 
				Pair("count", 1.0)
			])
		));
	}
	env1;
}

ruProve(prover_env : RuProverEnv) -> RuProverEnv {
	t0 = ruMakeTimer();
	tactic = ^(prover_env.tactic);
	tactic.before(prover_env);
	to_expand = tactic.expand(prover_env.tree);
	// !!!! REMOVE - CAUTION!! - WRITES TO LOG!!!
	/*ruDebugLog("to_expand: [" + 
		superglue(to_expand, \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]", 
		prover_env.env.conf
	);*/
	proving_trace = s2i(lookupTreeDef(prover_env.task.args, "proving-trace", lookupTreeDef(prover_env.env.conf.opts, "proving-trace", "0")));
	if (proving_trace >= 1) {
		prover_env.env.out.onMessage("TO EXPAND: [" + 
			superglue(to_expand, \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]"
			//+ " concurrency enabled: " + b2s(ruGetConcurrencyEnabled())
		);
		if (proving_trace >= 2) {
			prover_env.env.out.onMessage("TREE BEFORE EXPANSION:\n" + ruProverTree2s(prover_env.tree.root, prover_env.math));
		}
	}
	// ruAddStats(table_name : string, row : RuStatsRow) -> void;
	if (lookupTreeDef(prover_env.env.conf.opts, "stats-prove-expand", "") == "1") {
		ruAddStats("stats-prove-expand", RuStatsRow("", makeTree1("size", i2d(length(to_expand)))));
	}
	if (to_expand == []) {
		//prover_env.env.out.onMessage("RU_PROVE - X (to_expand == [])");
		prover_env;
		//tactic.after(prover_env);
		//if (tactic.finish(prover_env)) prover_env else {
		//	ruDebugLog("RU_PROVE... (to_expand == [])", prover_env.env.conf);
		//	ruProve(prover_env);
		//}
	} else {
		to_expand_removed = fold(to_expand, prover_env.tree.leafs, \acc, prop -> 
			removeFromTree(acc, prop.id)
		);
		/*if (prover_env.env.conf.verbose > 2) {
			prover_env.env.out.onMessage("to_expand_removed: [" + 
				superglue(getTreeValues(to_expand_removed), \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]"
			);
		}*/
		//ruDebugLog("to_expand_removed: [" + 
		//	superglue(getTreeValues(to_expand_removed), \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]", prover_env.env.conf
		//);
		env1 = RuProverEnv(prover_env with tree = RuProverTree(to_expand_removed, prover_env.tree.nodes, prover_env.tree.root));
		env1_expanded = ruConcurrent(
		//env1_expanded = ruSequential(
			map(to_expand, 
				\prop -> \env2 -> ruProveProp(prop, RuProverEnv(env1 with env = env2))
			), 
			env1.env
		);
		new_env = fold(env1_expanded, env1, \acc, e -> 
			RuProverEnv(acc with 
				tree = RuProverTree(
					mergeTree(acc.tree.leafs, e.tree.leafs), 
					mergeTree(acc.tree.nodes, e.tree.leafs), 
					acc.tree.root
				)
			)
		);
		if (lookupTreeDef(prover_env.task.args, "proving-trace", "") == "1") {
			prover_env.env.out.onMessage("LEAFS AFTER EXPANSION: [" + 
				superglue(getTreeValues(new_env.tree.leafs), \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]"
			);
			prover_env.env.out.onMessage("TREE BEFORE EXPANSION:\n" + ruProverTree2s(prover_env.tree.root, prover_env.math));
		}
		tactic.after(new_env);
		if (lookupTreeDef(prover_env.env.conf.opts, "proving-stats", "") == "1") {
			ruAddStats("choice", RuStatsRow("choice ", 
				pairs2tree([
					Pair("size", i2d(sizeTree(prover_env.tree.leafs))), 
					Pair("time", ruTimePassed(t0)), 
					Pair("count", 1.0)
				])
			));
		}
		if (tactic.finish(new_env)) new_env else {
			//ruDebugLog("RU_PROVE... (to_expand != [])", prover_env.env.conf);
			//prover_env.env.out.onMessage("RU_PROVE... (to_expand != [])");
			ruProve(new_env);
		}
	}
}
