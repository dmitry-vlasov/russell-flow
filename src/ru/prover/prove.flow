import ru/prover/expand;

export {
	ruInitProver(
		task : RuProverTask,
		math : RuMath, 
		env : RuEnv, 
		asses : RuIndex<RuAssertion>, 
		ms_time_limit : double
	) -> RuProverEnv;

	ruProve(prover_env : RuProverEnv) -> RuProverEnv;
}

ruInitProver(
	task : RuProverTask,
	math : RuMath, 
	env : RuEnv, 
	asses : RuIndex<RuAssertion>, 
	ms_time_limit : double
) -> RuProverEnv {
	prover_env = ruInitProverEnv(task, math, env, asses, ms_time_limit);
	ruExpandHyp(prover_env.tree.root, prover_env);
}

ruProveProp(prop : RuProverProp, prover_env : RuProverEnv) -> RuProverEnv {
	t1 = ruMakeTimer();
	env1 = ruExpandProp(prop, prover_env);
	if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
		ruAddStats("ruExpandProp", RuStatsRow("expanding " + id2s(prop.assertion.info.id), 
			pairs2tree([
				Pair("time", ruTimePassed(t1)), 
				Pair("count", 1.0)
			])
		));
	}
	t2 = ruMakeTimer();
	ruBuildPropProofs(prop, ^(prop.proofs), env1);
	if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
		ruAddStats("ruBuildPropProofs", RuStatsRow("building proofs for " + id2s(prop.assertion.info.id), 
			pairs2tree([
				Pair("time", ruTimePassed(t2)), 
				Pair("count", 1.0)
			])
		));
	}
	env1;
}

ruProve(prover_env : RuProverEnv) -> RuProverEnv {
	t0 = ruMakeTimer();
	^(prover_env.tactic).before(prover_env);
	to_expand = ^(prover_env.tactic).expand(prover_env.tree);
	//prover_env.env.out.onMessage("TO EXPAND: [" + 
	//	superglue(to_expand, \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]"
	//);
	if (to_expand == []) prover_env else {
		to_expand_removed = fold(to_expand, prover_env.tree.leafs, \acc, prop -> 
			removeFromTree(acc, prop.id)
		);
		env1 = RuProverEnv(prover_env with tree = RuProverTree(to_expand_removed, prover_env.tree.root));
		//env1_expanded = ruConcurrent(map(to_expand, \prop -> \-> ruProveProp(prop, env1)));
		env1_expanded = map(to_expand, \prop -> ruProveProp(prop, env1));
		new_env = fold(env1_expanded, env1, \acc, e -> 
			RuProverEnv(acc with 
				tree = RuProverTree(mergeTree(acc.tree.leafs, e.tree.leafs), acc.tree.root)
			)
		);
		//prover_env.env.out.onMessage("AFTER EXPANSION: [" + 
		//	superglue(getTreeValues(new_env.tree.leafs), \p -> i2s(p.id) + ":" + id2s(p.assertion.info.id), ", ") + "]"
		//);
		^(prover_env.tactic).after(new_env);
		if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
			ruAddStats("choice", RuStatsRow("choice ", 
				pairs2tree([
					Pair("size", i2d(sizeTree(prover_env.tree.leafs))), 
					Pair("time", ruTimePassed(t0)), 
					Pair("count", 1.0)
				])
			));
		}
		if (^(prover_env.tactic).finish(new_env)) new_env else {
			ruProve(new_env);
		}
	}
}
