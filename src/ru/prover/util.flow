import ru/prover/tree;
import ru/index;
import ru/verify/math;
import ru/util/transform;
import base/stats;

export {
	RuConstEnv(
		doconst  : (RuExp) -> RuExp,
		unconst  : (RuExp) -> RuExp,
		math     : RuMath
	);
	// Assertion with non-changeable variables replaced by constants
	RuConstAssertion(
		original : ?,
		const    : ?,
		env : RuConstEnv
	);

	ruMakeFresh(vars : [RuVar], fresher : (RuVar) -> RuVar) -> Tree<RuVar, RuExp>;
	ruInitTheoremAssertionsIndex(th : RuTheorem, math : RuMath, env : RuEnv) -> RuIndex<RuAssertion>;
	ruInitSourceAssertionsIndex(src : RuSource, math : RuMath, env : RuEnv) -> RuIndex<RuAssertion>;
	ruInitGlobalAssertionsIndex(math : RuMath) -> RuIndex<RuAssertion>;

	ruInitPremisesIndex(th : RuTheorem) -> RuIndex<RuHyp>;
	ruConstTheorem(th : RuTheorem, math0 : RuMath) -> RuConstAssertion<RuTheorem>;
	ruConstAxiom(ax : RuAxiom, math : RuMath) -> RuConstAssertion<RuAxiom>;
	ruConstDef(df : RuDef, math : RuMath) -> RuConstAssertion<RuDef>;
	ruConstAssertion(as : RuAssertion, math : RuMath) -> RuConstAssertion<RuAssertion>;

	ruSubSatisfies(s : Tree<RuVar, RuExp>, cond : (RuExp) -> bool) -> bool;
	ruUpdateTheoremWithSteps(th : RuTheorem, steps : [RuStep], math : RuMath, env : RuEnv) -> Maybe<RuTheorem>;

	ruFindLeastSourceContaining(assertions : Set<string>, math : RuMath, env : RuEnv) -> Maybe<string>;
}

ruMakeFresh(vars : [RuVar], fresher : (RuVar) -> RuVar) -> Tree<RuVar, RuExp> {
	fold(vars, makeTree(), \acc, v -> setTree(acc, v, RuExp([fresher(v)], -1)));
}

ruInitTheoremAssertionsIndex(th : RuTheorem, math : RuMath, env : RuEnv) -> RuIndex<RuAssertion> {
	t = ruMakeTimer();
	switch (lookupTree(math.sources, th.info.src)) {
		Some(th_src): {
			all_imported = removeSet(ruSourceAllImported(th.info.id, math.sources), th_src);
			th_index = ruIndexOfDecl(th.info.id, th_src);
			index = foldTree(math.decls.assertions, ruMakeIndex(), 
				\id, ass, acc -> {
					switch (ruFindSource(id, math)) {
						Some(ass_src): {
							if (containsSet(all_imported, ass_src)) {
								ruSetIndex(ass.stat.prop, ass, acc);
							} else if (ass_src == th_src) {
								if (ruIndexOfDecl(id, ass_src) < th_index) {
									ruSetIndex(ass.stat.prop, ass, acc);
								} else {
									acc
								}
							} else {
								acc
							}
						}
						None(): {
							env.out.onMessage("assertion: '" + id2s(id) + "' is not found");
							acc;
						}
					}
				}
			);
			stats = RuStatsRow("theorem: '" + id2s(th.info.id) + "'", 
				pairs2tree([
					Pair("size", i2d(sizeSet(all_imported))), 
					Pair("time", ruTimePassed(t))
				])
			);
			ruAddStats("init_assertion_index", stats);
			index;
		}
		None(): {
			env.out.onMessage("Source:  '" + id2s(th.info.src) + "' of a theorem: '" + id2s(th.info.id) + "' is not found");
			env.out.onMessage("ruFindSourceName():  '" + id2s(ruFindSourceId(th.info.id, math.decls)) + "'");
			env.out.onMessage("math.sources:\n" + strIndent(strGlue(map(getTreeKeys(math.sources), id2s), "\n")));
			ruMakeIndex();
		}
	}
}

ruInitSourceAssertionsIndex(src : RuSource, math : RuMath, env : RuEnv) -> RuIndex<RuAssertion> {
	t = ruMakeTimer();
	src_id = src.info.id;
	all_imported = insertSet(ruSourceAllImported(src_id, math.sources), src);
	index = foldTree(math.decls.assertions, ruMakeIndex(), 
		\id, ass, acc -> {
			switch (ruFindSource(id, math)) {
				Some(ass_src): {
					if (!containsSet(all_imported, ass_src)) acc else {
						ruSetIndex(ass.stat.prop, ass, acc);
					}
				}
				None(): {
					env.out.onMessage("assertion: '" + id2s(id) + "' is not found");
					acc;
				}
			}
		}
	);
	stats = RuStatsRow("source: " + id2s(src_id), 
		pairs2tree([Pair("size", i2d(sizeSet(all_imported))), Pair("time", ruTimePassed(t))])
	);
	ruAddStats("init_assertion_index", stats);
	index;
}


ruInitGlobalAssertionsIndex(math : RuMath) -> RuIndex<RuAssertion> {
	foldTree(math.decls.assertions, ruMakeIndex(), \name, ass, acc ->
		ruSetIndex(ass.stat.prop, ass, acc)
	);
}

ruInitPremisesIndex(th : RuTheorem) -> RuIndex<RuHyp> {
	fold(th.stat.hyps, ruMakeIndex(), \acc, h -> ruSetIndex(h.expr, h, acc));
}

ruMakeConstEnv(cv_vars : [RuVar], math0 : RuMath) -> RuConstEnv {
	cv_id = \cv -> s2id("_" + id2s(cv.id));
	cv_rules = map(cv_vars, \cv -> {
		id = cv_id(cv);
		RuRule(
			RuDeclInfo(id, -1, [], -1), 
			makeTree(), 
			RuTerm(cv.type, [RuConstRef(id)], -1)
		);
	});
	math = RuMath(math0 with 
		decls = RuDecls(math0.decls with 
			rules = mergeTree(math0.decls.rules, values2tree(cv_rules, \r -> r.info.id))
		)
	);
	cv_map = keys2tree(cv_vars, \cv -> RuRuleNode(cv_id(cv), cv.type, 0, 0));
	cv_exp = \e -> RuExp(map(e.nodes, \n -> lookupTreeDef(cv_map, n, n)), e.pos);
	uncv_map = foldTree(cv_map, makeTree(), \v, cv, acc -> setTree(acc, cv, v));
	uncv_exp = \e : RuExp -> RuExp(map(e.nodes, \n -> lookupTreeDef(uncv_map, n, n)), e.pos);
	RuConstEnv(cv_exp, uncv_exp, math);
}

ruConstTheorem(th : RuTheorem, math : RuMath) -> RuConstAssertion<RuTheorem> {
	th_vars = set2array(mergeSets(ruAssertion2Vars(th), ruProof2Vars(th.proof)));
	vars = filter(th_vars, \v -> !containsSet(th.meta, v.id));
	env = ruMakeConstEnv(vars, math);
	RuConstAssertion(th, ruTransformTheorem(th, env.doconst), env);
}

ruConstAxiom(ax : RuAxiom, math : RuMath) -> RuConstAssertion<RuAxiom> {
	env = ruMakeConstEnv(set2array(ruAssertion2Vars(ax)), math);
	RuConstAssertion(ax, ruTransformAxiom(ax, env.doconst), env);
}

ruConstDef(df : RuDef, math : RuMath) -> RuConstAssertion<RuDef> {
	env = ruMakeConstEnv(set2array(ruAssertion2Vars(df)), math);
	RuConstAssertion(df, ruTransformDef(df, env.doconst), env);
}

ruConstAssertion(as : RuAssertion, math : RuMath) -> RuConstAssertion<RuAssertion> {
	switch (as) {
		RuAxiom(__,__):         ruConstAxiom(as, math);
		RuDef(__,__,__,__):     ruConstDef(as, math);
		RuTheorem(__,__,__,__): ruConstTheorem(as, math);
	}
}

ruSubSatisfies(s : Tree<RuVar, RuExp>, cond : (RuExp) -> bool) -> bool {
	allTreeSatisfies(s, \__, e -> cond(e));
}

ruUpdateTheoremWithSteps(th : RuTheorem, steps : [RuStep], math : RuMath, env : RuEnv) -> Maybe<RuTheorem> {
	vs = values2tree(set2array(differenceSets(
		fold(steps, makeSet(), \acc, step -> mergeSets(acc, ruExp2Vars(step.expr))),
		ruAssertion2Vars(th)
	)), \v -> v.id);
	proof = RuProof(vs, makeSet(), steps, -1);
	updated = RuTheorem(th with proof = proof);
	res = ruVerifyTheorem(updated, math, env);
	if (ruIsVerified(res)) {
		Some(res.theorem) 
	} else {
		ruOutputVerifyErrs(ruFilterOutVerifyErrs(res, ruIsDisjointedViolation), math, env);
		None();
	}
}

ruFindLeastSourceContaining(assertions : Set<string>, math : RuMath, env : RuEnv) -> Maybe<string> {
	// A stub.
	None();
}
