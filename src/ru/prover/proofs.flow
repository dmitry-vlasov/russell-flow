import base/util/util;
import ru/prover/env;
import ru/unify/prod;
import ru/verify/math;

export {
	ruAddProof(prop : RuProverProp, hypProof : RuProverProofHyp, prover_env : RuProverEnv) -> void;
	ruBuildPropProofs(prop : RuProverProp, proofs : Vector<RuProverProofProp>, prover_env : RuProverEnv) -> void;
	ruBuildExpProofs(hyp : RuProverExp, proofs : Vector<RuProverProofHyp>, prover_env : RuProverEnv) -> void;
}

ruCheckTests(test1 : Tree<[RuProverProofHyp], RuProverProofProp>, test2 : Tree<[RuProverProofHyp], RuProverProofProp>) -> bool {
	ret = ref true;
	traverseInOrder(test1, \k1, p1 -> {
		switch (lookupTree(test2, k1)) {
			None(): ret := false;
			Some(p2): {
				switch (ruSubsAreSim(p1.sub, p2.sub)) {
					Some(__): { }
					None(): ret := false;
				}
			}
		}
	});
	^ret;
}

ruAddProof(prop : RuProverProp, hypProof : RuProverProofHyp, prover_env : RuProverEnv) -> void {
	if (sizeVector(prop.children) == ruArity(prop.assertion)) {
		prod = CartProd(map(vector2array(prop.children), \hyp ->
			if (hyp == hypProof.node) [hypProof] else vector2array(hyp.proofs)
		));
		size = sizeCartProd(prod);
		new_proofs = if (size == 0) {
			[];
		} else if (size == 1) {
			ruAddProofSingle(prod, prop, prover_env);
		} else if (size < 1024) {
			t = ruMakeTimer();
			//if (size > 1) {
			//	println("ruAddProofDirect: size=" + i2s(size));
			//}
			new_proofs = ruAddProofDirect(prod, prop, prover_env);
			if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
				stats = RuStatsRow("prod " + ruProd2s(prod), 
					pairs2tree([
						Pair("size", i2d(size)), 
						Pair("time", ruTimePassed(t)), 
						Pair("rets", i2d(length(new_proofs)))
					])
				);
				ruAddStats("add_proof", stats);
				ruAddStats("add_proof_prod", stats);
			}
			new_proofs;
		} else {
			t = ruMakeTimer();
			if (size > 10000) {
				//println("ruAddProofLarge: size=" + i2s(size));
			}
			new_proofs = ruAddProofLarge(prop, hypProof, prover_env);
			if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
				stats = RuStatsRow("tree " + ruProd2s(prod), 
					pairs2tree([
						Pair("size", i2d(size)), 
						Pair("time", ruTimePassed(t)), 
						Pair("rets", i2d(length(new_proofs)))
					])
				);
				ruAddStats("add_proof", stats);
				ruAddStats("add_proof_tree", stats);
			}
			new_proofs;
		}
		iter(new_proofs, \p -> 
			if (!ruTimeIsOver(prover_env.conf.timer)) {
				pushVector(prop.proofs, p)
			}
		);
	}
}

ruAddProofSingle(prod : CartProd<RuProverProofHyp>, prop : RuProverProp, prover_env : RuProverEnv) -> [RuProverProofProp] {
	hypProofs = map(prod.sets, \s -> s[0]);
	subs = map(hypProofs, \p -> p.sub);
	t = ruMakeTimer();
	rets = eitherMap(ruUnifySubs(subs, prover_env.math, prover_env.env),
		\s -> eitherMap(ruCompose(prop.sub, s), 
			\theta -> if (!ruCheckDisjs(theta, prop.assertion.stat.vars.disjs)) [] else [RuProverProofProp(prop, theta, hypProofs)],
			[]
		), []
	);
	if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
			stats = RuStatsRow("prop " + id2s(prop.assertion.info.id), 
				pairs2tree([
					Pair("size", i2d(sizeCartProd(prod))), 
					Pair("time", ruTimePassed(t)), 
					Pair("rets", i2d(length(rets))),
				])
			);
			ruAddStats("ruAddProof0", stats);
		}
	rets;
}

ruAddProofDirect(prod : CartProd<RuProverProofHyp>, prop : RuProverProp, prover_env : RuProverEnv) -> [RuProverProofProp] {
	if (sizeCartProd(prod) > 100000) {
		prover_env.env.out.onMessage("too much: ruSizeCart(prod)=" + i2s(sizeCartProd(prod)));
		[]
	} else {
		t = ruMakeTimer();
		rets = filtermapCartProd(prod, \hypProofs -> 
			maybeBind(ruUnifySubs(map(hypProofs, \hp -> hp.sub), prover_env.math, prover_env.env),
				\s ->
					maybeBind(ruCompose(prop.sub, s), \theta ->
						if (!ruCheckDisjs(theta, prop.assertion.stat.vars.disjs)) None() else {
							Some(RuProverProofProp(prop, theta, hypProofs))
						} 
					)
			)
		);
		if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
			stats = RuStatsRow("prop " + id2s(prop.assertion.info.id), 
				pairs2tree([
					Pair("size", i2d(sizeCartProd(prod))), 
					Pair("time", ruTimePassed(t)), 
					Pair("rets", i2d(length(rets)))
				])
			);
			ruAddStats("ruAddProofDirect", stats);
		}
		rets
	}
}

ruAddProofLarge(prop : RuProverProp, hypProof : RuProverProofHyp, prover_env : RuProverEnv) -> [RuProverProofProp] {
	subs = map(vector2array(prop.children), \hyp ->
		if (hyp == hypProof.node) [RuSubData(hypProof.sub, hypProof)] else 
		map(vector2array(hyp.proofs), \p -> RuSubData(p.sub, p))
	);
	filtermap(
		ruUnifySubsProd(
			subs, prover_env.fns.admitExp, 
			RuTaskTimer(prover_env.conf.timer, ref false), 
			prover_env.math, prover_env.env
		), 
		\unif -> maybeBind(ruCompose(prop.sub, unif.sub), \theta ->
			if (!ruCheckDisjs(theta, prop.assertion.stat.vars.disjs)) None() else {
				Some(RuProverProofProp(prop, theta, unif.data));
			}
		)
	);
}

ruBuildPropProofs(prop : RuProverProp, proofs : Vector<RuProverProofProp>, prover_env : RuProverEnv) -> void {
	parent = prop.parent;
	new_proofs = synchronizedUnaryFn(parent.proofs, \proofs_ : Vector<RuProverProofProp> -> {
		n = sizeVector(parent.proofs);
		iterVector(proofs_, \proof -> 
			pushVector(parent.proofs, 
				RuProverProofExp(
					parent,
					ruApplySubst(parent.expr, proof.sub),
					proof.sub,
					proof
				)
			)
		);
		vectorTailFrom(parent.proofs, n);
	})(proofs);
	switch (parent) {
		RuProverExp(__,__,ex,__,__): 
			ruBuildExpProofs(parent, new_proofs, prover_env);
		RuProverRoot(__,__,__):
			ruBuildRootProofs(parent, new_proofs, prover_env);
	}
}

ruBuildExpProofs(hyp : RuProverExp, proofs : Vector<RuProverProofHyp>, prover_env : RuProverEnv) -> void {
	parent = hyp.parent;
	new_proofs = synchronizedUnaryFn(parent.proofs, \proofs_ : Vector<RuProverProofHyp> -> {
		n = sizeVector(parent.proofs);
		//t = ruMakeTimer();
		iterVector(proofs, \proof -> ruAddProof(parent, proof, prover_env));
		/*if (lookupTreeDef(prover_env.env.conf.opts, "reprove-stats", "") == "1") {
			stats = RuStatsRow("hyp " + ru2s(ex, prover_env.math), 
				pairs2tree([
					Pair("size", i2d(length(proofs))), 
					Pair("time", ruTimePassed(t)), 
					Pair("rets", i2d(length(tailFrom(^(parent.proofs), n))))
				])
			);
			ruAddStats("ruBuildHypProofs", stats);
		}*/
		vectorTailFrom(parent.proofs, n);
	})(proofs);
	ruBuildPropProofs(parent, new_proofs, prover_env);
}

ruBuildRootProofs(root : RuProverRoot, proofs : Vector<RuProverProofHyp>, prover_env : RuProverEnv) -> void {
	iterVector(proofs, \proof_ : RuProverProofHyp -> 
		prover_env.fns.onProof(ruMakeProofTree(proof_))
	);
}
