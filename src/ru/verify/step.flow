import ru/subst;
import ru/verify/err;
import command;

export {
	RuMatchStepResult ::= RuMatchedStep, RuVerifyErr;
	RuMatchedStep(
		ass : RuAssertion,
		sub : Tree<RuVar, RuExp>,
		disjs : Set<RuDisj>
	);
	ruMatchStep(step : RuStep, th : RuTheorem, math : RuMath, conf : RuConf) -> RuMatchStepResult;
}

ruStepRefExp(ref : RuRef, th : RuTheorem) -> RuExp {
	switch (ref) {
		RuHypRef(i,__): th.stat.hyps[i].expr;
		RuStepRef(i,__): th.proof.steps[i].expr;
	}
}

ruMatchStepExps(step : RuStep, e1 : RuExp, e2 : RuExp, ind : int, acc : RuMatchStepResult, math : RuMath, conf : RuConf) -> RuMatchStepResult {
	switch (acc) {
		RuMatchedStep(ass, sub, __): {
			switch (ruMatchExp(e1, e2, math, conf)) {
				Some(s): {
					switch (ruMergeSubst(acc.sub, s)) {
						Some(new_sub): {
							RuMatchedStep(acc with sub = new_sub);
						}
						None(): {
							RuVerifyErrSubsMismatch(step, acc.sub, s, ind)
						}
					}
				}
				None(): {
					RuVerifyErrExprMismatch(step, e1, e2, ind);
			}
		}
		}
		RuVerifyErr(): acc;
	}
}

ruMatchStep(step : RuStep, th : RuTheorem, math : RuMath, conf : RuConf) -> RuMatchStepResult {
	switch (lookupTree(math.assertions, id2s(step.assertion))) {
		Some(ass): {
			if (length(step.refs) != ruArity(ass)) {
				RuVerifyErrArityMismatch(step, length(step.refs), ruArity(ass));
			} else {
				acc = foldi(ass.stat.hyps, 
					ruMatchStepExps(step, step.expr, ass.stat.prop, -1, RuMatchedStep(ass, makeTree(), makeSet()), math, conf),
					\i, ac, hyp -> ruMatchStepExps(step, ruStepRefExp(step.refs[i], th), hyp.expr, i, ac, math, conf)
				);
				switch (acc) {
					RuMatchedStep(__, sub, __): {
						switch (ruComputeDisjs(sub, ass.stat.disjs, RuDisjsInherent(makeSet()))) {
							RuDisjsInherent(disjs): {
								RuMatchedStep(acc with disjs = disjs);
							}
							RuDisjViolation(disj, vars): {
								RuVerifyErrDisjointedViolation(step, disj, vars);
							}
						}
					}
					RuVerifyErr(): acc;
				}
			}
		}
		None(): {
			RuVerifyErrUnknownAssertion(step);
		}
	}
}
