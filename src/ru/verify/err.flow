import ru/subst;
import command;

export {
	RuVerifyErr ::= 
		RuVerifyErrUnknownAssertion, RuVerifyErrExprMismatch,  RuVerifyErrSubsMismatch,   RuVerifyErrPropMismatch, 
		RuVerifyErrArityMismatch,   RuVerifyErrNonVerifiedRef, RuVerifyErrDisjointedViolation;

	RuVerifyErrUnknownAssertion(
		step : RuStep
	);
	RuVerifyErrExprMismatch(
		step : RuStep, 
		exp1 : RuExp, 
		exp2 : RuExp,
		ind  : int // index of a hyp/prop: -1 means it is prop.
	);
	RuVerifyErrSubsMismatch(
		step : RuStep, 
		sub1 : Tree<RuVar, RuExp>, 
		sub2 : Tree<RuVar, RuExp>,
		ind  : int
	);
	RuVerifyErrPropMismatch(
		step : RuStep, 
		prop : RuExp
	);
	RuVerifyErrArityMismatch(
		step : RuStep, 
		refLen : int, 
		hypLen : int
	);
	RuVerifyErrNonVerifiedRef(
		step : RuStep
	);
	RuVerifyErrDisjointedViolation(
		step : RuStep, 
		disj : RuDisj, 
		commonVars : Set<RuVar>
	);

	ruVerifyErr2s(err : RuVerifyErr, math : RuMath, conf : RuConf) -> string;
}

ruVerifyErr2s(err : RuVerifyErr, math : RuMath, conf : RuConf) -> string {
	step_ass_mgs = \step ->
		"step: " + i2s(step.ind + 1) + 
		eitherMap(lookupTree(math.assertions, step.assertion), 
			\ass -> ", assertion:\n" + strIndent(ruAssertion2s(ass, math.rules)),
			""
		);
	switch (err) {
		RuVerifyErrUnknownAssertion(step): {
			"unknown assertion '" + step.assertion + "'\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrExprMismatch(step, exp1, exp2, ind): {
			(if (ind == -1) "proposition" else "hypothesis " + i2s(ind + 1)) + " " +
			"expression:\n" + 
				"\t" + ru2s(exp1, math.rules) + "\n" + 
			"cannot be matched with:\n" +
				"\t" + ru2s(exp2, math.rules) + "\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrSubsMismatch(step, sub1, sub2, ind): {
			"hypothesis " + i2s(ind + 1) + " matching substution:\n" + 
				strIndent(ruSubst2s(sub1, math)) + "\n" + 
			"cannot be joined with:\n" + 
				strIndent(ruSubst2s(sub2, math)) + "\n" + 
			step_ass_mgs(step);
		}
		RuVerifyErrPropMismatch(step, prop): {
			"theorem statement:\n" + 
				"\t" + ru2s(prop, math.rules) + "\n"
			"does not coincide with the proved statement:\n" +
				"\t" + ru2s(step.expr, math.rules) + "\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrArityMismatch(step, refLen, hypLen): {
			"number of refs: " + i2s(refLen) + " mismatch assertion arity: " + i2s(hypLen) + "\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrNonVerifiedRef(step): {
			"proof depends on a non-verified assertion '" + step.assertion + "'\n" + 
			step_ass_mgs(step);
		}
		RuVerifyErrDisjointedViolation(step, disj, commonVars): {
			"disjointed variables violation, variables: '" + disj.v1.name + "' and '" + disj.v2.name + "' " +
			"are mappped onto expressions, with common vars: '" + strGlue(map(set2array(commonVars), \v -> v.name), ", ") + "'\n" +
			step_ass_mgs(step);
		}
	}
}
