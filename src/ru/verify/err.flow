import ru/subst;
import command;

export {
	RuVerifyErr ::= 
		RuVerifyErrUnknownAssertion, RuVerifyErrExprMismatch,   RuVerifyErrSubsMismatch,        RuVerifyErrPropMismatch, 
		RuVerifyErrArityMismatch,    RuVerifyErrNonVerifiedRef, RuVerifyErrDisjointedViolation, RuVerifyErrGeneral;

	RuVerifyErrUnknownAssertion(
		step : RuStep
	);
	RuVerifyErrExprMismatch(
		step : RuStep, 
		exp1 : RuExp, 
		exp2 : RuExp,
		ind  : int // index of a hyp/prop: -1 means it is prop.
	);
	RuVerifyErrSubsMismatch(
		step : RuStep, 
		sub1 : Tree<RuVar, RuExp>, 
		sub2 : Tree<RuVar, RuExp>,
		ind  : int
	);
	RuVerifyErrPropMismatch(
		step : RuStep, 
		prop : RuExp
	);
	RuVerifyErrArityMismatch(
		step : RuStep, 
		refLen : int, 
		hypLen : int
	);
	RuVerifyErrNonVerifiedRef(
		step : RuStep
	);
	RuVerifyErrDisjointedViolation(
		step : RuStep, 
		disj : RuDisj, 
		commonVars : Set<RuVar>
	);
	RuVerifyErrGeneral(
		message : string
	);

	ruVerifyErr2s(err : RuVerifyErr, math : RuMath, conf : RuConf) -> string;
	ruVerifyErr2place(err : RuVerifyErr, theorem : RuTheorem) -> RuPlace;
	ruIsDisjointedViolation(err : RuVerifyErr) -> bool;
	ruIsNonVerifiedRef(err : RuVerifyErr) -> bool;
}

ruVerifyErr2s(err : RuVerifyErr, math : RuMath, conf : RuConf) -> string {
	step_ass_mgs = \step ->
		"step: " + i2s(step.ind + 1) + 
		eitherMap(lookupTree(math.assertions, step.assertion), 
			\ass -> ", assertion:\n" + strIndent(ruDeclShort2s(ass, math)),
			""
		);
	switch (err) {
		RuVerifyErrUnknownAssertion(step): {
			"unknown assertion '" + id2s(step.assertion) + "'\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrExprMismatch(step, exp1, exp2, ind): {
			(if (ind == -1) "proposition" else "hypothesis " + i2s(ind + 1)) + " " +
			"expression:\n" + 
				"\t" + ru2s(exp1, math) + "\n" + 
			"cannot be matched with:\n" +
				"\t" + ru2s(exp2, math) + "\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrSubsMismatch(step, sub1, sub2, ind): {
			"hypothesis " + i2s(ind + 1) + " matching substution:\n" + 
				strIndent(ruSubst2s(sub1, math)) + "\n" + 
			"cannot be joined with:\n" + 
				strIndent(ruSubst2s(sub2, math)) + "\n" + 
			step_ass_mgs(step);
		}
		RuVerifyErrPropMismatch(step, prop): {
			"theorem statement:\n" + 
				"\t" + ru2s(prop, math) + "\n"
			"does not coincide with the proved statement:\n" +
				"\t" + ru2s(step.expr, math) + "\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrArityMismatch(step, refLen, hypLen): {
			"number of refs: " + i2s(refLen) + " mismatch assertion arity: " + i2s(hypLen) + "\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrNonVerifiedRef(step): {
			"proof depends on a non-verified assertion '" + id2s(step.assertion) + "'\n" + 
			step_ass_mgs(step);
		}
		RuVerifyErrDisjointedViolation(step, disj, commonVars): {
			"disjointed variables violation, variables: '" + id2s(disj.v1.id) + "' and '" + id2s(disj.v2.id) + "' " +
			"are mappped onto expressions, with common vars: '" + strGlue(map(set2array(commonVars), \v -> id2s(v.id)), ", ") + "'\n" +
			step_ass_mgs(step);
		}
		RuVerifyErrGeneral(msg): {
			msg;
		}
	}
}

ruVerifyErr2place(err : RuVerifyErr, theorem : RuTheorem) -> RuPlace {
	make_place = \pos -> RuPlace(id2s(theorem.descr.src), pos);
	switch (err) {
		RuVerifyErrUnknownAssertion(step):           make_place(step.pos);
		RuVerifyErrExprMismatch(step,__,__,__):      make_place(step.pos);
		RuVerifyErrSubsMismatch(step,__,__,__):      make_place(step.pos);
		RuVerifyErrPropMismatch(step,__):            make_place(step.pos);
		RuVerifyErrArityMismatch(step,__,__):        make_place(step.pos);
		RuVerifyErrNonVerifiedRef(step):             make_place(step.pos);
		RuVerifyErrDisjointedViolation(step,__, __): make_place(step.pos);
		RuVerifyErrGeneral(__):                      make_place(theorem.descr.pos);
	}
}

ruIsDisjointedViolation(err : RuVerifyErr) -> bool {
	switch (err) {
		RuVerifyErrDisjointedViolation(__,__,__): true;
		default: false;
	}
}

ruIsNonVerifiedRef(err : RuVerifyErr) -> bool {
	switch (err) {
		RuVerifyErrNonVerifiedRef(__): true;
		default: false;
	}
}
