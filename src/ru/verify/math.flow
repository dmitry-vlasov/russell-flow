import base/util/concurrent;
import ru/subst;
import ru/verify/source;

export {
	RuVerifyMathResult(
		math : RuMath,
		disproved : [RuVerifyTheoremResult]
	);
	ruVerifyMath(math : RuMath, env : RuEnv) -> RuVerifyMathResult;
}

ruVerifyMath(math : RuMath, env : RuEnv) -> RuVerifyMathResult {
	err_count = ref 0;
	timer = ruMakeTimer();
	imports_map = ruSourcesAllImported(math.sources, env);
	//verified_srcs = ruConcurrent(map(getTreeValues(math.sources), \s -> \-> ruVerifySource(s, imports_map, math, env)));
	res = ruDoVerifyMath(math.sources, imports_map, RuVerifyMathResult(ruEmptyMath, []), env);
	if (ruVerbose(env.conf) > 0) {
		env.out.onMessage(
			"ru verified: " +i2s(sizeTree(math.sources)) + " files in " + ruTimePassed2s(timer) +
			//(if (ruVerbose(env.conf) > 2) "\n\tapproved theorems:\n" + strGlue(map(set2array(acc.approved), \th -> "\t" + id2s(th)), "\n") else "")
		);
	}
	if (length(res.disproved) > 0) {
		env.out.onMessage(
			(if (ruVerbose(env.conf) > 0) "" else "ru disproved: " +i2s(length(res.disproved)) + " theorems in " + ruTimePassed2s(timer) + "\n") +
			"\tdisproved theorems:\n" + strGlue(map(res.disproved, \th -> "\t\t" + id2s(th.theorem.info.id)), "\n")
		);
	}
	res;
}

ruDoVerifyMath(left : Tree<int, RuSource>, imports_map : Tree<int, Set<int>>, acc : RuVerifyMathResult, env : RuEnv) -> RuVerifyMathResult {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.id))
		);
		if (ready == []) {
			env.out.onError("cannot verify: " +i2s(sizeTree(left)) + " files - cyclic import", []);
			acc;
		} else {
			verified = map(ready, \s -> ruVerifySource(s, imports_map, acc.math, env));
			new_acc = fold(verified, acc, \ac, res -> 
				RuVerifyMathResult(
					ruMathAddSource(ac.math, res.source, env),
					concat(ac.disproved, res.disproved)
				)
			);
			new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.id));
			ruDoVerifyMath(new_left, imports_map, new_acc, env);
		}
	}
}
