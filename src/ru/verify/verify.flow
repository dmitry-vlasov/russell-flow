import ru/subst;
import ru/verify/source;
import command;

export {
	ruVerifyMath(math : RuMath, conf : RuConf) -> RuVerifyAcc;
	ruCommVerify : RuComm;
}

ruCommVerify = RuComm(
	"verify", "misc", "verify Russell target", "target",
	[RuCommArg("target", false, "the target: a theorem name, file name or 'all' for verification of all math", "all")],
	ruRunVerify
);

ruVerifyMath(math : RuMath, conf : RuConf) -> RuVerifyAcc {
	err_count = ref 0;
	start = ruTime();
	acc = ruDoVerifyMath(math.sources, ruMakeVerifyAcc(), conf);
	if (ruVerbose(conf) > 0) {
		conf.onMessage(
			"ru verified: " +i2s(sizeTree(math.sources)) + " files in " + ruTime2s(ruTime() - start) +
			(if (ruVerbose(conf) > 2) "\n\tapproved theorems:\n" + strGlue(map(set2array(acc.approved), \th -> "\t" + id2s(th)), "\n") else "")
		);
	}
	if (sizeSet(acc.disproved) > 0) {
		conf.onMessage(
			(if (ruVerbose(conf) > 0) "" else "ru disproved: " +i2s(sizeSet(acc.disproved)) + " theorems in " + ruTime2s(ruTime() - start) + "\n") +
			"\tdisproved theorems:\n" + strGlue(map(set2array(acc.disproved), \th -> "\t\t" + id2s(th)), "\n")
		);
	}
	acc;
}

ruDoVerifyMath(left : Tree<int, RuSource>, acc : RuVerifyAcc, conf : RuConf) -> RuVerifyAcc {
	if (sizeTree(left) == 0) acc else {
		ready = filter(
			getTreeValues(left), 
			\src -> forall(src.imports, \imp -> !containsKeyTree(left, imp.id))
		);
		if (ready == []) {
			conf.onError("cannot verify: " +i2s(sizeTree(left)) + " files - cyclic import", []);
			acc;
		} else {
			verified = ruConcurrent(map(ready, \s -> \-> ruVerifySource(s, acc, conf)));
			new_acc = fold(verified, acc, \ac, v -> ruMergeVerifyAcc(ac, v, conf));
			new_left = fold(ready, left, \ac, src -> removeFromTree(ac, src.info.id));
			ruDoVerifyMath(new_left, new_acc, conf);
		}
	}
}

ruRunVerify(task : ScTask, env : RuState) -> Maybe<RuState> {
	target0 = lookupTreeDef(task.args, "target", "");
	target = if (!endsWith(target0, ".ru")) target0 else ruTrimPath(target0, env.conf, ".ru");
	math = env.ruMath;
	conf = env.conf;
	m = if (target == "" || target == "all" || target == "1") {
		//ruDebugLog("target: " + target, math.conf);
		verified = ruVerifyMath(math, conf);
		if (sizeSet(verified.disproved) == 0) {
			Some(verified.math);
		} else {
			None();
		}
	} else {
		id = s2id(target);
		switch (lookupTree(math.assertions, id)) {
			Some(th): {
				switch (th) {
					RuTheorem(__, __,__,__): {
						start = ruTime();
						res = ruVerifyTheorem(th, math, conf);
						ret = if (ruIsVerified(res)) Some(ruReplaceAssertion(res.theorem, math, conf)) else None();
						if (ruVerbose(conf) > 0) {
							conf.onMessage("ru " + (if (ruIsVerified(res)) "verified" else "disproved") + " " + target + "' in " + ruTime2s(ruTime() - start));
						}
						ret;
					}
					default: {
						conf.onError("assertion '" + target + "' is not a theorem", []);
						None();
					}
				}
			}
			None(): {
				switch (lookupTree(math.sources, id)) {
					Some(src): {
						start = ruTime();
						deps = fold(src.imports, makeSet(), \acc, imp -> ruSourceDeclNames(imp.id, acc, math, conf));
						acc = ruVerifySource(src, RuVerifyAcc(math, deps, makeSet()), conf);
						if (ruVerbose(conf) > 0) {
							conf.onMessage(
								"ru verified: '" + target + "' in " + ruTime2s(ruTime() - start) +
								(if (ruVerbose(conf) > 2) "\n\tapproved theorems:\n" + strGlue(map(set2array(acc.approved), \th -> "\t\t" + id2s(th)), "\n") else "")
							);
						}
						if (sizeSet(acc.disproved) > 0) {
							conf.onMessage(
								(if (ruVerbose(conf) > 0) "" else "ru disproved: '" + target + "' in " + ruTime2s(ruTime() - start) + "\n") +
								"\tdisproved theorems:\n" + strGlue(map(set2array(acc.disproved), \th -> "\t\t" + id2s(th)), "\n")
							);
							None();
						} else {
							Some(acc.math);
						}
					}
					None(): {
						conf.onError("verification target '" + target + "' is not found", []);
						None();
					}
				}
			}
		}
	}
	maybeMap(m, \new_math -> RuState(env with ruMath = new_math));
}
