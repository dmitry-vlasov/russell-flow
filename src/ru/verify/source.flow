import base/util/concurrent;
import ru/subst;
import ru/verify/theorem;

export {
	RuVerifySourceResult(
		source : RuSource,
		disproved : [RuVerifyTheoremResult]
	);
	ruVerifySource(src : RuSource, imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> RuVerifySourceResult;
	ruVerifyTheoremsAll(thms : [RuTheorem], imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> [RuVerifyTheoremResult];
	ruVerifyTheorems(thms : [RuTheorem], math : RuMath, env : RuEnv) -> [RuVerifyTheoremResult];
}

ruVerifySource(src : RuSource, imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> RuVerifySourceResult {
	timer = ruMakeTimer();
	disproved = ruVerifyTheoremsAll(ruSourceTheorems(src), imported_map, math, env);
	iter(disproved, \res -> 
		if (exists(res.errs, \err -> !ruIsNonVerifiedRef(err))) {
			ruOutputVerifyErrs(res, math, env);
			env.out.onMessage("Theorem '" + id2s(res.theorem.info.id) + "' is disproved");
			env.out.onMessage(ru2s(res.theorem, math));
		} else if (forall(res.errs, ruIsNonVerifiedRef)) {
			env.out.onMessage("Theorem '" + id2s(res.theorem.info.id) + "' is violates preceedence");
		}
	);
	if (ruVerbose(env.conf) > 1) {
		env.out.onMessage("\tru verified: '" + src.info.module + "' in " + ruTimePassed2s(timer));
	}
	RuVerifySourceResult(src, disproved);
}

ruVerifyTheoremsAll(thms : [RuTheorem], imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> [RuVerifyTheoremResult] {
	resa = ruConcurrent(map(thms, 
		\th -> \-> ruVerifyTheoremAll(th, imported_map, math, env)
	));
	filter(resa, \res -> length(res.errs) > 0);
}

ruVerifyTheorems(thms : [RuTheorem], math : RuMath, env : RuEnv) -> [RuVerifyTheoremResult] {
	resa = ruConcurrent(map(thms, 
		\th -> \-> ruVerifyTheorem(th, math, env)
	));
	filter(resa, \res -> length(res.errs) > 0);
}
