import base/util/concurrent;
import ru/subst;
import ru/verify/theorem;

export {
	RuVerifySourceResult(
		source : RuSource,
		disproved : [RuVerifyTheoremResult]
	);
	ruVerifySource(src : RuSource, imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> RuVerifySourceResult;
}

ruVerifySource(src : RuSource, imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> RuVerifySourceResult {
	timer = ruMakeTimer();
	disproved = ref [];
	add_disproved = ruAtomicRefArrayPush(disproved);
	verified_decls = filtermap(ruConcurrent(map(src.decls, 
		\decl -> \-> {
			switch (decl) {
				RuTheorem(info,__,__,__): {
					res = ruVerifyTheorem(decl, math, env);
					errs = concat(res.errs, ruVerifyPrecedenceInTheorem(decl, imported_map, math, env));
					if (length(errs) == 0) {
						if (ruVerbose(env.conf) > 2) {
							env.out.onMessage("Theorem '" + id2s(info.id) + "' is approved");
						}
						Some(res.theorem);
					} else {
						if (ruVerbose(env.conf) > 0 && length(res.errs) > 0) {
							add_disproved(res);
							env.out.onMessage("Theorem '" + id2s(info.id) + "' is disproved");
							env.out.onMessage(ru2s(decl, math));
						}
						Some(decl);
					}
				}
				default: {
					Some(decl);
				}
			}
		}
	)), idfn);
	if (ruVerbose(env.conf) > 1) {
		env.out.onMessage("\tru verified: '" + src.info.module + "' in " + ruTimePassed2s(timer));
	}
	RuVerifySourceResult(
		RuSource(src with decls = verified_decls),
		^disproved
	);
	/*RuVerifyAcc(src_acc.local with
		math = RuMath(src_acc.local.math with 
			sources = setTree(src_acc.local.math.sources, src.info.id, 
				RuSource(src with decls = src_acc.decls)
			)
		)
	);*/
}
