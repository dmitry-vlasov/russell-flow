import ru/subst;
import ru/verify/proof;
import ru/util/normalize;

export {
	RuVerifyTheoremResult(
		theorem : RuTheorem, 
		errs : [RuVerifyErr]
	);

	ruIsVerified(res : RuVerifyTheoremResult) -> bool;
	ruVerifyTheorem(th : RuTheorem, math : RuMath, env : RuEnv) -> RuVerifyTheoremResult;
	ruVerifyPrecedenceInTheorem(th : RuTheorem, imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> [RuVerifyErr];

	ruOutputVerifyErrs(res : RuVerifyTheoremResult, math : RuMath, env : RuEnv) -> void;
	ruVerifyErrs2s(res : RuVerifyTheoremResult, math : RuMath) -> string;
	ruFilterOutVerifyErrs(res : RuVerifyTheoremResult, pred : (RuVerifyErr) -> bool) -> RuVerifyTheoremResult;
}

ruIsVerified(res : RuVerifyTheoremResult) -> bool { 
	length(res.errs) == 0 
}

ruOutputVerifyErrs(res : RuVerifyTheoremResult, math : RuMath, env : RuEnv) -> void {
	iter(res.errs, \err ->	
		env.out.onError(
			"in theorem: '" + id2s(res.theorem.info.id) + "': " + ruVerifyErr2s(err, math),
			[ruVerifyErr2place(err, res.theorem, math)]
		)
	);
}

ruVerifyErrs2s(res : RuVerifyTheoremResult, math : RuMath) -> string {
	strGlue(map(res.errs, \err -> 
		ruVerifyErr2s(err, math) + "\n" + strIndent(ruPlace2s(ruVerifyErr2place(err, res.theorem, math)))
	), "\n");
}

ruFilterOutVerifyErrs(res : RuVerifyTheoremResult, pred : (RuVerifyErr) -> bool) -> RuVerifyTheoremResult {
	RuVerifyTheoremResult(res with errs = filter(res.errs, \err -> !pred(err)));
}

ruVerifyTheorem(th : RuTheorem, math : RuMath, env : RuEnv) -> RuVerifyTheoremResult {
	res = ruVerifyProof(th.proof, th.stat.hyps, th.stat.prop, math, env);
	RuVerifyTheoremResult(
		ruNormalizeTheoremVarsDisjs(RuTheorem(th with proof = res.proof)), 
		res.errs
	);
	/*acc = ruVerifyProof(th.proof, th.stat.hyps, th.stat.prop, math, env);
	th_vars = ruAssertion2Vars(th);
	th_ds = filterSet(acc.disjs, \d -> containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2));
	pr_ds = filterSet(acc.disjs, \d -> !(containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2)));
	RuVerifyTheoremResult(
		RuTheorem(th with 
			stat = RuStatement(th.stat with 
				vars = RuVarsDisjs(th.stat.vars with
					disjs = th_ds
				)
			),
			proof = RuProof(th.proof with 
				vars = RuVarsDisjs(th.proof.vars with
					disjs = pr_ds
				)
			)
		),
		acc.errs
	);*/
}

/*ruVerifyTheorem(th : RuTheorem, math : RuMath, env : RuEnv) -> RuVerifyTheoremResult {
	ruFilterOutVerifyErrs(ruDoVerifyTheorem(th, RuVerifyAcc(math, makeSet(), makeSet()), env), ruIsNonVerifiedRef)
}*/

ruVerifyPrecedenceInTheorem(th : RuTheorem, imported_map : Tree<int, Set<int>>, math : RuMath, env : RuEnv) -> [RuVerifyErr] {
	ruVerifyPrecedenceInProof(th, th.proof, imported_map, math, env);
}