import ru/subst;
import ru/verify/step;
import ru/verify/acc;

export {
	RuVerifyTheoremResult(
		theorem : RuTheorem, 
		errs : [RuVerifyErr]
	);

	ruIsVerified(res : RuVerifyTheoremResult) -> bool;
	ruVerifyTheorem(th : RuTheorem, math : RuMath, env : RuEnv) -> RuVerifyTheoremResult;
	ruDoVerifyTheorem(th : RuTheorem, verified : RuVerifyAcc, env : RuEnv) -> RuVerifyTheoremResult;
	ruOutputVerifyErrs(res : RuVerifyTheoremResult, math : RuMath, env : RuEnv) -> void;
	ruVerifyErrs2s(res : RuVerifyTheoremResult, math : RuMath) -> string;
	ruFilterOutVerifyErrs(res : RuVerifyTheoremResult, pred : (RuVerifyErr) -> bool) -> RuVerifyTheoremResult;
}

ruIsVerified(res : RuVerifyTheoremResult) -> bool { 
	length(res.errs) == 0 
}

ruOutputVerifyErrs(res : RuVerifyTheoremResult, math : RuMath, env : RuEnv) -> void {
	iter(res.errs, \err ->	
		env.out.onError(
			"in theorem: '" + id2s(res.theorem.descr.id) + "': " + ruVerifyErr2s(err, math),
			[ruVerifyErr2place(err, res.theorem, math)]
		)
	);
}

ruVerifyErrs2s(res : RuVerifyTheoremResult, math : RuMath) -> string {
	strGlue(map(res.errs, \err -> 
		ruVerifyErr2s(err, math) + "\n" + strIndent(ruPlace2s(ruVerifyErr2place(err, res.theorem, math)))
	), "\n");
}

ruFilterOutVerifyErrs(res : RuVerifyTheoremResult, pred : (RuVerifyErr) -> bool) -> RuVerifyTheoremResult {
	RuVerifyTheoremResult(res with errs = filter(res.errs, \err -> !pred(err)));
}

RuVerifyTheoremAcc(
	disjs : Set<RuDisj>,
	errs : [RuVerifyErr]
);

ruVerifyProof(th : RuTheorem, proof : RuProof, qed : RuExp, proof_acc : RuVerifyTheoremAcc, verified : RuVerifyAcc, env : RuEnv) -> RuVerifyTheoremAcc {
	math = verified.math;
	last_step = lastElement(proof.steps, ruNoStep);
	fold(
		proof.steps, 
		RuVerifyTheoremAcc(
			proof_acc.disjs, 
			concat(proof_acc.errs, if (qed.nodes == last_step.expr.nodes) [] else [RuVerifyErrPropMismatch(last_step, qed)])
		), 
		\acc, step -> {
			acc1 = if (containsSet(verified.approved, step.assertion)) acc else {
				RuVerifyTheoremAcc(acc with errs = concat(acc.errs, [RuVerifyErrNonVerifiedRef(step)]));
			}
			if (step.assertion == ruStepLemma) {
				ruVerifyProof(th, step.proof, step.expr, acc1, verified, env);
			} else if (step.assertion == ruStepProblem) {
				RuVerifyTheoremAcc(acc with errs = concat(acc.errs, [RuVerifyErrProblemFound(step)]));
			} else {
				ms = ruMatchStep(step, proof, th, math, env);
				switch (ms) {
					RuMatchedStep(__,__, disjs): 
						RuVerifyTheoremAcc(acc1 with disjs = mergeSets(acc1.disjs, disjs));
					RuVerifyErr(): 
						RuVerifyTheoremAcc(acc1 with errs = concat(acc1.errs, [ms]));
				}
			}
		}
	);
}

ruDoVerifyTheorem(th : RuTheorem, verified : RuVerifyAcc, env : RuEnv) -> RuVerifyTheoremResult {
	acc = ruVerifyProof(th, th.proof, th.stat.prop, RuVerifyTheoremAcc(makeSet(), []), verified, env);
	th_vars = ruAssertion2Vars(th);
	th_ds = filterSet(acc.disjs, \d -> containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2));
	pr_ds = filterSet(acc.disjs, \d -> !(containsSet(th_vars, d.v1) && containsSet(th_vars, d.v2)));
	RuVerifyTheoremResult(
		RuTheorem(th with 
			stat = RuStatement(th.stat with disjs = th_ds),
			proof = RuProof(th.proof with disjs = pr_ds)
		),
		acc.errs
	);
}

ruVerifyTheorem(th : RuTheorem, math : RuMath, env : RuEnv) -> RuVerifyTheoremResult {
	ruFilterOutVerifyErrs(ruDoVerifyTheorem(th, RuVerifyAcc(math, makeSet(), makeSet()), env), ruIsNonVerifiedRef)
}
