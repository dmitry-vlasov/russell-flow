import ru/src;

export {		
	ru2s(a : RuAny, rules : Tree<int, RuRule>) -> string;
	ru2sWrapExp(a : RuAny, rules : Tree<int, RuRule>, wrap_exp : (string) -> string) -> string;
	ruExp2s(e : RuExp, rules : Tree<int, RuRule>) -> string;
	ruExp2Term(e : RuExp, rules : Tree<int, RuRule>) -> RuTerm;
	ruSteps2s(steps : [RuStep], rules : Tree<int, RuRule>) -> string;
	ruIsVar(e : RuExp) -> bool;
	ruIsConst(e : RuExp) -> bool;
	ruExp2Var(e : RuExp) -> Maybe<RuVar>;
	ruExp2Const(e : RuExp) -> Maybe<Pair<int, int>>;
	ruDeclDescr(d : RuDecl) -> RuDescr;
	ruDeclSrcId(d : RuDecl) -> int;
	ruDeclPos(d : RuDecl) -> int;
	ruDeclName(d : RuDecl) -> string;
	ruDeclPos(d : RuDecl) -> int;
	ruDeclKind(d : RuDecl) -> string;
	ruDeclIsAssertion(d : RuDecl) -> bool;
	ruDeclIsTheorem(d : RuDecl) -> bool;
	ruDeclIsAxiom(d : RuDecl) -> bool;
	ruDeclIsDef(d : RuDecl) -> bool;
	ruSetDeclPos(d : RuDecl, pos : int) -> RuDecl;
	ruDecl2s(d : RuDecl, rules : Tree<int, RuRule>) -> string;
	ruDecl2Assertion(d : RuDecl) -> Maybe<RuAssertion>;
	ruAssertion2Theorem(a : RuAssertion) -> Maybe<RuTheorem>;
	ruAssertion2Axiom(a : RuAssertion) -> Maybe<RuAxiom>;
	ruAssertion2Def(a : RuAssertion) -> Maybe<RuDef>;
	ruAssertion2s(ass : RuAssertion, rules : Tree<int, RuRule>) -> string;
	ruProofQedStep(proof : RuProof) -> RuStep;

	ruExpType(exp : RuExp) -> int;
	ruTerm2s(term : RuTerm) -> string;
	ruExpRPN2s(exp : RuExp) -> string;
	ruExp2Vars(exp : RuExp) -> Set<RuVar>;
	ruExpContainsVar(exp : RuExp, v : RuVar) -> bool;
	ruAssertion2Vars(ass : RuAssertion) -> Set<RuVar>;
	ruProof2Vars(proof : RuProof) -> Set<RuVar>;
	ruDisjs2Array(disjs : Set<RuDisj>) -> [Set<RuVar>];
	ruDisjs2s(disjs : Set<RuDisj>) -> string;
	
	ruMakeDefProp(prop : [RuExpNode], dfm : [RuExpNode], dfs: [RuExpNode]) -> RuExp;
	ruIndexOfDecl(int : int, src : RuSource) -> int;

	// In case a declaration has comments before it, we take the start position of a first
	// comment right before the declaration. Otherwise the position of decl itself.
	ruStartPosition(decl : RuDecl) -> int;

	RuComputedDisjs ::= RuDisjsInherent, RuDisjViolation;
		RuDisjsInherent(disjs : Set<RuDisj>);
		RuDisjViolation(disj : RuDisj, commonVars : Set<RuVar>);
	ruComputeDisjs(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>, acc : RuComputedDisjs) -> RuComputedDisjs;
	ruCheckDisjs(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>) -> bool;
	ruCheckDisjsInherent(s : Tree<RuVar, RuExp>, ass_disjs : Set<RuDisj>, thm_disjs : Set<RuDisj>) -> bool;
	ruArity(a : RuAssertion) -> int;

	RuDAG(data : ?, children : [RuDAG<?>]);
	ruProofToDAG(proof : RuProof) -> RuDAG<int>;
	ruDAG2s(dag : RuDAG<?>, show_data : (?) -> string) -> string;
	ruProofDAG2s(dag : RuDAG<int>) -> string;

	ruUpdateTheoremVars(theorem : RuTheorem) -> RuTheorem;
	ruUpdateProofVars(proof : RuProof, th_new : RuTheorem, th_old : RuTheorem) -> RuProof;

	ruTransformStatement(st: RuStatement, f : (RuExp) -> RuExp) -> RuStatement;
	ruTransformTheorem(th: RuTheorem, f : (RuExp) -> RuExp) -> RuTheorem;
	ruTransformProof(th: RuProof, f : (RuExp) -> RuExp) -> RuProof;
	ruTransformAxiom(ax: RuAxiom, f : (RuExp) -> RuExp) -> RuAxiom;
	ruTransformDef(def: RuDef, f : (RuExp) -> RuExp) -> RuDef;

	ruSrc2Blocks(src : RuSource) -> [RuBlock];
	ruBclocks2Src(src : RuSource, blocks : [RuBlock]) -> RuSource;
	ruBlockName(block : RuBlock) -> string;

	ruSetDeclDescr(decl : RuDecl, descr : RuDescr) -> RuDecl;
	ruModifyAnnotation(decl : RuDecl, modify : (JsonObject) -> JsonObject) -> RuDecl;

	ruSuperTypeName(super : int, infer : int) -> int;
	ruMakeSuperRule(super : int, infer : int, src : int, pos : int) -> RuRule;
	ruFixLeftRecursiveRule(r : RuRule) -> RuRule;
}

ruArity(a : RuAssertion) -> int {
	length(a.stat.hyps);
}

ruIsVar(e : RuExp) -> bool {
	length(e.nodes) == 1 && 
	switch (e.nodes[0]) { 
		RuVar(__,__): true; 
		default: false 
	}
}

ruExp2Var(e : RuExp) -> Maybe<RuVar> {
	if (length(e.nodes) != 1) None() else {
		n = e.nodes[0];
		switch (n) { 
			RuVar(__,__): Some(n); 
			default: None(); 
		}
	}
}

ruIsConst(e : RuExp) -> bool {
	length(e.nodes) == 1 && 
	switch (e.nodes[0]) { 
		RuVar(__,__): false; 
		RuRuleNode(id,__, arity, len): 
			arity == 0 && len == 1;
	}
}

ruExp2Const(e : RuExp) -> Maybe<Pair<int, int>> {
	if (length(e.nodes) != 1) None() else {
		switch (e.nodes[0]) { 
			RuVar(__,__): None(); 
			RuRuleNode(id, type_id, arity, len): 
				if (arity == 0 && len == 1) Some(Pair(id, type_id)) else None();
		}
	}
}

ruTerm2s(term : RuTerm) -> string {
	strGlue(map(term.nodes, \n -> id2s(n.id)), " ")
}

ruExpRPN2s(exp : RuExp) -> string {
	strGlue(map(exp.nodes, \n -> {
		switch (n) {
			RuRuleNode(id, __,__, l): id2s(id) + "-" + i2s(l);
			RuVar(id, __): id2s(id);
		}
	}), " ")
}

ruExp2Vars(exp : RuExp) -> Set<RuVar> {
	fold(exp.nodes, makeSet(), \acc, n ->
		switch (n) {
			RuRuleNode(__,__,__,__): acc;
			RuVar(__,__): insertSet(acc, n);
		}
	)
}

ruExpContainsVar(exp : RuExp, v : RuVar) -> bool {
	exists(exp.nodes, \n ->
		switch (n) {
			RuVar(__,__): n == v;
			default: false;
		}
	);
}

ruAssertion2Vars(ass : RuAssertion) -> Set<RuVar> {
	fold(ass.stat.hyps, ruExp2Vars(ass.stat.prop), \acc, h ->
		mergeSets(acc, ruExp2Vars(h.expr))
	)
}

ruProof2Vars(proof : RuProof) -> Set<RuVar> {
	fold(proof.steps, makeSet(), \acc, step ->
		mergeSets(acc, ruExp2Vars(step.expr))
	)
}

ruExpType(exp : RuExp) -> int {
	exp.nodes[0].type_id
}

ruDeclDescr(d : RuDecl) -> RuDescr {
	switch (d) {
		RuConst(descr,__,__):      descr;
		RuType(descr,__):          descr;
		RuRule(descr,__,__):       descr;
		RuAxiom(descr,__):         descr;
		RuDef(descr,__,__,__):     descr;
		RuTheorem(descr,__,__,__): descr;
	}
}

ruDeclName(d : RuDecl) -> string {
	id2s(switch (d) {
		RuConst(descr,__,__):      descr.id;
		RuType(descr,__):          descr.id;
		RuRule(descr,__,__):       descr.id;
		RuAxiom(descr,__):         descr.id;
		RuDef(descr,__,__,__):     descr.id;
		RuTheorem(descr,__,__,__): descr.id;
	});
}

ruDeclSrcId(d : RuDecl) -> int {
	switch (d) {
		RuConst(descr,__,__):      descr.src;
		RuType(descr,__):          descr.src;
		RuRule(descr,__,__):       descr.src;
		RuAxiom(descr,__):         descr.src;
		RuDef(descr,__,__,__):     descr.src;
		RuTheorem(descr,__,__,__): descr.src;
	}
}

ruDeclPos(d : RuDecl) -> int {
	switch (d) {
		RuConst(descr,__,__):      descr.pos;
		RuType(descr,__):          descr.pos;
		RuRule(descr,__,__):       descr.pos;
		RuAxiom(descr,__):         descr.pos;
		RuDef(descr,__,__,__):     descr.pos;
		RuTheorem(descr,__,__,__): descr.pos;
	}
}

ruDeclKind(d : RuDecl) -> string {
	switch (d) {
		RuConst(__,__,__):      "const";
		RuType(__,__):          "type";
		RuRule(__,__,__):       "rule";
		RuAxiom(__,__):         "axiom";
		RuDef(__,__,__,__):     "def";
		RuTheorem(__,__,__,__): "theorem";
	}
}

ruDeclIsAssertion(d : RuDecl) -> bool {
	switch (d) {
		RuAssertion(): true;
		default: false;
	}
}

ruDeclIsTheorem(d : RuDecl) -> bool {
	switch (d) {
		RuTheorem(__,__,__,__): true;
		default: false;
	}
}

ruDeclIsAxiom(d : RuDecl) -> bool {
	switch (d) {
		RuAxiom(__,__): true;
		default: false;
	}
}

ruDeclIsDef(d : RuDecl) -> bool {
	switch (d) {
		RuDef(__,__,__,__): true;
		default: false;
	}
}

ruSetDeclPos(d : RuDecl, pos : int) -> RuDecl {
	switch (d) {
		RuConst(descr,__,__):      RuConst(d with descr = RuDescr(descr with pos = pos));
		RuType(descr,__):          RuType(d with descr = RuDescr(descr with pos = pos));
		RuRule(descr,__,__):       RuRule(d with descr = RuDescr(descr with pos = pos));
		RuAxiom(descr,__):         RuAxiom(d with descr = RuDescr(descr with pos = pos));
		RuDef(descr,__,__,__):     RuDef(d with descr = RuDescr(descr with pos = pos));
		RuTheorem(descr,__,__,__): RuTheorem(d with descr = RuDescr(descr with pos = pos));
	}
}

ruDecl2s(d : RuDecl, rules : Tree<int, RuRule>) -> string {
	switch (d) {
		RuTheorem(__,__,__,proof): {
			str = ru2s(RuTheorem(d with proof = RuProof(proof with steps = [])), rules);
			takeBefore(str, "proof", str);
		}
		default: ru2s(d, rules);
	}
}

ruDecl2Assertion(d : RuDecl) -> Maybe<RuAssertion> {
	switch (d) {
		RuAxiom(__,__):         Some(d);
		RuDef(__,__,__,__):     Some(d);
		RuTheorem(__,__,__,__): Some(d);
		default: None()
	}
}

ruAssertion2Theorem(a : RuAssertion) -> Maybe<RuTheorem> {
	switch (a) {
		RuTheorem(__,__,__,__): Some(a);
		default: None()
	}
}

ruAssertion2Axiom(a : RuAssertion) -> Maybe<RuAxiom> {
	switch (a) {
		RuAxiom(__,__): Some(a);
		default: None()
	}
}

ruAssertion2Def(a : RuAssertion) -> Maybe<RuDef> {
	switch (a) {
		RuDef(__,__,__,__): Some(a);
		default: None()
	}
}

ruAssertion2s(ass : RuAssertion, rules : Tree<int, RuRule>) -> string {
	str = ru2s(ass, rules);
	strLeft(str, strIndexOf(str, "proof"));
}

ruProofQedStep(proof : RuProof) -> RuStep {
	proof.steps[length(proof.steps) - 1];
}

ruExp2s(e : RuExp, rules : Tree<int, RuRule>) -> string {
	ruTerm2s(ruExp2Term(e, rules));
}

ruExp2Term(e : RuExp, rules : Tree<int, RuRule>) -> RuTerm {
	switch (foldr(e.nodes, None(), \acc, n -> ruExp2sAccOperation(n, acc, rules))) {
		Some(stack): RuTerm(ruExpType(e), stack.nodes, e.pos);
		None(): ruNoTerm;
	}
}

RuExp2sStack(
	parent : Maybe<RuExp2sStack>,
	nodes : [RuTermNode]
);

ruExp2sAccOperation(node : RuExpNode, stack : Maybe<RuExp2sStack>, rules : Tree<int, RuRule>) -> Maybe<RuExp2sStack> {
	switch (node) {
		RuVar(__,__): 
			Some(RuExp2sStack(stack, [node]));
		RuRuleNode(id, type_id, arity, len): {
			switch (lookupTree(rules, id)) {
				Some(rule): {
					stack_str = fold(rule.term.nodes, Pair(stack, []), 
						\ac, symb -> {
							switch (symb) {
								RuVar(__,__): {
									switch (ac.first) {
										Some(st): Pair(st.parent, concat(ac.second, st.nodes));
										None(): ac;
									}
								}
								RuConstRef(__):
									Pair(ac.first, concat(ac.second, [symb]));
							}
						}
					);
					Some(RuExp2sStack(stack_str.first, stack_str.second));
				}
				None(): {
					ruPrintln("rule '" + id2s(id) + "' is not found");
					quit(-1);
					None();
				}
			}
		}
	}
}

ru2sWrapExp(a : RuAny, rules : Tree<int, RuRule>, wrap_exp : (string) -> string) -> string {
	aru2s   = \x -> ru2sWrapExp(x, rules, wrap_exp);
	vars2s  = \vars -> if (sizeTree(vars) == 0) "" else "(" + strGlue(map(getTreeValues(vars), \v -> id2s(v.id) + " : " + id2s(v.type_id)), ", ") + ") ";
	disjs2s = \disjs -> if (sizeSet(disjs) == 0) "" else
		"disjointed(" + strGlue(map(ruDisjs2Array(disjs), \s -> strGlue(map(set2array(s), \v -> id2s(v.id)), " ")), ", ") + ") ";
	meta2s  = \meta -> if (sizeSet(meta) == 0) "" else "meta(" + strGlue(map(set2array(meta), id2s), ", ") + ") ";
	exp2s   = \expr, delim -> ": " + id2s(ruExpType(expr)) + " = " + delim + " " + wrap_exp(ruExp2s(expr, rules)) + " ;;";
	prop2s  = \prop -> "\tprop " + exp2s(prop, "|-") + "\n";
	refs2s  = \refs -> "(" + strGlue(map(refs, aru2s), ", ") + ")";
	hyps2s  = \hyps -> if (hyps == []) "" else strGlue(map(hyps, aru2s), "\n") + "\n";
	comm2s  = \comms -> if (comms == []) "" else strGlue(map(comms, aru2s), "\n") + "\n";
	switch (a) {
		RuSource(imps, decls, comms, info): 
			(if (imps == []) "" else strGlue(map(imps, aru2s), "\n") + "\n\n") +
			(if (comms == []) "" else strGlue(map(comms, aru2s), "\n") + "\n") + 
			strGlue(map(decls, aru2s), "\n");
		RuImport(id,__):
			"import " + id2s(id) + ";;";
		RuConst(descr, ascii, latex): 
			comm2s(descr.comments) + 
			"constant {\n" + 
				"\tsymbol " + id2s(descr.id) + " ;;\n" +
				(if (ascii != -1) "\tascii " + id2s(ascii) + " ;;\n" else "") + 
				(if (latex != -1) "\tlatex " + id2s(latex) + " ;;\n" else "") +
			"}\n";
		RuType(descr, supers): 
			comm2s(descr.comments) + 
			"type " + id2s(descr.id) + (if (supers == []) "" else " : " + strGlue(map(supers, id2s), ", ")) + " ;;\n";
		RuRule(descr, vars, term):
			comm2s(descr.comments) + 
			"rule " + id2s(descr.id) + " " + vars2s(vars) + "{\n" +
				"\tterm " + aru2s(term) + "\n" +
			"}\n";
		RuAxiom(descr, stat): 
			comm2s(descr.comments) + 
			"axiom " + id2s(descr.id) + " " + vars2s(stat.vars) + disjs2s(stat.disjs) + "{\n" +
				hyps2s(stat.hyps) +
				(if (stat.hyps == []) "" else "\t----------\n") +
				prop2s(stat.prop) +
			"}\n";
		RuDef(descr, stat, defm, defs): 
			comm2s(descr.comments) + 
			"definition " + id2s(descr.id) + " " + vars2s(stat.vars) + disjs2s(stat.disjs) + "{\n" +
				hyps2s(stat.hyps) +
				"\tdefiendum " + exp2s(defm, "#") + "\n" +
				"\tdefiniens " + exp2s(defs, "#") + "\n" +
				"\t-------------\n" +
				prop2s(ruMakeDefProp(stat.prop.nodes, defm.nodes, defs.nodes)) +
			"}\n";
		RuTheorem(descr, stat, meta, proof): 
			comm2s(descr.comments) + 
			"theorem " + id2s(descr.id) + " " + vars2s(stat.vars) + disjs2s(stat.disjs) + meta2s(meta) + "{\n" +
				hyps2s(stat.hyps) + 
				(if (stat.hyps == []) "" else "\t----------\n") +
				prop2s(stat.prop) +
			"} " + aru2s(proof);
		RuHyp(ind, expr, __): 
			"\thyp " + i2s(ind + 1) + " " + exp2s(expr, "|-");
		RuProof(vars, disjs, steps, __): 
			"proof " + vars2s(vars) + disjs2s(disjs) + "{\n" +
				strGlue(map(steps, aru2s), "\n") + "\n" +
			"}\n";
		RuStep(ind, assertion, refs, expr, __):
			"\tstep " + i2s(ind + 1) + " : " + id2s(ruExpType(expr)) + " = " + 
				id2s(assertion) + " " + refs2s(refs) + " |- " + wrap_exp(ruExp2s(expr, rules)) + " ;;";
		RuComment(text, ann, __): 
			if (length(ann.members) == 0) "/*" + text + "*/\n" else
			"/**" +json2string(ann) + (if (text == "") "" else "\n-----\n" + text) + "*/\n";
		RuDisj(v1, v2): id2s(v1.id) + " " + id2s(v2.id);
		RuExp(nodes, __): wrap_exp(ruExp2s(a, rules));
		RuHypRef(i, __): "hyp " + i2s(i + 1);
		RuStepRef(i, __): "step " + i2s(i + 1);
		RuVar(id, type_id): id2s(id);
		RuTerm(type_id, expr, __): 
			": " + id2s(type_id) + " = # " + strGlue(map(expr, aru2s), " ") + " ;;";
		RuConstRef(id): id2s(id);
		RuRuleNode(rule, type_id, arity, len): id2s(rule);
	}
}

ru2s(a : RuAny, rules : Tree<int, RuRule>) -> string {
	ru2sWrapExp(a, rules, idfn);
}

ruSteps2s(steps : [RuStep], rules : Tree<int, RuRule>) -> string {
	strGlue(map(steps, \s -> ru2s(s, rules)), "\n");
}

ruDisjs2Array(disjs : Set<RuDisj>) -> [Set<RuVar>] {
	make_disj = \v, w -> if (v.id < w.id) RuDisj(v, w) else RuDisj(w, v);
	may_be_added = \v, s ->
		forall(set2array(s), \w -> 
			if (v == w) true else {
				containsSet(disjs, make_disj(v, w))
			}
		);
	foldSet(disjs, [], \acc, disj ->
		if (exists(acc, \s -> containsSet(s, disj.v1) && containsSet(s, disj.v2))) acc else {
			switch (findi(acc, \s -> containsSet(s, disj.v1) && may_be_added(disj.v2, s))) {
				Some(i): replace(acc, i, insertSet(acc[i], disj.v2));
				None(): 
					switch (findi(acc, \s -> containsSet(s, disj.v2) && may_be_added(disj.v1, s))) {
						Some(i): replace(acc, i, insertSet(acc[i], disj.v1));
						None(): concat(acc, [insertSet(makeSet1(disj.v1), disj.v2)]);
					}
			}
		}
	);
}

ruDisjs2s(disjs : Set<RuDisj>) -> string {
	strGlue(map(set2array(disjs), \disj -> id2s(disj.v1.id) + " " + id2s(disj.v2.id)), ", ");
}

ruIndOfArr(arr1 : [?], arr2 : [?]) -> int {
	foldi(arr1, -1, \i, ac, x -> 
		if (ac >= 0) ac else {
			if (i <= length(arr1) - length(arr2)) {
				ind = fold(arr2, i, \j, y ->
					if (j == -1) -1 else
					if (y == arr1[j]) j + 1 else -1
				);
				if (ind != -1) i else -1;
			} else {
				-1
			}
		}
	)
}

ruMakeDefProp(prop : [RuExpNode], dfm : [RuExpNode], dfs: [RuExpNode]) -> RuExp {
	dfs_i = ruIndOfArr(prop, dfs);
	dfm_i = ruIndOfArr(prop, dfm);
	dfs_len = length(dfs);
	dfm_len = length(dfm);
	if (dfs_i == -1 || dfm_i == -1) {
		ruNoExp
	} else {
		RuExp(foldi(prop, [], \i, ac, s ->
			if (i == dfm_i) concat(ac, [RuVar(s2id("defiendum"), -1)]) else
			if (dfm_i < i && i < dfm_i + dfm_len) ac else
			if (i == dfs_i) concat(ac, [RuVar(s2id("definiens"), -1)]) else
			if (dfs_i < i && i < dfs_i + dfs_len) ac else
			concat(ac, [s])
		), -1)
	}
}

ruIndexOfDecl(id : int, src : RuSource) -> int {
	findiDef(src.decls, 
		\decl -> switch (decl) {
			RuConst(d,__,__):      d.id == id;
			RuType(d,__):          d.id == id;
			RuRule(d,__,__):       d.id == id;
			RuAxiom(d,__):         d.id == id;
			RuTheorem(d,__,__,__): d.id == id;
			RuDef(d,__,__,__):     d.id == id;
		},
		-1
	)
}

ruStartPosition(decl : RuDecl) -> int {
	if (decl.descr.comments == []) decl.descr.pos else {
		lastElement(decl.descr.comments, ruNoComment).pos;
	}
}

ruComputeDisjs(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>, acc : RuComputedDisjs) -> RuComputedDisjs {
	foldSet(disjs, acc, \ac, disj -> {
		e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], -1));
		e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], -1));
		e1_vars = ruExp2Vars(e1);
		e2_vars = ruExp2Vars(e2);
		common_vars = intersectSets(e1_vars, e2_vars);
		if (!isEmptySet(common_vars)) {
			switch (ac) {
				RuComputedDisjs(__):  RuDisjViolation(disj, common_vars);
				RuDisjViolation(__,__): ac;
			}
		} else {
			switch (ac) {
				RuDisjsInherent(dsj): {
					RuDisjsInherent(
						foldSet(e1_vars, dsj, \ac1, v1 ->
							foldSet(e2_vars, ac1, \a, v2 ->
								if (v1.id < v2.id) insertSet(a, RuDisj(v1, v2)) else
								if (v2.id < v1.id) insertSet(a, RuDisj(v2, v1)) else a
							)
						)
					);
				}
				RuDisjViolation(__,__): ac;
			}
		}
	});
}

ruCheckDisjs(s : Tree<RuVar, RuExp>, disjs : Set<RuDisj>) -> bool {
	forall(set2array(disjs), \disj -> {
		e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], -1));
		e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], -1));
		e1_vars = ruExp2Vars(e1);
		e2_vars = ruExp2Vars(e2);
		isEmptySet(intersectSets(e1_vars, e2_vars));
	})
}

ruCheckDisjsInherent(s : Tree<RuVar, RuExp>, ass_disjs : Set<RuDisj>, thm_disjs : Set<RuDisj>) -> bool {
	forall(set2array(ass_disjs), \disj -> {
		e1 = lookupTreeDef(s, disj.v1, RuExp([disj.v1], -1));
		e2 = lookupTreeDef(s, disj.v2, RuExp([disj.v2], -1));
		e1_vars = set2array(ruExp2Vars(e1));
		e2_vars = set2array(ruExp2Vars(e2));
		forall(e1_vars, \v1 ->
			forall(e2_vars, \v2 ->
				if (v1.id < v2.id) containsSet(thm_disjs, RuDisj(v1, v2)) else
				if (v2.id < v1.id) containsSet(thm_disjs, RuDisj(v2, v1)) else 
				true
			)
		);
	});
}

ruProofToDAG(proof : RuProof) -> RuDAG<int> {
	ruDoProofToDAG(proof.steps, lastElement(proof.steps, ruNoStep));
}

ruDoProofToDAG(steps : [RuStep], curr : RuStep) -> RuDAG<int> {
	RuDAG(curr.assertion, map(curr.refs, \ref -> 
		switch(ref) {
			RuStepRef(i,__): ruDoProofToDAG(steps, steps[i]);
			RuHypRef(i,__): RuDAG(-1, []);
		}
	));
}

ruDAG2s(dag : RuDAG<?>, show_data : (?) -> string) -> string {
	show_data(dag.data) + " {\n" +
		ruIndent(strGlue(map(dag.children, \ch -> ruDAG2s(ch, show_data)), ""))
	+ "}\n"
}

ruProofDAG2s(dag : RuDAG<int>) -> string {
	ruDAG2s(dag, \id -> if (id == -1) "hyp" else id2s(id));
}

ruUpdateProofVars(proof : RuProof, th_new : RuTheorem, th_old : RuTheorem) -> RuProof {
	proof_vars = ruProof2Vars(proof);
	RuProof(proof with
		vars = filterTree(
			mergeTree(proof.vars, th_old.stat.vars), 
			\__,v -> 
				containsSet(proof_vars, v) && 
				!containsKeyTree(th_new.stat.vars, v.id)
		),
		disjs = filterSet(
			mergeSets(proof.disjs, th_old.stat.disjs), 
			\d -> 
				containsSet(proof_vars, d.v1) && 
				containsSet(proof_vars, d.v2) &&
				!containsSet(th_new.stat.disjs, d)
		)
	);
}

ruUpdateTheoremVars(th_old : RuTheorem) -> RuTheorem {
	ass_vars = ruAssertion2Vars(th_old);
	th_new = RuTheorem(th_old with 
		stat = RuStatement(th_old.stat with
			vars = filterTree(th_old.stat.vars, \__,v -> containsSet(ass_vars, v)),
			disjs = filterSet(th_old.stat.disjs, \d -> containsSet(ass_vars, d.v1) && containsSet(ass_vars, d.v2))
		)
	);
	RuTheorem(th_new with
		proof = ruUpdateProofVars(th_new.proof, th_new, th_old)
	);
}

ruTransformProof(proof: RuProof, f : (RuExp) -> RuExp) -> RuProof {
	RuProof(proof with 
		steps = map(proof.steps, \step ->
			RuStep(step with expr = f(step.expr))
		)
	);
}

ruTransformTheorem(th: RuTheorem, f : (RuExp) -> RuExp) -> RuTheorem {
	RuTheorem(th with
		stat = ruTransformStatement(th.stat, f),
		proof = ruTransformProof(th.proof, f)
	);
}

ruTransformStatement(st: RuStatement, f : (RuExp) -> RuExp) -> RuStatement {
	RuStatement(st with
		hyps = map(st.hyps, \h -> RuHyp(h with expr = f(h.expr))),
		prop = f(st.prop)
	);
}

ruTransformAxiom(ax: RuAxiom, f : (RuExp) -> RuExp) -> RuAxiom {
	RuAxiom(ax with 
		stat = ruTransformStatement(ax.stat, f)
	);
}

ruTransformDef(def: RuDef, f : (RuExp) -> RuExp) -> RuDef {
	RuDef(def with
		stat = ruTransformStatement(def.stat, f),
		defm = f(def.defm),
		defs = f(def.defs)
	);
}

ruSrc2Blocks(src : RuSource) -> [RuBlock] {
	comms2blocks = \comms -> map(comms, \comm -> cast(comm : RuComment -> RuBlock));
	concat(
		comms2blocks(src.comments),
		fold(src.decls, [], \acc, decl ->
			concat3(acc, comms2blocks(decl.descr.comments), [cast(decl : RuDecl -> RuBlock)])
		)
	);
}

RuBclocks2SrcAcc(
	decls : [RuDecl],
	comms : [RuComment]
);

ruSetDeclComments(decl : RuDecl, comms : [RuComment]) -> RuDecl {
	switch (decl) {
		RuConst(__,__,__):
			RuConst(decl with descr = RuDescr(decl.descr with comments = comms));
		RuType(__,__):
			RuType(decl with descr = RuDescr(decl.descr with comments = comms));
		RuRule(__,__,__):
			RuRule(decl with descr = RuDescr(decl.descr with comments = comms));
		RuAxiom(__,__):
			RuAxiom(decl with descr = RuDescr(decl.descr with comments = comms));
		RuTheorem(__,__,__,__):
			RuTheorem(decl with descr = RuDescr(decl.descr with comments = comms));
		RuDef(__,__,__,__):
			RuDef(decl with descr = RuDescr(decl.descr with comments = comms));
	}
}

ruBclocks2Src(src : RuSource, blocks : [RuBlock]) -> RuSource {
	accum = fold(blocks, RuBclocks2SrcAcc([], []), \acc, block ->
		switch (block) {
			RuComment(__,__,__): 
				RuBclocks2SrcAcc(acc.decls, concat(acc.comms, [block]));
			RuDecl(): {
				RuBclocks2SrcAcc(
					concat(acc.decls, [ruSetDeclComments(block, acc.comms)]), 
					[]
				);
			}
		}
	);
	RuSource(src with 
		comments = accum.comms,
		decls = accum.decls
	);
}

ruBlockName(block : RuBlock) -> string {
	switch (block) {
		RuDecl(): ruDeclName(block);
		RuComment(text,__,__): "<comment>";
	}
}

ruSetDeclDescr(decl : RuDecl, descr : RuDescr) -> RuDecl {
	switch (decl) {
		RuConst(__,__,__):      RuConst(decl with descr = descr);
		RuType(__,__):          RuType(decl with descr = descr);
		RuRule(__,__,__):       RuRule(decl with descr = descr);
		RuAxiom(__,__):         RuAxiom(decl with descr = descr);
		RuDef(__,__,__,__):     RuDef(decl with descr = descr);
		RuTheorem(__,__,__,__): RuTheorem(decl with descr = descr);
	}
}

ruModifyAnnotation(decl : RuDecl, modify : (JsonObject) -> JsonObject) -> RuDecl {
	old_annotation = JsonObject(fold(decl.descr.comments, [], \acc, comm -> concat(acc, comm.annotation.members)));
	new_annotation = modify(old_annotation);
	num_comments = length(decl.descr.comments);
	comments_modified = if (num_comments == 0) {
		[RuComment("", new_annotation, -1)];
	} else {
		mapi(decl.descr.comments, \i, comm ->
			if (i + 1 == num_comments) {
				RuComment(comm with annotation = new_annotation)
			} else {
				RuComment(comm with annotation = JsonObject([]))
			}
		);
	}
	ruSetDeclDescr(decl, RuDescr(decl.descr with comments = comments_modified));
}

ruSuperTypeName(super : int, infer : int) -> int {
	s2id(id2s(infer) + "-" + id2s(super));
}

ruMakeSuperRule(super : int, infer : int, src : int, pos : int) -> RuRule {
	id = ruSuperTypeName(super, infer);
	x = RuVar(s2id("x"), infer);
	RuRule(
		RuDescr(id, src, [], pos),
		makeTree1(x.id, x), 
		RuTerm(super, [x], pos)
	);
}

ruFixLeftRecursiveRule(r : RuRule) -> RuRule { 
	if (length(r.term.nodes) <= 1) r else {
		switch (r.term.nodes[0]) {
			RuVar(__,__):
				RuRule(r with term = RuTerm(r.term with nodes = 
					concat3([RuConstRef(s2id("("))], r.term.nodes, [RuConstRef(s2id(")"))])
				));
			default: r;
		}
	}
}